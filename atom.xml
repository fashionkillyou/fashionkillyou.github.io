<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>DreamItPossible</title>
  
  <subtitle>I know I&#39;m changing</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://www.fashionkillyou.xyz/"/>
  <updated>2018-04-12T13:48:03.923Z</updated>
  <id>http://www.fashionkillyou.xyz/</id>
  
  <author>
    <name>liuxinming</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>mybatis逆向工程</title>
    <link href="http://www.fashionkillyou.xyz/2018/04/12/mybatis%E9%80%86%E5%90%91%E5%B7%A5%E7%A8%8B/"/>
    <id>http://www.fashionkillyou.xyz/2018/04/12/mybatis逆向工程/</id>
    <published>2018-04-12T13:45:43.000Z</published>
    <updated>2018-04-12T13:48:03.923Z</updated>
    
    <content type="html"><![CDATA[<script src="\assets\js\APlayer.min.js"> </script><h1 id="使用逆向工程时候遇到的一些问题"><a href="#使用逆向工程时候遇到的一些问题" class="headerlink" title="使用逆向工程时候遇到的一些问题"></a>使用逆向工程时候遇到的一些问题</h1><p>在使用Mybatis generatot 自动生成实体类时,遇到一个问题: 实体类中字段名和数据库中的字段名不一致。<br><a id="more"></a><br>具体问题描述如下:</p><p>如: 数据中：client_id , clientName 使用Mybatis generator 反转过来后变成了: clientId(下划线没了), clientname(统一小写)。</p><p>解决办法:</p><p>在 generatorConfig.xml 配置文件中,<table> 元素下增加 子元素 </table></p><pre><code>&lt;property name=&quot;useActualColumnNames&quot; value=&quot;true&quot;/&gt;</code></pre><p>如:</p><pre><code>&lt;table tableName=&quot;crm_client&quot; domainObjectName=&quot;crm_client&quot; enableCountByExample=&quot;false&quot; enableUpdateByExample=&quot;false&quot; enableDeleteByExample=&quot;false&quot; enableSelectByExample=&quot;false&quot; selectByExampleQueryId=&quot;false&quot;&gt;&lt;property name=&quot;useActualColumnNames&quot; value=&quot;true&quot;/&gt;&lt;/table&gt;</code></pre><p>至此即可解决Mybaits Generator 自动生成实体类和数据库中字段名不一致的问题。</p><p>MyBatis Generator中文文档</p><p>MyBatis Generator中文文档地址：</p><p><a href="http://mbg.cndocs.ml/" target="_blank" rel="noopener">http://mbg.cndocs.ml/</a></p><p>该中文文档由于尽可能和原文内容一致，所以有些地方如果不熟悉，看中文版的文档的也会有一定的障碍，所以本章根据该中文文档以及实际应用，使用通俗的语言来讲解详细的配置。</p><p>本文中所有节点的链接都是对应的中文文档地址，可以点击查看详细信息。</p><p>注:本文后面提到的MBG全部指代MyBatis Generator。</p><p>MyBatis Generator 1.3.4 扩展，可以设置 Mapper（Dao）后缀</p><p>运行MyBatis Generator</p><p>有4种运行MBG的方法，具体请看文档 运行 MyBatis Generator</p><p>MBG下载地址:<a href="http://repo1.maven.org/maven2/org/mybatis/generator/mybatis-generator-core/" target="_blank" rel="noopener">http://repo1.maven.org/maven2/org/mybatis/generator/mybatis-generator-core/</a></p><h1 id="XML配置详解"><a href="#XML配置详解" class="headerlink" title="XML配置详解"></a>XML配置详解</h1><p>在MBG中，最主要也最重要的就是XML配置文件，因此本篇文章主要的内容就是XML配置。</p><p>这里按照配置的顺序对配置逐个讲解，更细的内容可以配合中文文档参照。</p><h2 id="1-配置文件头"><a href="#1-配置文件头" class="headerlink" title="1. 配置文件头"></a>1. 配置文件头</h2><pre><code>&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;!DOCTYPE generatorConfiguration    PUBLIC &quot;-//mybatis.org//DTD MyBatis Generator Configuration 1.0//EN&quot;    &quot;http://mybatis.org/dtd/mybatis-generator-config_1_0.dtd&quot;&gt;</code></pre><p>使用最新版的MBG需要使用上面的xml头，配置文件必须包含上面的DOCTYPE。</p><h2 id="2-根节点"><a href="#2-根节点" class="headerlink" title="2. 根节点"></a>2. 根节点<generatorconfiguration></generatorconfiguration></h2><p>generatorConfiguration节点没有任何属性，直接写节点即可，如下：</p><pre><code>&lt;generatorConfiguration&gt;    &lt;!-- 具体配置内容 --&gt;&lt;/generatorConfiguration&gt;  </code></pre><h2 id="3-子元素"><a href="#3-子元素" class="headerlink" title="3. 子元素"></a>3. <generatorconfiguration>子元素</generatorconfiguration></h2><p>从这段开始，就是配置的主要内容，这些配置都是generatorConfiguration元素的子元素。</p><p>包含以下子元素（有严格的顺序）：</p><pre><code>&lt;properties&gt; (0个或1个)&lt;classPathEntry&gt; (0个或多个)&lt;context&gt; (1个或多个)</code></pre><h3 id="3-1-元素"><a href="#3-1-元素" class="headerlink" title="3.1  元素"></a>3.1 <properties> 元素</properties></h3><p>这个元素用来指定外部的属性元素，不是必须的元素。</p><p>元素用于指定一个需要在配置中解析使用的外部属性文件，引入属性文件后，可以在配置中使用 ${property}这种形式的引用，通过这种方式引用属性文件中的属性值。 对于后面需要配置的<strong>jdbc信息</strong>和targetProject属性会很有用。</p><p>这个属性可以通过resource或者url来指定属性文件的位置，这两个属性只能使用其中一个来指定，同时出现会报错。</p><p>resource：指定classpath下的属性文件，使用类似com/myproject/generatorConfig.properties这样的属性值。</p><p>url：可以指定文件系统上的特定位置，例如file:///C:/myfolder/generatorConfig.properties</p><h3 id="3-2-元素"><a href="#3-2-元素" class="headerlink" title="3.2  元素"></a>3.2 <classpathentry> 元素</classpathentry></h3><p>这个元素可以0或多个，不受限制。</p><p>最常见的用法是通过这个属性指定驱动的路径，例如：</p><p><classpathentry location="E:\mysql\mysql-connector-java-5.1.29.jar"><br>重点提醒：本文之前在这里有误导，特别强调。</classpathentry></p><p>注意，classPathEntry只在下面这两种情况下才有效：</p><pre><code>当加载 JDBC 驱动内省数据库时当加载根类中的 JavaModelGenerator 检查重写的方法时</code></pre><p>因此，如果你需要加载其他用途的jar包，classPathEntry起不到作用，不能这么写，解决的办法就是将你用的jar包添加到类路径中，在Eclipse等IDE中运行的时候，添加jar包比较容易。当从命令行执行的时候，需要用</p><pre><code>java -cp xx.jar,xx2.jar xxxMainClass</code></pre><p>这种方式在-cp后面指定来使用(注意-jar会导致-cp无效)。</p><h3 id="3-3-元素"><a href="#3-3-元素" class="headerlink" title="3.3  元素"></a>3.3 <context> 元素</context></h3><p>在MBG的配置中，至少需要有一个<context>元素。</context></p><p><context>元素用于指定生成一组对象的环境。例如指定要连接的数据库，要生成对象的类型和要处理的数据库中的表。运行MBG的时候还可以指定要运行的<context>。</context></context></p><p>该元素只有一个<strong>必选属性</strong>id，用来唯一确定一个<context>元素，该id属性可以在运行MBG的使用。</context></p><p>此外还有几个<strong>可选属性</strong>：</p><p>defaultModelType:<strong>这个属性很重要</strong>，这个属性定义了MBG如何生成<strong>实体类</strong>。<br>这个属性有以下可选值：</p><p>conditional:<em>这是默认值</em>,这个模型和下面的hierarchical类似，除了如果那个单独的类将只包含一个字段，将不会生成一个单独的类。 因此,如果一个表的主键只有一个字段,那么不会为该字段生成单独的实体类,会将该字段合并到基本实体类中。</p><p>flat:该模型为每一张表只生成一个实体类。这个实体类包含表中的所有字段。<strong>这种模型最简单，推荐使用。</strong></p><p>hierarchical:如果表有主键,那么该模型会产生一个单独的主键实体类,如果表还有BLOB字段， 则会为表生成一个包含所有BLOB字段的单独的实体类,然后为所有其他的字段生成一个单独的实体类。 MBG会在所有生成的实体类之间维护一个继承关系。</p><p>targetRuntime:此属性用于指定生成的代码的运行时环境。该属性支持以下可选值：</p><pre><code>MyBatis3:*这是默认值*MyBatis3SimpleIbatis2Java2Ibatis2Java5 一般情况下使用默认值即可，有关这些值的具体作用以及区别请查看中文文档的详细内容。introspectedColumnImpl:该参数可以指定扩展org.mybatis.generator.api.IntrospectedColumn该类的实现类。该属性的作用可以查看扩展MyBatis Generator。</code></pre><p>一般情况下，我们使用如下的配置即可：</p><pre><code>&lt;context id=&quot;Mysql&quot; defaultModelType=&quot;flat&quot;&gt;</code></pre><p>如果你希望不生成和Example查询有关的内容，那么可以按照如下进行配置:</p><pre><code>&lt;context id=&quot;Mysql&quot; targetRuntime=&quot;MyBatis3Simple&quot; defaultModelType=&quot;flat&quot;&gt;</code></pre><p>使用MyBatis3Simple可以避免在后面的<table>中逐个进行配置（后面会提到）。</table></p><p>MBG配置中的其他几个元素，基本上都是<context>的子元素，这些子元素（有严格的配置顺序）包括：</context></p><pre><code>&lt;property&gt; (0个或多个)&lt;plugin&gt; (0个或多个)&lt;commentGenerator&gt; (0个或1个)&lt;jdbcConnection&gt; (1个)&lt;javaTypeResolver&gt; (0个或1个)&lt;javaModelGenerator&gt; (1个)&lt;sqlMapGenerator&gt; (0个或1个)&lt;javaClientGenerator&gt; (0个或1个)&lt;table&gt; (1个或多个)</code></pre><p>其中<property>属性比较特殊，后面讲解的时候都会和父元素一起进行讲解。在讲解<property>属性前，我们先看看<strong>什么是分隔符？</strong>。</property></property></p><p>这里通过一个例子说明。假设在Mysql数据库中有一个表名为user info，你没有看错，中间是一个空格，这种情况下如果写出select * from user info这样的语句，肯定是要报错的，在Mysql中的时候我们一般会写成如下的样子:</p><pre><code>select * from `user info`</code></pre><p>这里的使用的<strong>反单引号(`)</strong>就是<strong>分隔符</strong>，<strong>分隔符</strong>可以用于<strong>表名</strong>或者<strong>列名</strong>。</p><p>下面继续看<property>支持的属性：</property></p><pre><code>autoDelimitKeywordsbeginningDelimiterendingDelimiterjavaFileEncodingjavaFormatterxmlFormatter</code></pre><p>由于这些属性比较重要，这里一一讲解。</p><p>首先是autoDelimitKeywords，当表名或者字段名为SQL关键字的时候，可以设置该属性为true，MBG会自动给表名或字段名添加<strong>分隔符</strong>。</p><p>然后这里继续上面的例子来讲beginningDelimiter和endingDelimiter属性。<br>由于beginningDelimiter和endingDelimiter的默认值为双引号(“)，在Mysql中不能这么写，所以还要将这两个默认值改为<strong>反单引号(`)</strong>，配置如下：</p><pre><code>&lt;property name=&quot;beginningDelimiter&quot; value=&quot;`&quot;/&gt;&lt;property name=&quot;endingDelimiter&quot; value=&quot;`&quot;/&gt;  </code></pre><p>属性javaFileEncoding设置要使用的Java文件的编码，默认使用当前平台的编码，只有当生产的编码需要特殊指定时才需要使用，一般用不到。</p><p>最后两个javaFormatter和xmlFormatter属性<strong>可能会</strong>很有用，如果你想使用模板来定制生成的java文件和xml文件的样式，你可以通过指定这两个属性的值来实现。</p><p>接下来分节对其他的子元素逐个进行介绍。</p><h4 id="3-3-1-元素"><a href="#3-3-1-元素" class="headerlink" title="3.3.1  元素"></a>3.3.1 <plugin> 元素</plugin></h4><p>该元素可以配置0个或者多个，不受限制。</p><p><plugin>元素用来定义一个插件。插件用于扩展或修改通过MyBatis Generator (MBG)代码生成器生成的代码。</plugin></p><p>插件将按在配置中配置的顺序执行。</p><p>有关插件的详细信息可以参考开发插件和提供的插件了解更多。</p><h4 id="3-3-2-元素"><a href="#3-3-2-元素" class="headerlink" title="3.3.2  元素"></a>3.3.2 <commentgenerator> 元素</commentgenerator></h4><p>该元素最多可以配置1个。</p><p>这个元素非常有用，相信很多人都有过这样的需求，就是希望MBG生成的代码中可以包含<strong>注释信息</strong>，具体就是生成表或字段的备注信息。</p><p>使用这个元素就能很简单的实现我们想要的功能。这里先介绍该元素，介绍完后会举例如何扩展实现该功能。</p><p>该元素有一个可选属性type,可以指定用户的实现类，该类需要实现org.mybatis.generator.api.CommentGenerator接口。而且必有一个默认的构造方法。这个属性接收默认的特殊值DEFAULT，会使用默认的实现类org.mybatis.generator.internal.DefaultCommentGenerator。</p><p>默认的实现类中提供了两个可选属性，需要通过<property>属性进行配置。</property></p><pre><code>suppressAllComments:**阻止**生成注释，默认为falsesuppressDate:**阻止**生成的注释包含时间戳，默认为false</code></pre><p>一般情况下由于MBG生成的注释信息没有任何价值，而且有时间戳的情况下每次生成的注释都不一样，使用<strong>版本控制</strong>的时候每次都会提交，因而一般情况下我们都会屏蔽注释信息，可以如下配置：</p><commentgenerator><br>    <property name="suppressAllComments" value="true"><br>    <property name="suppressDate" value="true"><br></property></property></commentgenerator><br>接下来我们简单举例实现生成包含表字段注释信息的注释<br><br>因为系统提供了一个默认的实现类，所以对我们来说，自己实现一个会很容易，最简单的方法就是复制默认实现类代码到一个新的文件中，修改类名如MyCommentGenerator，在你自己的实现类中，你可以选择是否继续支持上面的两个属性，你还可以增加对其他属性的支持。<br><br>我们通过下面一个方法的修改来了解，其他几个方法请自行修改(写本章的时候我也没有完全实现该类，所以不提供完整源码了):<br><br>    @Override<br>    public void addFieldComment(Field field, IntrospectedTable introspectedTable, IntrospectedColumn introspectedColumn) {<br>        if (introspectedColumn.getRemarks() != null &amp;&amp; !introspectedColumn.getRemarks().equals(“”)) {<br>            field.addJavaDocLine(“/<strong>“);<br>            field.addJavaDocLine(“ <em> “ + introspectedColumn.getRemarks());<br>            addJavadocTag(field, false);<br>            field.addJavaDocLine(“ </em>/“);<br>        }<br>    }<br>这个方法是给字段添加注释信息的，其中IntrospectedColumn包含了字段的完整信息，通过getRemarks方法可以获取字段的注释信息。上面这个方法修改起来还是很容易的。除了字段的注释外还有Getter和Setter，以及类的注释。此外还有生成XML的注释，大家可以根据默认的实现进行修改。<br><br>完成我们自己的实现类后，我们还需要做如下配置：<br><br>    <commentgenerator type="com.github.abel533.mybatis.generator.MyCommentGenerator"><br>#### 3.3.3 <jdbcconnection> 元素<br><br><jdbcconnection>用于指定数据库连接信息，该元素必选，并且只能有一个。<br><br>配置该元素只需要注意如果JDBC驱动不在</jdbcconnection></jdbcconnection></commentgenerator></strong>classpath<strong>下，就需要通过<classpathentry>元素引入jar包，这里</classpathentry></strong>推荐<strong>将jar包放到</strong>classpath<strong>下。<br><br>该元素有两个必选属性:<br><br>    driverClass:访问数据库的JDBC驱动程序的完全限定类名<br>    connectionURL:访问数据库的JDBC连接URL<br>该元素还有两个可选属性:<br><br>    userId:访问数据库的用户ID<br>    password:访问数据库的密码<br>此外该元素还可以接受多个<property>子元素，这里配置的<property>属性都会添加到JDBC驱动的属性中。<br><br>这个元素配置起来最容易，这里举个简单例子：<br><br>    <jdbcconnection driverclass="com.mysql.jdbc.Driver" connectionurl="jdbc:mysql://localhost:3306/test" userid="root" password=""><br>    </jdbcconnection><br>#### 3.3.4 <javatyperesolver> 元素<br><br>该元素最多可以配置一个。<br><br>这个元素的配置用来指定JDBC类型和Java类型如何转换。<br><br>该元素提供了一个可选的属性type，和<commentgenerator>比较类型，提供了默认的实现DEFAULT，一般情况下使用默认即可，需要特殊处理的情况可以通过其他元素配置来解决，不建议修改该属性。<br><br>该属性还有一个可以配置的<property>元素。<br><br>可以配置的属性为forceBigDecimals，该属性可以控制是否强制DECIMAL和NUMERIC类型的字段转换为Java类型的java.math.BigDecimal,默认值为false，一般不需要配置。<br><br>默认情况下的转换规则为：<br><br>    如果精度&gt;0或者长度&gt;18，就会使用java.math.BigDecimal<br>    如果精度=0并且10&lt;=长度&lt;=18，就会使用java.lang.Long<br>    如果精度=0并且5&lt;=长度&lt;=9，就会使用java.lang.Integer<br>    如果精度=0并且长度&lt;5，就会使用java.lang.Short<br>    如果设置为true，那么一定会使用java.math.BigDecimal，配置示例如下：<br><br>    <javatyperesolver><br>        <property name="forceBigDecimals" value="true"><br>    </property></javatyperesolver><br>#### 3.3.5 <javamodelgenerator> 元素<br><br>该元素必须配置一个，并且最多一个。<br><br>该元素用来控制生成的实体类，根据<context>中配置的defaultModelType，一个表可能会对应生成多个不同的实体类。一个表对应多个类实际上并不方便，所以前面也推荐使用flat，这种情况下一个表对应一个实体类。<br><br>该元素只有两个属性，都是必选的。<br><br>    targetPackage:生成实体类存放的包名，一般就是放在该包下。实际还会受到其他配置的影响(<table>中会提到)。<br><br>    targetProject:指定目标项目路径，可以是绝对路径或相对路径（如 targetProject=”src/main/java”）。<br>该元素支持以下几个<property>子元素属性：<br><br>    constructorBased:该属性只对MyBatis3有效，如果true就会使用构造方法入参，如果false就会使用setter方式。默认为false。<br><br>    enableSubPackages:如果true，MBG会根据catalog和schema来生成子包。如果false就会直接用targetPackage属性。默认为false。<br><br>    immutable:该属性用来配置实体类属性是否可变，如果设置为true，那么constructorBased不管设置成什么，都会使用构造方法入参，并且不会生成setter方法。如果为false，实体类属性就可以改变。默认为false。<br><br>    rootClass:设置所有实体类的基类。如果设置，需要使用类的全限定名称。并且如果MBG能够加载rootClass，那么MBG不会覆盖和父类中完全匹配的属性。匹配规则：<br><br>        属性名完全相同<br>        属性类型相同<br>        属性有getter方法<br>        属性有setter方法<br>        trimStrings:是否对数据库查询结果进行trim操作，如果设置为true就会生成类似这样public void setUsername(String username) {this.username = username == null ? null : username.trim();}的setter方法。默认值为false。<br>配置示例如下：<br><br>    <javamodelgenerator targetpackage="test.model" targetproject="src\main\java"><br>        <property name="enableSubPackages" value="true"><br>        <property name="trimStrings" value="true"><br>    </property></property></javamodelgenerator><br>#### 3.3.6 <sqlmapgenerator> 元素<br><br>该元素可选，最多配置一个。但是有如下两种必选的特殊情况：<br><br>如果targetRuntime目标是</sqlmapgenerator></property></table></context></javamodelgenerator></property></commentgenerator></javatyperesolver></property></property></strong>iBATIS2<strong>，该元素必须配置一个。<br><br>如果targetRuntime目标是</strong>MyBatis3<strong>，只有当<javaclientgenerator>需要XML时，该元素必须配置一个。 如果没有配置<javaclientgenerator>，则使用以下的规则：<br><br>    如果指定了一个<sqlmapgenerator>，那么MBG将只生成XML的SQL映射文件和实体类。<br><br>    如果没有指定<sqlmapgenerator>，那么MBG将只生成实体类。<br><br>该元素只有两个属性（和前面提过的<javamodelgenerator>的属性含义一样），都是必选的。<br><br>    targetPackage:生成实体类存放的包名，一般就是放在该包下。实际还会受到其他配置的影响(<table>中会提到)。<br>    targetProject:指定目标项目路径，可以是绝对路径或相对路径（如 targetProject=”src/main/resources”）。<br><br>该元素支持<property>子元素，只有一个可以配置的属性：<br><br>    enableSubPackages:如果true，MBG会根据catalog和schema来生成子包。如果false就会直接用targetPackage属性。默认为false。<br>配置示例：<br><br>    <sqlmapgenerator targetpackage="test.xml" targetproject="src\main\resources"><br>        <property name="enableSubPackages" value="true"><br>    </property></sqlmapgenerator><br>#### 3.3.7 <javaclientgenerator> 元素<br><br>该元素可选，最多配置一个。<br><br>如果不配置该元素，就不会生成Mapper接口。<br><br>该元素有3个必选属性：<br><br>type:该属性用于选择一个预定义的客户端代码（可以理解为Mapper接口）生成器，用户可以自定义实现，需要继承org.mybatis.generator.codegen.AbstractJavaClientGenerator类，必选有一个默认的构造方法。 该属性提供了以下预定的代码生成器，首先根据<context>的targetRuntime分成三类：<br><br>        MyBatis3:<br>            ANNOTATEDMAPPER:基于注解的Mapper接口，不会有对应的XML映射文件<br>            MIXEDMAPPER:XML和注解的混合形式，(上面这种情况中的)SqlProvider注解方法会被XML替代。<br>            XMLMAPPER:所有的方法都在XML中，接口调用依赖XML文件。<br>        MyBatis3Simple:<br>            ANNOTATEDMAPPER:基于注解的Mapper接口，不会有对应的XML映射文件<br>            XMLMAPPER:所有的方法都在XML中，接口调用依赖XML文件。<br>        Ibatis2Java2或</context></javaclientgenerator></property></table></javamodelgenerator></sqlmapgenerator></sqlmapgenerator></javaclientgenerator></javaclientgenerator></strong>Ibatis2Java5<strong>:<br>            IBATIS:生成的对象符合iBATIS的DAO框架（不建议使用）。<br>            GENERIC-CI:生成的对象将只依赖于SqlMapClient，通过构造方法注入。<br>            GENERIC-SI:生成的对象将只依赖于SqlMapClient，通过setter方法注入。<br>            SPRING:生成的对象符合Spring的DAO接口<br>            targetPackage:生成实体类存放的包名，一般就是放在该包下。实际还会受到其他配置的影响(<table>中会提到)。<br>targetProject:指定目标项目路径，可以是绝对路径或相对路径（如 targetProject=”src/main/java”）。<br>该元素还有一个可选属性：<br><br>    implementationPackage:如果指定了该属性，实现类就会生成在这个包中。<br>该元素支持<property>子元素设置的属性：<br><br>    enableSubPackages<br>    exampleMethodVisibility<br>    methodNameCalculator<br>    rootInterface<br>    useLegacyBuilder<br>这几个属性不太常用，具体作用请看完整的文档，这里对rootInterface做个简单介绍。<br><br>rootInterface用于指定一个所有生成的接口都继承的父接口。 这个值可以通过<table>配置的rootInterface属性覆盖。<br><br>这个属性对于通用Mapper来说，可以让生成的所有接口都继承该接口。<br><br>配置示例：<br><br>    <javaclientgenerator type="XMLMAPPER" targetpackage="test.dao" targetproject="src\main\java"><br>#### 3.3.8 <table> 元素<br><br>该元素至少要配置一个，可以配置多个。<br><br>该元素用来配置要通过内省的表。只有配置的才会生成实体类和其他文件。<br><br>该元素有一个必选属性：<br><br>tableName：指定要生成的表名，可以使用SQL通配符匹配多个表。<br>例如要生成全部的表，可以按如下配置：<br><br><table tablename="%"><br>该元素包含多个可选属性：<br><br>schema:数据库的schema,可以使用SQL通配符匹配。如果设置了该值，生成SQL的表名会变成如schema.tableName的形式。<br><br>catalog:数据库的catalog，如果设置了该值，生成SQL的表名会变成如catalog.tableName的形式。<br><br>alias:如果指定，这个值会用在生成的select查询SQL的表的别名和列名上。 列名会被别名为 alias<em>actualColumnName(别名</em>实际列名) 这种模式。<br><br>domainObjectName:生成对象的基本名称。如果没有指定，MBG会自动根据表名来生成名称。<br><br>enableXXX:XXX代表多种SQL方法，该属性用来指定是否生成对应的XXX语句。<br><br>selectByPrimaryKeyQueryId:DBA跟踪工具会用到，具体请看详细文档。<br><br>selectByExampleQueryId:DBA跟踪工具会用到，具体请看详细文档。<br><br>modelType:和<context>的defaultModelType含义一样，这里可以针对表进行配置，这里的配置会覆盖<context>的defaultModelType配置。<br><br>escapeWildcards:这个属性表示当查询列，是否对schema和表名中的SQL通配符 (‘_’ and ‘%’) 进行转义。 对于某些驱动当schema或表名中包含SQL通配符时（例如，一个表名是MY_TABLE，有一些驱动需要将下划线进行转义）是必须的。默认值是false。<br><br>delimitIdentifiers:是否给标识符增加</context></context></table></table></javaclientgenerator></table></property></table></strong>分隔符<strong>。默认false。当catalog,schema或tableName中包含空白时，默认为true。<br><br>delimitAllColumns:是否对所有列添加</strong>分隔符<strong>。默认false。<br>该元素包含多个可用的<property>子元素，可选属性为：<br><br>constructorBased:和<javamodelgenerator>中的属性含义一样。<br><br>ignoreQualifiersAtRuntime:生成的SQL中的表名将不会包含schema和catalog前缀。<br><br>immutable:和<javamodelgenerator>中的属性含义一样。<br><br>modelOnly:此属性用于配置是否为表只生成实体类。如果设置为true就不会有Mapper接口。如果配置了<sqlmapgenerator>，并且modelOnly为true，那么XML映射文件中只有实体对象的映射元素(<resultmap>)。如果为true还会覆盖属性中的enableXXX方法，将不会生成任何CRUD方法。<br><br>rootClass:和<javamodelgenerator>中的属性含义一样。<br><br>rootInterface:和<javaclientgenerator>中的属性含义一样。<br><br>runtimeCatalog:运行时的catalog，当生成表和运行环境的表的catalog不一样的时候可以使用该属性进行配置。<br><br>runtimeSchema:运行时的schema，当生成表和运行环境的表的schema不一样的时候可以使用该属性进行配置。<br><br>runtimeTableName:运行时的tableName，当生成表和运行环境的表的tableName不一样的时候可以使用该属性进行配置。<br><br>selectAllOrderByClause:该属性值会追加到selectAll方法后的SQL中，会直接跟order by拼接后添加到SQL末尾。<br><br>useActualColumnNames:如果设置为true,那么MBG会使用从数据库元数据获取的列名作为生成的实体对象的属性。 如果为false(默认值)，MGB将会尝试将返回的名称转换为驼峰形式。 在这两种情况下，可以通过 元素显示指定，在这种情况下将会忽略这个（useActualColumnNames）属性。<br><br>useColumnIndexes:如果是true,MBG生成resultMaps的时候会使用列的索引,而不是结果中列名的顺序。<br><br>useCompoundPropertyNames:如果是true,那么MBG生成属性名的时候会将列名和列备注接起来. 这对于那些通过第四代语言自动生成列(例如:FLD22237),但是备注包含有用信息(例如:”customer id”)的数据库来说很有用. 在这种情况下,MBG会生成属性名FLD2237_CustomerId。<br><br>除了<property>子元素外，<table>还包含以下子元素：<br><br>    <generatedkey> (0个或1个)<br>    <columnrenamingrule> (0个或1个)<br>    <columnoverride> (0个或多个)<br>    <ignorecolumn> (0个或多个)<br>下面对这4个元素进行详细讲解。<br><br>- 1. <generatedkey> 元素<br><br>这个元素最多可以配置一个。<br><br>这个元素用来指定自动生成主键的属性（identity字段或者sequences序列）。如果指定这个元素，MBG在生成insert的SQL映射文件中插入一个<selectkey>元素。 这个元素</selectkey></generatedkey></ignorecolumn></columnoverride></columnrenamingrule></generatedkey></table></property></javaclientgenerator></javamodelgenerator></resultmap></sqlmapgenerator></javamodelgenerator></javamodelgenerator></property></strong>非常重要<strong>，这个元素包含下面两个必选属性：<br><br>column:生成列的列名。<br><br>    sqlStatement:将返回新值的 SQL 语句。如果这是一个identity列，您可以使用其中一个预定义的的特殊值。预定义值如下：<br>    Cloudscape<br>    DB2<br>    DB2_MF<br>    Derby<br>    HSQLDB<br>    Informix<br>    MySql<br>    SqlServer<br>    SYBASE<br><br>JDBC:这会配置MBG使用MyBatis3支持的JDBC标准的生成key来生成代码。 这是一个独立于数据库获取标识列中的值的方法。 重要: 只有当目标运行为MyBatis3时才会产生正确的代码。 如果与iBATIS2一起使用目标运行时会产生运行时错误的代码。<br><br>这个元素还包含两个可选属性：<br><br>identity:当设置为true时,该列会被标记为identity列， 并且<selectkey>元素会被插入在insert后面。 当设置为false时，<selectkey>会插入到insert之前（通常是序列）。</selectkey></selectkey></strong>重要<strong>: 即使您type属性指定为post，您仍然需要为identity列将该参数设置为true。 这将标志MBG从插入列表中删除该列。默认值是false。<br><br>type:type=post and identity=true的时候生成的<selectkey>中的order=AFTER,当type=pre的时候，identity只能为false，生成的<selectkey>中的order=BEFORE。可以这么理解，自动增长的列只有插入到数据库后才能得到ID，所以是AFTER,使用序列时，只有先获取序列之后，才能插入数据库，所以是BEFORE。<br>配置示例一：<br><br>    <table tablename="user login info" domainobjectname="UserLoginInfo"><br>        <generatedkey column="id" sqlstatement="Mysql"><br>    </generatedkey></table><br>对应的生成的结果：<br><br>    <insert id="insert" parametertype="test.model.UserLoginInfo"><br>        <selectkey keyproperty="id" order="AFTER" resulttype="java.lang.Integer"><br>            SELECT LAST_INSERT_ID()<br>        </selectkey><br>        insert into <code>user login info</code> (Id, username, logindate, loginip)<br>        values (#{id,jdbcType=INTEGER}, #{username,jdbcType=VARCHAR}, #{logindate,jdbcType=TIMESTAMP}, #{loginip,jdbcType=VARCHAR})<br>    </insert><br>配置示例二：<br><br>    <table tablename="user login info" domainobjectname="UserLoginInfo"><br>        <generatedkey column="id" sqlstatement="select SEQ_ID.nextval from dual"><br>    </generatedkey></table><br>对应的生成结果：<br><br>    <insert id="insert" parametertype="test.model.UserLoginInfo"><br>        <selectkey keyproperty="id" order="BEFORE" resulttype="java.lang.Integer"><br>            select SEQ_ID.nextval from dual<br>        </selectkey><br>        insert into <code>user login info</code> (Id, username, logindate, loginip)<br>        values (#{id,jdbcType=INTEGER}, #{username,jdbcType=VARCHAR}, #{logindate,jdbcType=TIMESTAMP},#{loginip,jdbcType=VARCHAR})<br>    </insert><br>- 2. <columnrenamingrule> 元素<br><br>该元素最多可以配置一个，使用该元素可以在生成列之前，对列进行重命名。这对那些存在同一前缀的字段想在生成属性名时去除前缀的表非常有用。 例如假设一个表包含以下的列：<br><br>    CUST_BUSINESS_NAME<br>    CUST_STREET_ADDRESS<br>    CUST_CITY<br>    CUST<em>STATE<br>生成的所有属性名中如果都包含CUST的前缀可能会让人不爽。这些前缀可以通过如下方式定义重命名规则:<br><br>    &lt;columnRenamingRule searchString=”^CUST</em>“ replaceString=”” /&gt;<br>注意，在内部，MBG使用java.util.regex.Matcher.replaceAll方法实现这个功能。 请参阅有关该方法的文档和在Java中使用正则表达式的例子。<br><br>当<columnoverride>匹配一列时，这个元素（<columnrenamingrule>）会被忽略。<columnoverride>优先于重命名的规则。<br><br>该元素有一个必选属性：<br><br>searchString:定义将被替换的字符串的正则表达式。<br><br>该元素有一个可选属性：<br><br>replaceString:这是一个用来替换搜索字符串列每一个匹配项的字符串。如果没有指定，就会使用空字符串。<br>关于<table>的<property>属性useActualColumnNames对此的影响可以查看完整文档。<br><br>- 3. <columnoverride> 元素<br><br>该元素可选，可以配置多个。<br><br>该元素从将某些属性默认计算的值更改为指定的值。<br><br>该元素有一个必选属性:<br><br>column:要重写的列名。<br><br>该元素有多个可选属性：<br><br>property:要使用的Java属性的名称。如果没有指定，MBG会根据列名生成。 例如，如果一个表的一列名为STRT_DTE，MBG会根据<table>的useActualColumnNames属性生成STRT_DTE或strtDte。<br><br>javaType:该列属性值为完全限定的Java类型。如果需要，这可以覆盖由JavaTypeResolver计算出的类型。 对某些数据库来说，这是必要的用来处理</table></columnoverride></property></table></columnoverride></columnrenamingrule></columnoverride></columnrenamingrule></selectkey></selectkey></strong>“奇怪的”<strong>数据库类型（例如MySql的unsigned bigint类型需要映射为java.lang.Object)。<br><br>jdbcType:该列的JDBC类型(INTEGER, DECIMAL, NUMERIC, VARCHAR等等)。 如果需要，这可以覆盖由JavaTypeResolver计算出的类型。 对某些数据库来说，这是必要的用来处理怪异的JDBC驱动 (例如DB2的LONGVARCHAR类型需要为iBATIS 映射为VARCHAR)。<br><br>typeHandler:用户定义的需要用来处理这列的类型处理器。它必须是一个继承iBATIS的TypeHandler类或TypeHandlerCallback接口（该接口很容易继承）的全限定的类名。如果没有指定或者是空白，iBATIS会用默认的类型处理器来处理类型。</strong>重要<strong>:MBG不会校验这个类型处理器是否存在或者可用。 MGB只是简单的将这个值插入到生成的SQL映射的配置文件中。<br><br>delimitedColumnName:指定是否应在生成的SQL的列名称上增加</strong>分隔符<strong>。 如果列的名称中包含空格，MGB会自动添加</strong>分隔符<strong>， 所以这个重写只有当列名需要强制为一个合适的名字或者列名是数据库中的保留字时是必要的。<br><br>配置示例：<br><br>    <table schema="DB2ADMIN" tablename="ALLTYPES"><br>        <columnoverride column="LONG_VARCHAR_FIELD" javatype="java.lang.String" jdbctype="VARCHAR"><br>    </columnoverride></table><br>- 4. <ignorecolumn> 元素<br><br>该元素可选，可以配置多个。<br><br>该元素可以用来屏蔽不需要生成的列。<br><br>该元素有一个必选属性：<br><br>column:要忽略的列名。<br><br>该元素还有一个可选属性：<br><br>delimitedColumnName:匹配列名的时候是否区分大小写。如果为true则区分。默认值为false，不区分大小写。<br>MyBatis Generator最佳实践<br><br><br>### 本节内容针对MyBatis3，使用iBATIS的不一定适用。<br><br>以下根据个人经验（对此有意见的可以留言）对一些配置看法列出如下几点：<br><br>关于实体类的modelType，建议使用defaultModelType=”flat”，只有一个对象的情况下管理毕竟方便，使用也简单。<br><br>关于注释<commentgenerator>，不管你是否要重写自己的注释生成器，有一点不能忘记，那就是注释中一定要保留@mbggenerated,MBG通过该字符串来判断代码是否为代码生成器生成的代码，有该标记的的代码在重新生成的时候会被删除，不会重复。不会在XML中出现重复元素。<br><br>使用MBG生成的代码时，建议尽可能不要去修改自动生成的代码，而且要生成带有@mbggenerated，这样才不会在每次重新生成代码的时候需要手动修改好多内容。<br><br>仍然是注释相关，在<commentgenerator>中，建议一定要保留suppressAllComments属性(使用默认值false)，一定要取消(设为true)时间戳suppressDate，避免重复提交SVN。<br><br><jdbcconnection>建议将JDBC驱动放到项目的</jdbcconnection></commentgenerator></commentgenerator></ignorecolumn></strong>classpath**下，而不是使用<classpathentry>来引入jar包，主要考虑到所有开发人员的统一性。<br><br>当数据库字段使用CHAR时，建议在<javamodelgenerator>中设置<property name="trimStrings" value="true">，可以自动去掉不必要的空格。<br><br>在<javaclientgenerator>中，建议设置type=”XMLMAPPER”,不建议使用注解或混合模式，比较代码和SQL完全分离易于维护。<br><br>建议尽可能在<table>中配置<generatedkey>，避免手工操作，以便于MBG重复执行代码生成。<br>如果有其他有价值的经验，会继续补充。<br><br>综合以上信息，这里给出一个Mysql的简单配置：<br><br>    &lt;?xml version=”1.0” encoding=”UTF-8”?&gt;<br>    &lt;!DOCTYPE generatorConfiguration<br>            PUBLIC “-//mybatis.org//DTD MyBatis Generator Configuration 1.0//EN”<br>            “<a href="http://mybatis.org/dtd/mybatis-generator-config_1_0.dtd&quot;&gt;" target="_blank" rel="noopener">http://mybatis.org/dtd/mybatis-generator-config_1_0.dtd&quot;&gt;</a><br><br>    <generatorconfiguration><br>        <context id="MysqlContext" targetruntime="MyBatis3" defaultmodeltype="flat"><br>            <property name="beginningDelimiter" value="`"><br>            <property name="endingDelimiter" value="`"><br><br>            <commentgenerator><br>                <property name="suppressDate" value="true"><br>            </property></commentgenerator><pre><code>        &lt;jdbcConnection driverClass=&quot;com.mysql.jdbc.Driver&quot;                        connectionURL=&quot;jdbc:mysql://localhost:3306/test&quot;                        userId=&quot;root&quot;                        password=&quot;&quot;&gt;        &lt;/jdbcConnection&gt;        &lt;javaModelGenerator targetPackage=&quot;test.model&quot; targetProject=&quot;src\main\java&quot;&gt;            &lt;property name=&quot;trimStrings&quot; value=&quot;true&quot; /&gt;        &lt;/javaModelGenerator&gt;        &lt;sqlMapGenerator targetPackage=&quot;test.xml&quot;  targetProject=&quot;src\main\resources&quot;/&gt;        &lt;javaClientGenerator type=&quot;XMLMAPPER&quot; targetPackage=&quot;test.dao&quot;  targetProject=&quot;src\main\java&quot;/&gt;        &lt;table tableName=&quot;%&quot;&gt;            &lt;generatedKey column=&quot;id&quot; sqlStatement=&quot;Mysql&quot;/&gt;        &lt;/table&gt;    &lt;/context&gt;&lt;/generatorConfiguration&gt;</code></pre><p><table>这里用的通配符匹配全部的表，另外所有表都有自动增长的id字段。如果不是所有表的配置都一样，可以做针对性的配置。<br>改动：去掉来不建议使用Example查询的建议，Example在单表操作上优势明显，可以看个人情况使用。</table></p></property></property></context></generatorconfiguration></generatedkey></table></javaclientgenerator></property></javamodelgenerator></classpathentry>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;使用逆向工程时候遇到的一些问题&quot;&gt;&lt;a href=&quot;#使用逆向工程时候遇到的一些问题&quot; class=&quot;headerlink&quot; title=&quot;使用逆向工程时候遇到的一些问题&quot;&gt;&lt;/a&gt;使用逆向工程时候遇到的一些问题&lt;/h1&gt;&lt;p&gt;在使用Mybatis generatot 自动生成实体类时,遇到一个问题: 实体类中字段名和数据库中的字段名不一致。&lt;br&gt;
    
    </summary>
    
      <category term="java" scheme="http://www.fashionkillyou.xyz/categories/java/"/>
    
    
      <category term="逆向工程" scheme="http://www.fashionkillyou.xyz/tags/%E9%80%86%E5%90%91%E5%B7%A5%E7%A8%8B/"/>
    
  </entry>
  
  <entry>
    <title>eclipse常用的快捷键</title>
    <link href="http://www.fashionkillyou.xyz/2018/04/12/eclipse%E5%B8%B8%E7%94%A8%E7%9A%84%E5%BF%AB%E6%8D%B7%E9%94%AE/"/>
    <id>http://www.fashionkillyou.xyz/2018/04/12/eclipse常用的快捷键/</id>
    <published>2018-04-12T13:45:06.000Z</published>
    <updated>2018-04-12T13:50:08.727Z</updated>
    
    <content type="html"><![CDATA[<script src="\assets\js\APlayer.min.js"> </script><h1 id="以下是eclipse常用的快捷键"><a href="#以下是eclipse常用的快捷键" class="headerlink" title="以下是eclipse常用的快捷键"></a>以下是eclipse常用的快捷键</h1><p>为了方便记忆,先保存起来,这些都是常用的快捷键<br><a id="more"></a></p><p>ctrl+shift+o      导入包<br>alt+/             提示输入代码<br>ctrl+shift+/      全选要注释部分,用/*注释<br>ctrl+/            全选要注释部分，用//多段注释<br>Alt+Shift+R或者右键菜单里面的 refractor 功能          相同变量名全部改成想转换变量名<br>ctrl+shift+f      代码格式整理<br>ctrl+shift+t      查找某各类<br>ctrl+鼠标左键单击  直接查看这个类源代码<br>ctrl+shift+r    打开资源<br>ctrl+o        快速outline,查找当前类中的所有方法及属性<br>ctrl+e  快速切换打开文档<br>shift+enter        在当前行之下创建一个空白行，与光标是否在行末无关<br>ctrl+shift+enter   则在当前行之前插入空白行<br>ctrl+m          编辑器窗口最大化的快捷键<br>Alt+方向键      当前行的内容往上或下移动<br>ctrl+.及ctrl+1   下一个错误及快速修改<br>ctrl+d    删除当前行<br>shift+home 选中鼠标前面内容<br>shift+end  选中鼠标后面内容  </p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;以下是eclipse常用的快捷键&quot;&gt;&lt;a href=&quot;#以下是eclipse常用的快捷键&quot; class=&quot;headerlink&quot; title=&quot;以下是eclipse常用的快捷键&quot;&gt;&lt;/a&gt;以下是eclipse常用的快捷键&lt;/h1&gt;&lt;p&gt;为了方便记忆,先保存起来,这些都是常用的快捷键&lt;br&gt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>fastDFS与nginx安装部署</title>
    <link href="http://www.fashionkillyou.xyz/2018/04/03/fastDFS%E4%B8%8Enginx%E5%AE%89%E8%A3%85%E9%83%A8%E7%BD%B2/"/>
    <id>http://www.fashionkillyou.xyz/2018/04/03/fastDFS与nginx安装部署/</id>
    <published>2018-04-03T11:45:20.000Z</published>
    <updated>2018-04-03T12:22:50.301Z</updated>
    
    <content type="html"><![CDATA[<script src="\assets\js\APlayer.min.js"> </script><h1 id="关于fastDFS的安装"><a href="#关于fastDFS的安装" class="headerlink" title="关于fastDFS的安装"></a>关于fastDFS的安装</h1><h2 id="第一步：搭建虚拟环境"><a href="#第一步：搭建虚拟环境" class="headerlink" title="第一步：搭建虚拟环境"></a>第一步：搭建虚拟环境</h2><p>FastDFS需要在Linux系统上安装，我们一般使用的都是Windows系统，这样就需要有虚拟环境，我这里使用Vmware12创建虚拟机，关于虚拟机最小化的安装大家可以参考：<a href="http://blog.csdn.net/u012453843/article/details/68947589" target="_blank" rel="noopener">http://blog.csdn.net/u012453843/article/details/68947589</a>这篇博客进行学习<br><a id="more"></a></p><h2 id="第二步：配置静态IP而且要保证能上网"><a href="#第二步：配置静态IP而且要保证能上网" class="headerlink" title="第二步：配置静态IP而且要保证能上网"></a>第二步：配置静态IP而且要保证能上网</h2><p>大家可以参考：<a href="http://blog.csdn.net/u012453843/article/details/52839105" target="_blank" rel="noopener">http://blog.csdn.net/u012453843/article/details/52839105</a>这篇博客进行学习，需要提醒的是，由于最小化安装默认是没有vim命令的，因此在配置静态IP时使用vi命令即可。</p><h2 id="第三步：安装vim命令"><a href="#第三步：安装vim命令" class="headerlink" title="第三步：安装vim命令"></a>第三步：安装vim命令</h2><p>之所以安装vim命令是因为在安装它的同时会自动帮我们安装perl，而perl在进行编译安装时是必须要有的。安装vim的命令是：yum install vim-enhanced</p><h2 id="第四步：安装gcc"><a href="#第四步：安装gcc" class="headerlink" title="第四步：安装gcc"></a>第四步：安装gcc</h2><p>使用命令：yum install make cmake gcc gcc-c++进行安装即可</p><h2 id="第五步：上传安装文件到Linux服务器"><a href="#第五步：上传安装文件到Linux服务器" class="headerlink" title="第五步：上传安装文件到Linux服务器"></a>第五步：上传安装文件到Linux服务器</h2><p>  为了便于管理，我们在Linux服务器上新建一个/usr/local/software目录，专门用于存放安装包，如下所示</p><pre><code>[html] view plain copy[root@fastdfs ~]# mkdir /usr/local/software  [root@fastdfs ~]#  </code></pre><p>下面我们把需要用到的安装包都上传到/usr/local/software目录下，我们可以使用XShell和Xftp5相结合来方便的进行上传下载操作，大家可以参考<a href="http://blog.csdn.net/u012453843/article/details/68951776" target="_blank" rel="noopener">http://blog.csdn.net/u012453843/article/details/68951776</a>这篇博客进行学习。也可以通过安装rzsz命令来进行上传下载操作，安装rzsz的命令是yum install lrzsz，安装完之后，rz表示上传，sz 文件表示下载。</p><p>大家可以到<a href="http://download.csdn.net/detail/u012453843/9802538" target="_blank" rel="noopener">http://download.csdn.net/detail/u012453843/9802538</a>这个地址下载需要的安装包，上传完之后，如下所示</p><pre><code>[html] view plain copy[root@fastdfs software]# ll  总用量 1248 -rw-r--r--. 1 root root  17510 11月 28 00:19 fastdfs-nginx-module_v1.16.tar.gz  -rw-r--r--. 1 root root 345400 11月 28 00:20 FastDFS_v5.05.tar.gz  -rw-r--r--. 1 root root 102378 11月 28 00:19 libfastcommon-master.zip  -rw-r--r--. 1 root root 804164 11月 28 01:11 nginx-1.6.2.tar.gz  [root@fastdfs software]# </code></pre><h2 id="第六步：安装zip和unzip命令"><a href="#第六步：安装zip和unzip命令" class="headerlink" title="第六步：安装zip和unzip命令"></a>第六步：安装zip和unzip命令</h2><pre><code>由于解压.zip结尾的文件需要用到unzip命令，因此我们需要安装，安装命令是yum install zip unzip</code></pre><h2 id="第七步：安装libfastcommon"><a href="#第七步：安装libfastcommon" class="headerlink" title="第七步：安装libfastcommon"></a>第七步：安装libfastcommon</h2><pre><code>1、解压[html] view plain copy[root@fastdfs software]# unzip libfastcommon-master.zip -d /usr/local/fast/  2、进入目录[html] view plain copy[root@fastdfs software]# cd /usr/local/fast/libfastcommon-master/  [root@fastdfs libfastcommon-master]# ll  总用量 28  -rw-r--r--. 1 root root 2913 2月  27 2015 HISTORY  -rw-r--r--. 1 root root  582 2月  27 2015 INSTALL  -rw-r--r--. 1 root root 1342 2月  27 2015 libfastcommon.spec  -rwxr-xr-x. 1 root root 2151 2月  27 2015 make.sh  drwxr-xr-x. 2 root root 4096 2月  27 2015 php-fastcommon  -rw-r--r--. 1 root root  617 2月  27 2015 README  drwxr-xr-x. 2 root root 4096 2月  27 2015 src  [root@fastdfs libfastcommon-master]#    3、编译[html] view plain copy[root@fastdfs libfastcommon-master]# ./make.sh    4、安装[html] view plain copy[root@fastdfs libfastcommon-master]# ./make.sh install</code></pre><h2 id="第八步：创建软链接"><a href="#第八步：创建软链接" class="headerlink" title="第八步：创建软链接"></a>第八步：创建软链接</h2><p> FastDFS主程序设置的目录为/usr/local/lib/，所以我们需要创建/ usr/lib64/下的一些核心执行程序的软连接文件。如下所示。</p><pre><code>[html] view plain copy[root@fastdfs libfastcommon-master]# ln -s /usr/lib64/libfastcommon.so /usr/local/lib/libfastcommon.so  [root@fastdfs libfastcommon-master]# ln -s /usr/lib64/libfastcommon.so /usr/lib/libfastcommon.so  [root@fastdfs libfastcommon-master]# ln -s /usr/lib64/libfdfsclient.so /usr/local/lib/libfdfsclient.so  [root@fastdfs libfastcommon-master]# ln -s /usr/lib64/libfdfsclient.so /usr/lib/libfdfsclient.so</code></pre><h2 id="第九步：安装FastDFS"><a href="#第九步：安装FastDFS" class="headerlink" title="第九步：安装FastDFS"></a>第九步：安装FastDFS</h2><p>1、进入到cd /usr/local/software下，解压FastDFS_v5.05.tar.gz文件 </p><pre><code>[html] view plain copy[root@fastdfs fast]# cd /usr/local/software/  [root@fastdfs software]# ll  总用量 1248  -rw-r--r--. 1 root root  17510 4月  11 03:28 fastdfs-nginx-module_v1.16.tar.gz  -rw-r--r--. 1 root root 345400 4月  11 03:28 FastDFS_v5.05.tar.gz  -rw-r--r--. 1 root root 102378 4月  11 03:28 libfastcommon-master.zip  -rw-r--r--. 1 root root 804164 4月  11 03:29 nginx-1.6.2.tar.gz  [root@fastdfs software]# tar -zxvf FastDFS_v5.05.tar.gz -C /usr/local/fast/  </code></pre><p>2、编译安装</p><pre><code>[html] view plain copy[root@fastdfs software]# cd /usr/local/fast/FastDFS/  [root@fastdfs FastDFS]# ./make.sh  [root@fastdfs FastDFS]# ./make.sh install    安装完后，服务脚本位置如下[html] view plain copy[root@fastdfs FastDFS]# cd /etc/init.d/ &amp;&amp; ls | grep fdfs  fdfs_storaged  fdfs_trackerd  [root@fastdfs init.d]#     配置文件位置如下：[html] view plain copy[root@fastdfs init.d]# cd /etc/fdfs/  [root@fastdfs fdfs]# ll  总用量 20  -rw-r--r--. 1 root root 1461 4月  11 04:10 client.conf.sample  -rw-r--r--. 1 root root 7829 4月  11 04:10 storage.conf.sample  -rw-r--r--. 1 root root 7102 4月  11 04:10 tracker.conf.sample  [root@fastdfs fdfs]#      FastDFS一系列执行脚本如下，可以看到有上传文件脚本、下载文件脚本等等。[html] view plain copy[root@fastdfs fdfs]# cd /usr/bin/ &amp;&amp; ls | grep fdfs  fdfs_appender_test  fdfs_appender_test1  fdfs_append_file  fdfs_crc32  fdfs_delete_file  fdfs_download_file  fdfs_file_info  fdfs_monitor  fdfs_storaged  fdfs_test  fdfs_test1  fdfs_trackerd  fdfs_upload_appender  fdfs_upload_file  [root@fastdfs bin]#  </code></pre><p>3、因为FastDFS服务脚本设置的bin目录为/usr/local/bin/下,但是实际我们安装在了/u sr/bin/下面。所以我们需要修改FastDFS配置文件中的路径，也就是需要修改两个配置文件</p><p>使用命令vim /etc/init.d/fdfs_storaged进入编辑模式，然后直接输入”:”，光标会定位到最后一行，在”:”后输入”%s+/usr/local/bin+/usr/bin”，如下图所示。输入完之后回车，会提示修改了7处。为了确保所有的/usr/local/bin都被替换了，我们可以再打开文件确认一下。</p><p><img src="http://p6lpbrjv6.bkt.clouddn.com/1.jpg" alt=""></p><p>接着修改第二个配置文件，我们使用命令vim /etc/init.d/fdfs_trackerd进入编辑模式，接着按照上面那样输入”:%s+/usr/local/bin+/usr/bin “并按回车，同样会提醒我们修改了7处。</p><p><img src="http://p6lpbrjv6.bkt.clouddn.com/2.png" alt=""></p><h2 id="第十步：配置跟踪器"><a href="#第十步：配置跟踪器" class="headerlink" title="第十步：配置跟踪器"></a>第十步：配置跟踪器</h2><pre><code> 1、进入到/etc/fdfs目录并且复制一份tracker.conf.sample并命名为tracker.conf，如下所示。[html] view plain copy[root@fastdfs bin]# cd /etc/fdfs/  [root@fastdfs fdfs]# ll  总用量 20  -rw-r--r--. 1 root root 1461 4月  11 04:10 client.conf.sample  -rw-r--r--. 1 root root 7829 4月  11 04:10 storage.conf.sample  -rw-r--r--. 1 root root 7102 4月  11 04:10 tracker.conf.sample  [root@fastdfs fdfs]# cp tracker.conf.sample tracker.conf  [root@fastdfs fdfs]#   </code></pre><p>2、使用命令vim /etc/fdfs/tracker.conf进入编辑模式，然后修改base_path的值为/fastdfs/tracker，如下图所示。</p><p><img src="http://p6lpbrjv6.bkt.clouddn.com/3.png" alt=""></p><p>3、我们在上图配置文件中配置的/fastdfs/tracker目前是不存在的，因此我们需要创建一下该目录</p><pre><code>[html] view plain copy[root@fastdfs fdfs]# mkdir -p /fastdfs/tracker  [root@fastdfs fdfs]#   </code></pre><p>4、配置防火墙，放开tracker使用的端口22122，使用命令vim /etc/sysconfig/iptables进入编辑模式，添加一行内容-A INPUT -m state –state NEW -m tcp -p tcp –dport 22122 -j ACCEPT，如下图所示。</p><p><img src="http://p6lpbrjv6.bkt.clouddn.com/4.png" alt=""></p><p>5、重启防火墙</p><pre><code>[html] view plain copy[root@fastdfs fdfs]# service iptables restart  iptables：将链设置为政策 ACCEPT：filter                    [确定]  iptables：清除防火墙规则：                                 [确定]  iptables：正在卸载模块：                                   [确定]  iptables：应用防火墙规则：                                 [确定]  [root@fastdfs fdfs]#   </code></pre><p>6、在启动tracker之前，/fastdfs/tracker目录下是没有任何文件的，如下所示</p><pre><code>[html] view plain copy[root@fastdfs tracker]# cd /fastdfs/tracker/ &amp;&amp; ll  总用量 0  [root@fastdfs tracker]#  </code></pre><p>启动tracker，启动完之后，可以看到这个目录下多了两个目录data和logs。如下所示。</p><pre><code>[html] view plain copy[root@fastdfs tracker]# /etc/init.d/fdfs_trackerd start   Starting FastDFS tracker server:   [root@fastdfs tracker]# cd /fastdfs/tracker/ &amp;&amp; ll  总用量 8  drwxr-xr-x. 2 root root 4096 4月  11 05:01 data  drwxr-xr-x. 2 root root 4096 4月  11 05:01 logs  [root@fastdfs tracker]#   </code></pre><p>7、设置开机自启动，在rc.local文件中添加/etc/init.d/fdfs_trackerd start，如下所示。</p><pre><code>[html] view plain copy[root@fastdfs tracker]# vim /etc/rc.d/rc.local  #!/bin/sh  #  # This script will be executed *after* all the other init scripts.  # You can put your own initialization stuff in here if you don&apos;t  # want to do the full Sys V style init stuff.  touch /var/lock/subsys/local  /etc/init.d/fdfs_trackerd start</code></pre><h2 id="第十一步：配置FastDFS存储"><a href="#第十一步：配置FastDFS存储" class="headerlink" title="第十一步：配置FastDFS存储"></a>第十一步：配置FastDFS存储</h2><p>1、进入/etc/fdfs目录，复制一份storage.conf.sample文件并命名为storage.conf，如下所示。</p><pre><code>[html] view plain copy[root@fastdfs tracker]# cd /etc/fdfs/  [root@fastdfs fdfs]# ll  总用量 28  -rw-r--r--. 1 root root 1461 4月  11 04:10 client.conf.sample  -rw-r--r--. 1 root root 7829 4月  11 04:10 storage.conf.sample  -rw-r--r--. 1 root root 7098 4月  11 04:45 tracker.conf  -rw-r--r--. 1 root root 7102 4月  11 04:10 tracker.conf.sample  [root@fastdfs fdfs]# cp storage.conf.sample storage.conf  [root@fastdfs fdfs]# ll  总用量 36  -rw-r--r--. 1 root root 1461 4月  11 04:10 client.conf.sample  -rw-r--r--. 1 root root 7829 4月  11 05:07 storage.conf  -rw-r--r--. 1 root root 7829 4月  11 04:10 storage.conf.sample  -rw-r--r--. 1 root root 7098 4月  11 04:45 tracker.conf  -rw-r--r--. 1 root root 7102 4月  11 04:10 tracker.conf.sample  [root@fastdfs fdfs]#  </code></pre><p>2、修改storage.conf文件 ，我们使用命令vim /etc/fdfs/storage.conf进入编辑模式，对以下四项进行修改，192.168.156.13是我的虚拟机的IP，大家根据自己虚拟机的IP自行设置。(注意网上的那片文章没有加group_name和buff_size)</p><pre><code>[html] view plain copygroup_name=group1base_path=/fastdfs/storagestore_path0=/fastdfs/storagetracker_server=10.1.84.52:22122http.server_port=8888buff_size = 256KB </code></pre><p>3、创建存储目录，如下所示。</p><pre><code>[html] view plain copy[root@fastdfs fdfs]# mkdir -p /fastdfs/storage  [root@fastdfs fdfs]#   </code></pre><p>4、配置防火墙，允许外界访问storage的默认端口23000，如下所示。</p><pre><code>[html] view plain copy[root@fastdfs fdfs]# vim /etc/sysconfig/iptables  # Firewall configuration written by system-config-firewall  # Manual customization of this file is not recommended.  *filter  :INPUT ACCEPT [0:0]  :FORWARD ACCEPT [0:0]  :OUTPUT ACCEPT [0:0]  -A INPUT -m state --state ESTABLISHED,RELATED -j ACCEPT  -A INPUT -p icmp -j ACCEPT  -A INPUT -i lo -j ACCEPT  -A INPUT -m state --state NEW -m tcp -p tcp --dport 22 -j ACCEPT  -A INPUT -m state --state NEW -m tcp -p tcp --dport 22122 -j ACCEPT  -A INPUT -m state --state NEW -m tcp -p tcp --dport 23000 -j ACCEPT  -A INPUT -j REJECT --reject-with icmp-host-prohibited  -A FORWARD -j REJECT --reject-with icmp-host-prohibited  COMMIT  </code></pre><p>添加完之后，重启防火墙，如下所示。<br>    [html] view plain copy<br>    [root@fastdfs fdfs]# service iptables restart<br>    iptables：将链设置为政策 ACCEPT：filter                    [确定]<br>    iptables：清除防火墙规则：                                 [确定]<br>    iptables：正在卸载模块：                                   [确定]<br>    iptables：应用防火墙规则：                                 [确定]<br>    [root@fastdfs fdfs]#<br>5、在启动storage之前，/fastdbf/storage目录下是没有任何文件的</p><pre><code>[html] view plain copy[root@fastdfs fdfs]# cd /fastdfs/storage/ &amp;&amp; ll  总用量 0  [root@fastdfs storage]#   </code></pre><p>启动storage，启动后再看/fastdfs/storage目录，可以看到多了data和logs。</p><pre><code>[html] view plain copy[root@fastdfs storage]# /etc/init.d/fdfs_storaged start  Starting FastDFS storage server:   [root@fastdfs storage]# cd /fastdfs/storage/ &amp;&amp; ll  总用量 8  drwxr-xr-x. 68 root root 4096 4月  11 05:21 data  drwxr-xr-x.  2 root root 4096 4月  11 05:20 logs  [root@fastdfs storage]#  </code></pre><p>6、查看FastDFS tracker和storage 是否启动成功，当看到如下所示信息时说明都启动成功了。</p><pre><code>[html] view plain copy[root@fastdfs storage]# ps -ef | grep fdfs  root       2124      1  0 05:01 ?        00:00:00 /usr/bin/fdfs_trackerd /etc/fdfs/tracker.conf  root       2228      1  0 05:21 ?        00:00:00 /usr/bin/fdfs_storaged /etc/fdfs/storage.conf  root       2238   1360  0 05:22 pts/0    00:00:00 grep fdfs  [root@fastdfs storage]#  </code></pre><p>7、我们进入到 /fastdfs/storage/data/目录下，可以看到两级共256*256个目录，每级都是从00到FF，如下只是列出了第一级的目录，点进去每个目录都还有00到FF共256个目录。</p><pre><code>[html] view plain copy[root@fastdfs storage]# cd /fastdfs/storage/data/ &amp;&amp; ls  00  09  12  1B  24  2D  36  3F  48  51  5A  63  6C  75  7E  87  90  99  A2  AB  B4  BD  C6  CF  D8  E1  EA  F3  FC  01  0A  13  1C  25  2E  37  40  49  52  5B  64  6D  76  7F  88  91  9A  A3  AC  B5  BE  C7  D0  D9  E2  EB  F4  FD  02  0B  14  1D  26  2F  38  41  4A  53  5C  65  6E  77  80  89  92  9B  A4  AD  B6  BF  C8  D1  DA  E3  EC  F5  fdfs_storaged.pid  03  0C  15  1E  27  30  39  42  4B  54  5D  66  6F  78  81  8A  93  9C  A5  AE  B7  C0  C9  D2  DB  E4  ED  F6  FE  04  0D  16  1F  28  31  3A  43  4C  55  5E  67  70  79  82  8B  94  9D  A6  AF  B8  C1  CA  D3  DC  E5  EE  F7  FF  05  0E  17  20  29  32  3B  44  4D  56  5F  68  71  7A  83  8C  95  9E  A7  B0  B9  C2  CB  D4  DD  E6  EF  F8  storage_stat.dat  06  0F  18  21  2A  33  3C  45  4E  57  60  69  72  7B  84  8D  96  9F  A8  B1  BA  C3  CC  D5  DE  E7  F0  F9  sync  07  10  19  22  2B  34  3D  46  4F  58  61  6A  73  7C  85  8E  97  A0  A9  B2  BB  C4  CD  D6  DF  E8  F1  FA  08  11  1A  23  2C  35  3E  47  50  59  62  6B  74  7D  86  8F  98  A1  AA  B3  BC  C5  CE  D7  E0  E9  F2  FB  [root@fastdfs data]#   </code></pre><p>8、设置storage开机自启动，添加一行/etc/init.d/fdfs_storaged start，如下所示。</p><pre><code>[html] view plain copy[root@fastdfs data]# vim /etc/rc.local   #!/bin/sh  #  # This script will be executed *after* all the other init scripts.  # You can put your own initialization stuff in here if you don&apos;t  # want to do the full Sys V style init stuff.  touch /var/lock/subsys/local  /etc/init.d/fdfs_trackerd start  /etc/init.d/fdfs_storaged start  </code></pre><h2 id="第十二步：测试图片上传"><a href="#第十二步：测试图片上传" class="headerlink" title="第十二步：测试图片上传"></a>第十二步：测试图片上传</h2><p>1、进入到/etc/fdfs目录下并复制一份client.conf.sample并更名为client.conf，如下所示。</p><pre><code>[html] view plain copy[root@fastdfs data]# cd /etc/fdfs  [root@fastdfs fdfs]# ll  总用量 36  -rw-r--r--. 1 root root 1461 4月  11 04:10 client.conf.sample  -rw-r--r--. 1 root root 7820 4月  11 05:12 storage.conf  -rw-r--r--. 1 root root 7829 4月  11 04:10 storage.conf.sample  -rw-r--r--. 1 root root 7098 4月  11 04:45 tracker.conf  -rw-r--r--. 1 root root 7102 4月  11 04:10 tracker.conf.sample  [root@fastdfs fdfs]# cp client.conf.sample client.conf  [root@fastdfs fdfs]# ll  总用量 40  -rw-r--r--. 1 root root 1461 4月  11 05:40 client.conf  -rw-r--r--. 1 root root 1461 4月  11 04:10 client.conf.sample  -rw-r--r--. 1 root root 7820 4月  11 05:12 storage.conf  -rw-r--r--. 1 root root 7829 4月  11 04:10 storage.conf.sample  -rw-r--r--. 1 root root 7098 4月  11 04:45 tracker.conf  -rw-r--r--. 1 root root 7102 4月  11 04:10 tracker.conf.sample  [root@fastdfs fdfs]#   </code></pre><p>2、使用命令vim /etc/fdfs/client.conf进入编辑模式并修改如下两项内容，如下所示。</p><pre><code>[html] view plain copybase_path=/fastdfs/tracker  tracker_server=192.168.156.13:22122  </code></pre><p>3、我们找到命令的脚本位置，并且使用命令，进行文件的上传。</p><pre><code>[html] view plain copy[root@fastdfs bin]# cd /usr/bin/ &amp;&amp; ls | grep fdfs  fdfs_appender_test  fdfs_appender_test1  fdfs_append_file  fdfs_crc32  fdfs_delete_file  fdfs_download_file  fdfs_file_info  fdfs_monitor  fdfs_storaged  fdfs_test  fdfs_test1  fdfs_trackerd  fdfs_upload_appender  fdfs_upload_file  [root@fastdfs bin]#   </code></pre><p>下面使用fdfs_upload_file脚本进行文件上传操作，如下所示。可以看到已经上传成功了，返回的是图片的保存位置：group1/M00/00/00/wKicDVjr_ayAE4VVAAHk-VzqZ6w020.jpg</p><pre><code>[html] view plain copy[root@fastdfs bin]# /usr/bin/fdfs_upload_file /etc/fdfs/client.conf /usr/local/software/3.jpg  group1/M00/00/00/wKicDVjr_ayAE4VVAAHk-VzqZ6w020.jpg  [root@fastdfs bin]#  </code></pre><h2 id="第十三步：FastDFS与nginx相结合"><a href="#第十三步：FastDFS与nginx相结合" class="headerlink" title="第十三步：FastDFS与nginx相结合"></a>第十三步：FastDFS与nginx相结合</h2><p>1、先安装nginx，大家可以参考<a href="http://blog.csdn.net/u012453843/article/details/69396434" target="_blank" rel="noopener">http://blog.csdn.net/u012453843/article/details/69396434</a>这篇博客的第四步Nginx安装（我们已经安装过的vim、gcc等就不需要重复安装了）。</p><p>2、安装fastdfs-nginxmodule_v1.16.tar.gz（fast与nginx相结合的模块安装包）， 进入 /usr/local/software目录并解压，如下所示。</p><pre><code>[html] view plain copy[root@fastdfs nginx-1.6.2]# cd /usr/local/software/  [root@fastdfs software]# tar -zxvf fastdfs-nginx-module_v1.16.tar.gz -C /usr/local/fast/  fastdfs-nginx-module/  fastdfs-nginx-module/src/  fastdfs-nginx-module/src/ngx_http_fastdfs_module.c  fastdfs-nginx-module/src/mod_fastdfs.conf  fastdfs-nginx-module/src/config  fastdfs-nginx-module/src/common.h  fastdfs-nginx-module/src/common.c  fastdfs-nginx-module/INSTALL  fastdfs-nginx-module/HISTORY  [root@fastdfs software]#  </code></pre><p>3、进入到/usr/local/fast目录下可以看到解压的fastdfs-nginx-module目录，然后进入到fastdfs-nginx-module/src/目录下，可以看到config文件。</p><pre><code>[html] view plain copy[root@fastdfs software]# cd /usr/local/fast/  [root@fastdfs fast]# ll  总用量 12  drwxr-xr-x. 10 8980 users 4096 4月  11 04:10 FastDFS  drwxrwxr-x.  3  500   500 4096 5月   4 2014 fastdfs-nginx-module  drwxr-xr-x.  4 root root  4096 4月  11 03:30 libfastcommon-master  [root@fastdfs fast]# cd fastdfs-nginx-module/src/  [root@fastdfs src]# ll  总用量 76  -rw-rw-r--. 1 500 500 33207 8月  30 2013 common.c  -rw-rw-r--. 1 500 500  3479 1月   3 2012 common.h  -rw-rw-r--. 1 500 500   447 11月  4 2010 config  -rw-rw-r--. 1 500 500  3679 3月  30 2013 mod_fastdfs.conf  -rw-rw-r--. 1 500 500 28542 5月   4 2014 ngx_http_fastdfs_module.c  [root@fastdfs src]#   </code></pre><p>修改该conf文件，我们把文件的第四行配置中的/usr/local/include都改为/usr/include，共两处。</p><p><img src="http://p6lpbrjv6.bkt.clouddn.com/5.png" alt=""></p><p>4、fastdfs与nginx进行结合，由于我们刚才安装过nginx了，因此在/usr/local目录下已经生成了一个nginx目录了，如下图所示。</p><p><img src="http://p6lpbrjv6.bkt.clouddn.com/6.png" alt=""></p><p>为了将nginx与fastdfs相结合，我们先把这个nginx目录删除掉，如下图所示，可以看到已经没有nginx目录了。</p><p><img src="http://p6lpbrjv6.bkt.clouddn.com/7.png" alt=""></p><p> 进入到nginx-1.6.2/目录下并执行配置和编译安装，如下所示。</p><pre><code>[html] view plain copy[root@fastdfs local]# cd nginx-1.6.2/  [root@fastdfs nginx-1.6.2]# ./configure --add-module=/usr/local/fast/fastdfs-nginx-module/src/  [root@fastdfs nginx-1.6.2]# make &amp;&amp; make install  </code></pre><p>复制fastdfs-nginx-module中的配置文件，到/etc/fdfs目录中，如下所示。</p><pre><code>[html] view plain copy[root@fastdfs fdfs]# cd /usr/local/fast/fastdfs-nginx-module/src/  [root@fastdfs src]# ll  总用量 76  -rw-rw-r--. 1 500 500 33207 8月  30 2013 common.c  -rw-rw-r--. 1 500 500  3479 1月   3 2012 common.h  -rw-rw-r--. 1 500 500   435 4月  11 06:09 config  -rw-rw-r--. 1 500 500  3679 3月  30 2013 mod_fastdfs.conf  -rw-rw-r--. 1 500 500 28542 5月   4 2014 ngx_http_fastdfs_module.c  [root@fastdfs src]# cp /usr/local/fast/fastdfs-nginx-module/src/mod_fastdfs.conf /etc/fdfs/  [root@fastdfs src]#   </code></pre><p>我们到 /etc/fdfs/ 目录下，修改我们刚copy过来的mod_fastdfs.conf 文件，需要修改的项如下，其中第一项是超时时长，第三项是允许外界通过http方式访问资源。</p><pre><code>[html] view plain copyconnect_timeout=10  tracker_server=192.168.156.13:22122  url_have_group_name = true  store_path0=/fastdfs/storage  </code></pre><p>复制FastDFS里的2个文件，到/etc/fdfs目录中，如下所示。</p><pre><code>[html] view plain copy[root@fastdfs fdfs]# cd /usr/local/fast/FastDFS/conf/  [root@fastdfs conf]# ll  总用量 84  -rw-r--r--. 1 8980 users 23981 12月  2 2014 anti-steal.jpg  -rw-r--r--. 1 8980 users  1461 12月  2 2014 client.conf  -rw-r--r--. 1 8980 users   858 12月  2 2014 http.conf  -rw-r--r--. 1 8980 users 31172 12月  2 2014 mime.types  -rw-r--r--. 1 8980 users  7829 12月  2 2014 storage.conf  -rw-r--r--. 1 8980 users   105 12月  2 2014 storage_ids.conf  -rw-r--r--. 1 8980 users  7102 12月  2 2014 tracker.conf  [root@fastdfs conf]# cp http.conf mime.types /etc/fdfs/  [root@fastdfs conf]#   </code></pre><p>创建一个软连接，在/fastdfs/storage文件存储目录下创建软连接，将其链接到实际存放数据 的目录，如下所示。</p><pre><code>[html] view plain copy[root@fastdfs conf]# ln -s /fastdfs/storage/data/ /fastdfs/storage/data/M00  [root@fastdfs conf]#   </code></pre><p>进入到/usr/local/nginx/conf/目录下，修改nginx.conf文件，如下图所示。</p><p><img src="http://p6lpbrjv6.bkt.clouddn.com/8.png" alt=""></p><p>修改的内容如下图示</p><p><img src="http://p6lpbrjv6.bkt.clouddn.com/9.png" alt=""></p><p>可以直接复制下面的内容。</p><pre><code>[html] view plain copylisten       8888;  location ~/group([0-9])/M00 {       ngx_fastdfs_module;  }  </code></pre><p>设置nginx开机自启动，这样下次重启设备之后，tracker、storage、nginx都自动启动了，直接就可以使用服务，如下所示。</p><pre><code>[html] view plain copy[root@fastdfs ~]# vim /etc/rc.d/rc.local   #!/bin/sh  #  # This script will be executed *after* all the other init scripts.  # You can put your own initialization stuff in here if you don&apos;t  # want to do the full Sys V style init stuff.  touch /var/lock/subsys/local  /etc/init.d/fdfs_trackerd start  /etc/init.d/fdfs_storaged start  /usr/local/nginx/sbin/nginx  </code></pre><p>启动nginx，如下所示。</p><pre><code>[html] view plain copy[root@fastdfs conf]# /usr/local/nginx/sbin/nginx   ngx_http_fastdfs_set pid=6809  [root@fastdfs conf]#   </code></pre><p>5、在通过8888端口访问图片之前先配置下防火墙，允许外界访问8888端口，添加的一行是-A INPUT -m state –state NEW -m tcp -p tcp –dport 8888 -j ACCEPT，如下图所示。<br><img src="http://p6lpbrjv6.bkt.clouddn.com/10.png" alt=""></p><p>配置完防火墙后重启防火墙</p><pre><code>[html] view plain copy[root@fastdfs conf]# service iptables restart  iptables：将链设置为政策 ACCEPT：filter                    [确定]  iptables：清除防火墙规则：                                 [确定]  iptables：正在卸载模块：                                   [确定]  iptables：应用防火墙规则：                                 [确定]  [root@fastdfs conf]#   </code></pre><p>6、现在我们便可以通过http的方式访问我们刚才上传的图片了（我们刚才上传图片返回的地址是group1/M00/00/00/wKicDVjr_ayAE4VVAAHk-VzqZ6w020.jpg）</p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;关于fastDFS的安装&quot;&gt;&lt;a href=&quot;#关于fastDFS的安装&quot; class=&quot;headerlink&quot; title=&quot;关于fastDFS的安装&quot;&gt;&lt;/a&gt;关于fastDFS的安装&lt;/h1&gt;&lt;h2 id=&quot;第一步：搭建虚拟环境&quot;&gt;&lt;a href=&quot;#第一步：搭建虚拟环境&quot; class=&quot;headerlink&quot; title=&quot;第一步：搭建虚拟环境&quot;&gt;&lt;/a&gt;第一步：搭建虚拟环境&lt;/h2&gt;&lt;p&gt;FastDFS需要在Linux系统上安装，我们一般使用的都是Windows系统，这样就需要有虚拟环境，我这里使用Vmware12创建虚拟机，关于虚拟机最小化的安装大家可以参考：&lt;a href=&quot;http://blog.csdn.net/u012453843/article/details/68947589&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;http://blog.csdn.net/u012453843/article/details/68947589&lt;/a&gt;这篇博客进行学习&lt;br&gt;
    
    </summary>
    
      <category term="java" scheme="http://www.fashionkillyou.xyz/categories/java/"/>
    
    
      <category term="FastDFS" scheme="http://www.fashionkillyou.xyz/tags/FastDFS/"/>
    
  </entry>
  
  <entry>
    <title>最近收集的前端素材,给大家分享一波~</title>
    <link href="http://www.fashionkillyou.xyz/2018/03/25/%E6%9C%80%E8%BF%91%E6%94%B6%E9%9B%86%E7%9A%84%E5%89%8D%E7%AB%AF%E7%B4%A0%E6%9D%90-%E7%BB%99%E5%A4%A7%E5%AE%B6%E5%88%86%E4%BA%AB%E4%B8%80%E6%B3%A2/"/>
    <id>http://www.fashionkillyou.xyz/2018/03/25/最近收集的前端素材-给大家分享一波/</id>
    <published>2018-03-25T07:51:23.000Z</published>
    <updated>2018-03-25T08:03:09.102Z</updated>
    
    <content type="html"><![CDATA[<script src="\assets\js\APlayer.min.js"> </script><p>最近发现一个很好的网站,给大家推广一下:</p><p><a href="http://www.17sucai.com/" title="http://www.17sucai.com/" target="_blank" rel="noopener">http://www.17sucai.com/</a></p><p>这个网站里面有很多分享的前端很好用的素材,只需要每天签到,连续签3天就可以获得一天时间的vip会员,能下载10个素材.<br><a id="more"></a><br>下面是我积累的一些素材,如果有需要可以到下面我分享的连接下载:</p><p><img src="http://p57l8frp4.bkt.clouddn.com/17%E7%B4%A0%E6%9D%901.jpg" alt=""></p><p><img src="http://p57l8frp4.bkt.clouddn.com/17%E7%B4%A0%E6%9D%902.jpg" alt=""></p><p>下载地址:</p><p>链接：<br><a href="https://pan.baidu.com/s/11lkX4ShzfQOxuo8os-Zo3w" target="_blank" rel="noopener">https://pan.baidu.com/s/11lkX4ShzfQOxuo8os-Zo3w</a></p><p>密码： 61ne</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;最近发现一个很好的网站,给大家推广一下:&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;http://www.17sucai.com/&quot; title=&quot;http://www.17sucai.com/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;http://www.17sucai.com/&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;这个网站里面有很多分享的前端很好用的素材,只需要每天签到,连续签3天就可以获得一天时间的vip会员,能下载10个素材.&lt;br&gt;
    
    </summary>
    
      <category term="前端" scheme="http://www.fashionkillyou.xyz/categories/%E5%89%8D%E7%AB%AF/"/>
    
    
      <category term="素材" scheme="http://www.fashionkillyou.xyz/tags/%E7%B4%A0%E6%9D%90/"/>
    
  </entry>
  
  <entry>
    <title>FreeMarker模板引擎</title>
    <link href="http://www.fashionkillyou.xyz/2018/03/21/FreeMarker%E6%A8%A1%E6%9D%BF%E5%BC%95%E6%93%8E/"/>
    <id>http://www.fashionkillyou.xyz/2018/03/21/FreeMarker模板引擎/</id>
    <published>2018-03-21T11:53:33.000Z</published>
    <updated>2018-03-21T15:53:38.314Z</updated>
    
    <content type="html"><![CDATA[<script src="\assets\js\APlayer.min.js"> </script><h1 id="什么是-Freemarker"><a href="#什么是-Freemarker" class="headerlink" title="什么是 Freemarker"></a>什么是 Freemarker</h1><p>FreeMarker 是一个用 Java 语言编写的模板引擎，它基于模板来生成文本输出。FreeMarker与 Web 容器无关，即在 Web 运行时，它并不知道 Servlet 或 HTTP。它不仅可以用作表现层的实现技术，而且还可以用于生成 XML，JSP 或 Java 等。<br><a id="more"></a><br><img src="http://p57l8frp4.bkt.clouddn.com/freemarker1.png" alt=""></p><h1 id="Freemarker入门小DEMO"><a href="#Freemarker入门小DEMO" class="headerlink" title="Freemarker入门小DEMO"></a>Freemarker入门小DEMO</h1><h2 id="工程引入依赖"><a href="#工程引入依赖" class="headerlink" title="工程引入依赖"></a>工程引入依赖</h2><pre><code>&lt;dependency&gt;        &lt;groupId&gt;org.freemarker&lt;/groupId&gt;        &lt;artifactId&gt;freemarker&lt;/artifactId&gt;        &lt;version&gt;2.3.23&lt;/version&gt;&lt;/dependency&gt;  </code></pre><h2 id="创建模板文件"><a href="#创建模板文件" class="headerlink" title="创建模板文件"></a>创建模板文件</h2><p>模板文件中四种元素</p><p>  1、文本，直接输出的部分</p><p>  2、注释，即&lt;#–…–&gt;格式不会输出</p><p>  3、插值（Interpolation）：即${..}部分,将使用数据模型中的部分替代输出</p><p>  4、FTL指令：FreeMarker指令，和HTML标记类似，名字前加#予以区分，不会输出。</p><p>我们现在就创建一个简单的创建模板文件test.ftl</p><pre><code>&lt;html&gt;&lt;head&gt;    &lt;meta charset=&quot;utf-8&quot;&gt;    &lt;title&gt;Freemarker入门小DEMO &lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;#--我只是一个注释，我不会有任何输出  --&gt;${name},你好。${message}&lt;/body&gt;&lt;/html&gt;</code></pre><p>这里有文本、插值和注释</p><h2 id="生成文件"><a href="#生成文件" class="headerlink" title="生成文件"></a>生成文件</h2><p>使用步骤：</p><p>第一步：创建一个 Configuration 对象，直接 new 一个对象。构造方法的参数就是 freemarker的版本号。</p><p>第二步：设置模板文件所在的路径。</p><p>第三步：设置模板文件使用的字符集。一般就是 utf-8.</p><p>第四步：加载一个模板，创建一个模板对象。</p><p>第五步：创建一个模板使用的数据集，可以是 pojo 也可以是 map。一般是 Map。</p><p>第六步：创建一个 Writer 对象，一般创建一 FileWriter 对象，指定生成的文件名。</p><p>第七步：调用模板对象的 process 方法输出文件。</p><p>第八步：关闭流</p><p>代码：<br>创建Test类 main方法如下：</p><pre><code> //1.创建配置类Configuration configuration=new Configuration(Configuration.getVersion());//2.设置模板所在的目录 configuration.setDirectoryForTemplateLoading(new File(&quot;D:/pinyougou_work/freemarkerDemo/src/main/resources/&quot;));//3.设置字符集configuration.setDefaultEncoding(&quot;utf-8&quot;);//4.加载模板Template template = configuration.getTemplate(&quot;test.ftl&quot;);//5.创建数据模型Map map=new HashMap();map.put(&quot;name&quot;, &quot;张三 &quot;);map.put(&quot;message&quot;, &quot;欢迎来到神奇的品优购世界！&quot;);//6.创建Writer对象Writer out =new FileWriter(new File(&quot;d:\\test.html&quot;));//7.输出template.process(map, out);//8.关闭Writer对象out.close();</code></pre><p>执行后，在D盘根目录即可看到生成的test.html ，打开看看</p><h1 id="FTL指令"><a href="#FTL指令" class="headerlink" title="FTL指令"></a>FTL指令</h1><h2 id="assign指令"><a href="#assign指令" class="headerlink" title="assign指令"></a>assign指令</h2><p>此指令用于在页面上定义一个变量 </p><p>（1）定义简单类型：</p><pre><code>&lt;#assign linkman=&quot;周先生&quot;&gt;联系人：${linkman}</code></pre><p>（2）定义对象类型：</p><pre><code>&lt;#assign info={&quot;mobile&quot;:&quot;13301231212&quot;,&apos;address&apos;:&apos;北京市昌平区王府街&apos;} &gt;电话：${info.mobile}  地址：${info.address}</code></pre><h2 id="include指令"><a href="#include指令" class="headerlink" title="include指令"></a>include指令</h2><p>此指令用于模板文件的嵌套</p><p>创建模板文件head.ftl</p><pre><code>&lt;h1&gt;信息网&lt;/h1&gt;</code></pre><p>我们修改test.ftl，在模板文件中使用include指令引入刚才我们建立的模板</p><pre><code>&lt;#include &quot;head.ftl&quot;&gt;</code></pre><h2 id="if指令"><a href="#if指令" class="headerlink" title="if指令"></a>if指令</h2><p>在模板文件上添加</p><pre><code>&lt;#if success=true&gt;  你已通过实名认证&lt;#else&gt;    你未通过实名认证&lt;/#if&gt;</code></pre><p>在代码中对str变量赋值</p><pre><code>map.put(&quot;success&quot;, true);</code></pre><p>在freemarker的判断中，可以使用= 也可以使用== </p><h2 id="list指令"><a href="#list指令" class="headerlink" title="list指令"></a>list指令</h2><p>（1）代码中对变量goodsList赋值</p><pre><code>List goodsList=new ArrayList();Map goods1=new HashMap();goods1.put(&quot;name&quot;, &quot;苹果&quot;);goods1.put(&quot;price&quot;, 5.8);Map goods2=new HashMap();goods2.put(&quot;name&quot;, &quot;香蕉&quot;);goods2.put(&quot;price&quot;, 2.5);Map goods3=new HashMap();goods3.put(&quot;name&quot;, &quot;橘子&quot;);goods3.put(&quot;price&quot;, 3.2);goodsList.add(goods1);goodsList.add(goods2);goodsList.add(goods3);map.put(&quot;goodsList&quot;, goodsList);</code></pre><p>（2）在模板文件上添加</p><pre><code>----商品价格表----&lt;br&gt;&lt;#list goodsList as goods&gt;  ${goods_index+1} 商品名称： ${goods.name} 价格：${goods.price}&lt;br&gt;&lt;/#list&gt;</code></pre><p>如果想在循环中得到索引，使用循环变量+_index就可以得到。</p><h2 id="内建函数"><a href="#内建函数" class="headerlink" title="内建函数"></a>内建函数</h2><p>内建函数语法格式： 变量+?+函数名称  </p><h3 id="获取集合大小"><a href="#获取集合大小" class="headerlink" title="获取集合大小"></a>获取集合大小</h3><p>我们使用size函数来实现，代码如下：</p><pre><code>共  ${goodsList?size}  条记录</code></pre><h3 id="转换JSON字符串为对象"><a href="#转换JSON字符串为对象" class="headerlink" title="转换JSON字符串为对象"></a>转换JSON字符串为对象</h3><p>我们通常需要将json字符串转换为对象，那如何处理呢？看代码</p><pre><code>&lt;#assign text=&quot;{&apos;bank&apos;:&apos;工商银行&apos;,&apos;account&apos;:&apos;10101920201920212&apos;}&quot; /&gt;&lt;#assign data=text?eval /&gt;开户行：${data.bank}  账号：${data.account}</code></pre><h3 id="日期格式化"><a href="#日期格式化" class="headerlink" title="日期格式化"></a>日期格式化</h3><p>代码中对变量赋值：</p><pre><code>dataModel.put(&quot;today&quot;, new Date());</code></pre><p>在模板文件中加入</p><pre><code>当前日期：${today?date} &lt;br&gt;当前时间：${today?time} &lt;br&gt;   当前日期+时间：${today?datetime} &lt;br&gt;        日期格式化：  ${today?string(&quot;yyyy年MM月&quot;)}</code></pre><h3 id="数字转换为字符串"><a href="#数字转换为字符串" class="headerlink" title="数字转换为字符串"></a>数字转换为字符串</h3><p>代码中对变量赋值：</p><pre><code>map.put(&quot;point&quot;, 102920122);累计积分：${point}</code></pre><p>我们会发现数字会以每三位一个分隔符显示，有些时候我们不需要这个分隔符，就需要将数字转换为字符串,使用内建函数c</p><p>累计积分：${point?c}</p><h2 id="空值处理运算符"><a href="#空值处理运算符" class="headerlink" title="空值处理运算符"></a>空值处理运算符</h2><p>如果你在模板中使用了变量但是在代码中没有对变量赋值，那么运行生成时会抛出异常。但是有些时候，有的变量确实是null，怎么解决这个问题呢？</p><h3 id="判断某变量是否存在-“-”"><a href="#判断某变量是否存在-“-”" class="headerlink" title="判断某变量是否存在:“??”"></a>判断某变量是否存在:“??”</h3><p>用法为:variable??,如果该变量存在,返回true,否则返回false </p><pre><code>&lt;#if aaa??&gt;  aaa变量存在&lt;#else&gt;  aaa变量不存在&lt;/#if&gt;</code></pre><h3 id="缺失变量默认值-“-”"><a href="#缺失变量默认值-“-”" class="headerlink" title="缺失变量默认值:“!”"></a>缺失变量默认值:“!”</h3><p>我们除了可以判断是否为空值，也可以使用!对null值做转换处理<br>在模板文件中加入</p><pre><code>${aaa!&apos;-&apos;}</code></pre><p>在代码中不对aaa赋值，也不会报错了 ，当aaa为null则返回！后边的内容-</p><h2 id="运算符"><a href="#运算符" class="headerlink" title="运算符"></a>运算符</h2><h3 id="算数运算符"><a href="#算数运算符" class="headerlink" title="算数运算符"></a>算数运算符</h3><p>FreeMarker表达式中完全支持算术运算,FreeMarker支持的算术运算符包括:+, - , * , / , %</p><h3 id="逻辑运算符"><a href="#逻辑运算符" class="headerlink" title="逻辑运算符"></a>逻辑运算符</h3><p>逻辑运算符有如下几个: </p><p>逻辑与:&amp;&amp; </p><p>逻辑或:|| </p><p>逻辑非:! </p><p>逻辑运算符只能作用于布尔值,否则将产生错误 </p><h3 id="比较运算符"><a href="#比较运算符" class="headerlink" title="比较运算符"></a>比较运算符</h3><p>表达式中支持的比较运算符有如下几个:</p><p>1  =或者==:判断两个值是否相等. </p><p>2  !=:判断两个值是否不等. </p><p>3  &gt;或者gt:判断左边值是否大于右边值 </p><p>4  &gt;=或者gte:判断左边值是否大于等于右边值 </p><p>5  &lt;或者lt:判断左边值是否小于右边值</p><p>6  &lt;=或者lte:判断左边值是否小于等于右边值 </p><p>注意:  =和!=可以用于字符串,数值和日期来比较是否相等,但=和!=两边必须是相同类型的值,否则会产生错误,而且FreeMarker是精确比较,”x”,”x “,”X”是不等的.其它的运行符可以作用于数字和日期,但不能作用于字符串,大部分的时候,<strong>使用gt等字母运算符代替&gt;</strong>会有更好的效果,因为 FreeMarker会把&gt;解释成FTL标签的结束字符,当然,<strong>也可以使用括号来避免这种情况,如:&lt;#if (x&gt;y)&gt;</strong></p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;什么是-Freemarker&quot;&gt;&lt;a href=&quot;#什么是-Freemarker&quot; class=&quot;headerlink&quot; title=&quot;什么是 Freemarker&quot;&gt;&lt;/a&gt;什么是 Freemarker&lt;/h1&gt;&lt;p&gt;FreeMarker 是一个用 Java 语言编写的模板引擎，它基于模板来生成文本输出。FreeMarker与 Web 容器无关，即在 Web 运行时，它并不知道 Servlet 或 HTTP。它不仅可以用作表现层的实现技术，而且还可以用于生成 XML，JSP 或 Java 等。&lt;br&gt;
    
    </summary>
    
      <category term="java" scheme="http://www.fashionkillyou.xyz/categories/java/"/>
    
    
      <category term="FreeMarker" scheme="http://www.fashionkillyou.xyz/tags/FreeMarker/"/>
    
  </entry>
  
  <entry>
    <title>Solr搜索平台</title>
    <link href="http://www.fashionkillyou.xyz/2018/03/18/Solr%E6%90%9C%E7%B4%A2%E5%B9%B3%E5%8F%B0/"/>
    <id>http://www.fashionkillyou.xyz/2018/03/18/Solr搜索平台/</id>
    <published>2018-03-17T16:18:23.000Z</published>
    <updated>2018-03-30T08:23:06.794Z</updated>
    
    <content type="html"><![CDATA[<script src="\assets\js\APlayer.min.js"> </script><h1 id="Solr安装与配置"><a href="#Solr安装与配置" class="headerlink" title="Solr安装与配置"></a>Solr安装与配置</h1><h2 id="什么是Solr"><a href="#什么是Solr" class="headerlink" title="什么是Solr"></a>什么是Solr</h2><p>大多数搜索引擎应用都必须具有某种搜索功能，问题是搜索功能往往是巨大的资源消耗并且它们由于沉重的数据库加载而拖垮你的应用的性能。<br>这就是为什么转移负载到一个外部的搜索服务器是一个不错的主意，Apache Solr是一个流行的开源搜索服务器，它通过使用类似REST的HTTP API，这就确保你能从几乎任何编程语言来使用solr。<br><a id="more"></a><br>Solr是一个开源搜索平台，用于构建搜索应用程序。 它建立在Lucene(全文搜索引擎)之上。 Solr是企业级的，快速的和高度可扩展的。 使用Solr构建的应用程序非常复杂，可提供高性能。</p><p>为了在CNET网络的公司网站上添加搜索功能，Yonik Seely于2004年创建了Solr。并在2006年1月，它成为Apache软件基金会下的一个开源项目。并于2016年发布最新版本Solr 6.0，支持并行SQL查询的执行。</p><p>Solr可以和Hadoop一起使用。由于Hadoop处理大量数据，Solr帮助我们从这么大的源中找到所需的信息。不仅限于搜索，Solr也可以用于存储目的。像其他NoSQL数据库一样，它是一种非关系数据存储和处理技术。</p><p>总之，Solr是一个<strong>可扩展的，可部署，搜索/存储引擎，优化搜索大量以文本为中心的数据</strong>。</p><p>solr和Lucene的区别</p><pre><code>solr是基于Lucene的Lucene是一个全文检索工具包都是一些类库,只能java调用solr是个Apache开源顶级项目,一个服务平台,供不同的语言调用Lucene不支持数值范围的查询语法price:[100 To 200]solr支持数值范围的查询语法price:[100 To 200]</code></pre><h2 id="Solr安装"><a href="#Solr安装" class="headerlink" title="Solr安装"></a>Solr安装</h2><p>准备资料(包含solr、分词器、案例代码):</p><p>链接：<a href="https://pan.baidu.com/s/1JdTBbDyX9mWT2rWvatDdQg" target="_blank" rel="noopener">https://pan.baidu.com/s/1JdTBbDyX9mWT2rWvatDdQg</a> </p><p>密码：rcme</p><p>1：安装 Tomcat，解压缩即可。</p><p>2：解压 solr。</p><p>3：把 solr 下的dist目录solr-4.10.3.war部署到 Tomcat\webapps下(为了访问方便,去掉版本号)。</p><p>4：启动 Tomcat解压缩 war 包</p><p>5：把solr下example/lib/ext 目录下的所有的 jar 包，添加到 solr 的工程中(\WEB-INF\lib目录下)。</p><p>6：创建一个 solrhome 。solr 下的/example/solr 目录就是一个 solrhome。复制此目录到D盘改名为solrhome  </p><p>7：关联 solr 及 solrhome。需要修改 solr 工程的 web.xml 文件。(配置文件里面有只需解开注释然后修改成以下内容即可,如果只有war的话启动一下生成即可)</p><pre><code>&lt;env-entry&gt;   &lt;env-entry-name&gt;solr/home&lt;/env-entry-name&gt;   &lt;env-entry-value&gt;d:\solrhome&lt;/env-entry-value&gt;   &lt;env-entry-type&gt;java.lang.String&lt;/env-entry-type&gt;&lt;/env-entry&gt;</code></pre><p>8：启动 Tomcat(如果之前有了tomcat的话,这里必须要将端口号修改.然后访问自己配置的端口号即可)<br><a href="http://IP:8080/solr/" target="_blank" rel="noopener">http://IP:8080/solr/</a></p><h1 id="中文分析器IK-Analyzer"><a href="#中文分析器IK-Analyzer" class="headerlink" title="中文分析器IK Analyzer"></a>中文分析器IK Analyzer</h1><h2 id="IK-Analyzer简介"><a href="#IK-Analyzer简介" class="headerlink" title="IK Analyzer简介"></a>IK Analyzer简介</h2><p>IK Analyzer 是一个开源的，基亍 java 语言开发的轻量级的中文分词工具包。从 2006年 12 月推出 1.0 版开始， IKAnalyzer 已经推出了 4 个大版本。最初，它是以开源项目Luence 为应用主体的，结合词典分词和文法分析算法的中文分词组件。从 3.0 版本开始，IK 发展为面向 Java 的公用分词组件，独立亍 Lucene 项目，同时提供了对 Lucene 的默认优化实现。在 2012 版本中，IK 实现了简单的分词歧义排除算法，标志着 IK 分词器从单纯的词典分词向模拟语义分词衍化。</p><h2 id="IK-Analyzer配置"><a href="#IK-Analyzer配置" class="headerlink" title="IK Analyzer配置"></a>IK Analyzer配置</h2><p>步骤：<br>1、把IKAnalyzer2012FF_u1.jar 添加到 solr 工程的 lib 目录下</p><p>2、创建WEB-INF/classes文件夹  把扩展词典、停用词词典、配置文件放到 solr 工程的 WEB-INF/classes 目录下。</p><pre><code>(扩展词典、停用词词典、配置文件 ext_stopword.dic IKAnalyzer.cfg.xml  mydict.dic)</code></pre><p>3、修改 Solrhome 的collection1\conf\schema.xml 文件，配置一个 FieldType，使用 IKAnalyzer</p><pre><code>&lt;fieldType name=&quot;text_ik&quot; class=&quot;solr.TextField&quot;&gt;     &lt;analyzer class=&quot;org.wltea.analyzer.lucene.IKAnalyzer&quot;/&gt;&lt;/fieldType&gt;</code></pre><h3 id="配置域"><a href="#配置域" class="headerlink" title="配置域"></a>配置域</h3><p>域相当于数据库的表字段，用户存放数据，因此用户根据业务需要去定义相关的Field（域），一般来说，每一种对应着一种数据，用户对同一种数据进行相同的操作。</p><p>域的常用属性：</p><p>•    name：指定域的名称</p><p>•    type：指定域的类型</p><p>•    indexed：是否索引</p><p>•    stored：是否存储</p><p>•    required：是否必须</p><p>•    multiValued：是否多值</p><h4 id="域"><a href="#域" class="headerlink" title="域"></a>域</h4><p>修改solrhome的schema.xml 文件  设置业务系统 Field</p><pre><code>&lt;field name=&quot;item_goodsid&quot; type=&quot;long&quot; indexed=&quot;true&quot; stored=&quot;true&quot;/&gt;&lt;field name=&quot;item_title&quot; type=&quot;text_ik&quot; indexed=&quot;true&quot; stored=&quot;true&quot;/&gt;&lt;field name=&quot;item_price&quot; type=&quot;double&quot; indexed=&quot;true&quot; stored=&quot;true&quot;/&gt;&lt;field name=&quot;item_image&quot; type=&quot;string&quot; indexed=&quot;false&quot; stored=&quot;true&quot; /&gt;&lt;field name=&quot;item_category&quot; type=&quot;string&quot; indexed=&quot;true&quot; stored=&quot;true&quot; /&gt;&lt;field name=&quot;item_seller&quot; type=&quot;text_ik&quot; indexed=&quot;true&quot; stored=&quot;true&quot; /&gt;&lt;field name=&quot;item_brand&quot; type=&quot;string&quot; indexed=&quot;true&quot; stored=&quot;true&quot; /&gt;</code></pre><h4 id="复制域"><a href="#复制域" class="headerlink" title="复制域"></a>复制域</h4><p>复制域的作用在于将某一个Field中的数据复制到另一个域中(<strong>在电商项目的商品搜索中,设置这个复制域可以集成多个条件的查询,将其他域的数据集中到这一个item_keywords域中,方便查询</strong>)</p><pre><code>&lt;field name=&quot;item_keywords&quot; type=&quot;text_ik&quot; indexed=&quot;true&quot; stored=&quot;false&quot; multiValued=&quot;true&quot;/&gt;&lt;copyField source=&quot;item_title&quot; dest=&quot;item_keywords&quot;/&gt;&lt;copyField source=&quot;item_category&quot; dest=&quot;item_keywords&quot;/&gt;&lt;copyField source=&quot;item_seller&quot; dest=&quot;item_keywords&quot;/&gt;&lt;copyField source=&quot;item_brand&quot; dest=&quot;item_keywords&quot;/&gt;</code></pre><h4 id="动态域"><a href="#动态域" class="headerlink" title="动态域"></a>动态域</h4><p>当我们需要动态扩充字段时，我们需要使用动态域。<strong>对于电商项目，规格的值是不确定的，所以我们需要使用动态域来实现。</strong></p><p>配置：</p><pre><code>&lt;dynamicField name=&quot;item_spec_*&quot; type=&quot;string&quot; indexed=&quot;true&quot; stored=&quot;true&quot; /&gt;    </code></pre><h1 id="Spring-Data-Solr入门"><a href="#Spring-Data-Solr入门" class="headerlink" title="Spring Data Solr入门"></a>Spring Data Solr入门</h1><h2 id="Spring-Data-Solr简介"><a href="#Spring-Data-Solr简介" class="headerlink" title="Spring Data Solr简介"></a>Spring Data Solr简介</h2><p>虽然支持任何编程语言的能力具有很大的市场价值，你可能感兴趣的问题是：我如何将Solr的应用集成到Spring中？可以，Spring Data Solr就是为了方便Solr的开发所研制的一个框架，其底层是对SolrJ（官方API）的封装。</p><h2 id="Spring-Data-Solr入门小Demo"><a href="#Spring-Data-Solr入门小Demo" class="headerlink" title="Spring Data Solr入门小Demo"></a>Spring Data Solr入门小Demo</h2><p>(<strong>完整项目程序在上面的准备资料里面</strong>)</p><h3 id="搭建工程"><a href="#搭建工程" class="headerlink" title="搭建工程"></a>搭建工程</h3><p>（1）创建maven工程，pom.xml中引入依赖</p><pre><code> &lt;dependencies&gt;  &lt;dependency&gt;      &lt;groupId&gt;org.springframework.data&lt;/groupId&gt;      &lt;artifactId&gt;spring-data-solr&lt;/artifactId&gt;      &lt;version&gt;1.5.5.RELEASE&lt;/version&gt;  &lt;/dependency&gt;   &lt;dependency&gt;      &lt;groupId&gt;org.springframework&lt;/groupId&gt;      &lt;artifactId&gt;spring-test&lt;/artifactId&gt;      &lt;version&gt;4.2.4.RELEASE&lt;/version&gt;  &lt;/dependency&gt;  &lt;dependency&gt;      &lt;groupId&gt;junit&lt;/groupId&gt;      &lt;artifactId&gt;junit&lt;/artifactId&gt;      &lt;version&gt;4.9&lt;/version&gt;  &lt;/dependency&gt;&lt;/dependencies&gt;</code></pre><p>（2）在src/main/resources下创建  applicationContext-solr.xml</p><pre><code>&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot;    xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xmlns:p=&quot;http://www.springframework.org/schema/p&quot;    xmlns:context=&quot;http://www.springframework.org/schema/context&quot;    xmlns:solr=&quot;http://www.springframework.org/schema/data/solr&quot;    xsi:schemaLocation=&quot;http://www.springframework.org/schema/data/solr           http://www.springframework.org/schema/data/solr/spring-solr-1.0.xsd        http://www.springframework.org/schema/beans         http://www.springframework.org/schema/beans/spring-beans.xsd        http://www.springframework.org/schema/context         http://www.springframework.org/schema/context/spring-context.xsd&quot;&gt;    &lt;!-- solr服务器地址 --&gt;    &lt;solr:solr-server id=&quot;solrServer&quot; url=&quot;http://127.0.0.1:8080/solr&quot; /&gt;    &lt;!-- solr模板，使用solr模板可对索引库进行CRUD的操作 --&gt;    &lt;bean id=&quot;solrTemplate&quot; class=&quot;org.springframework.data.solr.core.SolrTemplate&quot;&gt;        &lt;constructor-arg ref=&quot;solrServer&quot; /&gt;    &lt;/bean&gt;&lt;/beans&gt;</code></pre><h3 id="Field-注解"><a href="#Field-注解" class="headerlink" title="@Field 注解"></a>@Field 注解</h3><p>创建 cn.lxm.pojo 包，创建TbItem实体类,属性使用@Field注解标识 。如果属性与配置文件定义的域名称不一致，需要在注解中指定域名称。</p><pre><code>public class TbItem implements Serializable{    @Field    private Long id;    @Field(&quot;item_title&quot;)    private String title;    @Field(&quot;item_price&quot;)private BigDecimal price;    @Field(&quot;item_image&quot;)    private String image;    @Field(&quot;item_goodsid&quot;)    private Long goodsId;    @Field(&quot;item_category&quot;)    private String category;    @Field(&quot;item_brand&quot;)    private String brand;    @Field(&quot;item_seller&quot;)private String seller;.......}</code></pre><h3 id="增加（修改）"><a href="#增加（修改）" class="headerlink" title="增加（修改）"></a>增加（修改）</h3><p>创建测试类TestTemplate.java</p><pre><code>@RunWith(SpringJUnit4ClassRunner.class)@ContextConfiguration(locations=&quot;classpath:applicationContext-solr.xml&quot;)public class TestTemplate {    @Autowired    private SolrTemplate solrTemplate;    @Test    public void testAdd(){        TbItem item=new TbItem();        item.setId(1L);        item.setBrand(&quot;华为&quot;);        item.setCategory(&quot;手机&quot;);        item.setGoodsId(1L);        item.setSeller(&quot;华为2号专卖店&quot;);        item.setTitle(&quot;华为Mate9&quot;);        item.setPrice(new BigDecimal(2000));                solrTemplate.saveBean(item);        solrTemplate.commit();    }}</code></pre><h3 id="按主键查询"><a href="#按主键查询" class="headerlink" title="按主键查询"></a>按主键查询</h3><pre><code>@Testpublic void testFindOne(){    TbItem item = solrTemplate.getById(1, TbItem.class);    System.out.println(item.getTitle());}</code></pre><h3 id="按主键删除"><a href="#按主键删除" class="headerlink" title="按主键删除"></a>按主键删除</h3><pre><code>@Testpublic void testDelete(){    solrTemplate.deleteById(&quot;1&quot;);    solrTemplate.commit();}</code></pre><h3 id="分页查询"><a href="#分页查询" class="headerlink" title="分页查询"></a>分页查询</h3><p>首先循环插入100条测试数据</p><pre><code>@Testpublic void testAddList(){    List&lt;TbItem&gt; list=new ArrayList();    for(int i=0;i&lt;100;i++){        TbItem item=new TbItem();        item.setId(i+1L);        item.setBrand(&quot;华为&quot;);        item.setCategory(&quot;手机&quot;);        item.setGoodsId(1L);        item.setSeller(&quot;华为2号专卖店&quot;);        item.setTitle(&quot;华为Mate&quot;+i);        item.setPrice(new BigDecimal(2000+i));            list.add(item);    }    solrTemplate.saveBeans(list);    solrTemplate.commit();}</code></pre><p>编写分页查询测试代码：</p><pre><code>@Testpublic void testPageQuery(){    Query query=new SimpleQuery(&quot;*:*&quot;);    query.setOffset(20);//开始索引（默认0）    query.setRows(20);//每页记录数(默认10)    ScoredPage&lt;TbItem&gt; page = solrTemplate.queryForPage(query, TbItem.class);    System.out.println(&quot;总记录数：&quot;+page.getTotalElements());    List&lt;TbItem&gt; list = page.getContent();    showList(list);}</code></pre><p>公共代码遍历循环显示查询结果:</p><pre><code>//显示记录数据private void showList(List&lt;TbItem&gt; list){            for(TbItem item:list){        System.out.println(item.getTitle() +item.getPrice());    }        }</code></pre><h3 id="条件查询"><a href="#条件查询" class="headerlink" title="条件查询"></a>条件查询</h3><p> Criteria 用于对条件的封装：</p><pre><code>@Testpublic void testPageQueryMutil(){        Query query=new SimpleQuery(&quot;*:*&quot;);    Criteria criteria=new Criteria(&quot;item_title&quot;).contains(&quot;2&quot;);    criteria=criteria.and(&quot;item_title&quot;).contains(&quot;5&quot;);            query.addCriteria(criteria);    //query.setOffset(20);//开始索引（默认0）    //query.setRows(20);//每页记录数(默认10)    ScoredPage&lt;TbItem&gt; page = solrTemplate.queryForPage(query, TbItem.class);    System.out.println(&quot;总记录数：&quot;+page.getTotalElements());    List&lt;TbItem&gt; list = page.getContent();    showList(list);}</code></pre><h3 id="删除全部数据"><a href="#删除全部数据" class="headerlink" title="删除全部数据"></a>删除全部数据</h3><pre><code>@Testpublic void testDeleteAll(){    Query query=new SimpleQuery(&quot;*:*&quot;);    solrTemplate.delete(query);    solrTemplate.commit();}</code></pre><h3 id="描述-设置高亮显示"><a href="#描述-设置高亮显示" class="headerlink" title="描述 设置高亮显示"></a>描述 设置高亮显示</h3><pre><code>@Testpublic void testHighLight(){    HighlightQuery query = new SimpleHighlightQuery();    //设置高亮的域    HighlightOptions highlightOptions = new HighlightOptions().addField(&quot;item_title&quot;);    //设置高亮显示的前缀    highlightOptions.setSimplePrefix(&quot;&lt;em style=&apos;color:red&apos;&quot;);    //设置高亮显示的后缀    highlightOptions.setSimplePostfix(&quot;&lt;/em&gt;&quot;);    //设置高亮选项    query.setHighlightOptions(highlightOptions);    //设置查询条件    Criteria criteria = new Criteria(&quot;item_title&quot;).contains(&quot;手机&quot;);    query.addCriteria(criteria);    HighlightPage&lt;TbItem&gt; page = solrTemplate.queryForHighlightPage(query, TbItem.class);    //循环高亮入口集合    for (HighlightEntry&lt;TbItem&gt; h : page.getHighlighted()) {        //获取原实体类        TbItem item = h.getEntity();        if(h.getHighlights().size()&gt;0 &amp;&amp; h.getHighlights().get(0).getSnipplets().size()&gt;0){            //设置高亮的结果            item.setTitle(h.getHighlights().get(0).getSnipplets().get(0));        }    }    System.out.println(&quot;总记录数：&quot;+page.getTotalElements());    List&lt;TbItem&gt; list = page.getContent();    showList(list);}</code></pre><h3 id="描述-分组查询"><a href="#描述-分组查询" class="headerlink" title="描述 分组查询"></a>描述 分组查询</h3><p>注意这里的测试数据的分组查询结果只有手机一项,可以自行添加索引库中item_category这一项的值</p><pre><code>@Testpublic void testFindForGroup(){    List&lt;String&gt; list=new ArrayList();    Query query=new SimpleQuery();    //按照关键字查询    Criteria criteria=new Criteria(&quot;item_keywords&quot;).is(&quot;三星&quot;);    query.addCriteria(criteria);    //设置分组选项    GroupOptions groupOptions=new GroupOptions().addGroupByField(&quot;item_category&quot;);    query.setGroupOptions(groupOptions);    //得到分组页    GroupPage&lt;TbItem&gt; page = solrTemplate.queryForGroupPage(query, TbItem.class);    //根据列得到分组结果集    GroupResult&lt;TbItem&gt; groupResult = page.getGroupResult(&quot;item_category&quot;);    //得到分组结果入口页    Page&lt;GroupEntry&lt;TbItem&gt;&gt; groupEntries = groupResult.getGroupEntries();    //得到分组入口集合    List&lt;GroupEntry&lt;TbItem&gt;&gt; content = groupEntries.getContent();    for(GroupEntry&lt;TbItem&gt; entry:content){        list.add(entry.getGroupValue());//将分组结果的名称封装到返回值中    }    for (String s : list) {        System.out.println(s);    }}</code></pre>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;Solr安装与配置&quot;&gt;&lt;a href=&quot;#Solr安装与配置&quot; class=&quot;headerlink&quot; title=&quot;Solr安装与配置&quot;&gt;&lt;/a&gt;Solr安装与配置&lt;/h1&gt;&lt;h2 id=&quot;什么是Solr&quot;&gt;&lt;a href=&quot;#什么是Solr&quot; class=&quot;headerlink&quot; title=&quot;什么是Solr&quot;&gt;&lt;/a&gt;什么是Solr&lt;/h2&gt;&lt;p&gt;大多数搜索引擎应用都必须具有某种搜索功能，问题是搜索功能往往是巨大的资源消耗并且它们由于沉重的数据库加载而拖垮你的应用的性能。&lt;br&gt;这就是为什么转移负载到一个外部的搜索服务器是一个不错的主意，Apache Solr是一个流行的开源搜索服务器，它通过使用类似REST的HTTP API，这就确保你能从几乎任何编程语言来使用solr。&lt;br&gt;
    
    </summary>
    
      <category term="搜索解决方案" scheme="http://www.fashionkillyou.xyz/categories/%E6%90%9C%E7%B4%A2%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88/"/>
    
    
      <category term="Solr" scheme="http://www.fashionkillyou.xyz/tags/Solr/"/>
    
  </entry>
  
  <entry>
    <title>Spring-Data-Redis总结</title>
    <link href="http://www.fashionkillyou.xyz/2018/03/15/Spring-Data-Redis%E6%80%BB%E7%BB%93/"/>
    <id>http://www.fashionkillyou.xyz/2018/03/15/Spring-Data-Redis总结/</id>
    <published>2018-03-15T09:57:36.000Z</published>
    <updated>2018-03-30T08:23:06.796Z</updated>
    
    <content type="html"><![CDATA[<script src="\assets\js\APlayer.min.js"> </script><h1 id="什么是Redis"><a href="#什么是Redis" class="headerlink" title="什么是Redis"></a>什么是Redis</h1><p>redis是一个非关系型Key-Value数据库,运行在内存中,由ANSI C编写。企业开发通常采用Redis来实现缓存。同类的产品还有memcache 、memcached 、MongoDB等。</p><a id="more"></a><h1 id="什么是Jedis"><a href="#什么是Jedis" class="headerlink" title="什么是Jedis"></a>什么是Jedis</h1><p>Jedis是Redis官方推出的一款面向Java的客户端，提供了很多接口供Java语言调用。可以在Redis官网下载，当然还有一些开源爱好者提供的客户端，如Jredis、SRP等等，推荐使用Jedis。</p><h1 id="Spring-Data-Redis"><a href="#Spring-Data-Redis" class="headerlink" title="Spring Data Redis"></a>Spring Data Redis</h1><p>Spring-data-redis是spring大家族的一部分，提供了在srping应用中通过简单的配置访问redis服务，对reids底层开发包(Jedis,  JRedis, and RJC)进行了高度封装，RedisTemplate提供了redis各种操作、异常处理及序列化，支持发布订阅，并对spring 3.1 cache进行了实现。<br>spring-data-redis针对jedis提供了如下功能：</p><p>1.连接池自动管理，提供了一个高度封装的“RedisTemplate”类</p><p>2.针对jedis客户端中大量api进行了归类封装,将同一类型操作封装为operation接口</p><pre><code>ValueOperations：简单K-V操作SetOperations：set类型数据操作ZSetOperations：zset类型数据操作HashOperations：针对map类型的数据操作ListOperations：针对list类型的数据操作</code></pre><h1 id="使用spring-data-redis"><a href="#使用spring-data-redis" class="headerlink" title="使用spring-data-redis"></a>使用spring-data-redis</h1><h2 id="准备工作"><a href="#准备工作" class="headerlink" title="准备工作:"></a>准备工作:</h2><h3 id="1-构建maven工程-步骤略-如果已有请忽略"><a href="#1-构建maven工程-步骤略-如果已有请忽略" class="headerlink" title="1.构建maven工程(步骤略,如果已有请忽略)"></a>1.构建maven工程(步骤略,如果已有请忽略)</h3><h3 id="2-引入spring相关依赖-引入junit依赖-步骤略-如果已有请忽略"><a href="#2-引入spring相关依赖-引入junit依赖-步骤略-如果已有请忽略" class="headerlink" title="2.引入spring相关依赖,引入junit依赖(步骤略,如果已有请忽略)"></a>2.引入spring相关依赖,引入junit依赖(步骤略,如果已有请忽略)</h3><h3 id="3-引入jedis和SpringDataRedis依赖"><a href="#3-引入jedis和SpringDataRedis依赖" class="headerlink" title="3.引入jedis和SpringDataRedis依赖"></a>3.引入jedis和SpringDataRedis依赖</h3><pre><code>&lt;!-- 缓存 --&gt;&lt;dependency&gt;           &lt;groupId&gt;redis.clients&lt;/groupId&gt;           &lt;artifactId&gt;jedis&lt;/artifactId&gt;           &lt;version&gt;2.8.1&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt;           &lt;groupId&gt;org.springframework.data&lt;/groupId&gt;           &lt;artifactId&gt;spring-data-redis&lt;/artifactId&gt;           &lt;version&gt;1.7.2.RELEASE&lt;/version&gt; &lt;/dependency&gt;</code></pre><h3 id="4-在src-main-resource下创建properties文件夹-建立redis-config-properties"><a href="#4-在src-main-resource下创建properties文件夹-建立redis-config-properties" class="headerlink" title="4.在src/main/resource下创建properties文件夹,建立redis-config.properties"></a>4.在src/main/resource下创建properties文件夹,建立redis-config.properties</h3><p>redis.host用来设置服务器地址</p><p>redis.port用来设置端口号</p><pre><code>redis.host=127.0.0.1 redis.port=6379 redis.pass= redis.database=0 redis.maxIdle=300 redis.maxWait=3000 redis.testOnBorrow=true</code></pre><h3 id="5-在src-main-resources下创建spring文件夹-，创建applicationContext-redis-xml"><a href="#5-在src-main-resources下创建spring文件夹-，创建applicationContext-redis-xml" class="headerlink" title="5.在src/main/resources下创建spring文件夹 ，创建applicationContext-redis.xml"></a>5.在src/main/resources下创建spring文件夹 ，创建applicationContext-redis.xml</h3><pre><code>&lt;context:property-placeholder location=&quot;classpath*:properties/*.properties&quot; /&gt;   &lt;!-- redis 相关配置 --&gt; &lt;bean id=&quot;poolConfig&quot; class=&quot;redis.clients.jedis.JedisPoolConfig&quot;&gt;   &lt;property name=&quot;maxIdle&quot; value=&quot;${redis.maxIdle}&quot; /&gt;    &lt;property name=&quot;maxWaitMillis&quot; value=&quot;${redis.maxWait}&quot; /&gt;   &lt;property name=&quot;testOnBorrow&quot; value=&quot;${redis.testOnBorrow}&quot; /&gt;  &lt;/bean&gt;  &lt;bean id=&quot;JedisConnectionFactory&quot; class=&quot;org.springframework.data.redis.connection.jedis.JedisConnectionFactory&quot;    p:host-name=&quot;${redis.host}&quot; p:port=&quot;${redis.port}&quot; p:password=&quot;${redis.pass}&quot; p:pool-config-ref=&quot;poolConfig&quot;/&gt;  &lt;bean id=&quot;redisTemplate&quot; class=&quot;org.springframework.data.redis.core.RedisTemplate&quot;&gt;   &lt;property name=&quot;connectionFactory&quot; ref=&quot;JedisConnectionFactory&quot; /&gt;  &lt;/bean&gt;</code></pre><p>maxIdle ：最大空闲数</p><p>maxWaitMillis:连接时的最大等待毫秒数</p><p>testOnBorrow：在提取一个jedis实例时，是否提前进行验证操作；如果为true，则得到的jedis实例均是可用的</p><h1 id="测试"><a href="#测试" class="headerlink" title="测试"></a>测试</h1><p>这里只写常用的hash和String两种类型的数据CRUD</p><h2 id="String"><a href="#String" class="headerlink" title="String:"></a>String:</h2><pre><code>@RunWith(SpringJUnit4ClassRunner.class)@ContextConfiguration(locations=&quot;classpath:spring/applicationContext-redis.xml&quot;)public class TestValue {    @Autowired    private RedisTemplate redisTemplate;        @Test    public void setValue(){        redisTemplate.boundValueOps(&quot;name&quot;).set(&quot;itcast&quot;);            }        @Test    public void getValue(){        String str = (String) redisTemplate.boundValueOps(&quot;name&quot;).get();        System.out.println(str);    }        @Test    public void deleteValue(){        redisTemplate.delete(&quot;name&quot;);;    }    }</code></pre><h2 id="Hash类型操作"><a href="#Hash类型操作" class="headerlink" title="Hash类型操作"></a>Hash类型操作</h2><p>创建测试类TestHash</p><p>（1）存入值</p><pre><code>@Testpublic void testSetValue(){    redisTemplate.boundHashOps(&quot;namehash&quot;).put(&quot;a&quot;, &quot;唐僧&quot;);    redisTemplate.boundHashOps(&quot;namehash&quot;).put(&quot;b&quot;, &quot;悟空&quot;);    redisTemplate.boundHashOps(&quot;namehash&quot;).put(&quot;c&quot;, &quot;八戒&quot;);    redisTemplate.boundHashOps(&quot;namehash&quot;).put(&quot;d&quot;, &quot;沙僧&quot;);}</code></pre><p>（2）提取所有的KEY</p><pre><code>@Testpublic void testGetKeys(){    Set s = redisTemplate.boundHashOps(&quot;namehash&quot;).keys();            System.out.println(s);        }</code></pre><p>运行结果：<br>[a, b, c, d]</p><p>（3）提取所有的值</p><pre><code>@Testpublic void testGetValues(){    List values = redisTemplate.boundHashOps(&quot;namehash&quot;).values();    System.out.println(values);        }</code></pre><p>运行结果：<br>[唐僧, 悟空, 八戒, 沙僧]</p><p>（4）根据KEY提取值</p><pre><code>@Testpublic void testGetValueByKey(){    Object object = redisTemplate.boundHashOps(&quot;namehash&quot;).get(&quot;b&quot;);    System.out.println(object);}</code></pre><p>运行结果：<br>悟空</p><p>（5）根据KEY移除值</p><pre><code>@Testpublic void testRemoveValueByKey(){    redisTemplate.boundHashOps(&quot;namehash&quot;).delete(&quot;c&quot;);}</code></pre><p>运行后再次查看集合内容：<br>[唐僧, 悟空, 沙僧]</p><h1 id="小节-缓存同步问题"><a href="#小节-缓存同步问题" class="headerlink" title="小节(缓存同步问题)"></a>小节(缓存同步问题)</h1><p> 在项目中使用redis会涉及到缓存同步的问题,解决这个问题是在进行缓存内容增删改之前要先删除缓存,然后再进行查询数据,这样在更改后的下次查询,在缓存中查不到数据就会去数据库中查询,然后再保存进缓存,这样就实现了缓存的同步.</p><p>在使用时是先要查询缓存,然后判断缓存是否存在所要查询的数据,如果存在的话就直接返回结果,如果没有查询到的话,就去数据库里面查询,然后将查询结果保存进缓存中.</p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;什么是Redis&quot;&gt;&lt;a href=&quot;#什么是Redis&quot; class=&quot;headerlink&quot; title=&quot;什么是Redis&quot;&gt;&lt;/a&gt;什么是Redis&lt;/h1&gt;&lt;p&gt;redis是一个非关系型Key-Value数据库,运行在内存中,由ANSI C编写。企业开发通常采用Redis来实现缓存。同类的产品还有memcache 、memcached 、MongoDB等。&lt;/p&gt;
    
    </summary>
    
      <category term="java" scheme="http://www.fashionkillyou.xyz/categories/java/"/>
    
    
      <category term="redis" scheme="http://www.fashionkillyou.xyz/tags/redis/"/>
    
  </entry>
  
  <entry>
    <title>数据库的事务</title>
    <link href="http://www.fashionkillyou.xyz/2018/03/14/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%9A%84%E4%BA%8B%E5%8A%A1/"/>
    <id>http://www.fashionkillyou.xyz/2018/03/14/数据库的事务/</id>
    <published>2018-03-14T08:32:27.000Z</published>
    <updated>2018-03-14T09:18:08.599Z</updated>
    
    <content type="html"><![CDATA[<script src="\assets\js\APlayer.min.js"> </script><h1 id="【事务的概述】"><a href="#【事务的概述】" class="headerlink" title="【事务的概述】"></a>【事务的概述】</h1><h2 id="什么是事务"><a href="#什么是事务" class="headerlink" title="什么是事务:"></a>什么是事务:</h2><p>事务指的是逻辑上的一组操作,组成这组操作的各个逻辑单元要么一起成功,要么一起失败.<br><a id="more"></a><br>MYSQL的事务管理有两种方式:(MYSQL数据库事务默认是自动提交的.Oracle数据库事务默认是不自动提交.)</p><p>1.手动开启事务</p><ul><li>start transaction; – 开启事务</li><li>多条sql;</li><li>commit/rollback;</li></ul><p>2.设置一个自动提交参数</p><ul><li>show variables like ‘%commit%’; – 查看与commit相关参数.</li><li>set autocommit = 0; – 将autocommit参数设置为OFF.</li></ul><h1 id="【JDBC中的事务管理】"><a href="#【JDBC中的事务管理】" class="headerlink" title="【JDBC中的事务管理】"></a>【JDBC中的事务管理】</h1><h2 id="JDBC的事务的管理的API"><a href="#JDBC的事务的管理的API" class="headerlink" title="JDBC的事务的管理的API:"></a>JDBC的事务的管理的API:</h2><p>同一个事务 连接必须得是同一个对象(就是提交和设置的connection必须得是同一个),要加在业务层</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结:"></a>总结:</h2><h3 id="事务特性"><a href="#事务特性" class="headerlink" title="事务特性:"></a>事务特性:</h3><ul><li>原子性：强调事务的不可分割.(要么一起成功,要么一起失败)</li><li>一致性：强调的是事务的执行的前后，数据的完整性要保持一致.(转账前总和2000,转完后总和也得是2000)</li><li>隔离性：一个事务的执行不应该受到其他事务的干扰.</li><li>持久性：事务一旦结束(提交/回滚)数据就持久保持到了数据库.</li><li>如果不考虑事务的隔离性,引发一些安全性问题:</li></ul><p>一类是  读问题:</p><ul><li>不可重复读    :一个事务读到了另一个事务已经提交的update的数据,导致在当前的事务中多次查询结果不一致.</li><li>虚读/幻读    :一个事务读到另一个事务已经提交的insert的数据,导致在</li><li>当前的事务中多次的查询结果不一致.</li></ul><p>一类是  写问题:</p><p>引发两类丢失更新:</p><h3 id="解决引发的读问题"><a href="#解决引发的读问题" class="headerlink" title="解决引发的读问题:"></a>解决引发的读问题:</h3><p>设置事务的隔离级别:</p><ul><li>read uncommitted        :未提交读.脏读，不可重复读，虚读都可能发生.(安全性低,但是效率高)</li><li>read committed        :已提交读.避免脏读.但是不可重复读和虚读有可能发生.</li><li>repeatable read        :可重复读.避免脏读,不可重复读.但是虚读有可能发生.</li><li>serializable            :串行化的.避免脏读，不可重复读，虚读的发生.(安全性高,但是效率低)</li></ul><p><strong>*</strong> MYSQL隔离级别：repeatable read  Oracle隔离级别:read committed</p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;【事务的概述】&quot;&gt;&lt;a href=&quot;#【事务的概述】&quot; class=&quot;headerlink&quot; title=&quot;【事务的概述】&quot;&gt;&lt;/a&gt;【事务的概述】&lt;/h1&gt;&lt;h2 id=&quot;什么是事务&quot;&gt;&lt;a href=&quot;#什么是事务&quot; class=&quot;headerlink&quot; title=&quot;什么是事务:&quot;&gt;&lt;/a&gt;什么是事务:&lt;/h2&gt;&lt;p&gt;事务指的是逻辑上的一组操作,组成这组操作的各个逻辑单元要么一起成功,要么一起失败.&lt;br&gt;
    
    </summary>
    
      <category term="数据库" scheme="http://www.fashionkillyou.xyz/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    
    
      <category term="事务管理" scheme="http://www.fashionkillyou.xyz/tags/%E4%BA%8B%E5%8A%A1%E7%AE%A1%E7%90%86/"/>
    
  </entry>
  
  <entry>
    <title>使用FastDFS+angularJS+HTML5+springMVC进行文件上传</title>
    <link href="http://www.fashionkillyou.xyz/2018/03/12/%E4%BD%BF%E7%94%A8FastDFS-angularJS-HTML5-springMVC%E8%BF%9B%E8%A1%8C%E6%96%87%E4%BB%B6%E4%B8%8A%E4%BC%A0/"/>
    <id>http://www.fashionkillyou.xyz/2018/03/12/使用FastDFS-angularJS-HTML5-springMVC进行文件上传/</id>
    <published>2018-03-11T17:14:11.000Z</published>
    <updated>2018-03-30T08:23:06.802Z</updated>
    
    <content type="html"><![CDATA[<script src="\assets\js\APlayer.min.js"> </script><h1 id="分布式文件服务器FastDFS"><a href="#分布式文件服务器FastDFS" class="headerlink" title="分布式文件服务器FastDFS"></a>分布式文件服务器FastDFS</h1><h2 id="什么是FastDFS"><a href="#什么是FastDFS" class="headerlink" title="什么是FastDFS"></a>什么是FastDFS</h2><p>FastDFS 是用 c 语言编写的一款开源的分布式文件系统。FastDFS 为互联网量身定制，充分考虑了冗余备份、负载均衡、线性扩容等机制，并注重高可用、高性能等指标，使用 FastDFS很容易搭建一套高性能的文件服务器集群提供文件上传、下载等服务。</p><a id="more"></a><p>FastDFS 架构包括 Tracker server 和 Storage server。客户端请求 Tracker server 进行文件上传、下载，通过 Tracker server 调度最终由 Storage server 完成文件上传和下载。</p><p>Tracker server 作用是负载均衡和调度，通过 Tracker server 在文件上传时可以根据一些策略找到 Storage server 提供文件上传服务。可以将 tracker 称为追踪服务器或调度服务器。</p><p>Storage server 作用是文件存储，客户端上传的文件最终存储在 Storage 服务器上，Storageserver 没有实现自己的文件系统而是利用操作系统 的文件系统来管理文件。可以将storage称为存储服务器。</p><p><img src="http://p57l8frp4.bkt.clouddn.com/FastDFS1.png" alt=""></p><p>服务端两个角色：</p><ul><li><p>Tracker：管理集群，tracker 也可以实现集群。每个 tracker 节点地位平等。收集 Storage 集群的状态。</p></li><li><p>Storage：实际保存文件   Storage 分为多个组，每个组之间保存的文件是不同的。每个组内部可以有多个成员，组成员内部保存的内容是一样的，组成员的地位是一致的，没有主从的概念。</p><h2 id="文件上传及下载的流程"><a href="#文件上传及下载的流程" class="headerlink" title="文件上传及下载的流程"></a>文件上传及下载的流程</h2><h3 id="文件上传流程"><a href="#文件上传流程" class="headerlink" title="文件上传流程"></a>文件上传流程</h3></li></ul><p><img src="http://p57l8frp4.bkt.clouddn.com/FastDFS2.png" alt=""></p><p>客户端上传文件后存储服务器将文件 ID 返回给客户端，此文件 ID 用于以后访问该文件的索引信息。文件索引信息包括：组名，虚拟磁盘路径，数据两级目录，文件名。</p><p><img src="http://p57l8frp4.bkt.clouddn.com/FastDFS3.png" alt=""></p><p>组名：文件上传后所在的 storage 组名称，在文件上传成功后有 storage 服务器返回，需要客户端自行保存。</p><ul><li><p>虚拟磁盘路径：storage 配置的虚拟路径，与磁盘选项 store_path*对应。如果配置了<br>store_path0 则是 M00，如果配置了 store_path1 则是 M01，以此类推。</p></li><li><p>数据两级目录：storage 服务器在每个虚拟磁盘路径下创建的两级目录，用于存储数据<br>文件。</p></li><li><p>文件名：与文件上传时不同。是由存储服务器根据特定信息生成，文件名包含：源存储<br>服务器 IP 地址、文件创建时间戳、文件大小、随机数和文件拓展名等信息。</p></li></ul><h3 id="文件下载流程"><a href="#文件下载流程" class="headerlink" title="文件下载流程"></a>文件下载流程</h3><p><img src="http://p57l8frp4.bkt.clouddn.com/FastDFS4.png" alt=""></p><h3 id="最简单的-FastDFS-架构"><a href="#最简单的-FastDFS-架构" class="headerlink" title="最简单的 FastDFS 架构"></a>最简单的 FastDFS 架构</h3><p><img src="http://p57l8frp4.bkt.clouddn.com/FastDFS5.png" alt=""></p><h3 id="FastDFS安装"><a href="#FastDFS安装" class="headerlink" title="FastDFS安装"></a>FastDFS安装</h3><p>请参考一下博客:</p><p><a href="https://www.cnblogs.com/fishbay/archive/2017/09/24/7586772.html" target="_blank" rel="noopener">https://www.cnblogs.com/fishbay/archive/2017/09/24/7586772.html</a></p><p><a href="http://blog.csdn.net/XingJames/article/details/52759876" target="_blank" rel="noopener">http://blog.csdn.net/XingJames/article/details/52759876</a></p><p><a href="https://www.cnblogs.com/jym-sunshine/p/6397470.html" target="_blank" rel="noopener">FastDFS安装全过程记录</a></p><h2 id="代码案例"><a href="#代码案例" class="headerlink" title="代码案例"></a>代码案例</h2><h3 id="依赖的jar包"><a href="#依赖的jar包" class="headerlink" title="依赖的jar包:"></a>依赖的jar包:</h3><pre><code>&lt;!-- 文件上传组件 --&gt;    &lt;dependency&gt;        &lt;groupId&gt;org.csource.fastdfs&lt;/groupId&gt;        &lt;artifactId&gt;fastdfs&lt;/artifactId&gt;    &lt;/dependency&gt;    &lt;dependency&gt;        &lt;groupId&gt;commons-fileupload&lt;/groupId&gt;        &lt;artifactId&gt;commons-fileupload&lt;/artifactId&gt;    &lt;/dependency&gt;</code></pre><h3 id="使用的工具类"><a href="#使用的工具类" class="headerlink" title="使用的工具类:"></a>使用的工具类:</h3><pre><code>package util;import org.csource.common.NameValuePair;import org.csource.fastdfs.ClientGlobal;import org.csource.fastdfs.StorageClient1;import org.csource.fastdfs.StorageServer;import org.csource.fastdfs.TrackerClient;import org.csource.fastdfs.TrackerServer;public class FastDFSClient {    private TrackerClient trackerClient = null;    private TrackerServer trackerServer = null;    private StorageServer storageServer = null;    private StorageClient1 storageClient = null;    public FastDFSClient(String conf) throws Exception {        if (conf.contains(&quot;classpath:&quot;)) {            conf = conf.replace(&quot;classpath:&quot;, this.getClass().getResource(&quot;/&quot;).getPath());        }        ClientGlobal.init(conf);        trackerClient = new TrackerClient();        trackerServer = trackerClient.getConnection();        storageServer = null;        storageClient = new StorageClient1(trackerServer, storageServer);    }    /**     * 上传文件方法     * &lt;p&gt;Title: uploadFile&lt;/p&gt;     * &lt;p&gt;Description: &lt;/p&gt;     * @param fileName 文件全路径     * @param extName 文件扩展名，不包含（.）     * @param metas 文件扩展信息     * @return     * @throws Exception     */    public String uploadFile(String fileName, String extName, NameValuePair[] metas) throws Exception {        String result = storageClient.upload_file1(fileName, extName, metas);        return result;    }    public String uploadFile(String fileName) throws Exception {        return uploadFile(fileName, null, null);    }    public String uploadFile(String fileName, String extName) throws Exception {        return uploadFile(fileName, extName, null);    }    /**     * 上传文件方法     * &lt;p&gt;Title: uploadFile&lt;/p&gt;     * &lt;p&gt;Description: &lt;/p&gt;     * @param fileContent 文件的内容，字节数组     * @param extName 文件扩展名     * @param metas 文件扩展信息     * @return     * @throws Exception     */    public String uploadFile(byte[] fileContent, String extName, NameValuePair[] metas) throws Exception {        String result = storageClient.upload_file1(fileContent, extName, metas);        return result;    }    public String uploadFile(byte[] fileContent) throws Exception {        return uploadFile(fileContent, null, null);    }    public String uploadFile(byte[] fileContent, String extName) throws Exception {        return uploadFile(fileContent, extName, null);    }}</code></pre><h3 id="config下的配置文件-fdfs-client-conf"><a href="#config下的配置文件-fdfs-client-conf" class="headerlink" title="config下的配置文件(fdfs_client.conf):"></a>config下的配置文件(fdfs_client.conf):</h3><p>注意修改</p><p>tracker_server=192.168.25.133:22122为tracker服务器地址</p><pre><code># connect timeout in seconds# default value is 30sconnect_timeout=30# network timeout in seconds# default value is 30snetwork_timeout=60# the base path to store log filesbase_path=/home/fastdfs# tracker_server can ocur more than once, and tracker_server format is#  &quot;host:port&quot;, host can be hostname or ip addresstracker_server=192.168.25.133:22122#standard log level as syslog, case insensitive, value list:### emerg for emergency### alert### crit for critical### error### warn for warning### notice### info### debuglog_level=info# if use connection pool# default value is false# since V4.05use_connection_pool = false# connections whose the idle time exceeds this time will be closed# unit: second# default value is 3600# since V4.05connection_pool_max_idle_time = 3600# if load FastDFS parameters from tracker server# since V4.05# default value is falseload_fdfs_parameters_from_tracker=false# if use storage ID instead of IP address# same as tracker.conf# valid only when load_fdfs_parameters_from_tracker is false# default value is false# since V4.05use_storage_id = false# specify storage ids filename, can use relative or absolute path# same as tracker.conf# valid only when load_fdfs_parameters_from_tracker is false# since V4.05storage_ids_filename = storage_ids.conf#HTTP settingshttp.tracker_server_port=80#use &quot;#include&quot; directive to include HTTP other settiongs##include http.conf</code></pre><h3 id="springmvc-xml中添加配置"><a href="#springmvc-xml中添加配置" class="headerlink" title="springmvc.xml中添加配置"></a>springmvc.xml中添加配置</h3><pre><code>&lt;!-- 配置多媒体解析器 --&gt;&lt;bean id=&quot;multipartResolver&quot; class=&quot;org.springframework.web.multipart.commons.CommonsMultipartResolver&quot;&gt;    &lt;property name=&quot;defaultEncoding&quot; value=&quot;UTF-8&quot;&gt;&lt;/property&gt;    &lt;!-- 设定文件上传的最大值5MB，5*1024*1024 --&gt;    &lt;property name=&quot;maxUploadSize&quot; value=&quot;5242880&quot;&gt;&lt;/property&gt;&lt;/bean&gt;</code></pre><h3 id="controller控制层代码"><a href="#controller控制层代码" class="headerlink" title="controller控制层代码:"></a>controller控制层代码:</h3><pre><code>/** * 文件上传Controller * @author Administrator * */@RestControllerpublic class UploadController {@RequestMapping(&quot;/upload&quot;)public Result upload( MultipartFile file){                    //1、取文件的扩展名    String originalFilename = file.getOriginalFilename();    String extName = originalFilename.substring(originalFilename.lastIndexOf(&quot;.&quot;) + 1);    try {    //2、创建一个 FastDFS 的客户端            FastDFSClient fastDFSClient      = new FastDFSClient(&quot;classpath:config/fdfs_client.conf&quot;);            //3、执行上传处理            String path = fastDFSClient.uploadFile(file.getBytes(), extName);            //4、拼接返回的 url 和 ip 地址，拼装成完整的 url            String url = &quot;文件服务器地址&quot; + path;                        return new Result(true,url);                    } catch (Exception e) {            e.printStackTrace();            return new Result(false, &quot;上传失败&quot;);        }            }    }</code></pre><h3 id="前端Service-js代码"><a href="#前端Service-js代码" class="headerlink" title="前端Service.js代码"></a>前端Service.js代码</h3><pre><code>//文件上传服务层app.service(&quot;uploadService&quot;,function($http){    this.uploadFile=function(){        var formData=new FormData();        formData.append(&quot;file&quot;,file.files[0]);           return $http({            method:&apos;POST&apos;,            url:&quot;../upload.do&quot;,            data: formData,            headers: {&apos;Content-Type&apos;:undefined},            transformRequest: angular.identity        });            }    });</code></pre><p>anjularjs对于post和get请求默认的Content-Type header 是application/json。通过设置‘Content-Type’: undefined，这样浏览器会帮我们把Content-Type 设置为 multipart/form-data.</p><p>通过设置 transformRequest: angular.identity ，anjularjs transformRequest function 将序列化我们的formdata object.</p><h3 id="前端controller-js代码"><a href="#前端controller-js代码" class="headerlink" title="前端controller.js代码"></a>前端controller.js代码</h3><pre><code>app.controller(&apos;myController&apos; ,function($scope,$controller,goodsService,itemCatService,uploadService){/** * 上传图片 */$scope.uploadFile=function(){          uploadService.uploadFile().success(function(response) {                    if(response.success){//如果上传成功，取出url            $scope.image_entity.url=response.message;//设置文件地址        }else{            alert(response.message);        }    }).error(function() {                        alert(&quot;上传发生错误&quot;);    });        }; }</code></pre><h3 id="页面显示"><a href="#页面显示" class="headerlink" title="页面显示"></a>页面显示</h3><pre><code>&lt;div class=&quot;modal-body&quot;&gt;                    &lt;table class=&quot;table table-bordered table-striped&quot;&gt;              &lt;tr&gt;                  &lt;td&gt;图片&lt;/td&gt;                  &lt;td&gt;                    &lt;table&gt;                        &lt;tr&gt;                            &lt;td&gt;                            &lt;input type=&quot;file&quot; id=&quot;file&quot; /&gt;                                                                &lt;button class=&quot;btn btn-primary&quot; type=&quot;button&quot; ng-click=&quot;uploadFile()&quot;&gt;                                       上传                                &lt;/button&gt;                                &lt;/td&gt;                            &lt;td&gt;                                &lt;img  src=&quot;{{image_entity.url}}&quot; width=&quot;200px&quot; height=&quot;200px&quot;&gt;                            &lt;/td&gt;                        &lt;/tr&gt;                                            &lt;/table&gt;                  &lt;/td&gt;              &lt;/tr&gt;                           &lt;/table&gt;                &lt;/div&gt;</code></pre>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;分布式文件服务器FastDFS&quot;&gt;&lt;a href=&quot;#分布式文件服务器FastDFS&quot; class=&quot;headerlink&quot; title=&quot;分布式文件服务器FastDFS&quot;&gt;&lt;/a&gt;分布式文件服务器FastDFS&lt;/h1&gt;&lt;h2 id=&quot;什么是FastDFS&quot;&gt;&lt;a href=&quot;#什么是FastDFS&quot; class=&quot;headerlink&quot; title=&quot;什么是FastDFS&quot;&gt;&lt;/a&gt;什么是FastDFS&lt;/h2&gt;&lt;p&gt;FastDFS 是用 c 语言编写的一款开源的分布式文件系统。FastDFS 为互联网量身定制，充分考虑了冗余备份、负载均衡、线性扩容等机制，并注重高可用、高性能等指标，使用 FastDFS很容易搭建一套高性能的文件服务器集群提供文件上传、下载等服务。&lt;/p&gt;
    
    </summary>
    
      <category term="前端" scheme="http://www.fashionkillyou.xyz/categories/%E5%89%8D%E7%AB%AF/"/>
    
    
      <category term="FastDFS" scheme="http://www.fashionkillyou.xyz/tags/FastDFS/"/>
    
  </entry>
  
  <entry>
    <title>基于angularJS的多选框select2</title>
    <link href="http://www.fashionkillyou.xyz/2018/03/09/%E5%9F%BA%E4%BA%8EangularJS%E7%9A%84%E5%A4%9A%E9%80%89%E6%A1%86select2/"/>
    <id>http://www.fashionkillyou.xyz/2018/03/09/基于angularJS的多选框select2/</id>
    <published>2018-03-09T03:03:38.000Z</published>
    <updated>2018-03-30T08:23:06.800Z</updated>
    
    <content type="html"><![CDATA[<script src="\assets\js\APlayer.min.js"> </script><h1 id="基于angularJS框架下的select2插件的使用"><a href="#基于angularJS框架下的select2插件的使用" class="headerlink" title="基于angularJS框架下的select2插件的使用"></a>基于angularJS框架下的select2插件的使用</h1><a id="more"></a><p><img src="http://p57l8frp4.bkt.clouddn.com/select2.jpg" alt=""></p><h2 id="使用步骤"><a href="#使用步骤" class="headerlink" title="使用步骤:"></a>使用步骤:</h2><h3 id="引入JS文件"><a href="#引入JS文件" class="headerlink" title="引入JS文件"></a>引入JS文件</h3><pre><code>&lt;link rel=&quot;stylesheet&quot; href=&quot;bootstrap/css/bootstrap.min.css&quot;&gt;&lt;script src=&quot;jQuery/jquery-2.2.3.min.js&quot;&gt;&lt;/script&gt;&lt;script src=&quot;bootstrap/js/bootstrap.min.js&quot;&gt;&lt;/script&gt;&lt;!-- 引入angularJS,分页,controller,service --&gt;&lt;script type=&quot;text/javascript&quot; src=&quot;angularjs/angular.min.js&quot;&gt;  &lt;/script&gt;&lt;!-- 引入select2的插件 --&gt;&lt;!-- 这个要在base_pagination.js之后,因为用到了app --&gt;&lt;link rel=&quot;stylesheet&quot; href=&quot;select2/select2.css&quot; /&gt;&lt;link rel=&quot;stylesheet&quot; href=&quot;select2/select2-bootstrap.css&quot; /&gt;&lt;script src=&quot;select2/select2.min.js&quot; type=&quot;text/javascript&quot;&gt;&lt;/script&gt;&lt;script type=&quot;text/javascript&quot; src=&quot;select2/angular-select2.js&quot;&gt;&lt;/script&gt;</code></pre><h3 id="写input的属性"><a href="#写input的属性" class="headerlink" title="写input的属性"></a>写input的属性</h3><pre><code>&lt;input select2 select2-model=&quot;entity.brandIds&quot;  config=&quot;brandList&quot; multiple placeholder=&quot; 选择品牌（可多选） &quot; class=&quot;form-control&quot;&gt;</code></pre><p>multiple 表示可多选</p><p>Config用于配置数据来源</p><p>select2-model用于指定用户选择后提交的变量</p><p>select2 必须加上否则失效</p><h3 id="给定数据源"><a href="#给定数据源" class="headerlink" title="给定数据源"></a>给定数据源</h3><p><strong>注意这个要放置在select插件的前面,因为select2使用到了app</strong></p><pre><code>这里的数据格式默认是{{id:2,text:'华为'}}&lt;script type=&quot;text/javascript&quot;&gt;    var app = angular.module(&apos;app&apos;,[]);    app.controller(&apos;myController&apos;,function($scope){        //列表数据        $scope.brandList={data:[{id:1,text:&apos;联想&apos;},{id:2,text:&apos;华为&apos;},{id:3,text:&apos;小米&apos;}]};    });&lt;/script&gt;</code></pre><p>资源文件:</p><h3 id="简单多选demo"><a href="#简单多选demo" class="headerlink" title="简单多选demo"></a>简单多选demo</h3><p>链接：<a href="https://pan.baidu.com/s/12xz7kcmZGwcTjMH7MJhmDg" target="_blank" rel="noopener">https://pan.baidu.com/s/12xz7kcmZGwcTjMH7MJhmDg</a> </p><p>密码：0aq2</p><h3 id="完整说明文档"><a href="#完整说明文档" class="headerlink" title="完整说明文档"></a>完整说明文档</h3><p>链接：<a href="https://pan.baidu.com/s/1XSHqbbx3ikZRlkIFgXgMGQ" target="_blank" rel="noopener">https://pan.baidu.com/s/1XSHqbbx3ikZRlkIFgXgMGQ</a> </p><p>密码：66gc</p><h3 id="官网"><a href="#官网" class="headerlink" title="官网"></a>官网</h3><p><a href="https://select2.org/" target="_blank" rel="noopener">https://select2.org</a>/</p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;基于angularJS框架下的select2插件的使用&quot;&gt;&lt;a href=&quot;#基于angularJS框架下的select2插件的使用&quot; class=&quot;headerlink&quot; title=&quot;基于angularJS框架下的select2插件的使用&quot;&gt;&lt;/a&gt;基于angularJS框架下的select2插件的使用&lt;/h1&gt;
    
    </summary>
    
      <category term="前端" scheme="http://www.fashionkillyou.xyz/categories/%E5%89%8D%E7%AB%AF/"/>
    
    
      <category term="select2" scheme="http://www.fashionkillyou.xyz/tags/select2/"/>
    
  </entry>
  
  <entry>
    <title>使用Mybatis的PageHelper插件进行分页</title>
    <link href="http://www.fashionkillyou.xyz/2018/03/07/%E4%BD%BF%E7%94%A8Mybatis%E7%9A%84PageHelper%E6%8F%92%E4%BB%B6%E8%BF%9B%E8%A1%8C%E5%88%86%E9%A1%B5/"/>
    <id>http://www.fashionkillyou.xyz/2018/03/07/使用Mybatis的PageHelper插件进行分页/</id>
    <published>2018-03-07T12:39:39.000Z</published>
    <updated>2018-03-19T06:00:58.869Z</updated>
    
    <content type="html"><![CDATA[<script src="\assets\js\APlayer.min.js"> </script><h1 id="PageHelper插件进行分页"><a href="#PageHelper插件进行分页" class="headerlink" title="PageHelper插件进行分页"></a>PageHelper插件进行分页</h1><h2 id="实现效果"><a href="#实现效果" class="headerlink" title="实现效果"></a>实现效果</h2><a id="more"></a><p> <img src="http://p57l8frp4.bkt.clouddn.com/PageHelper.png" alt=""></p><p>##准备内容<br>本文是建立在以下框架之上:</p><ul><li>前端使用的是angularJS框架+BootStrap</li><li>后台是SpringMVC+Spring+Mybatis</li></ul><p>前期的搭建请看(<a href="https://github.com/pagehelper/Mybatis-PageHelper/blob/master/wikis/zh/HowToUse.md" title="官方文档" target="_blank" rel="noopener">官方文档</a>)</p><p>推荐博客:</p><p><a href="http://blog.csdn.net/maoyuanming0806/article/details/77720754" target="_blank" rel="noopener">http://blog.csdn.net/maoyuanming0806/article/details/77720754</a></p><p><a href="http://blog.csdn.net/FansUnion/article/details/40304187" target="_blank" rel="noopener">http://blog.csdn.net/FansUnion/article/details/40304187</a></p><h2 id="后端代码"><a href="#后端代码" class="headerlink" title="后端代码"></a>后端代码</h2><h3 id="分页结果封装实体"><a href="#分页结果封装实体" class="headerlink" title="分页结果封装实体"></a>分页结果封装实体</h3><p>创建类PageResult用于在controller中返回分页数据</p><pre><code>package entity;import java.util.List;/** * 分页结果封装对象 * @author Administrator * */public class PageResult implements Serializable{    private long total;//总记录数    private List rows;//当前页结果            public PageResult(long total, List rows) {        super();        this.total = total;        this.rows = rows;    }     //getter  and setter .....}</code></pre><h3 id="服务接口层"><a href="#服务接口层" class="headerlink" title="服务接口层"></a>服务接口层</h3><p>在service的接口BrandService.java 增加方法定义</p><pre><code>/** * 返回分页列表 * @return */public PageResult findPage(int pageNum,int pageSize);</code></pre><h3 id="服务实现层"><a href="#服务实现层" class="headerlink" title="服务实现层"></a>服务实现层</h3><p>service的实现类BrandServiceImpl.java中实现该方法</p><pre><code>@Overridepublic PageResult findPage(int pageNum, int pageSize) {    PageHelper.startPage(pageNum, pageSize);            Page&lt;TbBrand&gt; page=   (Page&lt;TbBrand&gt;) brandMapper.selectByExample(null);    return new PageResult(page.getTotal(), page.getResult());}</code></pre><p>PageHelper为MyBatis分页插件</p><h3 id="控制层"><a href="#控制层" class="headerlink" title="控制层"></a>控制层</h3><p>在控制层BrandController.java新增方法</p><pre><code>/** * 返回全部列表 * @return */@RequestMapping(&quot;/findPage&quot;)public PageResult  findPage(int page,int rows){                return brandService.findPage(page, rows);}</code></pre><h2 id="前端代码"><a href="#前端代码" class="headerlink" title="前端代码"></a>前端代码</h2><h3 id="HTML"><a href="#HTML" class="headerlink" title="HTML"></a>HTML</h3><p>在brand.html引入分页组件</p><pre><code>&lt;!-- 分页组件开始 --&gt;&lt;script src=&quot;../plugins/angularjs/pagination.js&quot;&gt;&lt;/script&gt;&lt;link rel=&quot;stylesheet&quot; href=&quot;../plugins/angularjs/pagination.css&quot;&gt;&lt;!-- 分页组件结束 --&gt;</code></pre><p>构建app模块时引入pagination模块</p><pre><code>var app=angular.module(&apos;pinyougou&apos;,[&apos;pagination&apos;]);</code></pre><p>页面的表格下放置分页组件</p><pre><code> &lt;!-- 分页 --&gt;&lt;tm-pagination conf=&quot;paginationConf&quot;&gt;&lt;/tm-pagination&gt;</code></pre><h3 id="JS代码"><a href="#JS代码" class="headerlink" title="JS代码"></a>JS代码</h3><pre><code>//重新加载列表 数据$scope.reloadList=function(){     //切换页码      $scope.findPage( $scope.paginationConf.currentPage, $scope.paginationConf.itemsPerPage);}//分页控件配置 $scope.paginationConf = {         currentPage: 1,         totalItems: 10,         itemsPerPage: 10,         perPageOptions: [10, 20, 30, 40, 50],         onChange: function(){                     $scope.reloadList();//重新加载         }}; //分页$scope.findPage=function(page,rows){        $http.get(&apos;../brand/findPage.do?page=&apos;+page+&apos;&amp;rows=&apos;+rows).success(            function(response){                $scope.list=response.rows;                    $scope.paginationConf.totalItems=response.total;//更新总记录数            }                );}</code></pre><p>paginationConf 变量各属性的意义：</p><ul><li><p>currentPage：当前页码</p></li><li><p>totalItems:总条数</p></li><li><p>itemsPerPage:</p></li><li><p>perPageOptions：页码选项</p></li><li><p>onChange：更改页面时触发事件</p></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;PageHelper插件进行分页&quot;&gt;&lt;a href=&quot;#PageHelper插件进行分页&quot; class=&quot;headerlink&quot; title=&quot;PageHelper插件进行分页&quot;&gt;&lt;/a&gt;PageHelper插件进行分页&lt;/h1&gt;&lt;h2 id=&quot;实现效果&quot;&gt;&lt;a href=&quot;#实现效果&quot; class=&quot;headerlink&quot; title=&quot;实现效果&quot;&gt;&lt;/a&gt;实现效果&lt;/h2&gt;
    
    </summary>
    
      <category term="SSM" scheme="http://www.fashionkillyou.xyz/categories/SSM/"/>
    
    
      <category term="Mybatis" scheme="http://www.fashionkillyou.xyz/tags/Mybatis/"/>
    
      <category term="PageHelper" scheme="http://www.fashionkillyou.xyz/tags/PageHelper/"/>
    
  </entry>
  
  <entry>
    <title>AngularJS框架</title>
    <link href="http://www.fashionkillyou.xyz/2018/03/07/AngularJS%E6%A1%86%E6%9E%B6/"/>
    <id>http://www.fashionkillyou.xyz/2018/03/07/AngularJS框架/</id>
    <published>2018-03-07T04:45:07.000Z</published>
    <updated>2018-03-30T08:23:06.778Z</updated>
    
    <content type="html"><![CDATA[<script src="\assets\js\APlayer.min.js"> </script><h1 id="AngularJS简介"><a href="#AngularJS简介" class="headerlink" title="AngularJS简介"></a>AngularJS简介</h1><p><img src="http://p57l8frp4.bkt.clouddn.com/angularJS.png" alt=""></p><p>AngularJS  诞生于2009年，由Misko Hevery 等人创建，后为Google所收购。是一款优秀的前端JS框架，已经被用于Google的多款产品当中。AngularJS有着诸多特性，最为核心的是：MVC、模块化、自动化双向数据绑定、依赖注入等等。<br>  <a id="more"></a></p><h2 id="AngularJS四大特征"><a href="#AngularJS四大特征" class="headerlink" title="AngularJS四大特征"></a>AngularJS四大特征</h2><h3 id="MVC-模式"><a href="#MVC-模式" class="headerlink" title="MVC    模式"></a>MVC    模式</h3><p>Angular遵循软件工程的MVC模式,并鼓励展现，数据，和逻辑组件之间的松耦合.通过依赖注入（dependency injection），Angular为客户端的Web应用带来了传统服务端的服务，例如独立于视图的控制。 因此，后端减少了许多负担，产生了更轻的Web应用。<br> <img src="http://p57l8frp4.bkt.clouddn.com/angularJS1.png" alt=""></p><ul><li>Model:数据,其实就是angular变量($scope.XX);</li><li>View: 数据的呈现,Html+Directive(指令);</li><li>Controller:操作数据,就是function,数据的增删改查;</li></ul><h3 id="双向绑定"><a href="#双向绑定" class="headerlink" title="双向绑定"></a>双向绑定</h3><p>AngularJS是建立在这样的信念上的：即声明式编程应该用于构建用户界面以及编写软件构建，而指令式编程非常适合来表示业务逻辑。框架采用并扩展了传统HTML，通过双向的数据绑定来适应动态内容，双向的数据绑定允许模型和视图之间的自动同步。因此，AngularJS使得对DOM的操作不再重要并提升了可测试性。<br> <img src="http://p57l8frp4.bkt.clouddn.com/angularJS2.png" alt=""></p><h3 id="依赖注入"><a href="#依赖注入" class="headerlink" title="依赖注入"></a>依赖注入</h3><p>依赖注入(Dependency Injection,简称DI)是一种设计模式, 指某个对象依赖的其他对象无需手工创建，只需要“吼一嗓子”，则此对象在创建时，其依赖的对象由框架来自动创建并注入进来,其实就是最少知识法则;模块中所有的service和provider两类对象，都可以根据形参名称实现DI.</p><h3 id="模块化设计"><a href="#模块化设计" class="headerlink" title="模块化设计"></a>模块化设计</h3><p>高内聚低耦合法则</p><ul><li><p>官方提供的模块           ng、ngRoute、ngAnimate</p></li><li><p>用户自定义的模块     angular.module(‘模块名’,[ ])</p></li></ul><h2 id="入门小Demo"><a href="#入门小Demo" class="headerlink" title="入门小Demo"></a>入门小Demo</h2><h3 id="表达式"><a href="#表达式" class="headerlink" title="表达式"></a>表达式</h3><pre><code>&lt;html&gt;&lt;head&gt;    &lt;title&gt;入门小Demo-1&lt;/title&gt;    &lt;script src=&quot;angular.min.js&quot;&gt;&lt;/script&gt;&lt;/head&gt;&lt;body ng-app&gt;{{100+100}}&lt;/body&gt;&lt;/html&gt;</code></pre><p>执行结果如下：</p><p>表达式的写法是 表达式可以是变量或是运算式</p><ul><li>ng-app 指令 作用是告诉子元素一下的指令是归angularJs的,angularJs会识别的</li><li>ng-app 指令定义了 AngularJS 应用程序的 根元素。</li><li>ng-app 指令在网页加载完毕时会自动引导（自动初始化）应用程序。</li></ul><h3 id="双向绑定-1"><a href="#双向绑定-1" class="headerlink" title="双向绑定"></a>双向绑定</h3><pre><code>&lt;html&gt;&lt;head&gt;    &lt;title&gt;入门小Demo-1  双向绑定&lt;/title&gt;    &lt;script src=&quot;angular.min.js&quot;&gt;&lt;/script&gt;&lt;/head&gt;&lt;body ng-app&gt;请输入你的姓名：&lt;input ng-model=&quot;myname&quot;&gt;&lt;br&gt;{{myname}},你好&lt;/body&gt;&lt;/html&gt;</code></pre><p>运行效果如下：</p><p>ng-model 指令用于绑定变量,这样用户在文本框输入的内容会绑定到变量上，而表达式可以实时地输出变量。</p><h3 id="初始化指令"><a href="#初始化指令" class="headerlink" title="初始化指令"></a>初始化指令</h3><p>我们如果希望有些变量具有初始值，可以使用ng-init指令来对变量初始化</p><pre><code>&lt;html&gt;&lt;head&gt;    &lt;title&gt;入门小Demo-3  初始化&lt;/title&gt;    &lt;script src=&quot;angular.min.js&quot;&gt;&lt;/script&gt;&lt;/head&gt;&lt;body ng-app   ng-init=&quot;myname=&apos;陈大海&apos;&quot;&gt;请输入你的姓名：&lt;input ng-model=&quot;myname&quot;&gt;&lt;br&gt;{{myname}},你好&lt;/body&gt;&lt;/html&gt;</code></pre><h3 id="控制器"><a href="#控制器" class="headerlink" title="控制器"></a>控制器</h3><pre><code>&lt;html&gt;&lt;head&gt;    &lt;title&gt;入门小Demo-3  初始化&lt;/title&gt;    &lt;script src=&quot;angular.min.js&quot;&gt;&lt;/script&gt;    &lt;script&gt;        var app=angular.module(&apos;myApp&apos;,[]); //定义了一个叫myApp的模块        //定义控制器        app.controller(&apos;myController&apos;,function($scope){            $scope.add=function(){                return parseInt($scope.x)+parseInt($scope.y);            }        });    &lt;/script&gt;&lt;/head&gt;&lt;body ng-app=&quot;myApp&quot; ng-controller=&quot;myController&quot;&gt;x:&lt;input ng-model=&quot;x&quot; &gt;y:&lt;input ng-model=&quot;y&quot; &gt;运算结果：{{add()}}&lt;/body&gt;&lt;/html&gt;</code></pre><p>运行结果如下：</p><p>ng-controller用于指定所使用的控制器。</p><p>理解 $scope：</p><p>$scope 的使用贯穿整个 AngularJS App 应用,它与数据模型相关联,同时也是表达式执行的上下文.有了$scope 就在视图和控制器之间建立了一个通道,基于作用域视图在修改数据时会立刻更新 $scope,同样的$scope 发生改变时也会立刻重新渲染视图.</p><h3 id="事件指令"><a href="#事件指令" class="headerlink" title="事件指令"></a>事件指令</h3><pre><code>&lt;html&gt;&lt;head&gt;    &lt;title&gt;入门小Demo-5  事件指令&lt;/title&gt;    &lt;script src=&quot;angular.min.js&quot;&gt;&lt;/script&gt;        &lt;script&gt;        var app=angular.module(&apos;myApp&apos;,[]); //定义了一个叫myApp的模块        //定义控制器        app.controller(&apos;myController&apos;,function($scope){                        $scope.add=function(){                $scope.z= parseInt($scope.x)+parseInt($scope.y);            }                    });        &lt;/script&gt;&lt;/head&gt;&lt;body ng-app=&quot;myApp&quot; ng-controller=&quot;myController&quot;&gt;x:&lt;input ng-model=&quot;x&quot; &gt;y:&lt;input ng-model=&quot;y&quot; &gt;&lt;button ng-click=&quot;add()&quot;&gt;运算&lt;/button&gt;结果：{{z}}&lt;/body&gt;&lt;/html&gt;</code></pre><p>运行结果：</p><p>ng-click  是最常用的单击事件指令，再点击时触发控制器的某个方法</p><h3 id="循环数组"><a href="#循环数组" class="headerlink" title="循环数组"></a>循环数组</h3><pre><code>&lt;html&gt;&lt;head&gt;    &lt;title&gt;入门小Demo-6  循环数据&lt;/title&gt;    &lt;script src=&quot;angular.min.js&quot;&gt;&lt;/script&gt;    &lt;script&gt;        var app=angular.module(&apos;myApp&apos;,[]); //定义了一个叫myApp的模块        //定义控制器        app.controller(&apos;myController&apos;,function($scope){            $scope.list= [100,192,203,434 ];//定义数组        });    &lt;/script&gt;&lt;/head&gt;&lt;body ng-app=&quot;myApp&quot; ng-controller=&quot;myController&quot;&gt;&lt;table&gt;&lt;tr ng-repeat=&quot;x in list&quot;&gt;    &lt;td&gt;{{x}}&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/body&gt;&lt;/html&gt;</code></pre><p>这里的ng-repeat指令用于循环数组变量。<br>运行结果如下：</p><h3 id="循环对象数组"><a href="#循环对象数组" class="headerlink" title="循环对象数组"></a>循环对象数组</h3><pre><code>&lt;html&gt;&lt;head&gt;    &lt;title&gt;入门小Demo-7  循环对象数组&lt;/title&gt;    &lt;script src=&quot;angular.min.js&quot;&gt;&lt;/script&gt;        &lt;script&gt;        var app=angular.module(&apos;myApp&apos;,[]); //定义了一个叫myApp的模块        //定义控制器        app.controller(&apos;myController&apos;,function($scope){                    $scope.list= [                {name:&apos;张三&apos;,shuxue:100,yuwen:93},                {name:&apos;李四&apos;,shuxue:88,yuwen:87},                {name:&apos;王五&apos;,shuxue:77,yuwen:56}            ];//定义数组                    });        &lt;/script&gt;    &lt;/head&gt;&lt;body ng-app=&quot;myApp&quot; ng-controller=&quot;myController&quot;&gt;&lt;table&gt;&lt;tr&gt;    &lt;td&gt;姓名&lt;/td&gt;    &lt;td&gt;数学&lt;/td&gt;    &lt;td&gt;语文&lt;/td&gt;&lt;/tr&gt;&lt;tr ng-repeat=&quot;entity in list&quot;&gt;    &lt;td&gt;{{entity.name}}&lt;/td&gt;    &lt;td&gt;{{entity.shuxue}}&lt;/td&gt;    &lt;td&gt;{{entity.yuwen}}&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/body&gt;&lt;/html&gt;</code></pre><p>运行结果如下：</p><h3 id="内置服务"><a href="#内置服务" class="headerlink" title="内置服务"></a>内置服务</h3><p>我们的数据一般都是从后端获取的，那么如何获取数据呢？我们一般使用内置服务$http来实现。注意：以下代码需要在tomcat中运行。</p><pre><code>&lt;html&gt;&lt;head&gt;    &lt;title&gt;入门小Demo-8  内置服务&lt;/title&gt;    &lt;meta charset=&quot;utf-8&quot; /&gt;    &lt;script src=&quot;angular.min.js&quot;&gt;&lt;/script&gt;        &lt;script&gt;        var app=angular.module(&apos;myApp&apos;,[]); //定义了一个叫myApp的模块        //定义控制器        app.controller(&apos;myController&apos;,function($scope,$http){                    $scope.findAll=function(){                $http.get(&apos;data.json&apos;).success(                    function(response){                        $scope.list=response;                    }                                    );                            }                    });        &lt;/script&gt;    &lt;/head&gt;&lt;body ng-app=&quot;myApp&quot; ng-controller=&quot;myController&quot; ng-init=&quot;findAll()&quot;&gt;&lt;table&gt;&lt;tr&gt;    &lt;td&gt;姓名&lt;/td&gt;    &lt;td&gt;数学&lt;/td&gt;    &lt;td&gt;语文&lt;/td&gt;&lt;/tr&gt;&lt;tr ng-repeat=&quot;entity in list&quot;&gt;    &lt;td&gt;{{entity.name}}&lt;/td&gt;    &lt;td&gt;{{entity.shuxue}}&lt;/td&gt;    &lt;td&gt;{{entity.yuwen}}&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/body&gt;&lt;/html&gt;建立文件 data.json[    {&quot;name&quot;:&quot;张三&quot;,&quot;shuxue&quot;:100,&quot;yuwen&quot;:93},    {&quot;name&quot;:&quot;李四&quot;,&quot;shuxue&quot;:88,&quot;yuwen&quot;:87},    {&quot;name&quot;:&quot;王五&quot;,&quot;shuxue&quot;:77,&quot;yuwen&quot;:56},    {&quot;name&quot;:&quot;赵六&quot;,&quot;shuxue&quot;:67,&quot;yuwen&quot;:86}]</code></pre><h1 id="常用的指令"><a href="#常用的指令" class="headerlink" title="常用的指令"></a>常用的指令</h1><p>名称       描述</p><p><strong>ngApp    定义应用程序的根元素。</strong></p><p>ngBind    绑定 HTML 元素到应用程序数据</p><p><strong>ngBindhtml    绑定 HTML 元素的 innerHTML 到应用程序数据，并移除 HTML 字符串中危险字<br>符</strong></p><p>ngBindtemplate    规定要使用模板替换的文本内容</p><p>ngBlur    规定 blur 事件的行为</p><p>ngChange    规定在内容改变时要执行的表达式</p><p><strong>ngChecked    规定元素是否被选中</strong></p><p>ngClass    指定 HTML 元素使用的 CSS 类</p><p>ngClasseven    类似 ng-class，但只在偶数行起作用</p><p>ngClassodd    类似 ng-class，但只在奇数行起作用</p><p><strong>ngClick    定义元素被点击时的行为</strong></p><p>ngCloak    在应用正要加载时防止其闪烁</p><p>ngController    定义应用的控制器对象</p><p>ngCopy    规定拷贝事件的行为</p><p>ngCsp    修改内容的安全策略</p><p>ngCut    规定剪切事件的行为</p><p>ngDblclick    规定双击事件的行为</p><p>ngDisabled    规定一个元素是否被禁用</p><p>ngFocus    规定聚焦事件的行为</p><p>ngHide    隐藏或显示 HTML 元素</p><p>ngHref    为 元素指定链接</p><p><strong>ngIf    判断语句，如果值为falsh，所在的div层不显示</strong></p><p>ngInclude    在应用中包含 HTML 文件</p><p>ngInit    定义应用的初始化值</p><p>ngKeydown    规定按下按键事件的行为</p><p>ngKeypress    规定按下按键事件的行为</p><p>ngKeyup    规定松开按键事件的行为</p><p>ngList    将文本转换为列表 (数组)</p><p><strong>ngModel    绑定 HTML 控制器的值到应用数据</strong></p><p>ngModeloptions    规定如何更新模型</p><p>ngMousedown    规定按下鼠标按键时的行为</p><p>ngMouseenter    规定鼠标指针穿过元素时的行为</p><p>ngMouseleave    规定鼠标指针离开元素时的行为</p><p>ngMousemove    规定鼠标指针在指定的元素中移动时的行为</p><p>ngMouseover    规定鼠标指针位于元素上方时的行为</p><p>ngMouseup    规定当在元素上松开鼠标按钮时的行为</p><p>ngNonbindable    规定元素或子元素不能绑定数据</p><p>ngOpen    指定元素的 open 属性</p><p><strong>ngOptions    在 &lt; select&gt; 列表中指定 &lt; options&gt;</strong></p><p>ngPaste    规定粘贴事件的行为</p><p>ngReadonly    指定元素的 readonly 属性</p><p><strong>ngRepeat    定义集合中每项数据的模板</strong></p><p>ngSelected    指定元素的 selected 属性</p><p>ngShow    显示或隐藏 HTML 元素</p><p>ngSrc    指定  元素的 src 属性</p><p>ngSrcset    指定  元素的 srcset 属性</p><p>ngStyle    指定元素的 style 属性</p><p>ngSubmit    规定 onsubmit 事件发生时执行的表达式</p><p>ngSwitch    规定显示或隐藏子元素的条件</p><p><strong>ngValue    规定input元素的值</strong></p><h1 id="服务"><a href="#服务" class="headerlink" title="服务"></a>服务</h1><p>名称    描述</p><p>$http    $http是Angular的一个核心服务，它有利于浏览器通过XMLHttpRequest 对象或者 JSONP和远程HTTP服务器交互。</p><p>$controller    </p><p>$filter    ()</p><pre><code>// 定义过滤器app.filter(&apos;trustHtml&apos;,[&apos;$sce&apos;,function($sce){    return function(data){//传入参数时被过滤的内容        return $sce.trustAsHtml(data);//返回的是过滤后的内容（信任html的转换）    }    } ]);</code></pre><p>页面:<br>    <div class="attr" ng-bind-html="item.title | trustHtml"></div></p><p>$location    $location服务解析浏览器地址中的url（基于window.location）并且使url在应用程序中可用。将地址栏中的网址的变化反映到$location服务和$location的变化反映到浏览器地址栏。</p><p>$sce    $sce 服务是AngularJs提供的一种严格上下文转义服务。</p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;AngularJS简介&quot;&gt;&lt;a href=&quot;#AngularJS简介&quot; class=&quot;headerlink&quot; title=&quot;AngularJS简介&quot;&gt;&lt;/a&gt;AngularJS简介&lt;/h1&gt;&lt;p&gt;&lt;img src=&quot;http://p57l8frp4.bkt.clouddn.com/angularJS.png&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;p&gt;AngularJS  诞生于2009年，由Misko Hevery 等人创建，后为Google所收购。是一款优秀的前端JS框架，已经被用于Google的多款产品当中。AngularJS有着诸多特性，最为核心的是：MVC、模块化、自动化双向数据绑定、依赖注入等等。&lt;br&gt;
    
    </summary>
    
      <category term="前端" scheme="http://www.fashionkillyou.xyz/categories/%E5%89%8D%E7%AB%AF/"/>
    
    
      <category term="AngularJS" scheme="http://www.fashionkillyou.xyz/tags/AngularJS/"/>
    
  </entry>
  
  <entry>
    <title>Dubbox框架入门小demo</title>
    <link href="http://www.fashionkillyou.xyz/2018/03/05/Dubbox%E6%A1%86%E6%9E%B6%E5%85%A5%E9%97%A8%E5%B0%8Fdemo/"/>
    <id>http://www.fashionkillyou.xyz/2018/03/05/Dubbox框架入门小demo/</id>
    <published>2018-03-05T12:02:42.000Z</published>
    <updated>2018-03-30T08:23:06.781Z</updated>
    
    <content type="html"><![CDATA[<script src="\assets\js\APlayer.min.js"> </script><h1 id="Dubbox框架"><a href="#Dubbox框架" class="headerlink" title="Dubbox框架"></a>Dubbox框架</h1><h2 id="Dubbox简介"><a href="#Dubbox简介" class="headerlink" title="Dubbox简介"></a>Dubbox简介</h2><p>Dubbox 是一个<strong>分布式服务框架</strong>，其前身是阿里巴巴开源项目Dubbo ，被国内电商及互联网项目中使用，后期阿里巴巴停止了该项目的维护，当当网便在Dubbo基础上进行优化，并继续维护，为了与原有的Dubbo区分，故将其命名为Dubbox。<br><a id="more"></a><br>Dubbox 致力于提供高性能和透明化的RPC远程服务调用方案，以及SOA服务治理方案。简单的说，dubbox就是个服务框架，如果没有分布式的需求，其实是不需要用的，只有在分布式的时候，才有dubbox这样的分布式服务框架的需求，并且本质上是个服务调用的东东，说白了就是个远程服务调用的分布式框架。</p><p>###节点角色说明：<br>• Provider: 暴露服务的服务提供方。</p><p>• Consumer: 调用远程服务的服务消费方。</p><p>• Registry: 服务注册与发现的注册中心。</p><p>• Monitor: 统计服务的调用次调和调用时间的监控中心。</p><p>• Container: 服务运行容器。</p><h3 id="调用关系说明："><a href="#调用关系说明：" class="headerlink" title="调用关系说明："></a>调用关系说明：</h3><p>• 0. 服务容器负责启动，加载，运行服务提供者。</p><p>• 1. 服务提供者在启动时，向注册中心注册自己提供的服务。</p><p>• 2. 服务消费者在启动时，向注册中心订阅自己所需的服务。</p><p>• 3. 注册中心返回服务提供者地址列表给消费者，如果有变更，注册中心将基于长连接推<br>送变更数据给消费者。</p><p>• 4. 服务消费者，从提供者地址列表中，基于软负载均衡算法，选一台提供者进行调用，<br>如果调用失败，再选另一台调用。</p><p>• 5. 服务消费者和提供者，在内存中累计调用次数和调用时间，定时每分钟发送一次统计<br>数据到监控中心。</p><h2 id="注册中心Zookeeper"><a href="#注册中心Zookeeper" class="headerlink" title="注册中心Zookeeper"></a>注册中心Zookeeper</h2><h3 id="Zookeeper-介绍"><a href="#Zookeeper-介绍" class="headerlink" title="Zookeeper 介绍"></a>Zookeeper 介绍</h3><p>官方推荐使用 zookeeper 注册中心。注册中心负责服务地址的注册与查找，相当于目录服务，服务提供者和消费者只在启动时与注册中心交互，注册中心不转发请求，压力较小。</p><p>Zookeeper 是 Apacahe Hadoop 的子项目，是一个树型的目录服务，支持变更推送，适合作为Dubbox 服务的注册中心，工业强度较高，可用于生产环境。</p><h3 id="Zookeeper-在Linux系统的安装"><a href="#Zookeeper-在Linux系统的安装" class="headerlink" title="Zookeeper 在Linux系统的安装"></a>Zookeeper 在Linux系统的安装</h3><p>安装步骤：</p><p>第一步：安装 jdk(这里请自行百度,如何在Linux中安装jdk)</p><p>第二步：把 zookeeper 的压缩包（…\dubbox\zookeeper-3.4.6.tar.gz）上传到 linux 系统。</p><pre><code>Alt+P 进入SFTP ，输入put d:\zookeeper-3.4.6.tar.gz 上传(这里d:是你放置压缩包的位置)</code></pre><p>第三步：解压缩压缩包</p><pre><code>tar -zxvf zookeeper-3.4.6.tar.gz</code></pre><p>第四步：进入 zookeeper-3.4.6 目录，创建 data 文件夹。</p><pre><code>mkdir data</code></pre><p>第五步：进入conf目录 ，把 zoo_sample.cfg 改名为 zoo.cfg</p><pre><code>cd confmv zoo_sample.cfg zoo.cfg</code></pre><p>第六步：打开zoo.cfg ,  修改 data 属性：</p><pre><code>dataDir=/root/zookeeper-3.4.6/data</code></pre><h3 id="Zookeeper-服务启动"><a href="#Zookeeper-服务启动" class="headerlink" title="Zookeeper 服务启动"></a>Zookeeper 服务启动</h3><p>进入bin目录，启动服务输入命令</p><pre><code>./zkServer.sh start</code></pre><p>关闭服务输入命令</p><pre><code>./zkServer.sh stop</code></pre><p>查看状态：</p><pre><code>./zkServer.sh status</code></pre><h3 id="Dubbox本地-JAR包部署与安装"><a href="#Dubbox本地-JAR包部署与安装" class="headerlink" title="Dubbox本地 JAR包部署与安装"></a>Dubbox本地 JAR包部署与安装</h3><p>Dubbox的jar包并没有部署到Maven的中央仓库中，大家在Maven的中央仓库中可以查找到Dubbo的最终版本是2.5.3 , 阿里巴巴解散了Dubbo团队后由当当网继续维护此项目，并改名为 Dubbox ,坐标不变，版本变更了，但是并没有提交到中央仓库。</p><p>我们现在需要手动将Dubbox的jar包安装到我的本地仓库中。</p><p>先将dubbo-2.8.4.jar包放到d:\setup, 然后输入命令</p><pre><code>mvn install:install-file -Dfile=d:\setup\dubbo-2.8.4.jar -DgroupId=com.alibaba -DartifactId=dubbo -Dversion=2.8.4 -Dpackaging=jar</code></pre><h3 id="配置离线约束"><a href="#配置离线约束" class="headerlink" title="配置离线约束"></a>配置离线约束</h3><p>地址：</p><pre><code>http://code.alibabatech.com/schema/dubbo/dubbo.xsd </code></pre><h2 id="入门小Demo"><a href="#入门小Demo" class="headerlink" title="入门小Demo"></a>入门小Demo</h2><h3 id="服务提供者开发"><a href="#服务提供者开发" class="headerlink" title="服务提供者开发"></a>服务提供者开发</h3><p>开发步骤：</p><p>（1）创建Maven工程（WAR）dubboxdemo-service  ，在pom.xml中引入依赖</p><pre><code>&lt;project xmlns=&quot;http://maven.apache.org/POM/4.0.0&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xsi:schemaLocation=&quot;http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd&quot;&gt;  &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt;  &lt;groupId&gt;cn.lxm.dubboxdemo&lt;/groupId&gt;  &lt;artifactId&gt;dubboxdemo-service&lt;/artifactId&gt;  &lt;version&gt;0.0.1-SNAPSHOT&lt;/version&gt;  &lt;packaging&gt;war&lt;/packaging&gt;     &lt;properties&gt;                &lt;spring.version&gt;4.2.4.RELEASE&lt;/spring.version&gt;   &lt;/properties&gt;        &lt;dependencies&gt;        &lt;!-- Spring --&gt;        &lt;dependency&gt;            &lt;groupId&gt;org.springframework&lt;/groupId&gt;            &lt;artifactId&gt;spring-context&lt;/artifactId&gt;            &lt;version&gt;${spring.version}&lt;/version&gt;        &lt;/dependency&gt;        &lt;dependency&gt;            &lt;groupId&gt;org.springframework&lt;/groupId&gt;            &lt;artifactId&gt;spring-beans&lt;/artifactId&gt;            &lt;version&gt;${spring.version}&lt;/version&gt;        &lt;/dependency&gt;        &lt;dependency&gt;            &lt;groupId&gt;org.springframework&lt;/groupId&gt;            &lt;artifactId&gt;spring-webmvc&lt;/artifactId&gt;            &lt;version&gt;${spring.version}&lt;/version&gt;        &lt;/dependency&gt;        &lt;dependency&gt;            &lt;groupId&gt;org.springframework&lt;/groupId&gt;            &lt;artifactId&gt;spring-jdbc&lt;/artifactId&gt;            &lt;version&gt;${spring.version}&lt;/version&gt;        &lt;/dependency&gt;        &lt;dependency&gt;            &lt;groupId&gt;org.springframework&lt;/groupId&gt;            &lt;artifactId&gt;spring-aspects&lt;/artifactId&gt;            &lt;version&gt;${spring.version}&lt;/version&gt;        &lt;/dependency&gt;        &lt;dependency&gt;            &lt;groupId&gt;org.springframework&lt;/groupId&gt;            &lt;artifactId&gt;spring-jms&lt;/artifactId&gt;            &lt;version&gt;${spring.version}&lt;/version&gt;        &lt;/dependency&gt;        &lt;dependency&gt;            &lt;groupId&gt;org.springframework&lt;/groupId&gt;            &lt;artifactId&gt;spring-context-support&lt;/artifactId&gt;            &lt;version&gt;${spring.version}&lt;/version&gt;        &lt;/dependency&gt;            &lt;!-- dubbo相关 --&gt;        &lt;dependency&gt;            &lt;groupId&gt;com.alibaba&lt;/groupId&gt;            &lt;artifactId&gt;dubbo&lt;/artifactId&gt;            &lt;version&gt;2.8.4&lt;/version&gt;                    &lt;/dependency&gt;        &lt;dependency&gt;            &lt;groupId&gt;org.apache.zookeeper&lt;/groupId&gt;            &lt;artifactId&gt;zookeeper&lt;/artifactId&gt;            &lt;version&gt;3.4.6&lt;/version&gt;        &lt;/dependency&gt;        &lt;dependency&gt;            &lt;groupId&gt;com.github.sgroschupf&lt;/groupId&gt;            &lt;artifactId&gt;zkclient&lt;/artifactId&gt;            &lt;version&gt;0.1&lt;/version&gt;        &lt;/dependency&gt;                &lt;dependency&gt;            &lt;groupId&gt;javassist&lt;/groupId&gt;            &lt;artifactId&gt;javassist&lt;/artifactId&gt;            &lt;version&gt;3.11.0.GA&lt;/version&gt;        &lt;/dependency&gt;            &lt;/dependencies&gt;   &lt;build&gt;        &lt;plugins&gt;          &lt;plugin&gt;                &lt;groupId&gt;org.apache.maven.plugins&lt;/groupId&gt;                &lt;artifactId&gt;maven-compiler-plugin&lt;/artifactId&gt;                &lt;version&gt;2.3.2&lt;/version&gt;                &lt;configuration&gt;                    &lt;source&gt;1.7&lt;/source&gt;                    &lt;target&gt;1.7&lt;/target&gt;                &lt;/configuration&gt;            &lt;/plugin&gt;            &lt;plugin&gt;                &lt;groupId&gt;org.apache.tomcat.maven&lt;/groupId&gt;                &lt;artifactId&gt;tomcat7-maven-plugin&lt;/artifactId&gt;                &lt;configuration&gt;                    &lt;!-- 指定端口 --&gt;                    &lt;port&gt;8081&lt;/port&gt;                    &lt;!-- 请求路径 --&gt;                    &lt;path&gt;/&lt;/path&gt;                &lt;/configuration&gt;            &lt;/plugin&gt;      &lt;/plugins&gt;      &lt;/build&gt;&lt;/project&gt;</code></pre><p>（2）在工程的webapps下创建WEB-INF文件夹，创建web.xml</p><pre><code>&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;web-app xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;    xmlns=&quot;http://java.sun.com/xml/ns/javaee&quot;    xsi:schemaLocation=&quot;http://java.sun.com/xml/ns/javaee http://java.sun.com/xml/ns/javaee/web-app_2_5.xsd&quot;    version=&quot;2.5&quot;&gt;        &lt;!-- 加载spring容器 --&gt;    &lt;context-param&gt;        &lt;param-name&gt;contextConfigLocation&lt;/param-name&gt;        &lt;param-value&gt;classpath:applicationContext*.xml&lt;/param-value&gt;    &lt;/context-param&gt;    &lt;listener&gt;        &lt;listener-class&gt;org.springframework.web.context.ContextLoaderListener&lt;/listener-class&gt;    &lt;/listener&gt;    &lt;/web-app&gt;</code></pre><p>（3）创建业务接口<br>创建包cn.lxm.dubbodemo.service，用于存放业务接口，创建接口</p><pre><code>package cn.lxm.dubbodemo.service;/** * 业务接口 * @author Administrator * */public interface UserService {        public String getName();    }</code></pre><p>（4）创建业务实现类<br>创建包cn.lxm.dubbodemo.service.impl ，用于存放业务实现类。创建业务实现类：</p><pre><code>package cn.lxm.dubbodemo.service.impl;import com.alibaba.dubbo.config.annotation.Service;import cn.lxm.dubbodemo.service.UserService;@Servicepublic class UserServiceImpl implements UserService {    public String getName() {                return &quot;lxm&quot;;    }}</code></pre><p>注意：Service注解与原来不同，需要引入com.alibaba包下的</p><p>（5）编写配置文件<br>在src/main/resources下创建applicationContext-service.xml ,内容如下：</p><pre><code>&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot;    xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xmlns:p=&quot;http://www.springframework.org/schema/p&quot;    xmlns:context=&quot;http://www.springframework.org/schema/context&quot;    xmlns:dubbo=&quot;http://code.alibabatech.com/schema/dubbo&quot; xmlns:mvc=&quot;http://www.springframework.org/schema/mvc&quot;    xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd        http://www.springframework.org/schema/mvc http://www.springframework.org/schema/mvc/spring-mvc.xsd        http://code.alibabatech.com/schema/dubbo http://code.alibabatech.com/schema/dubbo/dubbo.xsd        http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context.xsd&quot;&gt;    &lt;dubbo:application name=&quot;dubboxdemo-service&quot;/&gt;  &lt;dubbo:registry address=&quot;zookeeper://192.168.25.132:2181&quot;/&gt; &lt;dubbo:annotation package=&quot;cn.lxm.dubboxdemo.service&quot; /&gt; &lt;/beans&gt;</code></pre><p>注意：dubbo:annotation用于扫描@Service注解。</p><h3 id="服务消费者开发"><a href="#服务消费者开发" class="headerlink" title="服务消费者开发"></a>服务消费者开发</h3><p>开发步骤：</p><p>（1）创建Maven工程（WAR）dubboxdemo-web ，在pom.xml引入依赖 ，同“dubboxdemo-service”工程。区别就是把tomcat插件的运行端口改为8082 。</p><p>（2）在webapps目录下创建WEB-INF 目录，并创建web.xml </p><pre><code>&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;web-app xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;    xmlns=&quot;http://java.sun.com/xml/ns/javaee&quot;    xsi:schemaLocation=&quot;http://java.sun.com/xml/ns/javaee http://java.sun.com/xml/ns/javaee/web-app_2_5.xsd&quot;    version=&quot;2.5&quot;&gt;       &lt;!-- 解决post乱码 --&gt;    &lt;filter&gt;        &lt;filter-name&gt;CharacterEncodingFilter&lt;/filter-name&gt;        &lt;filter-class&gt;org.springframework.web.filter.CharacterEncodingFilter&lt;/filter-class&gt;        &lt;init-param&gt;            &lt;param-name&gt;encoding&lt;/param-name&gt;            &lt;param-value&gt;utf-8&lt;/param-value&gt;        &lt;/init-param&gt;        &lt;init-param&gt;              &lt;param-name&gt;forceEncoding&lt;/param-name&gt;              &lt;param-value&gt;true&lt;/param-value&gt;          &lt;/init-param&gt;      &lt;/filter&gt;    &lt;filter-mapping&gt;        &lt;filter-name&gt;CharacterEncodingFilter&lt;/filter-name&gt;        &lt;url-pattern&gt;/*&lt;/url-pattern&gt;    &lt;/filter-mapping&gt;          &lt;servlet&gt;      &lt;servlet-name&gt;springmvc&lt;/servlet-name&gt;      &lt;servlet-class&gt;org.springframework.web.servlet.DispatcherServlet&lt;/servlet-class&gt;      &lt;!-- 指定加载的配置文件 ，通过参数contextConfigLocation加载--&gt;      &lt;init-param&gt;          &lt;param-name&gt;contextConfigLocation&lt;/param-name&gt;          &lt;param-value&gt;classpath:applicationContext-web.xml&lt;/param-value&gt;      &lt;/init-param&gt;  &lt;/servlet&gt;    &lt;servlet-mapping&gt;      &lt;servlet-name&gt;springmvc&lt;/servlet-name&gt;      &lt;url-pattern&gt;*.do&lt;/url-pattern&gt;  &lt;/servlet-mapping&gt;&lt;/web-app&gt;</code></pre><p>（3）拷贝业务接口<br>将“dubboxdemo-service”工程的cn.lxm.dubboxdemo.service 包以及下面的接口拷贝至此工程。</p><p>（4）编写Controller </p><pre><code>package cn.lxm.dubboxdemo.controller;import org.springframework.beans.factory.annotation.Autowired;import org.springframework.stereotype.Controller;import org.springframework.web.bind.annotation.RequestMapping;import org.springframework.web.bind.annotation.ResponseBody;import cn.lxm.dubbodemo.service.UserService;@Controller@RequestMapping(&quot;/user&quot;)public class UserController {    @Reference    private UserService userService;        @RequestMapping(&quot;/showName&quot;)    @ResponseBody    public String showName(){        return userService.getName();    }        }</code></pre><p>（5）编写spring配置文件<br>在src/main/resources下创建applicationContext-web.xml  </p><pre><code>&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot;    xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xmlns:p=&quot;http://www.springframework.org/schema/p&quot;    xmlns:context=&quot;http://www.springframework.org/schema/context&quot;    xmlns:dubbo=&quot;http://code.alibabatech.com/schema/dubbo&quot; xmlns:mvc=&quot;http://www.springframework.org/schema/mvc&quot;    xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd        http://www.springframework.org/schema/mvc http://www.springframework.org/schema/mvc/spring-mvc.xsd        http://code.alibabatech.com/schema/dubbo http://code.alibabatech.com/schema/dubbo/dubbo.xsd        http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context.xsd&quot;&gt;    &lt;mvc:annotation-driven &gt;        &lt;mvc:message-converters register-defaults=&quot;false&quot;&gt;            &lt;bean class=&quot;org.springframework.http.converter.StringHttpMessageConverter&quot;&gt;                  &lt;constructor-arg value=&quot;UTF-8&quot; /&gt;            &lt;/bean&gt;          &lt;/mvc:message-converters&gt;        &lt;/mvc:annotation-driven&gt;    &lt;!-- 引用dubbo 服务 --&gt;    &lt;dubbo:application name=&quot;dubboxdemo-web&quot; /&gt;    &lt;dubbo:registry address=&quot;zookeeper://192.168.25.132:2181&quot;/&gt;     &lt;dubbo:annotation package=&quot;cn.lxm.dubboxdemo.controller&quot; /&gt;&lt;/beans&gt;</code></pre><p>（6）测试运行</p><p>tomcat7:run<br>在浏览器输入<a href="http://localhost:8082/user/showName.do，查看浏览器输出结果" target="_blank" rel="noopener">http://localhost:8082/user/showName.do，查看浏览器输出结果</a></p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;Dubbox框架&quot;&gt;&lt;a href=&quot;#Dubbox框架&quot; class=&quot;headerlink&quot; title=&quot;Dubbox框架&quot;&gt;&lt;/a&gt;Dubbox框架&lt;/h1&gt;&lt;h2 id=&quot;Dubbox简介&quot;&gt;&lt;a href=&quot;#Dubbox简介&quot; class=&quot;headerlink&quot; title=&quot;Dubbox简介&quot;&gt;&lt;/a&gt;Dubbox简介&lt;/h2&gt;&lt;p&gt;Dubbox 是一个&lt;strong&gt;分布式服务框架&lt;/strong&gt;，其前身是阿里巴巴开源项目Dubbo ，被国内电商及互联网项目中使用，后期阿里巴巴停止了该项目的维护，当当网便在Dubbo基础上进行优化，并继续维护，为了与原有的Dubbo区分，故将其命名为Dubbox。&lt;br&gt;
    
    </summary>
    
      <category term="java" scheme="http://www.fashionkillyou.xyz/categories/java/"/>
    
    
      <category term="Dubbox" scheme="http://www.fashionkillyou.xyz/tags/Dubbox/"/>
    
  </entry>
  
  <entry>
    <title>Lucene全文检索入门</title>
    <link href="http://www.fashionkillyou.xyz/2018/03/03/Lucene%E5%85%A8%E6%96%87%E6%A3%80%E7%B4%A2%E5%85%A5%E9%97%A8/"/>
    <id>http://www.fashionkillyou.xyz/2018/03/03/Lucene全文检索入门/</id>
    <published>2018-03-03T13:02:41.000Z</published>
    <updated>2018-03-30T08:23:06.782Z</updated>
    
    <content type="html"><![CDATA[<script src="\assets\js\APlayer.min.js"> </script><p>#Lucene概述</p><h2 id="什么是Lucene"><a href="#什么是Lucene" class="headerlink" title="什么是Lucene"></a>什么是Lucene</h2><ul><li><p>Lucene是一套用于全文检索和搜寻的开源程序库，由Apache软件基金会支持和提供</p></li><li><p>Lucene提供了一个简单却强大的应用程序接口（API），能够做全文索引和搜寻，在Java开发环境里Lucene是一个成熟的免费开放源代码工具</p></li><li><p>Lucene并不是现成的搜索引擎产品，但可以用来制作搜索引擎产品</p></li><li><p>官网：<a href="http://lucene.apache.org/" target="_blank" rel="noopener">http://lucene.apache.org/</a></p></li></ul><p># </p><p>待更新…</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;script src=&quot;\assets\js\APlayer.min.js&quot;&gt; &lt;/script&gt;&lt;p&gt;#Lucene概述&lt;/p&gt;
&lt;h2 id=&quot;什么是Lucene&quot;&gt;&lt;a href=&quot;#什么是Lucene&quot; class=&quot;headerlink&quot; title=&quot;什么是Luce
      
    
    </summary>
    
      <category term="搜索解决方案" scheme="http://www.fashionkillyou.xyz/categories/%E6%90%9C%E7%B4%A2%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88/"/>
    
    
      <category term="Lucene" scheme="http://www.fashionkillyou.xyz/tags/Lucene/"/>
    
  </entry>
  
  <entry>
    <title>使用formfill.js快速填充表单</title>
    <link href="http://www.fashionkillyou.xyz/2018/03/02/%E4%BD%BF%E7%94%A8formfill-js%E5%BF%AB%E9%80%9F%E5%A1%AB%E5%85%85%E8%A1%A8%E5%8D%95/"/>
    <id>http://www.fashionkillyou.xyz/2018/03/02/使用formfill-js快速填充表单/</id>
    <published>2018-03-02T13:26:17.000Z</published>
    <updated>2018-03-02T16:12:15.573Z</updated>
    
    <content type="html"><![CDATA[<script src="\assets\js\APlayer.min.js"> </script><h1 id="form表单的快速回显"><a href="#form表单的快速回显" class="headerlink" title="form表单的快速回显"></a>form表单的快速回显</h1><p>做项目开发的时候在写修改的页面时,如果字段很多的话,数据回显塞值挺麻烦的,所以最近找了一个formfill.js快速填充表单的js</p><p>使用起来很简单,首先引用js文件<br><a id="more"></a><br>百度云盘下载:</p><p>链接：<a href="https://pan.baidu.com/s/1mjSDRtA" target="_blank" rel="noopener">https://pan.baidu.com/s/1mjSDRtA</a></p><p>密码：5ljt</p><pre><code>&lt;script src=&quot;../js/jquery.formautofill.js&quot;&gt;&lt;/script&gt;</code></pre><p>使用:</p><pre><code>var data = {&quot;name&quot;:&quot;haha&quot;,&quot;password&quot;:&quot;123&quot;}$(&quot;#formId&quot;).autofill(data);</code></pre><h1 id="英文解释"><a href="#英文解释" class="headerlink" title="英文解释:"></a>英文解释:</h1><h1 id="jQuery-form-autofill"><a href="#jQuery-form-autofill" class="headerlink" title="jQuery form autofill"></a>jQuery form autofill</h1><p>jQuery plugin to simply autofill an empty form with data.</p><h2 id="Documentation"><a href="#Documentation" class="headerlink" title="Documentation"></a>Documentation</h2><p><a href="http://labs.creative-area.net/jquery.formautofill/doc/" target="_blank" rel="noopener">See complete documentation and demo</a></p><h2 id="Usage"><a href="#Usage" class="headerlink" title="Usage"></a>Usage</h2><p>You have a <strong>form</strong></p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">form</span> <span class="attr">id</span>=<span class="string">"f"</span>&gt;</span></span><br><span class="line">    name <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"text"</span> <span class="attr">name</span>=<span class="string">"name"</span>&gt;</span></span><br><span class="line">    email <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"text"</span> <span class="attr">name</span>=<span class="string">"email"</span>&gt;</span></span><br><span class="line">    love jQuery</span><br><span class="line">    <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"radio"</span> <span class="attr">name</span>=<span class="string">"lovejquery"</span> <span class="attr">value</span>=<span class="string">"yes"</span>&gt;</span> yes</span><br><span class="line">    <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"radio"</span> <span class="attr">name</span>=<span class="string">"lovejquery"</span> <span class="attr">value</span>=<span class="string">"no"</span>&gt;</span> no</span><br><span class="line"><span class="tag">&lt;/<span class="name">form</span>&gt;</span></span><br></pre></td></tr></table></figure><p>And <strong>data</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> data = &#123;</span><br><span class="line">    <span class="string">"name"</span>: <span class="string">"John Doe"</span>,</span><br><span class="line">    <span class="string">"email"</span>: <span class="string">"johndoe@mail.com"</span>,</span><br><span class="line">    <span class="string">"lovejquery"</span>: <span class="string">"yes"</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>Autofill</strong> the form with data ? just do</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$(<span class="string">"#f"</span>).autofill( data );</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;form表单的快速回显&quot;&gt;&lt;a href=&quot;#form表单的快速回显&quot; class=&quot;headerlink&quot; title=&quot;form表单的快速回显&quot;&gt;&lt;/a&gt;form表单的快速回显&lt;/h1&gt;&lt;p&gt;做项目开发的时候在写修改的页面时,如果字段很多的话,数据回显塞值挺麻烦的,所以最近找了一个formfill.js快速填充表单的js&lt;/p&gt;
&lt;p&gt;使用起来很简单,首先引用js文件&lt;br&gt;
    
    </summary>
    
      <category term="前端" scheme="http://www.fashionkillyou.xyz/categories/%E5%89%8D%E7%AB%AF/"/>
    
    
      <category term="jquery" scheme="http://www.fashionkillyou.xyz/tags/jquery/"/>
    
      <category term="formautofill" scheme="http://www.fashionkillyou.xyz/tags/formautofill/"/>
    
  </entry>
  
  <entry>
    <title>SpringMVC架构入门二</title>
    <link href="http://www.fashionkillyou.xyz/2018/03/01/SpringMVC%E6%9E%B6%E6%9E%84%E5%85%A5%E9%97%A8%E4%BA%8C/"/>
    <id>http://www.fashionkillyou.xyz/2018/03/01/SpringMVC架构入门二/</id>
    <published>2018-02-28T16:10:20.000Z</published>
    <updated>2018-03-16T04:01:45.057Z</updated>
    
    <content type="html"><![CDATA[<script src="\assets\js\APlayer.min.js"> </script><h1 id="高级参数绑定"><a href="#高级参数绑定" class="headerlink" title="高级参数绑定"></a>高级参数绑定</h1><h2 id="绑定数组"><a href="#绑定数组" class="headerlink" title="绑定数组"></a>绑定数组</h2><p>Controller方法中可以用String[]接收，或者pojo的String[]属性接收。两种方式任选其一即可。<br><a id="more"></a><br>使用String[]:</p><pre><code>@RequestMapping(&quot;/queryitem&quot;)public String queryItem(Query queryVo, String[] ids) {    System.out.println(queryVo.getItems().getName());    System.out.println(queryVo.getItems().getPrice());    System.out.println(ids.toString());    return null;}</code></pre><p>pojo的String[]:</p><pre><code>public class Query{    private Items items;    private String[] ids;    get/set...}</code></pre><h2 id="将表单的数据绑定到List"><a href="#将表单的数据绑定到List" class="headerlink" title="将表单的数据绑定到List"></a>将表单的数据绑定到List</h2><p>List中存放对象，并将定义的List放在包装类中，使用包装pojo对象接收。</p><pre><code>public class Query{    private Items items;    private String[] ids;    private List&lt;Items&gt; itemList;    get/set...}</code></pre><p>jsp页面:</p><pre><code>&lt;tr&gt;    &lt;td&gt;        &lt;input type=&quot;text&quot; name=&quot; itemsList[0].id&quot; value=&quot;${item.id}&quot;/&gt;    &lt;/td&gt;    &lt;td&gt;        &lt;input type=&quot;text&quot; name=&quot; itemsList[0].name&quot; value=&quot;${item.name }&quot;/&gt;    &lt;/td&gt;    &lt;td&gt;        &lt;input type=&quot;text&quot; name=&quot; itemsList[0].price&quot; value=&quot;${item.price}&quot;/&gt;    &lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;    &lt;td&gt;        &lt;input type=&quot;text&quot; name=&quot; itemsList[1].id&quot; value=&quot;${item.id}&quot;/&gt;    &lt;/td&gt;    &lt;td&gt;        &lt;input type=&quot;text&quot; name=&quot; itemsList[1].name&quot; value=&quot;${item.name }&quot;/&gt;    &lt;/td&gt;    &lt;td&gt;        &lt;input type=&quot;text&quot; name=&quot; itemsList[1].price&quot; value=&quot;${item.price}&quot;/&gt;    &lt;/td&gt;&lt;/tr&gt;</code></pre><p>Name属性必须是包装pojo的list属性+下标+元素属性。</p><p>Jsp做如下改造：</p><pre><code>&lt;c:forEach items=&quot;${itemList }&quot; var=&quot;item&quot;&gt;&lt;tr&gt;    &lt;td&gt;        &lt;input name=&quot;ids&quot; value=&quot;${item.id}&quot; type=&quot;checkbox&quot;&gt;&lt;/td&gt;    &lt;td&gt;        &lt;input name=&quot;id&quot; value=&quot;${item.id}&quot; type=&quot;hidden&quot;&gt;        &lt;input name=&quot;name&quot; value=&quot;${item.name }&quot; type=&quot;text&quot;&gt;    &lt;/td&gt;    &lt;td&gt;        &lt;input name=&quot;name&quot; value=&quot;${item.price }&quot; type=&quot;text&quot;&gt;&lt;/td&gt;    &lt;td&gt;        &lt;input name=&quot;name&quot; value=&quot;&lt;fmt:formatDate value=&quot;${item.createtime}&quot; pattern=&quot;yyyy-MM-dd HH:mm:ss&quot;/&gt;&quot; type=&quot;text&quot;&gt;&lt;/td&gt;    &lt;td&gt;        &lt;input name=&quot;name&quot; value=&quot;${item.detail }&quot; type=&quot;text&quot;&gt;&lt;/td&gt;    &lt;td&gt;        &lt;a href=&quot;${pageContext.request.contextPath }/itemEdit.action?id=${item.id}&quot;&gt;修改&lt;/a&gt;    &lt;/td&gt;&lt;/tr&gt;&lt;/c:forEach&gt;</code></pre><p>varStatus属性常用参数总结下：</p><pre><code>${status.index}      输出行号，从0开始。${status.count}      输出行号，从1开始。${status.current}   当前这次迭代的（集合中的）项${status.first}  判断当前项是否为集合中的第一项，返回值为true或false${status.last}   判断当前项是否为集合中的最后一项，返回值为true或falsebegin、end、step分别表示：起始序号，结束序号，跳跃步伐。</code></pre><p>Contrller</p><pre><code>@RequestMapping(&quot;/queryitem&quot;)public String queryItem(QueryVo queryVo, String[] ids) {    System.out.println(queryVo.getItems().getName());    System.out.println(queryVo.getItems().getPrice());    System.out.println(ids.toString());    return null;}</code></pre><p>注意：接收List类型的数据必须是pojo的属性，方法的形参为List类型无法正确接收到数据。</p><h1 id="RequestMapping"><a href="#RequestMapping" class="headerlink" title="@RequestMapping"></a>@RequestMapping</h1><p>通过RequestMapping注解可以定义不同的处理器映射规则。</p><h2 id="URL路径映射"><a href="#URL路径映射" class="headerlink" title="URL路径映射"></a>URL路径映射</h2><p>@RequestMapping(value=”/item”)或@RequestMapping(“/item）<br>value的值是数组，可以将多个url映射到同一个方法</p><h2 id="窄化请求映射"><a href="#窄化请求映射" class="headerlink" title="窄化请求映射"></a>窄化请求映射</h2><p>在class上添加@RequestMapping(url)指定通用请求前缀， 限制此类下的所有方法请求url必须以请求前缀开头，通过此方法对url进行分类管理。</p><p>如下：</p><pre><code>@RequestMapping放在类名上边，设置请求前缀 @Controller@RequestMapping(&quot;/item&quot;)</code></pre><p>方法名上边设置请求映射url：</p><pre><code>@RequestMapping放在方法名上边，如下：@RequestMapping(&quot;/queryItem &quot;)</code></pre><p>访问地址为：/item/queryItem</p><h2 id="请求方法限定"><a href="#请求方法限定" class="headerlink" title="请求方法限定"></a>请求方法限定</h2><h3 id="限定GET方法"><a href="#限定GET方法" class="headerlink" title="限定GET方法"></a>限定GET方法</h3><pre><code>@RequestMapping(method = RequestMethod.GET)</code></pre><p>如果通过Post访问则报错：<br>HTTP Status 405 - Request method ‘POST’ not supported</p><p>例如：</p><pre><code>@RequestMapping(value=&quot;/editItem&quot;,method=RequestMethod.GET)</code></pre><h3 id="限定POST方法"><a href="#限定POST方法" class="headerlink" title="限定POST方法"></a>限定POST方法</h3><pre><code>@RequestMapping(method = RequestMethod.POST)</code></pre><p>如果通过Post访问则报错：<br>HTTP Status 405 - Request method ‘GET’ not supported</p><h3 id="GET和POST都可以"><a href="#GET和POST都可以" class="headerlink" title="GET和POST都可以"></a>GET和POST都可以</h3><pre><code>@RequestMapping(method={RequestMethod.GET,RequestMethod.POST})</code></pre><h1 id="controller方法返回值"><a href="#controller方法返回值" class="headerlink" title="controller方法返回值"></a>controller方法返回值</h1><h2 id="返回ModelAndView"><a href="#返回ModelAndView" class="headerlink" title="返回ModelAndView"></a>返回ModelAndView</h2><p>controller方法中定义ModelAndView对象并返回，对象中可添加model数据、指定view。</p><h2 id="返回void"><a href="#返回void" class="headerlink" title="返回void"></a>返回void</h2><p>在controller方法形参上可以定义request和response，使用request或response指定响应结果：</p><p>1、使用request转向页面，如下：</p><pre><code>request.getRequestDispatcher(&quot;页面路径&quot;).forward(request, response);</code></pre><p>2、也可以通过response页面重定向：</p><pre><code>response.sendRedirect(&quot;url&quot;)</code></pre><p>3、也可以通过response指定响应结果，例如响应json数据如下：</p><pre><code>response.setCharacterEncoding(&quot;utf-8&quot;);response.setContentType(&quot;application/json;charset=utf-8&quot;);response.getWriter().write(&quot;json串&quot;);</code></pre><h2 id="返回字符串"><a href="#返回字符串" class="headerlink" title="返回字符串"></a>返回字符串</h2><h3 id="逻辑视图名"><a href="#逻辑视图名" class="headerlink" title="逻辑视图名"></a>逻辑视图名</h3><p>controller方法返回字符串可以指定逻辑视图名，通过视图解析器解析为物理视图地址。</p><pre><code>//指定逻辑视图名，经过视图解析器解析为jsp物理路径：/WEB-INF/jsp/item/editItem.jspreturn &quot;item/editItem&quot;;</code></pre><h3 id="Redirect重定向"><a href="#Redirect重定向" class="headerlink" title="Redirect重定向"></a>Redirect重定向</h3><p>Contrller方法返回结果重定向到一个url地址，如下商品修改提交后重定向到商品查询方法，参数无法带到商品查询方法中。</p><pre><code>//重定向到queryItem.action地址,request无法带过去return &quot;redirect:queryItem.action&quot;;</code></pre><p>redirect方式相当于“response.sendRedirect()”，转发后浏览器的地址栏变为转发后的地址，因为转发即执行了一个新的request和response。<br>由于新发起一个request原来的参数在转发时就不能传递到下一个url，如果要传参数可以/item/queryItem.action后边加参数，如下：</p><pre><code>/item/queryItem?...&amp;…..</code></pre><p>如果使用了model的话,他会自动给你拼接数据,就是自动在后面拼接?</p><h3 id="forward转发"><a href="#forward转发" class="headerlink" title="forward转发"></a>forward转发</h3><p>controller方法执行后继续执行另一个controller方法，如下商品修改提交后转向到商品修改页面，修改商品的id参数可以带到商品修改方法中。</p><pre><code>//结果转发到editItem.action，request可以带过去return &quot;forward:editItem.action&quot;;</code></pre><p>forward方式相当于“request.getRequestDispatcher().forward(request,response)”，转发后浏览器地址栏还是原来的地址。转发并没有执行新的request和response，而是和转发前的请求共用一个request和response。所以转发前请求的参数在转发后仍然可以读取到。</p><h1 id="异常处理器"><a href="#异常处理器" class="headerlink" title="异常处理器"></a>异常处理器</h1><p>springmvc在处理请求过程中出现异常信息交由异常处理器进行处理，自定义异常处理器可以实现一个系统的异常处理逻辑。</p><h2 id="异常处理思路"><a href="#异常处理思路" class="headerlink" title="异常处理思路"></a>异常处理思路</h2><p>系统中异常包括两类：预期异常和运行时异常RuntimeException，前者通过捕获异常从而获取异常信息，后者主要通过规范代码开发、测试通过手段减少运行时异常的发生。</p><p>系统的dao、service、controller出现都通过throws Exception向上抛出，最后由springmvc前端控制器交由异常处理器进行异常处理</p><p>步骤:写异常处理器类,然后在springmvc.xml中配置,然后写异常错误页面</p><h2 id="自定义异常处理器"><a href="#自定义异常处理器" class="headerlink" title="自定义异常处理器"></a>自定义异常处理器</h2><pre><code>public class CustomExceptionResolver implements HandlerExceptionResolver {    @Override    public ModelAndView resolveException(HttpServletRequest request,            HttpServletResponse response, Object handler, Exception ex) {        ex.printStackTrace();        CustomException customException = null;        //如果抛出的是系统自定义异常则直接转换        if(ex instanceof CustomException){            customException = (CustomException)ex;        }else{            //如果抛出的不是系统自定义异常则重新构造一个系统错误异常。            customException = new CustomException(&quot;系统错误，请与系统管理 员联系！&quot;);        }        ModelAndView modelAndView = new ModelAndView();        modelAndView.addObject(&quot;message&quot;, customException.getMessage());        modelAndView.setViewName(&quot;error&quot;);        return modelAndView;    }}</code></pre><p>###取异常堆栈：</p><pre><code>//错误信息存储在堆栈中,取异常堆栈将其显示在控制台上,或输出到日志文件中       try {        } catch (Exception e) {            StringWriter s = new StringWriter();            PrintWriter printWriter = new PrintWriter(s);            e.printStackTrace(printWriter);            s.toString();        }</code></pre><h2 id="错误页面"><a href="#错误页面" class="headerlink" title="错误页面"></a>错误页面</h2><pre><code>&lt;%@ page language=&quot;java&quot; contentType=&quot;text/html; charset=UTF-8&quot;    pageEncoding=&quot;UTF-8&quot;%&gt;&lt;%@ taglib uri=&quot;http://java.sun.com/jsp/jstl/core&quot; prefix=&quot;c&quot; %&gt;&lt;%@ taglib uri=&quot;http://java.sun.com/jsp/jstl/fmt&quot;  prefix=&quot;fmt&quot;%&gt; &lt;!DOCTYPE html PUBLIC &quot;-//W3C//DTD HTML 4.01 Transitional//EN&quot; &quot;http://www.w3.org/TR/html4/loose.dtd&quot;&gt;&lt;html&gt;&lt;head&gt;&lt;meta http-equiv=&quot;Content-Type&quot; content=&quot;text/html; charset=UTF-8&quot;&gt;&lt;title&gt;错误页面&lt;/title&gt;&lt;/head&gt;&lt;body&gt;您的操作出现错误如下：&lt;br/&gt;${message }&lt;/body&gt;&lt;/html&gt;</code></pre><h2 id="异常处理器配置"><a href="#异常处理器配置" class="headerlink" title="异常处理器配置"></a>异常处理器配置</h2><p>在springmvc.xml中添加：</p><pre><code>&lt;!-- 全局异常处理器 --&gt;&lt;bean class=&quot;com.lxm.springmvc.exception.GlobalExceptionResolver&quot;/&gt;</code></pre><h2 id="测试异常"><a href="#测试异常" class="headerlink" title="测试异常"></a>测试异常</h2><p>在需要抛出异常的地方加上throw new CustomerException(“出错信息”);然后方法上向上抛出就可以了</p><pre><code>@RequestMapping(&quot;/itemEdit&quot;)public String getEditItem(@RequestParam(value=&quot;id&quot;,required=true)Integer id,Model model) throws CustomerException{    Items items = itemService.getItemById(id);    if(items == null){        throw new CustomerException(&quot;商品信息不存在!&quot;);    }    model.addAttribute(&quot;item&quot;,items);    return &quot;editItem&quot;;}</code></pre><h1 id="上传图片"><a href="#上传图片" class="headerlink" title="上传图片"></a>上传图片</h1><h2 id="配置虚拟目录"><a href="#配置虚拟目录" class="headerlink" title="配置虚拟目录"></a>配置虚拟目录</h2><p>在tomcat上配置图片虚拟目录，在tomcat下conf/server.xml中添加：</p><pre><code>&lt;Context docBase=&quot;F:\develop\upload\temp&quot; path=&quot;/pic&quot; reloadable=&quot;false&quot;/&gt;</code></pre><p>访问<a href="http://localhost:8080/pic即可访问F:\develop\upload\temp下的图片。" target="_blank" rel="noopener">http://localhost:8080/pic即可访问F:\develop\upload\temp下的图片。</a></p><p>也可以通过eclipse配置：</p><p>1:在tomcat服务配置里面有个modules,<br>点击AddExternalWebModule</p><p>2:然后在Documentbase里面填写虚拟路径的绝对路径(例如:F:\develop\upload\temp),</p><p>3:在Path里面填写虚拟路径(例如:/pic)</p><p>4:AutoReload(这个根据需要自行设定,以下是作用,一般设置为disabled就可以)</p><pre><code>在eclipse中集成tomca来开发时,如果使用run as模式启动项目的话,tomcat配置Auto reloading enabled,我们修改java文件,项目会重新加载,修改的内容会生效.如果使用debug as 模式启动项目的话,tomcat不要配置Auto reloading enabled,我们修改的java文件,也会生效.注意:在debug模式下,tomcat配置了Auto reloading enabled,当修改了java文件,项目会报错.</code></pre><h2 id="jar包"><a href="#jar包" class="headerlink" title="jar包"></a>jar包</h2><p>CommonsMultipartResolver解析器依赖:</p><pre><code>commons-fileuploadcommons-io</code></pre><h2 id="配置解析器"><a href="#配置解析器" class="headerlink" title="配置解析器"></a>配置解析器</h2><p>springmvc.xml</p><pre><code>&lt;!-- 文件上传 --&gt;&lt;bean id=&quot;multipartResolver&quot;    class=&quot;org.springframework.web.multipart.commons.CommonsMultipartResolver&quot;&gt;    &lt;!-- 设置上传文件的最大尺寸为5MB --&gt;    &lt;property name=&quot;maxUploadSize&quot;&gt;        &lt;value&gt;5242880&lt;/value&gt;    &lt;/property&gt;&lt;/bean&gt;</code></pre><h2 id="图片上传"><a href="#图片上传" class="headerlink" title="图片上传"></a>图片上传</h2><p>controller：</p><pre><code>@RequestMapping(&quot;/updateitem&quot;)public String updateItem(Items items,MultipartFile pictureFile) throws Exception, IOException{    //把图片保存到图片目录下    //为每个文件生成一个新的文件名    String picName = UUID.randomUUID().toString();    //去文件的扩展名    String oriName = pictureFile.getOriginalFilename();    System.out.println(&quot;oriName&quot;+oriName);    if(oriName!=null &amp;&amp; oriName!=&quot;&quot;){        String extName = oriName.substring(oriName.lastIndexOf(&quot;.&quot;));        System.out.println(&quot;extName&quot;+extName);        //保存文件 d:\picture\temp        pictureFile.transferTo(new File(&quot;d:\\picture\\temp\\&quot;+picName+extName));        //把文件名保存到数据库        items.setPic(picName+extName);    }    itemService.updateItem(items);//        return &quot;forward:/itemList.action?items=&quot;+items;//转发是可以传递对象的    return &quot;forward:/itemList.action&quot;;}</code></pre><h2 id="页面："><a href="#页面：" class="headerlink" title="页面："></a>页面：</h2><pre><code>form添加enctype=&quot;multipart/form-data&quot;：&lt;form id=&quot;itemForm&quot;action=&quot;${pageContext.request.contextPath }/item/editItemSubmit.action&quot;    method=&quot;post&quot; enctype=&quot;multipart/form-data&quot;&gt;    &lt;input type=&quot;hidden&quot; name=&quot;pic&quot; value=&quot;${item.pic }&quot; /&gt;file的name与controller形参一致：&lt;tr&gt;    &lt;td&gt;商品图片&lt;/td&gt;    &lt;td&gt;&lt;c:if test=&quot;${item.pic !=null}&quot;&gt;            &lt;img src=&quot;/pic/${item.pic}&quot; width=100 height=100 /&gt;            &lt;br /&gt;        &lt;/c:if&gt; &lt;input type=&quot;file&quot; name=&quot;pictureFile&quot; /&gt;&lt;/td&gt;&lt;/tr&gt;</code></pre><h1 id="json数据交互"><a href="#json数据交互" class="headerlink" title="json数据交互"></a>json数据交互</h1><h2 id="RequestBody"><a href="#RequestBody" class="headerlink" title="@RequestBody"></a>@RequestBody</h2><p>作用：</p><p>@RequestBody注解用于读取http请求的内容(字符串)，通过springmvc提供的HttpMessageConverter接口将读到的内容转换为json、xml等格式的数据并绑定到controller方法的参数上。</p><p>List.action?id=1&amp;name=zhangsan&amp;age=12</p><p>本例子应用：</p><p>@RequestBody注解实现接收http请求的json数据，将json数据转换为java对象</p><h2 id="ResponseBody"><a href="#ResponseBody" class="headerlink" title="@ResponseBody"></a>@ResponseBody</h2><p>作用：</p><p>该注解用于将Controller的方法返回的对象，通过HttpMessageConverter接口转换为指定格式的数据如：json,xml等，通过Response响应给客户端</p><p>本例子应用：</p><p>@ResponseBody注解实现将controller方法返回对象转换为json响应给客户端</p><h2 id="请求json，响应json实现："><a href="#请求json，响应json实现：" class="headerlink" title="请求json，响应json实现："></a>请求json，响应json实现：</h2><h3 id="环境准备"><a href="#环境准备" class="headerlink" title="环境准备"></a>环境准备</h3><p>Springmvc默认用MappingJacksonHttpMessageConverter对json数据进行转换，需要加入jackson的包，</p><pre><code>jackson-annotations-2.4.0.jarjackson-core-2.4.2.jarjackson-databind-2.4.2.jar</code></pre><h3 id="配置json转换器"><a href="#配置json转换器" class="headerlink" title="配置json转换器"></a>配置json转换器</h3><p>在注解适配器中加入messageConverters</p><pre><code>&lt;!--注解适配器 --&gt;&lt;bean class=&quot;org.springframework.web.servlet.mvc.method.annotation.RequestMappingHandlerAdapter&quot;&gt;    &lt;property name=&quot;messageConverters&quot;&gt;    &lt;list&gt;    &lt;bean class=&quot;org.springframework.http.converter.json.MappingJacksonHttpMessageConverter&quot;&gt;&lt;/bean&gt;    &lt;/list&gt;    &lt;/property&gt;&lt;/bean&gt;</code></pre><p>注意：如果使用<mvc:annotation-driven> 则不用定义上边的内容。</mvc:annotation-driven></p><h3 id="controller编写"><a href="#controller编写" class="headerlink" title="controller编写"></a>controller编写</h3><pre><code>// 商品修改提交json信息，响应json信息@RequestMapping(&quot;/editItemSubmit_RequestJson&quot;)public @ResponseBody Items editItemSubmit_RequestJson(@RequestBody Items items) throws Exception {    System.out.println(items);    //itemService.saveItem(items);    return items;}</code></pre><h3 id="页面js方法编写："><a href="#页面js方法编写：" class="headerlink" title="页面js方法编写："></a>页面js方法编写：</h3><p>引入 js：<br>    <script type="text/javascript" src="${pageContext.request.contextPath }/js/jquery-1.4.4.min.js"></script></p><pre><code>//请求json响应jsonfunction request_json(){    $.ajax({        type:&quot;post&quot;,        url:&quot;${pageContext.request.contextPath }/item/editItemSubmit_RequestJson.action&quot;,        contentType:&quot;application/json;charset=utf-8&quot;,        data:&apos;{&quot;name&quot;:&quot;测试商品&quot;,&quot;price&quot;:99.9}&apos;,        success:function(data){            alert(data);        }    });}</code></pre>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;高级参数绑定&quot;&gt;&lt;a href=&quot;#高级参数绑定&quot; class=&quot;headerlink&quot; title=&quot;高级参数绑定&quot;&gt;&lt;/a&gt;高级参数绑定&lt;/h1&gt;&lt;h2 id=&quot;绑定数组&quot;&gt;&lt;a href=&quot;#绑定数组&quot; class=&quot;headerlink&quot; title=&quot;绑定数组&quot;&gt;&lt;/a&gt;绑定数组&lt;/h2&gt;&lt;p&gt;Controller方法中可以用String[]接收，或者pojo的String[]属性接收。两种方式任选其一即可。&lt;br&gt;
    
    </summary>
    
      <category term="SSM" scheme="http://www.fashionkillyou.xyz/categories/SSM/"/>
    
    
      <category term="SpringMVC" scheme="http://www.fashionkillyou.xyz/tags/SpringMVC/"/>
    
      <category term="SpringWebMVC" scheme="http://www.fashionkillyou.xyz/tags/SpringWebMVC/"/>
    
  </entry>
  
  <entry>
    <title>SpringMVC架构入门一</title>
    <link href="http://www.fashionkillyou.xyz/2018/02/27/SpringMVC%E6%9E%B6%E6%9E%84%E5%85%A5%E9%97%A8%E4%B8%80/"/>
    <id>http://www.fashionkillyou.xyz/2018/02/27/SpringMVC架构入门一/</id>
    <published>2018-02-27T10:58:33.000Z</published>
    <updated>2018-03-30T08:23:06.798Z</updated>
    
    <content type="html"><![CDATA[<script src="\assets\js\APlayer.min.js"> </script><h1 id="SpringMVC架构"><a href="#SpringMVC架构" class="headerlink" title="SpringMVC架构"></a>SpringMVC架构</h1><p>Spring web mvc和Struts2都属于表现层的框架,它是Spring框架的一部分.</p><h2 id="架构流程"><a href="#架构流程" class="headerlink" title="架构流程"></a>架构流程</h2><pre><code>1、    用户发送请求至前端控制器DispatcherServlet2、    DispatcherServlet收到请求调用HandlerMapping处理器映射器。3、    处理器映射器根据请求url找到具体的处理器，生成处理器对象及处理器拦截器(如果有则生成)一并返回给DispatcherServlet。4、    DispatcherServlet通过HandlerAdapter处理器适配器调用处理器5、    执行处理器(Controller，也叫后端控制器)。6、    Controller执行完成返回ModelAndView7、    HandlerAdapter将controller执行结果ModelAndView返回给DispatcherServlet8、    DispatcherServlet将ModelAndView传给ViewReslover视图解析器9、    ViewReslover解析后返回具体View10、    DispatcherServlet对View进行渲染视图（即将模型数据填充至视图中）。11、    DispatcherServlet响应用户</code></pre><a id="more"></a><p><img src="http://p57l8frp4.bkt.clouddn.com/springmvc%E6%89%A7%E8%A1%8C%E6%B5%81%E7%A8%8B%E5%9B%BE2.jpg" alt=""></p><h2 id="组件说明"><a href="#组件说明" class="headerlink" title="组件说明"></a>组件说明</h2><p>以下组件通常使用框架提供实现：</p><ul><li><p>DispatcherServlet：前端控制器</p><p>  用户请求到达前端控制器，它就相当于mvc模式中的c，dispatcherServlet是整个流程控制的中心，由它调用其它组件处理用户的请求，dispatcherServlet的存在降低了组件之间的耦合性。</p></li><li><p>HandlerMapping：处理器映射器</p><p>  HandlerMapping负责根据用户请求找到Handler即处理器，springmvc提供了不同的映射器实现不同的映射方式，例如：配置文件方式，实现接口方式，注解方式等。</p></li><li><p>Handler：处理器</p><p>  Handler 是继DispatcherServlet前端控制器的后端控制器，在DispatcherServlet的控制下Handler对具体的用户请求进行处理。<br>  由于Handler涉及到具体的用户业务请求，所以一般情况需要程序员根据业务需求开发Handler。</p></li><li><p>HandlAdapter：处理器适配器</p><p>  通过HandlerAdapter对处理器进行执行，这是适配器模式的应用，通过扩展适配器可以对更多类型的处理器进行执行。</p></li><li><p>View Resolver：视图解析器</p><p>  View Resolver负责将处理结果生成View视图，View Resolver首先根据逻辑视图名解析成物理视图名即具体的页面地址，再生成View视图对象，最后对View进行渲染将处理结果通过页面展示给用户。 </p></li><li><p>View：视图</p><p>  springmvc框架提供了很多的View视图类型的支持，包括：jstlView、freemarkerView、pdfView等。我们最常用的视图就是jsp。<br>  一般情况下需要通过页面标签或页面模版技术将模型数据通过页面展示给用户，需要由程序员根据业务需求开发具体的页面。</p></li></ul><p>说明：在springmvc的各个组件中，<strong>处理器映射器</strong>、<strong>处理器适配器</strong>、<strong>视图解析器</strong>称为springmvc的三大组件。</p><p>需要用户开放的组件有<strong>handler、view</strong></p><h2 id="注解映射器和适配器"><a href="#注解映射器和适配器" class="headerlink" title="注解映射器和适配器"></a>注解映射器和适配器</h2><h3 id="组件扫描器"><a href="#组件扫描器" class="headerlink" title="组件扫描器"></a>组件扫描器</h3><p>使用组件扫描器省去在spring容器配置每个controller类的繁琐。使用<context:component-scan>自动扫描标记@controller的控制器类，配置如下：</context:component-scan></p><pre><code>&lt;!-- 扫描controller注解,多个包中间使用半角逗号分隔 --&gt;&lt;context:component-scan base-package=&quot;cn.lxm.springmvc.controller.first&quot;/&gt;</code></pre><h3 id="RequestMappingHandlerMapping"><a href="#RequestMappingHandlerMapping" class="headerlink" title="RequestMappingHandlerMapping"></a>RequestMappingHandlerMapping</h3><p>注解式处理器映射器，对类中标记@ResquestMapping的方法进行映射，根据ResquestMapping定义的url匹配ResquestMapping标记的方法，匹配成功返回HandlerMethod对象给前端控制器，HandlerMethod对象中封装url对应的方法Method。 </p><p>从spring3.1版本开始，废除了DefaultAnnotationHandlerMapping的使用，推荐使用RequestMappingHandlerMapping完成注解式处理器映射。</p><p>配置如下：</p><pre><code>&lt;!--注解映射器 --&gt;&lt;bean class=&quot;org.springframework.web.servlet.mvc.method.annotation.RequestMappingHandlerMapping&quot;/&gt;</code></pre><p>注解描述：<br>@RequestMapping：定义请求url到处理器功能方法的映射</p><h3 id="RequestMappingHandlerAdapter"><a href="#RequestMappingHandlerAdapter" class="headerlink" title="RequestMappingHandlerAdapter"></a>RequestMappingHandlerAdapter</h3><p>注解式处理器适配器，对标记@ResquestMapping的方法进行适配。</p><p>从spring3.1版本开始，废除了AnnotationMethodHandlerAdapter的使用，推荐使用RequestMappingHandlerAdapter完成注解式处理器适配。</p><p>配置如下：</p><pre><code>&lt;!--注解适配器 --&gt;&lt;bean class=&quot;org.springframework.web.servlet.mvc.method.annotation.RequestMappingHandlerAdapter&quot;/&gt;</code></pre><h3 id=""><a href="#" class="headerlink" title=""></a><mvc:annotation-driven></mvc:annotation-driven></h3><p>springmvc使用<mvc:annotation-driven>自动加载RequestMappingHandlerMapping和RequestMappingHandlerAdapter，可用在springmvc.xml配置文件中使用<mvc:annotation-driven>替代注解处理器和适配器的配置。</mvc:annotation-driven></mvc:annotation-driven></p><h2 id="视图解析器"><a href="#视图解析器" class="headerlink" title="视图解析器"></a>视图解析器</h2><p>在springmvc.xml文件配置如下：</p><pre><code>&lt;bean class=&quot;org.springframework.web.servlet.view.InternalResourceViewResolver&quot;&gt;    &lt;property name=&quot;viewClass&quot;        value=&quot;org.springframework.web.servlet.view.JstlView&quot; /&gt;    &lt;property name=&quot;prefix&quot; value=&quot;/WEB-INF/jsp/&quot; /&gt;    &lt;property name=&quot;suffix&quot; value=&quot;.jsp&quot; /&gt;&lt;/bean&gt;</code></pre><p>InternalResourceViewResolver：支持JSP视图解析</p><p>viewClass：JstlView表示JSP模板页面需要使用JSTL标签库，所以classpath中必须包含jstl的相关jar 包。此属性可以不设置，默认为JstlView。</p><p>prefix 和suffix：查找视图页面的前缀和后缀，最终视图的地址为：<br>前缀+逻辑视图名+后缀，逻辑视图名需要在controller中返回ModelAndView指定，比如逻辑视图名为hello，则最终返回的jsp视图地址 “WEB-INF/jsp/hello.jsp”</p><h1 id="整合mybatis"><a href="#整合mybatis" class="headerlink" title="整合mybatis"></a>整合mybatis</h1><p>ssm框架:springmvc + spring + mybatis</p><p>控制层采用springmvc、持久层使用mybatis实现。</p><h2 id="准备jar包"><a href="#准备jar包" class="headerlink" title="准备jar包"></a>准备jar包</h2><p>spring（包括springmvc）、mybatis、mybatis-spring整合包、数据库驱动、第三方连接池。</p><h2 id="整合思路"><a href="#整合思路" class="headerlink" title="整合思路"></a>整合思路</h2><h3 id="Dao层："><a href="#Dao层：" class="headerlink" title="Dao层："></a>Dao层：</h3><p>1、SqlMapConfig.xml</p><pre><code>空文件即可。需要文件头。</code></pre><p>2、applicationContext-dao.xml。</p><pre><code>a)    数据库连接池b)    SqlSessionFactory对象，需要spring和mybatis整合包下的。c)    配置mapper文件扫描器。</code></pre><h3 id="Service层："><a href="#Service层：" class="headerlink" title="Service层："></a>Service层：</h3><p>1、applicationContext-service.xml</p><pre><code>包扫描器，扫描@service注解的类。</code></pre><p>2、applicationContext-trans.xml</p><pre><code>配置事务。</code></pre><h3 id="表现层："><a href="#表现层：" class="headerlink" title="表现层："></a>表现层：</h3><p>Springmvc.xml</p><pre><code>1、包扫描器，扫描@Controller注解的类。2、配置注解驱动。3、视图解析器</code></pre><p>Web.xml</p><pre><code>配置前端控制器。</code></pre><h1 id="参数绑定"><a href="#参数绑定" class="headerlink" title="参数绑定"></a>参数绑定</h1><h2 id="Controller参数绑定"><a href="#Controller参数绑定" class="headerlink" title="Controller参数绑定"></a>Controller参数绑定</h2><p>要根据id查询商品数据，需要从请求的参数中把请求的id取出来。Id应该包含在Request对象中。可以从Request对象中取id。</p><pre><code>@RequestMapping(&quot;/itemEdit&quot;)public ModelAndView itemEdit(HttpServletRequest request) {    //从Request中取id    String strId = request.getParameter(&quot;id&quot;);    Integer id = null;    //如果id有值则转换成int类型    if (strId != null &amp;&amp; !&quot;&quot;.equals(strId)) {        id = new Integer(strId);    } else {        //出错        return null;    }    Items items = itemService.getItemById(id);    //创建ModelAndView    ModelAndView modelAndView = new ModelAndView();    //向jsp传递数据    modelAndView.addObject(&quot;item&quot;, items);    //设置跳转的jsp页面    modelAndView.setViewName(&quot;editItem&quot;);    return modelAndView;}</code></pre><p>如果想获得Request对象只需要在Controller方法的形参中添加一个参数即可。Springmvc框架会自动把Request对象传递给方法。</p><h2 id="Service"><a href="#Service" class="headerlink" title="Service"></a>Service</h2><pre><code>@Overridepublic Items getItemById(int id) {    Items items = itemsMapper.selectByPrimaryKey(id);    return items;}</code></pre><h2 id="默认支持的参数类型"><a href="#默认支持的参数类型" class="headerlink" title="默认支持的参数类型"></a>默认支持的参数类型</h2><p>处理器形参中添加如下类型的参数处理适配器会默认识别并进行赋值。</p><h3 id="HttpServletRequest"><a href="#HttpServletRequest" class="headerlink" title="HttpServletRequest"></a>HttpServletRequest</h3><p>通过request对象获取请求信息</p><h3 id="HttpServletResponse"><a href="#HttpServletResponse" class="headerlink" title="HttpServletResponse"></a>HttpServletResponse</h3><p>通过response处理响应信息</p><h3 id="HttpSession"><a href="#HttpSession" class="headerlink" title="HttpSession"></a>HttpSession</h3><p>通过session对象得到session中存放的对象</p><h3 id="Model-ModelMap"><a href="#Model-ModelMap" class="headerlink" title="Model/ModelMap"></a>Model/ModelMap</h3><p>ModelMap是Model接口的实现类，通过Model或ModelMap向页面传递数据，如下：</p><pre><code>//调用service查询商品信息Items item = itemService.findItemById(id);model.addAttribute(&quot;item&quot;, item);</code></pre><p>页面通过${item.XXXX}获取item对象的属性值。</p><p>使用Model和ModelMap的效果一样，如果直接使用Model，springmvc会实例化ModelMap。</p><p>如果使用Model则可以不使用ModelAndView对象，Model对象可以向页面传递数据，View对象则可以使用String返回值替代。不管是Model还是ModelAndView，其本质都是使用Request对象向jsp传递数据。<br>如果使用Model则方法可以改造成：</p><pre><code>@RequestMapping(&quot;/itemEdit&quot;)public String itemEdit(HttpServletRequest request, Model model) {    //从Request中取id    String strId = request.getParameter(&quot;id&quot;);    Integer id = null;    //如果id有值则转换成int类型    if (strId != null &amp;&amp; !&quot;&quot;.equals(strId)) {        id = new Integer(strId);    } else {        //出错        return null;    }    Items items = itemService.getItemById(id);    //创建ModelAndView    //ModelAndView modelAndView = new ModelAndView();    //向jsp传递数据    //modelAndView.addObject(&quot;item&quot;, items);    model.addAttribute(&quot;item&quot;, items);    //设置跳转的jsp页面    //modelAndView.setViewName(&quot;editItem&quot;);    //return modelAndView;    return &quot;editItem&quot;;}</code></pre><h2 id="绑定简单类型"><a href="#绑定简单类型" class="headerlink" title="绑定简单类型"></a>绑定简单类型</h2><p>当请求的参数名称和处理器形参名称一致时会将请求参数与形参进行绑定。从Request取参数的方法可以进一步简化。</p><pre><code>@RequestMapping(&quot;/itemEdit&quot;)public String itemEdit(Integer id, Model model) {    Items items = itemService.getItemById(id);    //向jsp传递数据    model.addAttribute(&quot;item&quot;, items);    //设置跳转的jsp页面    return &quot;editItem&quot;;}</code></pre><h3 id="支持的数据类型"><a href="#支持的数据类型" class="headerlink" title="支持的数据类型"></a>支持的数据类型</h3><p>参数类型推荐使用包装数据类型，因为基础数据类型不可以为null</p><p>整形：Integer、int</p><p>字符串：String</p><p>单精度：Float、float</p><p>双精度：Double、double</p><p>布尔型：Boolean、boolean</p><p>说明：对于布尔类型的参数，请求的参数值为true或false。</p><p>处理器方法：</p><pre><code>public String editItem(Model model,Integer id,Boolean status) throws Exception</code></pre><p>请求url：</p><pre><code>http://localhost:8080/xxx.action?id=2&amp;status=false</code></pre><h3 id="RequestParam"><a href="#RequestParam" class="headerlink" title="@RequestParam"></a>@RequestParam</h3><p>使用@RequestParam常用于处理简单类型的绑定。</p><p>value：参数名字，即入参的请求参数名字，如value=“item_id”表示请求的参数区中的名字为item_id的参数的值将传入；</p><p>required：是否必须，默认是true，表示请求中一定要有相应的参数，否则将报；</p><p>TTP Status 400 - Required Integer parameter ‘XXXX’ is not present</p><p>defaultValue：默认值，表示如果请求中没有同名参数时的默认值</p><p>定义如下：</p><pre><code>public String editItem(@RequestParam(value=&quot;item_id&quot;,required=true) String id) {}</code></pre><p>形参名称为id，但是这里使用value=” item_id”限定请求的参数名为item_id，所以页面传递参数的名必须为item_id。</p><p>注意：如果请求参数中没有item_id将跑出异常：</p><pre><code>HTTP Status 500 - Required Integer parameter &apos;item_id&apos; is not present</code></pre><p>这里通过required=true限定item_id参数为必需传递，如果不传递则报400错误，可以使用defaultvalue设置默认值，即使required=true也可以不传item_id参数值</p><h2 id="绑定pojo类型"><a href="#绑定pojo类型" class="headerlink" title="绑定pojo类型"></a>绑定pojo类型</h2><h3 id="Controller"><a href="#Controller" class="headerlink" title="Controller:"></a>Controller:</h3><pre><code>@RequestMapping(&quot;/updateitem&quot;)public String updateItem(Items items){    itemService.updateItem(items);    return &quot;success&quot;;}</code></pre><h3 id="service"><a href="#service" class="headerlink" title="service"></a>service</h3><pre><code>@Overridepublic void updateItem(Items items) {    //ItemsExample example = new ItemsExample();    //如果example定义了两个字段，数据库共4个字段，则修改数据库的两个字段，其余两个字段改为null    //itemsMapper.updateByExample(items, example);    //成功,但是没有的值置为了null    //itemsMapper.updateByPrimaryKey(items);    //成功,但是没有的值置为了null    //itemsMapper.updateByPrimaryKeyWithBLOBs(items);    //和updateByExample相比此方法可以修改大字段类型，其余性质和updateByExample相同    //itemsMapper.updateByExampleWithBLOBs(items, example);    //如果example定义了两个字段，数据库共4个字段，则修改数据库的两个字段，其余两个字段不动    itemsMapper.updateByPrimaryKeySelective(items);}</code></pre><p>注意：提交的表单中不要有日期类型的数据，否则会报400错误。如果想提交日期类型的数据需要用到后面的自定义参数绑定的内容。</p><h2 id="解决日期参数问题"><a href="#解决日期参数问题" class="headerlink" title="解决日期参数问题:"></a>解决日期参数问题:</h2><h3 id="自定义Converter"><a href="#自定义Converter" class="headerlink" title="自定义Converter"></a>自定义Converter</h3><pre><code>import org.joda.time.DateTime;import org.joda.time.format.DateTimeFormat;import org.joda.time.format.DateTimeFormatter;import org.springframework.core.convert.converter.Converter;import org.springframework.util.StringUtils;import java.util.ArrayList;import java.util.Date;import java.util.List;/** * Created by Rock 2016/12/6. */public class DateConverter implements Converter&lt;String,Date&gt; {private static final List&lt;String&gt; formarts = new ArrayList&lt;&gt;(4);static {    formarts.add(&quot;yyyy-MM&quot;);    formarts.add(&quot;yyyy-MM-dd&quot;);    formarts.add(&quot;yyyy-MM-dd HH:mm&quot;);    formarts.add(&quot;yyyy-MM-dd HH:mm:ss&quot;);}@Overridepublic Date convert(String s) {    if(StringUtils.isEmpty(s)){        return null;    }    try {        String formatter = &quot;&quot;;        if (s.matches(&quot;^\\d{4}-\\d{1,2}$&quot;)) {            formatter = formarts.get(0);        } else if (s.matches(&quot;^\\d{4}-\\d{1,2}-\\d{1,2}$&quot;)) {            formatter = formarts.get(1);        } else if (s.matches(&quot;^\\d{4}-\\d{1,2}-\\d{1,2} {1}\\d{1,2}:\\d{1,2}$&quot;)) {            formatter = formarts.get(2);        } else if (s.matches(&quot;^\\d{4}-\\d{1,2}-\\d{1,2} {1}\\d{1,2}:\\d{1,2}:\\d{1,2}$&quot;)) {            formatter = formarts.get(3);        } else {            throw new IllegalArgumentException(&quot;Invalid boolean value &apos;&quot; + s + &quot;&apos;&quot;);        }        DateFormat dateFormat = new SimpleDateFormat(formatter);        Date date = dateFormat.parse(s);        return date;    } catch (Exception e){        return null;    }}}</code></pre><h3 id="在springmvc-xml里面配置"><a href="#在springmvc-xml里面配置" class="headerlink" title="在springmvc.xml里面配置"></a>在springmvc.xml里面配置</h3><pre><code>&lt;!-- 配置注解驱动，如果配置此标签可以不用配置处理器映射器和适配器  --&gt;&lt;!-- &lt;mvc:annotation-driven /&gt; --&gt;&lt;!-- 加载注解驱动 --&gt;&lt;mvc:annotation-driven conversion-service=&quot;conversionService&quot;/&gt;&lt;!-- 转换器配置 --&gt;&lt;bean id=&quot;conversionService&quot;    class=&quot;org.springframework.format.support.FormattingConversionServiceFactoryBean&quot;&gt;    &lt;property name=&quot;converters&quot;&gt;        &lt;set&gt;            &lt;bean class=&quot;cn.lxm.springmvc.convert.DateConverter&quot;/&gt;        &lt;/set&gt;    &lt;/property&gt;&lt;/bean&gt;</code></pre><h2 id="解决post乱码问题"><a href="#解决post乱码问题" class="headerlink" title="解决post乱码问题"></a>解决post乱码问题</h2><p>在web.xml中加入：</p><pre><code>&lt;filter&gt;    &lt;filter-name&gt;CharacterEncodingFilter&lt;/filter-name&gt;    &lt;filter-class&gt;org.springframework.web.filter.CharacterEncodingFilter&lt;/filter-class&gt;    &lt;init-param&gt;        &lt;param-name&gt;encoding&lt;/param-name&gt;        &lt;param-value&gt;utf-8&lt;/param-value&gt;    &lt;/init-param&gt;&lt;/filter&gt;&lt;filter-mapping&gt;    &lt;filter-name&gt;CharacterEncodingFilter&lt;/filter-name&gt;    &lt;url-pattern&gt;/*&lt;/url-pattern&gt;&lt;/filter-mapping&gt;</code></pre><p>以上可以解决post请求乱码问题。</p><p>对于get请求中文参数出现乱码解决方法有两个：</p><p>修改tomcat配置文件添加编码与工程编码一致，如下：</p><pre><code>&lt;Connector URIEncoding=&quot;utf-8&quot; connectionTimeout=&quot;20000&quot; port=&quot;8080&quot; protocol=&quot;HTTP/1.1&quot; redirectPort=&quot;8443&quot;/&gt;</code></pre><p>另外一种方法对参数进行重新编码：</p><pre><code>String userName new String(request.getParamter(&quot;userName&quot;).getBytes(&quot;ISO8859-1&quot;),&quot;utf-8&quot;)</code></pre><p>ISO8859-1是tomcat默认编码，需要将tomcat编码后的内容按utf-8编码</p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;SpringMVC架构&quot;&gt;&lt;a href=&quot;#SpringMVC架构&quot; class=&quot;headerlink&quot; title=&quot;SpringMVC架构&quot;&gt;&lt;/a&gt;SpringMVC架构&lt;/h1&gt;&lt;p&gt;Spring web mvc和Struts2都属于表现层的框架,它是Spring框架的一部分.&lt;/p&gt;
&lt;h2 id=&quot;架构流程&quot;&gt;&lt;a href=&quot;#架构流程&quot; class=&quot;headerlink&quot; title=&quot;架构流程&quot;&gt;&lt;/a&gt;架构流程&lt;/h2&gt;&lt;pre&gt;&lt;code&gt;1、    用户发送请求至前端控制器DispatcherServlet

2、    DispatcherServlet收到请求调用HandlerMapping处理器映射器。

3、    处理器映射器根据请求url找到具体的处理器，生成处理器对象及处理器拦截器(如果有则生成)一并返回给DispatcherServlet。

4、    DispatcherServlet通过HandlerAdapter处理器适配器调用处理器

5、    执行处理器(Controller，也叫后端控制器)。

6、    Controller执行完成返回ModelAndView

7、    HandlerAdapter将controller执行结果ModelAndView返回给DispatcherServlet

8、    DispatcherServlet将ModelAndView传给ViewReslover视图解析器

9、    ViewReslover解析后返回具体View

10、    DispatcherServlet对View进行渲染视图（即将模型数据填充至视图中）。

11、    DispatcherServlet响应用户
&lt;/code&gt;&lt;/pre&gt;
    
    </summary>
    
      <category term="SSM" scheme="http://www.fashionkillyou.xyz/categories/SSM/"/>
    
    
      <category term="SpringMVC" scheme="http://www.fashionkillyou.xyz/tags/SpringMVC/"/>
    
  </entry>
  
  <entry>
    <title>mybatis五</title>
    <link href="http://www.fashionkillyou.xyz/2018/02/26/mybatis%E4%BA%94/"/>
    <id>http://www.fashionkillyou.xyz/2018/02/26/mybatis五/</id>
    <published>2018-02-26T08:21:09.000Z</published>
    <updated>2018-03-30T08:23:06.790Z</updated>
    
    <content type="html"><![CDATA[<script src="\assets\js\APlayer.min.js"> </script><h1 id="mybatis整合spring"><a href="#mybatis整合spring" class="headerlink" title="mybatis整合spring"></a>mybatis整合spring</h1><h2 id="整合思路"><a href="#整合思路" class="headerlink" title="整合思路"></a>整合思路</h2><p>1、SqlSessionFactory对象应该放到spring容器中作为单例存在。</p><p>2、传统dao的开发方式中，应该从spring容器中获得sqlsession对象。</p><p>3、Mapper代理形式中，应该从spring容器中直接获得mapper的代理对象。</p><p>4、数据库的连接以及数据库连接池事务管理都交给spring容器来完成。</p><a id="more"></a><h2 id="整合需要的jar包"><a href="#整合需要的jar包" class="headerlink" title="整合需要的jar包"></a>整合需要的jar包</h2><p>1、spring的jar包<br>2、Mybatis的jar包<br>3、Spring+mybatis的整合包。<br>4、Mysql的数据库驱动jar包。<br>5、数据库连接池的jar包。</p><h2 id="整合的步骤"><a href="#整合的步骤" class="headerlink" title="整合的步骤"></a>整合的步骤</h2><p>第一步：创建一个java工程。</p><p>第二步：导入jar包。（上面提到的jar包）</p><p>第三步：mybatis的配置文件SqlMapConfig.xml</p><p>第四步：编写Spring的配置文件</p><pre><code>1、数据库连接及连接池2、事务管理（暂时可以不配置）3、sqlsessionFactory对象，配置到spring容器中4、mapeer代理对象或者是dao实现类配置到spring容器中。</code></pre><p>第五步：编写dao或者mapper文件</p><p>第六步：测试。</p><h3 id="SqlMapConfig-xml"><a href="#SqlMapConfig-xml" class="headerlink" title="SqlMapConfig.xml"></a>SqlMapConfig.xml</h3><pre><code>&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; ?&gt;&lt;!DOCTYPE configurationPUBLIC &quot;-//mybatis.org//DTD Config 3.0//EN&quot;&quot;http://mybatis.org/dtd/mybatis-3-config.dtd&quot;&gt;&lt;configuration&gt;    &lt;typeAliases&gt;        &lt;package name=&quot;cn.lxm.mybatis.pojo&quot;/&gt;    &lt;/typeAliases&gt;    &lt;mappers&gt;        &lt;!-- 使用包扫描扫描mapper.xml            如果在ApplicationContext.xml中配置了扫描包之后,就 不需要此配置         --&gt;        &lt;package name=&quot;cn.lxm.mybatis.mapper&quot;/&gt;    &lt;/mappers&gt;&lt;/configuration&gt;</code></pre><h3 id="applicationContext-xml"><a href="#applicationContext-xml" class="headerlink" title="applicationContext.xml"></a>applicationContext.xml</h3><pre><code>&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot;    xmlns:context=&quot;http://www.springframework.org/schema/context&quot; xmlns:p=&quot;http://www.springframework.org/schema/p&quot;    xmlns:aop=&quot;http://www.springframework.org/schema/aop&quot; xmlns:tx=&quot;http://www.springframework.org/schema/tx&quot;    xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;    xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans-4.0.xsd    http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context-4.0.xsd    http://www.springframework.org/schema/aop http://www.springframework.org/schema/aop/spring-aop-4.0.xsd http://www.springframework.org/schema/tx http://www.springframework.org/schema/tx/spring-tx-4.0.xsd    http://www.springframework.org/schema/util http://www.springframework.org/schema/util/spring-util-4.0.xsd&quot;&gt;    &lt;!-- 加载配置文件 --&gt;    &lt;context:property-placeholder location=&quot;classpath:db.properties&quot; /&gt;    &lt;!-- 数据库连接池 --&gt;    &lt;bean id=&quot;dataSource&quot; class=&quot;org.apache.commons.dbcp.BasicDataSource&quot;        destroy-method=&quot;close&quot;&gt;        &lt;property name=&quot;driverClassName&quot; value=&quot;${jdbc.driver}&quot; /&gt;        &lt;property name=&quot;url&quot; value=&quot;${jdbc.url}&quot; /&gt;        &lt;property name=&quot;username&quot; value=&quot;${jdbc.username}&quot; /&gt;        &lt;property name=&quot;password&quot; value=&quot;${jdbc.password}&quot; /&gt;        &lt;property name=&quot;maxActive&quot; value=&quot;10&quot; /&gt;        &lt;property name=&quot;maxIdle&quot; value=&quot;5&quot; /&gt;    &lt;/bean&gt;    &lt;!-- mapper配置 --&gt;    &lt;!-- 让spring管理sqlsessionfactory 使用mybatis和spring整合包中的 --&gt;    &lt;bean id=&quot;sqlSessionFactory&quot; class=&quot;org.mybatis.spring.SqlSessionFactoryBean&quot;&gt;        &lt;!-- 数据库连接池 --&gt;        &lt;property name=&quot;dataSource&quot; ref=&quot;dataSource&quot; /&gt;        &lt;!-- 加载mybatis的全局配置文件 --&gt;        &lt;property name=&quot;configLocation&quot; value=&quot;classpath:mybatis/SqlMapConfig.xml&quot; /&gt;    &lt;/bean&gt;&lt;/beans&gt;</code></pre><h3 id="db-properties"><a href="#db-properties" class="headerlink" title="db.properties"></a>db.properties</h3><pre><code>jdbc.driver=com.mysql.jdbc.Driverjdbc.url=jdbc:mysql://localhost:3306/mybatis?characterEncoding=utf-8jdbc.username=rootjdbc.password=root</code></pre><h2 id="Dao的开发"><a href="#Dao的开发" class="headerlink" title="Dao的开发"></a>Dao的开发</h2><p>三种dao的实现方式：</p><pre><code>1、传统dao的开发方式2、使用mapper代理形式开发方式3、使用扫描包配置mapper代理。</code></pre><p>这里只介绍第二种和第三种</p><h3 id="Mapper代理形式开发dao"><a href="#Mapper代理形式开发dao" class="headerlink" title="Mapper代理形式开发dao"></a>Mapper代理形式开发dao</h3><h4 id="开发mapper接口"><a href="#开发mapper接口" class="headerlink" title="开发mapper接口"></a>开发mapper接口</h4><p>开发mapper文件</p><p>创建UserMapper.java</p><pre><code>public interface UserMapper {    User findUserById(Integer id) throws Exception;}</code></pre><p>并且在同一目录下创建UserMapper.xml</p><pre><code> &lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; ?&gt;&lt;!DOCTYPE mapperPUBLIC &quot;-//mybatis.org//DTD Mapper 3.0//EN&quot;&quot;http://mybatis.org/dtd/mybatis-3-mapper.dtd&quot;&gt;&lt;mapper namespace=&quot;cn.lxm.mybatis.mapper.UserMapper&quot;&gt;    &lt;!-- 根据id获取用户信息 --&gt;    &lt;select id=&quot;findUserById&quot; parameterType=&quot;int&quot; resultType=&quot;cn.lxm.mybatis.po.User&quot;&gt;        select * from user where id = #{id}    &lt;/select&gt;&lt;/mapper&gt;</code></pre><h4 id="配置mapper代理"><a href="#配置mapper代理" class="headerlink" title="配置mapper代理"></a>配置mapper代理</h4><pre><code>&lt;!-- 配置mapper代理对象 --&gt;&lt;bean class=&quot;org.mybatis.spring.mapper.MapperFactoryBean&quot;&gt;    &lt;property name=&quot;mapperInterface&quot; value=&quot;cn.lxm.mybatis.mapper.UserMapper&quot;/&gt;    &lt;property name=&quot;sqlSessionFactory&quot; ref=&quot;sqlSessionFactory&quot;&gt;&lt;/property&gt;&lt;/bean&gt;</code></pre><h4 id="测试方法"><a href="#测试方法" class="headerlink" title="测试方法"></a>测试方法</h4><pre><code>public class UserMapperTest {    private ApplicationContext applicationContext;    @Before    public void setUp() throws Exception {        applicationContext = new ClassPathXmlApplicationContext(&quot;classpath:spring/applicationContext.xml&quot;);    }    @Test    public void testGetUserById() {        UserMapper userMapper = applicationContext.getBean(UserMapper.class);        User user = userMapper.getUserById(1);        System.out.println(user);    }}</code></pre><h3 id="扫描包形式配置mapper"><a href="#扫描包形式配置mapper" class="headerlink" title="扫描包形式配置mapper"></a>扫描包形式配置mapper</h3><pre><code>&lt;!-- 使用扫描包的形式来创建mapper代理对象 --&gt;&lt;bean class=&quot;org.mybatis.spring.mapper.MapperScannerConfigurer&quot;&gt;    &lt;property name=&quot;basePackage&quot; value=&quot;cn.lxm.mybatis.mapper&quot;&gt;&lt;/property&gt;&lt;/bean&gt;</code></pre><p>如果配置了这个后 ,在SQLMapConfig.xml中的包扫描配置就不需要了</p><h2 id="逆向工程生成代码"><a href="#逆向工程生成代码" class="headerlink" title="逆向工程生成代码"></a>逆向工程生成代码</h2><p>步骤:</p><p>1.导入逆向工程代码,然后修改配置文件generatorConfig.xml</p><pre><code>&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;!DOCTYPE generatorConfiguration  PUBLIC &quot;-//mybatis.org//DTD MyBatis Generator Configuration 1.0//EN&quot;  &quot;http://mybatis.org/dtd/mybatis-generator-config_1_0.dtd&quot;&gt;&lt;generatorConfiguration&gt;    &lt;context id=&quot;testTables&quot; targetRuntime=&quot;MyBatis3&quot;&gt;        &lt;commentGenerator&gt;            &lt;!-- 是否去除自动生成的注释 true：是 ： false:否 --&gt;            &lt;property name=&quot;suppressAllComments&quot; value=&quot;true&quot; /&gt;        &lt;/commentGenerator&gt;        &lt;!--数据库连接的信息：驱动类、连接地址、用户名、密码 --&gt;        &lt;jdbcConnection driverClass=&quot;com.mysql.jdbc.Driver&quot;            connectionURL=&quot;jdbc:mysql://localhost:3306/mybatis&quot; userId=&quot;root&quot;            password=&quot;root&quot;&gt;        &lt;/jdbcConnection&gt;        &lt;!-- &lt;jdbcConnection driverClass=&quot;oracle.jdbc.OracleDriver&quot;            connectionURL=&quot;jdbc:oracle:thin:@127.0.0.1:1521:yycg&quot;             userId=&quot;yycg&quot;            password=&quot;yycg&quot;&gt;        &lt;/jdbcConnection&gt; --&gt;        &lt;!-- 默认false，把JDBC DECIMAL 和 NUMERIC 类型解析为 Integer，为 true时把JDBC DECIMAL 和             NUMERIC 类型解析为java.math.BigDecimal --&gt;        &lt;javaTypeResolver&gt;            &lt;property name=&quot;forceBigDecimals&quot; value=&quot;false&quot; /&gt;        &lt;/javaTypeResolver&gt;        &lt;!-- targetProject:生成PO类的位置 --&gt;        &lt;javaModelGenerator targetPackage=&quot;cn.lxm.mybatis.po&quot;            targetProject=&quot;.\src&quot;&gt;            &lt;!-- enableSubPackages:是否让schema作为包的后缀 --&gt;            &lt;property name=&quot;enableSubPackages&quot; value=&quot;false&quot; /&gt;            &lt;!-- 从数据库返回的值被清理前后的空格 --&gt;            &lt;property name=&quot;trimStrings&quot; value=&quot;true&quot; /&gt;        &lt;/javaModelGenerator&gt;        &lt;!-- targetProject:mapper映射文件生成的位置 --&gt;        &lt;sqlMapGenerator targetPackage=&quot;cn.lxm.mybatis.mapper&quot;             targetProject=&quot;.\src&quot;&gt;            &lt;!-- enableSubPackages:是否让schema作为包的后缀 --&gt;            &lt;property name=&quot;enableSubPackages&quot; value=&quot;false&quot; /&gt;        &lt;/sqlMapGenerator&gt;        &lt;!-- targetPackage：mapper接口生成的位置 --&gt;        &lt;javaClientGenerator type=&quot;XMLMAPPER&quot;            targetPackage=&quot;cn.lxm.mybatis.mapper&quot;             targetProject=&quot;.\src&quot;&gt;            &lt;!-- enableSubPackages:是否让schema作为包的后缀 --&gt;            &lt;property name=&quot;enableSubPackages&quot; value=&quot;false&quot; /&gt;        &lt;/javaClientGenerator&gt;        &lt;!-- 指定数据库表 --&gt;        &lt;table schema=&quot;&quot; tableName=&quot;user&quot;&gt;&lt;/table&gt;        &lt;table schema=&quot;&quot; tableName=&quot;orders&quot;&gt;&lt;/table&gt;        &lt;!-- 有些表的字段需要指定java类型         &lt;table schema=&quot;&quot; tableName=&quot;&quot;&gt;            &lt;columnOverride column=&quot;&quot; javaType=&quot;&quot; /&gt;        &lt;/table&gt; --&gt;    &lt;/context&gt;&lt;/generatorConfiguration&gt;</code></pre>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;mybatis整合spring&quot;&gt;&lt;a href=&quot;#mybatis整合spring&quot; class=&quot;headerlink&quot; title=&quot;mybatis整合spring&quot;&gt;&lt;/a&gt;mybatis整合spring&lt;/h1&gt;&lt;h2 id=&quot;整合思路&quot;&gt;&lt;a href=&quot;#整合思路&quot; class=&quot;headerlink&quot; title=&quot;整合思路&quot;&gt;&lt;/a&gt;整合思路&lt;/h2&gt;&lt;p&gt;1、SqlSessionFactory对象应该放到spring容器中作为单例存在。&lt;/p&gt;
&lt;p&gt;2、传统dao的开发方式中，应该从spring容器中获得sqlsession对象。&lt;/p&gt;
&lt;p&gt;3、Mapper代理形式中，应该从spring容器中直接获得mapper的代理对象。&lt;/p&gt;
&lt;p&gt;4、数据库的连接以及数据库连接池事务管理都交给spring容器来完成。&lt;/p&gt;
    
    </summary>
    
      <category term="SSM" scheme="http://www.fashionkillyou.xyz/categories/SSM/"/>
    
    
      <category term="Mybatis" scheme="http://www.fashionkillyou.xyz/tags/Mybatis/"/>
    
  </entry>
  
  <entry>
    <title>mybatis四</title>
    <link href="http://www.fashionkillyou.xyz/2018/02/25/mybatis%E5%9B%9B/"/>
    <id>http://www.fashionkillyou.xyz/2018/02/25/mybatis四/</id>
    <published>2018-02-25T08:07:42.000Z</published>
    <updated>2018-03-30T08:23:06.788Z</updated>
    
    <content type="html"><![CDATA[<script src="\assets\js\APlayer.min.js"> </script><h1 id="关联查询"><a href="#关联查询" class="headerlink" title="关联查询"></a>关联查询</h1><h2 id="一对一查询"><a href="#一对一查询" class="headerlink" title="一对一查询"></a>一对一查询</h2><p>这里举例是一个订单对应一个用户</p><h3 id="方法一："><a href="#方法一：" class="headerlink" title="方法一："></a>方法一：</h3><p>使用resultType，定义订单信息po类，此po类中包括了订单信息和用户信息：</p><a id="more"></a><h4 id="Sql语句："><a href="#Sql语句：" class="headerlink" title="Sql语句："></a>Sql语句：</h4><pre><code>SELECT   orders.*,  user.username,  user.addressFROM  orders,  user WHERE orders.user_id = user.id</code></pre><h4 id="定义po类"><a href="#定义po类" class="headerlink" title="定义po类"></a>定义po类</h4><p>Po类中应该包括上边sql查询出来的所有字段，如下：</p><pre><code>public class OrdersCustom extends Orders {private String username;// 用户名称private String address;// 用户地址get/set。。。。</code></pre><p>OrdersCustom类继承Orders类后OrdersCustom类包括了Orders类的所有字段，只需要定义用户的信息字段即可。</p><h4 id="Mapper-xml"><a href="#Mapper-xml" class="headerlink" title="Mapper.xml"></a>Mapper.xml</h4><pre><code>&lt;!-- 查询所有订单信息 --&gt;&lt;select id=&quot;findOrdersList&quot; resultType=&quot;cn.lxm.mybatis.po.OrdersCustom&quot;&gt;SELECTorders.*,user.username,user.addressFROMorders,    userWHERE orders.user_id = user.id &lt;/select&gt;</code></pre><h4 id="Mapper接口："><a href="#Mapper接口：" class="headerlink" title="Mapper接口："></a>Mapper接口：</h4><pre><code>public List&lt;OrdersCustom&gt; findOrdersList() throws Exception;</code></pre><h4 id="测试："><a href="#测试：" class="headerlink" title="测试："></a>测试：</h4><pre><code>Public void testfindOrdersList()throws Exception{    //获取session    SqlSession session = sqlSessionFactory.openSession();    //获限mapper接口实例    UserMapper userMapper = session.getMapper(UserMapper.class);    //查询订单信息    List&lt;OrdersCustom&gt; list = userMapper.findOrdersList();    System.out.println(list);    //关闭session    session.close();}</code></pre><h4 id="小结："><a href="#小结：" class="headerlink" title="小结："></a>小结：</h4><pre><code>定义专门的po类作为输出类型，其中定义了sql查询结果集所有的字段。此方法较为简单，企业中使用普遍。</code></pre><h3 id="方法二："><a href="#方法二：" class="headerlink" title="方法二："></a>方法二：</h3><p>使用resultMap，定义专门的resultMap用于映射一对一查询结果。</p><h4 id="Sql语句：-1"><a href="#Sql语句：-1" class="headerlink" title="Sql语句："></a>Sql语句：</h4><pre><code>SELECT   orders.*,  user.username,  user.addressFROM  orders,  user WHERE orders.user_id = user.id</code></pre><h4 id="定义po类-1"><a href="#定义po类-1" class="headerlink" title="定义po类"></a>定义po类</h4><p>在Orders类中加入User属性，user属性中用于存储关联查询的用户信息，因为订单关联查询用户是一对一关系，所以这里使用单个User对象存储关联查询的用户信息。<br>    public class Orders {<br>    private Integer id;</p><pre><code>private Integer userId;private String number;private Date createtime;private String note;private User user;get/set()...</code></pre><h4 id="Mapper-xml-1"><a href="#Mapper-xml-1" class="headerlink" title="Mapper.xml"></a>Mapper.xml</h4><pre><code>&lt;!-- 查询订单关联用户信息使用resultmap --&gt;&lt;resultMap type=&quot;Orders&quot; id=&quot;orderUserResultMap&quot;&gt;    &lt;id column=&quot;id&quot; property=&quot;id&quot;/&gt;    &lt;result column=&quot;user_id&quot; property=&quot;userId&quot;/&gt;    &lt;result column=&quot;number&quot; property=&quot;number&quot;/&gt;    &lt;result column=&quot;createtime&quot; property=&quot;createtime&quot;/&gt;    &lt;result column=&quot;note&quot; property=&quot;note&quot;/&gt;    &lt;!-- 一对一关联映射 --&gt;    &lt;!--     property:Orders对象的user属性    javaType：user属性对应 的类型     --&gt;    &lt;association property=&quot;user&quot; javaType=&quot;cn.lxm.po.User&quot;&gt;        &lt;!-- column:user表的主键对应的列  property：user对象中id属性--&gt;        &lt;id column=&quot;user_id&quot; property=&quot;id&quot;/&gt;        &lt;result column=&quot;username&quot; property=&quot;username&quot;/&gt;        &lt;result column=&quot;address&quot; property=&quot;address&quot;/&gt;    &lt;/association&gt;&lt;/resultMap&gt;&lt;select id=&quot;findOrdersWithUserResultMap&quot; resultMap=&quot;orderUserResultMap&quot;&gt;    SELECT        o.id,        o.user_id,        o.number,        o.createtime,        o.note,        u.username,        u.address    FROM        orders o    JOIN `user` u ON u.id = o.user_id&lt;/select&gt;</code></pre><p>这里resultMap指定orderUserResultMap。</p><p>association：表示进行关联查询单条记录</p><p>property：表示关联查询的结果存储在cn.lxm.mybatis.po.Orders的user属性中</p><p>javaType：表示关联查询的结果类型</p><p>&lt; id property=”id” column=”user_id”/&gt;：查询结果的user_id列对应关联对象的id属性，这里是&lt; id /&gt;表示user_id是关联查询对象的唯一标识。</p><p>&lt; result property=”username” column=”username”/&gt;：查询结果的username列对应关联对象的username属性。</p><h4 id="Mapper接口：-1"><a href="#Mapper接口：-1" class="headerlink" title="Mapper接口："></a>Mapper接口：</h4><pre><code>public List&lt;Orders&gt; findOrdersListResultMap() throws Exception;</code></pre><h4 id="测试：-1"><a href="#测试：-1" class="headerlink" title="测试："></a>测试：</h4><pre><code>Public void testfindOrdersListResultMap()throws Exception{    //获取session    SqlSession session = sqlSessionFactory.openSession();    //获限mapper接口实例    UserMapper userMapper = session.getMapper(UserMapper.class);    //查询订单信息    List&lt;Orders&gt; list = userMapper.findOrdersList2();    System.out.println(list);    //关闭session    session.close();}</code></pre><h4 id="小结：-1"><a href="#小结：-1" class="headerlink" title="小结："></a>小结：</h4><p>使用association完成关联查询，将关联查询信息映射到pojo对象中。</p><h2 id="一对多查询"><a href="#一对多查询" class="headerlink" title="一对多查询"></a>一对多查询</h2><p>案例：查询所有用户信息及用户关联的订单信息。</p><p>用户信息和订单信息为一对多关系。</p><p>使用resultMap实现如下：</p><h3 id="Sql语句：-2"><a href="#Sql语句：-2" class="headerlink" title="Sql语句："></a>Sql语句：</h3><pre><code>SELECTu.*, o.id oid,o.number,o.createtime,o.noteFROM`user` uLEFT JOIN orders o ON u.id = o.user_id</code></pre><h3 id="定义po类-2"><a href="#定义po类-2" class="headerlink" title="定义po类"></a>定义po类</h3><p>在User类中加入List&lt; Orders&gt; orders属性</p><pre><code>public class User {   private int id;   private String username;// 用户姓名   private String sex;// 性别   private Date birthday;// 生日   private String address;// 地址   private List&lt;Orders&gt; orders;   get/set()...</code></pre><h3 id="Mapper-xml-2"><a href="#Mapper-xml-2" class="headerlink" title="Mapper.xml"></a>Mapper.xml</h3><pre><code>&lt;resultMap type=&quot;user&quot; id=&quot;userOrderResultMap&quot;&gt;    &lt;!-- 用户信息映射 --&gt;    &lt;id property=&quot;id&quot; column=&quot;id&quot;/&gt;    &lt;result property=&quot;username&quot; column=&quot;username&quot;/&gt;    &lt;result property=&quot;birthday&quot; column=&quot;birthday&quot;/&gt;    &lt;result property=&quot;sex&quot; column=&quot;sex&quot;/&gt;    &lt;result property=&quot;address&quot; column=&quot;address&quot;/&gt;    &lt;!-- 一对多关联映射 --&gt;    &lt;collection property=&quot;orders&quot; ofType=&quot;orders&quot;&gt;        &lt;id property=&quot;id&quot; column=&quot;oid&quot;/&gt;              &lt;!--用户id已经在user对象中存在，此处可以不设置--&gt;        &lt;!-- &lt;result property=&quot;userId&quot; column=&quot;id&quot;/&gt; --&gt;        &lt;result property=&quot;number&quot; column=&quot;number&quot;/&gt;        &lt;result property=&quot;createtime&quot; column=&quot;createtime&quot;/&gt;        &lt;result property=&quot;note&quot; column=&quot;note&quot;/&gt;    &lt;/collection&gt;&lt;/resultMap&gt;&lt;select id=&quot;getUserOrderList&quot; resultMap=&quot;userOrderResultMap&quot;&gt;    SELECT    u.*, o.id oid,    o.number,    o.createtime,    o.note    FROM    `user` u    LEFT JOIN orders o ON u.id = o.user_id&lt;/select&gt;</code></pre><p>collection部分定义了用户关联的订单信息。表示关联查询结果集</p><p>property=”orders”：关联查询的结果集存储在User对象的上哪个属性。</p><p>ofType=”orders”：指定关联查询的结果集中的对象类型即List中的对象类型。此处可以使用别名，也可以使用全限定名。</p><p>&lt; id /&gt;及&lt; result/&gt;的意义同一对一查询。</p><h3 id="Mapper接口：-2"><a href="#Mapper接口：-2" class="headerlink" title="Mapper接口："></a>Mapper接口：</h3><pre><code>List&lt;User&gt; getUserOrderList();</code></pre><h3 id="测试"><a href="#测试" class="headerlink" title="测试"></a>测试</h3><pre><code>@Testpublic void getUserOrderList() {    SqlSession session = sqlSessionFactory.openSession();    UserMapper userMapper = session.getMapper(UserMapper.class);    List&lt;User&gt; result = userMapper.getUserOrderList();    for (User user : result) {        System.out.println(user);    }    session.close();}</code></pre>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;关联查询&quot;&gt;&lt;a href=&quot;#关联查询&quot; class=&quot;headerlink&quot; title=&quot;关联查询&quot;&gt;&lt;/a&gt;关联查询&lt;/h1&gt;&lt;h2 id=&quot;一对一查询&quot;&gt;&lt;a href=&quot;#一对一查询&quot; class=&quot;headerlink&quot; title=&quot;一对一查询&quot;&gt;&lt;/a&gt;一对一查询&lt;/h2&gt;&lt;p&gt;这里举例是一个订单对应一个用户&lt;/p&gt;
&lt;h3 id=&quot;方法一：&quot;&gt;&lt;a href=&quot;#方法一：&quot; class=&quot;headerlink&quot; title=&quot;方法一：&quot;&gt;&lt;/a&gt;方法一：&lt;/h3&gt;&lt;p&gt;使用resultType，定义订单信息po类，此po类中包括了订单信息和用户信息：&lt;/p&gt;
    
    </summary>
    
      <category term="SSM" scheme="http://www.fashionkillyou.xyz/categories/SSM/"/>
    
    
      <category term="Mybatis" scheme="http://www.fashionkillyou.xyz/tags/Mybatis/"/>
    
  </entry>
  
  <entry>
    <title>mybatis三</title>
    <link href="http://www.fashionkillyou.xyz/2018/02/25/mybatis%E4%B8%89/"/>
    <id>http://www.fashionkillyou.xyz/2018/02/25/mybatis三/</id>
    <published>2018-02-25T00:58:28.000Z</published>
    <updated>2018-03-30T08:23:06.786Z</updated>
    
    <content type="html"><![CDATA[<script src="\assets\js\APlayer.min.js"> </script><h1 id="输入映射和输出映射"><a href="#输入映射和输出映射" class="headerlink" title="输入映射和输出映射"></a>输入映射和输出映射</h1><p>Mapper.xml映射文件中定义了操作数据库的sql，每个sql是一个statement，映射文件是mybatis的核心。<br><a id="more"></a></p><h2 id="parameterType-输入类型"><a href="#parameterType-输入类型" class="headerlink" title="parameterType(输入类型)"></a>parameterType(输入类型)</h2><h3 id="传递简单类型"><a href="#传递简单类型" class="headerlink" title="传递简单类型"></a>传递简单类型</h3><p>参考文章 <a href="http://fashionkillyou.xyz/2018/02/24/mybatis入门一/" title="mybatis入门一" target="_blank" rel="noopener">mybatis入门一</a></p><h3 id="传递pojo对象"><a href="#传递pojo对象" class="headerlink" title="传递pojo对象"></a>传递pojo对象</h3><p>Mybatis使用ognl表达式解析对象字段的值，#{}或者${}括号中的值为pojo属性名称。</p><h3 id="传递pojo包装对象"><a href="#传递pojo包装对象" class="headerlink" title="传递pojo包装对象"></a>传递pojo包装对象</h3><p>开发中通过pojo传递查询条件 ，查询条件是综合的查询条件，不仅包括用户查询条件还包括其它的查询条件（比如将用户购买商品信息也作为查询条件），这时可以使用包装对象传递输入参数。<br>Pojo类中包含pojo。</p><p>需求：根据用户名查询用户信息，查询条件放到QueryVo的user属性中。</p><h4 id="QueryVo"><a href="#QueryVo" class="headerlink" title="QueryVo"></a>QueryVo</h4><pre><code>public class QueryVo {    private User user;    public User getUser() {        return user;    }    public void setUser(User user) {        this.user = user;    }}</code></pre><h4 id="Sql语句"><a href="#Sql语句" class="headerlink" title="Sql语句"></a>Sql语句</h4><p>SELECT * FROM user where username like ‘%刘%’</p><h4 id="Mapper文件"><a href="#Mapper文件" class="headerlink" title="Mapper文件"></a>Mapper文件</h4><pre><code>&lt;!-- 使用包装类型查询用户使用ognl从对象中取属性值，如果是包装对象可以使用.操作符来取内容部的属性--&gt;&lt;select id=&quot;findUserByQueryVo&quot; parameterType=&quot;queryvo&quot; resultType=&quot;user&quot;&gt;    SELECT * FROM user where username like &apos;%${user.username}%&apos;&lt;/select&gt;</code></pre><h4 id="接口"><a href="#接口" class="headerlink" title="接口"></a>接口</h4><pre><code> public interface UserMapper{    User findUserById(int id) throws Exception;    void insertUser(User user) throws Exception;    List&lt;User&gt; findUserByQueryVo(QueryVo queryVo) throws Exception;}</code></pre><h4 id="测试方法"><a href="#测试方法" class="headerlink" title="测试方法"></a>测试方法</h4><pre><code>@Testpublic void testFindUserByQueryVo() throws Exception {    SqlSession sqlSession = sessionFactory.openSession();    //获得mapper的代理对象    UserMapper userMapper = sqlSession.getMapper(UserMapper.class);    //创建QueryVo对象    QueryVo queryVo = new QueryVo();    //创建user对象    User user = new User();    user.setUsername(&quot;刘&quot;);    queryVo.setUser(user);    //根据queryvo查询用户    List&lt;User&gt; list = userMapper.findUserByQueryVo(queryVo);    System.out.println(list);    sqlSession.close();}</code></pre><h2 id="resultType-输出类型"><a href="#resultType-输出类型" class="headerlink" title="resultType(输出类型)"></a>resultType(输出类型)</h2><h3 id="输出简单类型"><a href="#输出简单类型" class="headerlink" title="输出简单类型"></a>输出简单类型</h3><p>参考getnow输出日期类型，看下边的例子输出整型：</p><p>Mapper.xml文件</p><pre><code>&lt;!-- 获取用户列表总数 --&gt;&lt;select id=&quot;findUserCount&quot; parameterType=&quot;user&quot; resultType=&quot;int&quot;&gt;   select count(1) from user&lt;/select&gt;</code></pre><p>Mapper接口</p><pre><code>public int findUserCount(User user) throws Exception;</code></pre><p>调用：</p><pre><code>Public void testFindUserCount() throws Exception{    //获取session    SqlSession session = sqlSessionFactory.openSession();    //获取mapper接口实例    UserMapper userMapper = session.getMapper(UserMapper.class);    User user = new User();    user.setUsername(&quot;管理员&quot;);    //传递Hashmap对象查询用户列表    int count = userMapper.findUserCount(user);    //关闭session    session.close();}</code></pre><p>输出简单类型必须查询出来的结果集有一条记录，最终将第一个字段的值转换为输出类型。<br>使用session的selectOne可查询单条记录。</p><h3 id="输出pojo对象"><a href="#输出pojo对象" class="headerlink" title="输出pojo对象"></a>输出pojo对象</h3><p>参考文章 <a href="http://fashionkillyou.xyz/2018/02/24/mybatis入门一/" title="mybatis入门一" target="_blank" rel="noopener">mybatis入门一</a></p><h3 id="输出pojo列表"><a href="#输出pojo列表" class="headerlink" title="输出pojo列表"></a>输出pojo列表</h3><p>参考文章 <a href="http://fashionkillyou.xyz/2018/02/24/mybatis入门一/" title="mybatis入门一" target="_blank" rel="noopener">mybatis入门一</a></p><h2 id="resultMap"><a href="#resultMap" class="headerlink" title="resultMap"></a>resultMap</h2><p>resultType可以指定pojo将查询结果映射为pojo，但需要pojo的属性名和sql查询的列名一致方可映射成功。</p><p>如果sql查询字段名和pojo的属性名不一致，可以通过resultMap将字段名和属性名作一个对应关系 ，resultMap实质上还需要将查询结果映射到pojo对象中。</p><p>resultMap可以实现将查询结果映射为复杂类型的pojo，比如在查询结果映射对象中包括pojo和list实现一对一查询和一对多查询。</p><h3 id="Mapper-xml定义"><a href="#Mapper-xml定义" class="headerlink" title="Mapper.xml定义"></a>Mapper.xml定义</h3><pre><code> &lt;select id=&quot;findUserListResultMap&quot; parameterType=&quot;queryVo&quot; resultMap=&quot;userListResultMap&quot;&gt;    select id id_,username username_,birthday birthday_ from user&lt;/select&gt;</code></pre><p>使用resultMap指定上边定义的personmap。</p><h3 id="定义resultMap"><a href="#定义resultMap" class="headerlink" title="定义resultMap"></a>定义resultMap</h3><p>由于上边的mapper.xml中sql查询列和Users.java类属性不一致，需要定义resultMap：</p><p>userListResultMap将sql查询列和Users.java类属性对应起来</p><pre><code>&lt;!-- type:最终映射的java对象.id:resultMap的唯一标识 --&gt;&lt;resultMap type=&quot;user&quot; id=&quot;userListResultMap&quot;&gt;&lt;!-- id标签:查询结果集的唯一标识列(主键或唯一标识)    column:SQL查询字段名(列名)    property:pojo的属性名    result标签:普通列 --&gt;    &lt;id property=&quot;id&quot; column=&quot;id_&quot;/&gt;    &lt;result property=&quot;username&quot; column=&quot;username_&quot;/&gt;    &lt;result property=&quot;birthday&quot; column=&quot;birthday_&quot;/&gt;&lt;/resultMap&gt;</code></pre><p>&lt; id /&gt;：此属性表示查询结果集的唯一标识，非常重要。如果是多个字段为复合唯一约束则定义多个&lt; id /&gt;。</p><p>Property：表示User类的属性。</p><p>Column：表示sql查询出来的字段名。</p><p>Column和property放在一块儿表示将sql查询出来的字段映射到指定的pojo类属性上。</p><p>&lt; result /&gt;：普通结果，即pojo的属性。</p><h3 id="Mapper接口定义"><a href="#Mapper接口定义" class="headerlink" title="Mapper接口定义"></a>Mapper接口定义</h3><pre><code>public List&lt;User&gt; findUserListResultMap() throws Exception;</code></pre><h1 id="动态sql"><a href="#动态sql" class="headerlink" title="动态sql"></a>动态sql</h1><p>通过mybatis提供的各种标签方法实现动态拼接sql。</p><h2 id="If"><a href="#If" class="headerlink" title="If"></a>If</h2><pre><code>&lt;!-- 传递pojo综合查询用户信息 --&gt;&lt;select id=&quot;findUserList&quot; parameterType=&quot;user&quot; resultType=&quot;user&quot;&gt;    select * from user     where 1=1     &lt;if test=&quot;id!=null and id!=&apos;&apos;&quot;&gt;    and id=#{id}    &lt;/if&gt;    &lt;if test=&quot;username!=null and username!=&apos;&apos;&quot;&gt;    and username like &apos;%${username}%&apos;    &lt;/if&gt;&lt;/select&gt;</code></pre><p>注意要做不等于空字符串校验。</p><h2 id="Where"><a href="#Where" class="headerlink" title="Where"></a>Where</h2><p>上边的sql也可以改为：</p><pre><code>&lt;select id=&quot;findUserList&quot; parameterType=&quot;user&quot; resultType=&quot;user&quot;&gt;    select * from user     &lt;where&gt;    &lt;if test=&quot;id!=null and id!=&apos;&apos;&quot;&gt;    and id=#{id}    &lt;/if&gt;    &lt;if test=&quot;username!=null and username!=&apos;&apos;&quot;&gt;    and username like &apos;%${username}%&apos;    &lt;/if&gt;    &lt;/where&gt;&lt;/select&gt;</code></pre><p>&lt; where /&gt;可以自动处理第一个and。</p><h2 id="foreach"><a href="#foreach" class="headerlink" title="foreach"></a>foreach</h2><p>向sql传递数组或List，mybatis使用foreach解析，如下：</p><p>需求<br>传入多个id查询用户信息，用下边两个sql实现：</p><pre><code>SELECT * FROM USERS WHERE username LIKE &apos;%张%&apos; AND (id =10 OR id =89 OR id=16)SELECT * FROM USERS WHERE username LIKE &apos;%张%&apos;  id IN (10,89,16)</code></pre><p>在pojo中定义list属性ids存储多个用户id，并添加getter/setter方法</p><pre><code> public class QueryVo {    private User user;    private List&lt;Integer&gt; ids;    public List&lt;Integer&gt; getIds() {        return ids;    }    public void setIds(List&lt;Integer&gt; ids) {        this.ids = ids;    }...</code></pre><p>mapper.xml</p><pre><code>&lt;if test=&quot;ids!=null and ids.size&gt;0&quot;&gt;        &lt;foreach collection=&quot;ids&quot; open=&quot; and id in(&quot; close=&quot;)&quot; item=&quot;id&quot; separator=&quot;,&quot; &gt;            #{id}        &lt;/foreach&gt;&lt;/if&gt;</code></pre><p>测试代码：</p><pre><code>List&lt;Integer&gt; ids = new ArrayList&lt;Integer&gt;();    ids.add(1);//查询id为1的用户    ids.add(10); //查询id为10的用户    queryVo.setIds(ids);    List&lt;User&gt; list = userMapper.findUserList(queryVo);</code></pre><h2 id="Sql片段"><a href="#Sql片段" class="headerlink" title="Sql片段"></a>Sql片段</h2><p>Sql中可将重复的sql提取出来，使用时用include引用即可，最终达到sql重用的目的，如下：</p><pre><code>&lt;!-- 传递pojo综合查询用户信息 --&gt;&lt;select id=&quot;findUserList&quot; parameterType=&quot;user&quot; resultType=&quot;user&quot;&gt;    select * from user     &lt;where&gt;    &lt;if test=&quot;id!=null and id!=&apos;&apos;&quot;&gt;    and id=#{id}    &lt;/if&gt;    &lt;if test=&quot;username!=null and username!=&apos;&apos;&quot;&gt;    and username like &apos;%${username}%&apos;    &lt;/if&gt;    &lt;/where&gt;&lt;/select&gt;</code></pre><p>    将where条件抽取出来：</p><pre><code>&lt;sql id=&quot;query_user_where&quot;&gt;    &lt;if test=&quot;id!=null and id!=&apos;&apos;&quot;&gt;        and id=#{id}    &lt;/if&gt;    &lt;if test=&quot;username!=null and username!=&apos;&apos;&quot;&gt;        and username like &apos;%${username}%&apos;    &lt;/if&gt;&lt;/sql&gt;</code></pre><p>    使用include引用：</p><pre><code>&lt;select id=&quot;findUserList&quot; parameterType=&quot;user&quot; resultType=&quot;user&quot;&gt;    select * from user     &lt;where&gt;    &lt;include refid=&quot;query_user_where&quot;/&gt;    &lt;/where&gt;&lt;/select&gt;</code></pre><p>注意：如果引用其它mapper.xml的sql片段，则在引用时需要加上namespace，如下：</p><pre><code>&lt;include refid=&quot;namespace.sql片段”/&gt;</code></pre><p>如果使用 &gt;或者&lt;符号的时候,因为是在xml文件中这些符号都是有特殊含义的,可以使用CDATA区域 &lt;![CDATA[要写的内容]]&gt;       &lt;![CDATA[&gt;]]&gt;大于   &lt;![CDATA[&lt;]]&gt;</p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;输入映射和输出映射&quot;&gt;&lt;a href=&quot;#输入映射和输出映射&quot; class=&quot;headerlink&quot; title=&quot;输入映射和输出映射&quot;&gt;&lt;/a&gt;输入映射和输出映射&lt;/h1&gt;&lt;p&gt;Mapper.xml映射文件中定义了操作数据库的sql，每个sql是一个statement，映射文件是mybatis的核心。&lt;br&gt;
    
    </summary>
    
      <category term="SSM" scheme="http://www.fashionkillyou.xyz/categories/SSM/"/>
    
    
      <category term="Mybatis" scheme="http://www.fashionkillyou.xyz/tags/Mybatis/"/>
    
  </entry>
  
</feed>
