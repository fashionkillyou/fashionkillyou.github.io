<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Fashionkillyou</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://yoursite.com/"/>
  <updated>2018-03-02T16:04:04.968Z</updated>
  <id>http://yoursite.com/</id>
  
  <author>
    <name>liuxinming</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>使用formfill.js快速填充表单</title>
    <link href="http://yoursite.com/2018/03/02/%E4%BD%BF%E7%94%A8formfill-js%E5%BF%AB%E9%80%9F%E5%A1%AB%E5%85%85%E8%A1%A8%E5%8D%95/"/>
    <id>http://yoursite.com/2018/03/02/使用formfill-js快速填充表单/</id>
    <published>2018-03-02T13:26:17.000Z</published>
    <updated>2018-03-02T16:04:04.968Z</updated>
    
    <content type="html"><![CDATA[<h1 id="form表单的快速回显"><a href="#form表单的快速回显" class="headerlink" title="form表单的快速回显"></a>form表单的快速回显</h1><p>做项目开发的时候在写修改的页面时,如果字段很多的话,数据回显塞值挺麻烦的,所以最近找了一个formfill.js快速填充表单的js</p><p>使用起来很简单,首先引用js文件<br><a id="more"></a><br>百度云盘下载:</p><p><a href="链接：https://pan.baidu.com/s/1mjSDRtA" title=" formfill.js ">链接：https://pan.baidu.com/s/1mjSDRtA</a></p><p>密码：5ljt</p><pre><code>&lt;script src=&quot;../js/jquery.formautofill.js&quot;&gt;&lt;/script&gt;</code></pre><p>使用:</p><pre><code>var data = {&quot;name&quot;:&quot;haha&quot;,&quot;password&quot;:&quot;123&quot;}$(&quot;#formId&quot;).autofill(data);</code></pre><h1 id="英文解释"><a href="#英文解释" class="headerlink" title="英文解释:"></a>英文解释:</h1><h1 id="jQuery-form-autofill"><a href="#jQuery-form-autofill" class="headerlink" title="jQuery form autofill"></a>jQuery form autofill</h1><p>jQuery plugin to simply autofill an empty form with data.</p><h2 id="Documentation"><a href="#Documentation" class="headerlink" title="Documentation"></a>Documentation</h2><p><a href="http://labs.creative-area.net/jquery.formautofill/doc/" target="_blank" rel="noopener">See complete documentation and demo</a></p><h2 id="Usage"><a href="#Usage" class="headerlink" title="Usage"></a>Usage</h2><p>You have a <strong>form</strong></p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">form</span> <span class="attr">id</span>=<span class="string">"f"</span>&gt;</span></span><br><span class="line">    name <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"text"</span> <span class="attr">name</span>=<span class="string">"name"</span>&gt;</span></span><br><span class="line">    email <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"text"</span> <span class="attr">name</span>=<span class="string">"email"</span>&gt;</span></span><br><span class="line">    love jQuery</span><br><span class="line">    <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"radio"</span> <span class="attr">name</span>=<span class="string">"lovejquery"</span> <span class="attr">value</span>=<span class="string">"yes"</span>&gt;</span> yes</span><br><span class="line">    <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"radio"</span> <span class="attr">name</span>=<span class="string">"lovejquery"</span> <span class="attr">value</span>=<span class="string">"no"</span>&gt;</span> no</span><br><span class="line"><span class="tag">&lt;/<span class="name">form</span>&gt;</span></span><br></pre></td></tr></table></figure><p>And <strong>data</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> data = &#123;</span><br><span class="line">    <span class="string">"name"</span>: <span class="string">"John Doe"</span>,</span><br><span class="line">    <span class="string">"email"</span>: <span class="string">"johndoe@mail.com"</span>,</span><br><span class="line">    <span class="string">"lovejquery"</span>: <span class="string">"yes"</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>Autofill</strong> the form with data ? just do</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$(<span class="string">"#f"</span>).autofill( data );</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;form表单的快速回显&quot;&gt;&lt;a href=&quot;#form表单的快速回显&quot; class=&quot;headerlink&quot; title=&quot;form表单的快速回显&quot;&gt;&lt;/a&gt;form表单的快速回显&lt;/h1&gt;&lt;p&gt;做项目开发的时候在写修改的页面时,如果字段很多的话,数据回显塞值挺麻烦的,所以最近找了一个formfill.js快速填充表单的js&lt;/p&gt;
&lt;p&gt;使用起来很简单,首先引用js文件&lt;br&gt;
    
    </summary>
    
      <category term="前端" scheme="http://yoursite.com/categories/%E5%89%8D%E7%AB%AF/"/>
    
    
      <category term="jquery" scheme="http://yoursite.com/tags/jquery/"/>
    
      <category term="formautofill" scheme="http://yoursite.com/tags/formautofill/"/>
    
  </entry>
  
  <entry>
    <title>技术交流文章</title>
    <link href="http://yoursite.com/2018/03/02/%E6%8A%80%E6%9C%AF%E4%BA%A4%E6%B5%81%E6%96%87%E7%AB%A0/"/>
    <id>http://yoursite.com/2018/03/02/技术交流文章/</id>
    <published>2018-03-02T06:25:39.000Z</published>
    <updated>2018-03-02T15:53:02.857Z</updated>
    
    <content type="html"><![CDATA[<h1 id="站长留言-置顶博文"><a href="#站长留言-置顶博文" class="headerlink" title="站长留言(置顶博文)"></a>站长留言(置顶博文)</h1><h3 id="你好-朋友-如果你有神马想和我说的请留言-可以在此处评论留言也可以发送邮件至我的邮箱"><a href="#你好-朋友-如果你有神马想和我说的请留言-可以在此处评论留言也可以发送邮件至我的邮箱" class="headerlink" title="你好,朋友!如果你有神马想和我说的请留言,可以在此处评论留言也可以发送邮件至我的邮箱:"></a>你好,朋友!如果你有神马想和我说的请留言,可以在此处评论留言也可以发送邮件至我的邮箱:</h3><h2 id="fashionkillyou-foxmail-com"><a href="#fashionkillyou-foxmail-com" class="headerlink" title="fashionkillyou@foxmail.com"></a>fashionkillyou@foxmail.com</h2><h3 id="请大家多多支持-多多指教-持续更新中…"><a href="#请大家多多支持-多多指教-持续更新中…" class="headerlink" title="请大家多多支持,多多指教!持续更新中…"></a>请大家多多支持,多多指教!持续更新中…</h3>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;站长留言-置顶博文&quot;&gt;&lt;a href=&quot;#站长留言-置顶博文&quot; class=&quot;headerlink&quot; title=&quot;站长留言(置顶博文)&quot;&gt;&lt;/a&gt;站长留言(置顶博文)&lt;/h1&gt;&lt;h3 id=&quot;你好-朋友-如果你有神马想和我说的请留言-可以在此处评论留言也可以发送
      
    
    </summary>
    
      <category term="站长留言" scheme="http://yoursite.com/categories/%E7%AB%99%E9%95%BF%E7%95%99%E8%A8%80/"/>
    
    
      <category term="站长留言" scheme="http://yoursite.com/tags/%E7%AB%99%E9%95%BF%E7%95%99%E8%A8%80/"/>
    
  </entry>
  
  <entry>
    <title>SpringMVC架构入门二</title>
    <link href="http://yoursite.com/2018/03/01/SpringMVC%E6%9E%B6%E6%9E%84%E5%85%A5%E9%97%A8%E4%BA%8C/"/>
    <id>http://yoursite.com/2018/03/01/SpringMVC架构入门二/</id>
    <published>2018-02-28T16:10:20.000Z</published>
    <updated>2018-03-01T12:56:11.029Z</updated>
    
    <content type="html"><![CDATA[<h1 id="高级参数绑定"><a href="#高级参数绑定" class="headerlink" title="高级参数绑定"></a>高级参数绑定</h1><h2 id="绑定数组"><a href="#绑定数组" class="headerlink" title="绑定数组"></a>绑定数组</h2><p>Controller方法中可以用String[]接收，或者pojo的String[]属性接收。两种方式任选其一即可。<br><a id="more"></a><br>使用String[]:</p><pre><code>@RequestMapping(&quot;/queryitem&quot;)public String queryItem(Query queryVo, String[] ids) {    System.out.println(queryVo.getItems().getName());    System.out.println(queryVo.getItems().getPrice());    System.out.println(ids.toString());    return null;}</code></pre><p>pojo的String[]:</p><pre><code>public class Query{    private Items items;    private String[] ids;    get/set...}</code></pre><h2 id="将表单的数据绑定到List"><a href="#将表单的数据绑定到List" class="headerlink" title="将表单的数据绑定到List"></a>将表单的数据绑定到List</h2><p>List中存放对象，并将定义的List放在包装类中，使用包装pojo对象接收。</p><pre><code>public class Query{    private Items items;    private String[] ids;    private List&lt;Items&gt; itemList;    get/set...}</code></pre><p>jsp页面:</p><pre><code>&lt;tr&gt;    &lt;td&gt;        &lt;input type=&quot;text&quot; name=&quot; itemsList[0].id&quot; value=&quot;${item.id}&quot;/&gt;    &lt;/td&gt;    &lt;td&gt;        &lt;input type=&quot;text&quot; name=&quot; itemsList[0].name&quot; value=&quot;${item.name }&quot;/&gt;    &lt;/td&gt;    &lt;td&gt;        &lt;input type=&quot;text&quot; name=&quot; itemsList[0].price&quot; value=&quot;${item.price}&quot;/&gt;    &lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;    &lt;td&gt;        &lt;input type=&quot;text&quot; name=&quot; itemsList[1].id&quot; value=&quot;${item.id}&quot;/&gt;    &lt;/td&gt;    &lt;td&gt;        &lt;input type=&quot;text&quot; name=&quot; itemsList[1].name&quot; value=&quot;${item.name }&quot;/&gt;    &lt;/td&gt;    &lt;td&gt;        &lt;input type=&quot;text&quot; name=&quot; itemsList[1].price&quot; value=&quot;${item.price}&quot;/&gt;    &lt;/td&gt;&lt;/tr&gt;</code></pre><p>Name属性必须是包装pojo的list属性+下标+元素属性。</p><p>Jsp做如下改造：</p><pre><code>&lt;c:forEach items=&quot;${itemList }&quot; var=&quot;item&quot;&gt;&lt;tr&gt;    &lt;td&gt;        &lt;input name=&quot;ids&quot; value=&quot;${item.id}&quot; type=&quot;checkbox&quot;&gt;&lt;/td&gt;    &lt;td&gt;        &lt;input name=&quot;id&quot; value=&quot;${item.id}&quot; type=&quot;hidden&quot;&gt;        &lt;input name=&quot;name&quot; value=&quot;${item.name }&quot; type=&quot;text&quot;&gt;    &lt;/td&gt;    &lt;td&gt;        &lt;input name=&quot;name&quot; value=&quot;${item.price }&quot; type=&quot;text&quot;&gt;&lt;/td&gt;    &lt;td&gt;        &lt;input name=&quot;name&quot; value=&quot;&lt;fmt:formatDate value=&quot;${item.createtime}&quot; pattern=&quot;yyyy-MM-dd HH:mm:ss&quot;/&gt;&quot; type=&quot;text&quot;&gt;&lt;/td&gt;    &lt;td&gt;        &lt;input name=&quot;name&quot; value=&quot;${item.detail }&quot; type=&quot;text&quot;&gt;&lt;/td&gt;    &lt;td&gt;        &lt;a href=&quot;${pageContext.request.contextPath }/itemEdit.action?id=${item.id}&quot;&gt;修改&lt;/a&gt;    &lt;/td&gt;&lt;/tr&gt;&lt;/c:forEach&gt;</code></pre><p>varStatus属性常用参数总结下：</p><pre><code>${status.index}      输出行号，从0开始。${status.count}      输出行号，从1开始。${status.current}   当前这次迭代的（集合中的）项${status.first}  判断当前项是否为集合中的第一项，返回值为true或false${status.last}   判断当前项是否为集合中的最后一项，返回值为true或falsebegin、end、step分别表示：起始序号，结束序号，跳跃步伐。</code></pre><p>Contrller</p><pre><code>@RequestMapping(&quot;/queryitem&quot;)public String queryItem(QueryVo queryVo, String[] ids) {    System.out.println(queryVo.getItems().getName());    System.out.println(queryVo.getItems().getPrice());    System.out.println(ids.toString());    return null;}</code></pre><p>注意：接收List类型的数据必须是pojo的属性，方法的形参为List类型无法正确接收到数据。</p><h1 id="RequestMapping"><a href="#RequestMapping" class="headerlink" title="@RequestMapping"></a>@RequestMapping</h1><p>通过RequestMapping注解可以定义不同的处理器映射规则。</p><h2 id="URL路径映射"><a href="#URL路径映射" class="headerlink" title="URL路径映射"></a>URL路径映射</h2><p>@RequestMapping(value=”/item”)或@RequestMapping(“/item）<br>value的值是数组，可以将多个url映射到同一个方法</p><h2 id="窄化请求映射"><a href="#窄化请求映射" class="headerlink" title="窄化请求映射"></a>窄化请求映射</h2><p>在class上添加@RequestMapping(url)指定通用请求前缀， 限制此类下的所有方法请求url必须以请求前缀开头，通过此方法对url进行分类管理。</p><p>如下：</p><pre><code>@RequestMapping放在类名上边，设置请求前缀 @Controller@RequestMapping(&quot;/item&quot;)</code></pre><p>方法名上边设置请求映射url：</p><pre><code>@RequestMapping放在方法名上边，如下：@RequestMapping(&quot;/queryItem &quot;)</code></pre><p>访问地址为：/item/queryItem</p><h2 id="请求方法限定"><a href="#请求方法限定" class="headerlink" title="请求方法限定"></a>请求方法限定</h2><h3 id="限定GET方法"><a href="#限定GET方法" class="headerlink" title="限定GET方法"></a>限定GET方法</h3><pre><code>@RequestMapping(method = RequestMethod.GET)</code></pre><p>如果通过Post访问则报错：<br>HTTP Status 405 - Request method ‘POST’ not supported</p><p>例如：</p><pre><code>@RequestMapping(value=&quot;/editItem&quot;,method=RequestMethod.GET)</code></pre><h3 id="限定POST方法"><a href="#限定POST方法" class="headerlink" title="限定POST方法"></a>限定POST方法</h3><pre><code>@RequestMapping(method = RequestMethod.POST)</code></pre><p>如果通过Post访问则报错：<br>HTTP Status 405 - Request method ‘GET’ not supported</p><h3 id="GET和POST都可以"><a href="#GET和POST都可以" class="headerlink" title="GET和POST都可以"></a>GET和POST都可以</h3><pre><code>@RequestMapping(method={RequestMethod.GET,RequestMethod.POST})</code></pre><h1 id="controller方法返回值"><a href="#controller方法返回值" class="headerlink" title="controller方法返回值"></a>controller方法返回值</h1><h2 id="返回ModelAndView"><a href="#返回ModelAndView" class="headerlink" title="返回ModelAndView"></a>返回ModelAndView</h2><p>controller方法中定义ModelAndView对象并返回，对象中可添加model数据、指定view。</p><h2 id="返回void"><a href="#返回void" class="headerlink" title="返回void"></a>返回void</h2><p>在controller方法形参上可以定义request和response，使用request或response指定响应结果：</p><p>1、使用request转向页面，如下：</p><pre><code>request.getRequestDispatcher(&quot;页面路径&quot;).forward(request, response);</code></pre><p>2、也可以通过response页面重定向：</p><pre><code>response.sendRedirect(&quot;url&quot;)</code></pre><p>3、也可以通过response指定响应结果，例如响应json数据如下：</p><pre><code>response.setCharacterEncoding(&quot;utf-8&quot;);response.setContentType(&quot;application/json;charset=utf-8&quot;);response.getWriter().write(&quot;json串&quot;);</code></pre><h2 id="返回字符串"><a href="#返回字符串" class="headerlink" title="返回字符串"></a>返回字符串</h2><h3 id="逻辑视图名"><a href="#逻辑视图名" class="headerlink" title="逻辑视图名"></a>逻辑视图名</h3><p>controller方法返回字符串可以指定逻辑视图名，通过视图解析器解析为物理视图地址。</p><pre><code>//指定逻辑视图名，经过视图解析器解析为jsp物理路径：/WEB-INF/jsp/item/editItem.jspreturn &quot;item/editItem&quot;;</code></pre><h3 id="Redirect重定向"><a href="#Redirect重定向" class="headerlink" title="Redirect重定向"></a>Redirect重定向</h3><p>Contrller方法返回结果重定向到一个url地址，如下商品修改提交后重定向到商品查询方法，参数无法带到商品查询方法中。</p><pre><code>//重定向到queryItem.action地址,request无法带过去return &quot;redirect:queryItem.action&quot;;</code></pre><p>redirect方式相当于“response.sendRedirect()”，转发后浏览器的地址栏变为转发后的地址，因为转发即执行了一个新的request和response。<br>由于新发起一个request原来的参数在转发时就不能传递到下一个url，如果要传参数可以/item/queryItem.action后边加参数，如下：</p><pre><code>/item/queryItem?...&amp;…..</code></pre><p>如果使用了model的话,他会自动给你拼接数据,就是自动在后面拼接?</p><h3 id="forward转发"><a href="#forward转发" class="headerlink" title="forward转发"></a>forward转发</h3><p>controller方法执行后继续执行另一个controller方法，如下商品修改提交后转向到商品修改页面，修改商品的id参数可以带到商品修改方法中。</p><pre><code>//结果转发到editItem.action，request可以带过去return &quot;forward:editItem.action&quot;;</code></pre><p>forward方式相当于“request.getRequestDispatcher().forward(request,response)”，转发后浏览器地址栏还是原来的地址。转发并没有执行新的request和response，而是和转发前的请求共用一个request和response。所以转发前请求的参数在转发后仍然可以读取到。</p><h1 id="异常处理器"><a href="#异常处理器" class="headerlink" title="异常处理器"></a>异常处理器</h1><p>springmvc在处理请求过程中出现异常信息交由异常处理器进行处理，自定义异常处理器可以实现一个系统的异常处理逻辑。</p><h2 id="异常处理思路"><a href="#异常处理思路" class="headerlink" title="异常处理思路"></a>异常处理思路</h2><p>系统中异常包括两类：预期异常和运行时异常RuntimeException，前者通过捕获异常从而获取异常信息，后者主要通过规范代码开发、测试通过手段减少运行时异常的发生。</p><p>系统的dao、service、controller出现都通过throws Exception向上抛出，最后由springmvc前端控制器交由异常处理器进行异常处理</p><p>步骤:写异常处理器类,然后在springmvc.xml中配置,然后写异常错误页面</p><h2 id="自定义异常处理器"><a href="#自定义异常处理器" class="headerlink" title="自定义异常处理器"></a>自定义异常处理器</h2><pre><code>public class CustomExceptionResolver implements HandlerExceptionResolver {    @Override    public ModelAndView resolveException(HttpServletRequest request,            HttpServletResponse response, Object handler, Exception ex) {        ex.printStackTrace();        CustomException customException = null;        //如果抛出的是系统自定义异常则直接转换        if(ex instanceof CustomException){            customException = (CustomException)ex;        }else{            //如果抛出的不是系统自定义异常则重新构造一个系统错误异常。            customException = new CustomException(&quot;系统错误，请与系统管理 员联系！&quot;);        }        ModelAndView modelAndView = new ModelAndView();        modelAndView.addObject(&quot;message&quot;, customException.getMessage());        modelAndView.setViewName(&quot;error&quot;);        return modelAndView;    }}</code></pre><p>###取异常堆栈：</p><pre><code>//错误信息存储在堆栈中,取异常堆栈将其显示在控制台上,或输出到日志文件中       try {        } catch (Exception e) {            StringWriter s = new StringWriter();            PrintWriter printWriter = new PrintWriter(s);            e.printStackTrace(printWriter);            s.toString();        }</code></pre><h2 id="错误页面"><a href="#错误页面" class="headerlink" title="错误页面"></a>错误页面</h2><pre><code>&lt;%@ page language=&quot;java&quot; contentType=&quot;text/html; charset=UTF-8&quot;    pageEncoding=&quot;UTF-8&quot;%&gt;&lt;%@ taglib uri=&quot;http://java.sun.com/jsp/jstl/core&quot; prefix=&quot;c&quot; %&gt;&lt;%@ taglib uri=&quot;http://java.sun.com/jsp/jstl/fmt&quot;  prefix=&quot;fmt&quot;%&gt; &lt;!DOCTYPE html PUBLIC &quot;-//W3C//DTD HTML 4.01 Transitional//EN&quot; &quot;http://www.w3.org/TR/html4/loose.dtd&quot;&gt;&lt;html&gt;&lt;head&gt;&lt;meta http-equiv=&quot;Content-Type&quot; content=&quot;text/html; charset=UTF-8&quot;&gt;&lt;title&gt;错误页面&lt;/title&gt;&lt;/head&gt;&lt;body&gt;您的操作出现错误如下：&lt;br/&gt;${message }&lt;/body&gt;&lt;/html&gt;</code></pre><h2 id="异常处理器配置"><a href="#异常处理器配置" class="headerlink" title="异常处理器配置"></a>异常处理器配置</h2><p>在springmvc.xml中添加：</p><pre><code>&lt;!-- 全局异常处理器 --&gt;&lt;bean class=&quot;com.lxm.springmvc.exception.GlobalExceptionResolver&quot;/&gt;</code></pre><h2 id="测试异常"><a href="#测试异常" class="headerlink" title="测试异常"></a>测试异常</h2><p>在需要抛出异常的地方加上throw new CustomerException(“出错信息”);然后方法上向上抛出就可以了</p><pre><code>@RequestMapping(&quot;/itemEdit&quot;)public String getEditItem(@RequestParam(value=&quot;id&quot;,required=true)Integer id,Model model) throws CustomerException{    Items items = itemService.getItemById(id);    if(items == null){        throw new CustomerException(&quot;商品信息不存在!&quot;);    }    model.addAttribute(&quot;item&quot;,items);    return &quot;editItem&quot;;}</code></pre><h1 id="上传图片"><a href="#上传图片" class="headerlink" title="上传图片"></a>上传图片</h1><h2 id="配置虚拟目录"><a href="#配置虚拟目录" class="headerlink" title="配置虚拟目录"></a>配置虚拟目录</h2><p>在tomcat上配置图片虚拟目录，在tomcat下conf/server.xml中添加：</p><pre><code>&lt;Context docBase=&quot;F:\develop\upload\temp&quot; path=&quot;/pic&quot; reloadable=&quot;false&quot;/&gt;</code></pre><p>访问<a href="http://localhost:8080/pic即可访问F:\develop\upload\temp下的图片。" target="_blank" rel="noopener">http://localhost:8080/pic即可访问F:\develop\upload\temp下的图片。</a></p><p>也可以通过eclipse配置：</p><p>1:在tomcat服务配置里面有个modules,<br>点击AddExternalWebModule</p><p>2:然后在Documentbase里面填写虚拟路径的绝对路径(例如:F:\develop\upload\temp),</p><p>3:在Path里面填写虚拟路径(例如:/pic)</p><p>4:AutoReload(这个根据需要自行设定,以下是作用,一般设置为disabled就可以)</p><pre><code>在eclipse中集成tomca来开发时,如果使用run as模式启动项目的话,tomcat配置Auto reloading enabled,我们修改java文件,项目会重新加载,修改的内容会生效.如果使用debug as 模式启动项目的话,tomcat不要配置Auto reloading enabled,我们修改的java文件,也会生效.注意:在debug模式下,tomcat配置了Auto reloading enabled,当修改了java文件,项目会报错.</code></pre><h2 id="jar包"><a href="#jar包" class="headerlink" title="jar包"></a>jar包</h2><p>CommonsMultipartResolver解析器依赖:</p><pre><code>commons-fileuploadcommons-io</code></pre><h2 id="配置解析器"><a href="#配置解析器" class="headerlink" title="配置解析器"></a>配置解析器</h2><p>springmvc.xml</p><pre><code>&lt;!-- 文件上传 --&gt;&lt;bean id=&quot;multipartResolver&quot;    class=&quot;org.springframework.web.multipart.commons.CommonsMultipartResolver&quot;&gt;    &lt;!-- 设置上传文件的最大尺寸为5MB --&gt;    &lt;property name=&quot;maxUploadSize&quot;&gt;        &lt;value&gt;5242880&lt;/value&gt;    &lt;/property&gt;&lt;/bean&gt;</code></pre><h2 id="图片上传"><a href="#图片上传" class="headerlink" title="图片上传"></a>图片上传</h2><p>controller：</p><pre><code>@RequestMapping(&quot;/updateitem&quot;)public String updateItem(Items items,MultipartFile pictureFile) throws Exception, IOException{    //把图片保存到图片目录下    //为每个文件生成一个新的文件名    String picName = UUID.randomUUID().toString();    //去文件的扩展名    String oriName = pictureFile.getOriginalFilename();    System.out.println(&quot;oriName&quot;+oriName);    if(oriName!=null &amp;&amp; oriName!=&quot;&quot;){        String extName = oriName.substring(oriName.lastIndexOf(&quot;.&quot;));        System.out.println(&quot;extName&quot;+extName);        //保存文件 d:\picture\temp        pictureFile.transferTo(new File(&quot;d:\\picture\\temp\\&quot;+picName+extName));        //把文件名保存到数据库        items.setPic(picName+extName);    }    itemService.updateItem(items);//        return &quot;forward:/itemList.action?items=&quot;+items;//转发是可以传递对象的    return &quot;forward:/itemList.action&quot;;}</code></pre><h2 id="页面："><a href="#页面：" class="headerlink" title="页面："></a>页面：</h2><pre><code>form添加enctype=&quot;multipart/form-data&quot;：&lt;form id=&quot;itemForm&quot;action=&quot;${pageContext.request.contextPath }/item/editItemSubmit.action&quot;    method=&quot;post&quot; enctype=&quot;multipart/form-data&quot;&gt;    &lt;input type=&quot;hidden&quot; name=&quot;pic&quot; value=&quot;${item.pic }&quot; /&gt;file的name与controller形参一致：&lt;tr&gt;    &lt;td&gt;商品图片&lt;/td&gt;    &lt;td&gt;&lt;c:if test=&quot;${item.pic !=null}&quot;&gt;            &lt;img src=&quot;/pic/${item.pic}&quot; width=100 height=100 /&gt;            &lt;br /&gt;        &lt;/c:if&gt; &lt;input type=&quot;file&quot; name=&quot;pictureFile&quot; /&gt;&lt;/td&gt;&lt;/tr&gt;</code></pre><h1 id="json数据交互"><a href="#json数据交互" class="headerlink" title="json数据交互"></a>json数据交互</h1><h2 id="RequestBody"><a href="#RequestBody" class="headerlink" title="@RequestBody"></a>@RequestBody</h2><p>作用：</p><p>@RequestBody注解用于读取http请求的内容(字符串)，通过springmvc提供的HttpMessageConverter接口将读到的内容转换为json、xml等格式的数据并绑定到controller方法的参数上。</p><p>List.action?id=1&amp;name=zhangsan&amp;age=12</p><p>本例子应用：</p><p>@RequestBody注解实现接收http请求的json数据，将json数据转换为java对象</p><h2 id="ResponseBody"><a href="#ResponseBody" class="headerlink" title="@ResponseBody"></a>@ResponseBody</h2><p>作用：</p><p>该注解用于将Controller的方法返回的对象，通过HttpMessageConverter接口转换为指定格式的数据如：json,xml等，通过Response响应给客户端</p><p>本例子应用：</p><p>@ResponseBody注解实现将controller方法返回对象转换为json响应给客户端</p><h2 id="请求json，响应json实现："><a href="#请求json，响应json实现：" class="headerlink" title="请求json，响应json实现："></a>请求json，响应json实现：</h2><h3 id="环境准备"><a href="#环境准备" class="headerlink" title="环境准备"></a>环境准备</h3><p>Springmvc默认用MappingJacksonHttpMessageConverter对json数据进行转换，需要加入jackson的包，</p><pre><code>jackson-annotations-2.4.0.jarjackson-core-2.4.2.jarjackson-databind-2.4.2.jar</code></pre><h3 id="配置json转换器"><a href="#配置json转换器" class="headerlink" title="配置json转换器"></a>配置json转换器</h3><p>在注解适配器中加入messageConverters</p><pre><code>&lt;!--注解适配器 --&gt;&lt;bean class=&quot;org.springframework.web.servlet.mvc.method.annotation.RequestMappingHandlerAdapter&quot;&gt;    &lt;property name=&quot;messageConverters&quot;&gt;    &lt;list&gt;    &lt;bean class=&quot;org.springframework.http.converter.json.MappingJacksonHttpMessageConverter&quot;&gt;&lt;/bean&gt;    &lt;/list&gt;    &lt;/property&gt;&lt;/bean&gt;</code></pre><p>注意：如果使用<mvc:annotation-driven> 则不用定义上边的内容。</mvc:annotation-driven></p><h3 id="controller编写"><a href="#controller编写" class="headerlink" title="controller编写"></a>controller编写</h3><pre><code>// 商品修改提交json信息，响应json信息@RequestMapping(&quot;/editItemSubmit_RequestJson&quot;)public @ResponseBody Items editItemSubmit_RequestJson(@RequestBody Items items) throws Exception {    System.out.println(items);    //itemService.saveItem(items);    return items;}</code></pre><h3 id="页面js方法编写："><a href="#页面js方法编写：" class="headerlink" title="页面js方法编写："></a>页面js方法编写：</h3><p>引入 js：<br>    <script type="text/javascript" src="${pageContext.request.contextPath }/js/jquery-1.4.4.min.js"></script></p><pre><code>//请求json响应jsonfunction request_json(){    $.ajax({        type:&quot;post&quot;,        url:&quot;${pageContext.request.contextPath }/item/editItemSubmit_RequestJson.action&quot;,        contentType:&quot;application/json;charset=utf-8&quot;,        data:&apos;{&quot;name&quot;:&quot;测试商品&quot;,&quot;price&quot;:99.9}&apos;,        success:function(data){            alert(data);        }    });}</code></pre>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;高级参数绑定&quot;&gt;&lt;a href=&quot;#高级参数绑定&quot; class=&quot;headerlink&quot; title=&quot;高级参数绑定&quot;&gt;&lt;/a&gt;高级参数绑定&lt;/h1&gt;&lt;h2 id=&quot;绑定数组&quot;&gt;&lt;a href=&quot;#绑定数组&quot; class=&quot;headerlink&quot; title=&quot;绑定数组&quot;&gt;&lt;/a&gt;绑定数组&lt;/h2&gt;&lt;p&gt;Controller方法中可以用String[]接收，或者pojo的String[]属性接收。两种方式任选其一即可。&lt;br&gt;
    
    </summary>
    
      <category term="java" scheme="http://yoursite.com/categories/java/"/>
    
    
      <category term="SpringMVC" scheme="http://yoursite.com/tags/SpringMVC/"/>
    
      <category term="SpringWebMVC" scheme="http://yoursite.com/tags/SpringWebMVC/"/>
    
  </entry>
  
  <entry>
    <title>SpringMVC架构入门一</title>
    <link href="http://yoursite.com/2018/02/27/SpringMVC%E6%9E%B6%E6%9E%84%E5%85%A5%E9%97%A8%E4%B8%80/"/>
    <id>http://yoursite.com/2018/02/27/SpringMVC架构入门一/</id>
    <published>2018-02-27T10:58:33.000Z</published>
    <updated>2018-02-28T16:57:03.167Z</updated>
    
    <content type="html"><![CDATA[<h1 id="SpringMVC架构"><a href="#SpringMVC架构" class="headerlink" title="SpringMVC架构"></a>SpringMVC架构</h1><p>Spring web mvc和Struts2都属于表现层的框架,它是Spring框架的一部分.</p><h2 id="架构流程"><a href="#架构流程" class="headerlink" title="架构流程"></a>架构流程</h2><pre><code>1、    用户发送请求至前端控制器DispatcherServlet2、    DispatcherServlet收到请求调用HandlerMapping处理器映射器。3、    处理器映射器根据请求url找到具体的处理器，生成处理器对象及处理器拦截器(如果有则生成)一并返回给DispatcherServlet。4、    DispatcherServlet通过HandlerAdapter处理器适配器调用处理器5、    执行处理器(Controller，也叫后端控制器)。6、    Controller执行完成返回ModelAndView7、    HandlerAdapter将controller执行结果ModelAndView返回给DispatcherServlet8、    DispatcherServlet将ModelAndView传给ViewReslover视图解析器9、    ViewReslover解析后返回具体View10、    DispatcherServlet对View进行渲染视图（即将模型数据填充至视图中）。11、    DispatcherServlet响应用户</code></pre><a id="more"></a><h2 id="组件说明"><a href="#组件说明" class="headerlink" title="组件说明"></a>组件说明</h2><p>以下组件通常使用框架提供实现：</p><ul><li><p>DispatcherServlet：前端控制器</p><p>  用户请求到达前端控制器，它就相当于mvc模式中的c，dispatcherServlet是整个流程控制的中心，由它调用其它组件处理用户的请求，dispatcherServlet的存在降低了组件之间的耦合性。</p></li><li><p>HandlerMapping：处理器映射器</p><p>  HandlerMapping负责根据用户请求找到Handler即处理器，springmvc提供了不同的映射器实现不同的映射方式，例如：配置文件方式，实现接口方式，注解方式等。</p></li><li><p>Handler：处理器</p><p>  Handler 是继DispatcherServlet前端控制器的后端控制器，在DispatcherServlet的控制下Handler对具体的用户请求进行处理。<br>  由于Handler涉及到具体的用户业务请求，所以一般情况需要程序员根据业务需求开发Handler。</p></li><li><p>HandlAdapter：处理器适配器</p><p>  通过HandlerAdapter对处理器进行执行，这是适配器模式的应用，通过扩展适配器可以对更多类型的处理器进行执行。</p></li><li><p>View Resolver：视图解析器</p><p>  View Resolver负责将处理结果生成View视图，View Resolver首先根据逻辑视图名解析成物理视图名即具体的页面地址，再生成View视图对象，最后对View进行渲染将处理结果通过页面展示给用户。 </p></li><li><p>View：视图</p><p>  springmvc框架提供了很多的View视图类型的支持，包括：jstlView、freemarkerView、pdfView等。我们最常用的视图就是jsp。<br>  一般情况下需要通过页面标签或页面模版技术将模型数据通过页面展示给用户，需要由程序员根据业务需求开发具体的页面。</p></li></ul><p>说明：在springmvc的各个组件中，<strong>处理器映射器</strong>、<strong>处理器适配器</strong>、<strong>视图解析器</strong>称为springmvc的三大组件。</p><p>需要用户开放的组件有<strong>handler、view</strong></p><h2 id="注解映射器和适配器"><a href="#注解映射器和适配器" class="headerlink" title="注解映射器和适配器"></a>注解映射器和适配器</h2><h3 id="组件扫描器"><a href="#组件扫描器" class="headerlink" title="组件扫描器"></a>组件扫描器</h3><p>使用组件扫描器省去在spring容器配置每个controller类的繁琐。使用<context:component-scan>自动扫描标记@controller的控制器类，配置如下：</context:component-scan></p><pre><code>&lt;!-- 扫描controller注解,多个包中间使用半角逗号分隔 --&gt;&lt;context:component-scan base-package=&quot;cn.lxm.springmvc.controller.first&quot;/&gt;</code></pre><h3 id="RequestMappingHandlerMapping"><a href="#RequestMappingHandlerMapping" class="headerlink" title="RequestMappingHandlerMapping"></a>RequestMappingHandlerMapping</h3><p>注解式处理器映射器，对类中标记@ResquestMapping的方法进行映射，根据ResquestMapping定义的url匹配ResquestMapping标记的方法，匹配成功返回HandlerMethod对象给前端控制器，HandlerMethod对象中封装url对应的方法Method。 </p><p>从spring3.1版本开始，废除了DefaultAnnotationHandlerMapping的使用，推荐使用RequestMappingHandlerMapping完成注解式处理器映射。</p><p>配置如下：</p><pre><code>&lt;!--注解映射器 --&gt;&lt;bean class=&quot;org.springframework.web.servlet.mvc.method.annotation.RequestMappingHandlerMapping&quot;/&gt;</code></pre><p>注解描述：<br>@RequestMapping：定义请求url到处理器功能方法的映射</p><h3 id="RequestMappingHandlerAdapter"><a href="#RequestMappingHandlerAdapter" class="headerlink" title="RequestMappingHandlerAdapter"></a>RequestMappingHandlerAdapter</h3><p>注解式处理器适配器，对标记@ResquestMapping的方法进行适配。</p><p>从spring3.1版本开始，废除了AnnotationMethodHandlerAdapter的使用，推荐使用RequestMappingHandlerAdapter完成注解式处理器适配。</p><p>配置如下：</p><pre><code>&lt;!--注解适配器 --&gt;&lt;bean class=&quot;org.springframework.web.servlet.mvc.method.annotation.RequestMappingHandlerAdapter&quot;/&gt;</code></pre><h3 id=""><a href="#" class="headerlink" title=""></a><mvc:annotation-driven></mvc:annotation-driven></h3><p>springmvc使用<mvc:annotation-driven>自动加载RequestMappingHandlerMapping和RequestMappingHandlerAdapter，可用在springmvc.xml配置文件中使用<mvc:annotation-driven>替代注解处理器和适配器的配置。</mvc:annotation-driven></mvc:annotation-driven></p><h2 id="视图解析器"><a href="#视图解析器" class="headerlink" title="视图解析器"></a>视图解析器</h2><p>在springmvc.xml文件配置如下：</p><pre><code>&lt;bean class=&quot;org.springframework.web.servlet.view.InternalResourceViewResolver&quot;&gt;    &lt;property name=&quot;viewClass&quot;        value=&quot;org.springframework.web.servlet.view.JstlView&quot; /&gt;    &lt;property name=&quot;prefix&quot; value=&quot;/WEB-INF/jsp/&quot; /&gt;    &lt;property name=&quot;suffix&quot; value=&quot;.jsp&quot; /&gt;&lt;/bean&gt;</code></pre><p>InternalResourceViewResolver：支持JSP视图解析</p><p>viewClass：JstlView表示JSP模板页面需要使用JSTL标签库，所以classpath中必须包含jstl的相关jar 包。此属性可以不设置，默认为JstlView。</p><p>prefix 和suffix：查找视图页面的前缀和后缀，最终视图的地址为：<br>前缀+逻辑视图名+后缀，逻辑视图名需要在controller中返回ModelAndView指定，比如逻辑视图名为hello，则最终返回的jsp视图地址 “WEB-INF/jsp/hello.jsp”</p><h1 id="整合mybatis"><a href="#整合mybatis" class="headerlink" title="整合mybatis"></a>整合mybatis</h1><p>ssm框架:springmvc + spring + mybatis</p><p>控制层采用springmvc、持久层使用mybatis实现。</p><h2 id="准备jar包"><a href="#准备jar包" class="headerlink" title="准备jar包"></a>准备jar包</h2><p>spring（包括springmvc）、mybatis、mybatis-spring整合包、数据库驱动、第三方连接池。</p><h2 id="整合思路"><a href="#整合思路" class="headerlink" title="整合思路"></a>整合思路</h2><h3 id="Dao层："><a href="#Dao层：" class="headerlink" title="Dao层："></a>Dao层：</h3><p>1、SqlMapConfig.xml</p><pre><code>空文件即可。需要文件头。</code></pre><p>2、applicationContext-dao.xml。</p><pre><code>a)    数据库连接池b)    SqlSessionFactory对象，需要spring和mybatis整合包下的。c)    配置mapper文件扫描器。</code></pre><h3 id="Service层："><a href="#Service层：" class="headerlink" title="Service层："></a>Service层：</h3><p>1、applicationContext-service.xml</p><pre><code>包扫描器，扫描@service注解的类。</code></pre><p>2、applicationContext-trans.xml</p><pre><code>配置事务。</code></pre><h3 id="表现层："><a href="#表现层：" class="headerlink" title="表现层："></a>表现层：</h3><p>Springmvc.xml</p><pre><code>1、包扫描器，扫描@Controller注解的类。2、配置注解驱动。3、视图解析器</code></pre><p>Web.xml</p><pre><code>配置前端控制器。</code></pre><h1 id="参数绑定"><a href="#参数绑定" class="headerlink" title="参数绑定"></a>参数绑定</h1><h2 id="Controller参数绑定"><a href="#Controller参数绑定" class="headerlink" title="Controller参数绑定"></a>Controller参数绑定</h2><p>要根据id查询商品数据，需要从请求的参数中把请求的id取出来。Id应该包含在Request对象中。可以从Request对象中取id。</p><pre><code>@RequestMapping(&quot;/itemEdit&quot;)public ModelAndView itemEdit(HttpServletRequest request) {    //从Request中取id    String strId = request.getParameter(&quot;id&quot;);    Integer id = null;    //如果id有值则转换成int类型    if (strId != null &amp;&amp; !&quot;&quot;.equals(strId)) {        id = new Integer(strId);    } else {        //出错        return null;    }    Items items = itemService.getItemById(id);    //创建ModelAndView    ModelAndView modelAndView = new ModelAndView();    //向jsp传递数据    modelAndView.addObject(&quot;item&quot;, items);    //设置跳转的jsp页面    modelAndView.setViewName(&quot;editItem&quot;);    return modelAndView;}</code></pre><p>如果想获得Request对象只需要在Controller方法的形参中添加一个参数即可。Springmvc框架会自动把Request对象传递给方法。</p><h2 id="Service"><a href="#Service" class="headerlink" title="Service"></a>Service</h2><pre><code>@Overridepublic Items getItemById(int id) {    Items items = itemsMapper.selectByPrimaryKey(id);    return items;}</code></pre><h2 id="默认支持的参数类型"><a href="#默认支持的参数类型" class="headerlink" title="默认支持的参数类型"></a>默认支持的参数类型</h2><p>处理器形参中添加如下类型的参数处理适配器会默认识别并进行赋值。</p><h3 id="HttpServletRequest"><a href="#HttpServletRequest" class="headerlink" title="HttpServletRequest"></a>HttpServletRequest</h3><p>通过request对象获取请求信息</p><h3 id="HttpServletResponse"><a href="#HttpServletResponse" class="headerlink" title="HttpServletResponse"></a>HttpServletResponse</h3><p>通过response处理响应信息</p><h3 id="HttpSession"><a href="#HttpSession" class="headerlink" title="HttpSession"></a>HttpSession</h3><p>通过session对象得到session中存放的对象</p><h3 id="Model-ModelMap"><a href="#Model-ModelMap" class="headerlink" title="Model/ModelMap"></a>Model/ModelMap</h3><p>ModelMap是Model接口的实现类，通过Model或ModelMap向页面传递数据，如下：</p><pre><code>//调用service查询商品信息Items item = itemService.findItemById(id);model.addAttribute(&quot;item&quot;, item);</code></pre><p>页面通过${item.XXXX}获取item对象的属性值。</p><p>使用Model和ModelMap的效果一样，如果直接使用Model，springmvc会实例化ModelMap。</p><p>如果使用Model则可以不使用ModelAndView对象，Model对象可以向页面传递数据，View对象则可以使用String返回值替代。不管是Model还是ModelAndView，其本质都是使用Request对象向jsp传递数据。<br>如果使用Model则方法可以改造成：</p><pre><code>@RequestMapping(&quot;/itemEdit&quot;)public String itemEdit(HttpServletRequest request, Model model) {    //从Request中取id    String strId = request.getParameter(&quot;id&quot;);    Integer id = null;    //如果id有值则转换成int类型    if (strId != null &amp;&amp; !&quot;&quot;.equals(strId)) {        id = new Integer(strId);    } else {        //出错        return null;    }    Items items = itemService.getItemById(id);    //创建ModelAndView    //ModelAndView modelAndView = new ModelAndView();    //向jsp传递数据    //modelAndView.addObject(&quot;item&quot;, items);    model.addAttribute(&quot;item&quot;, items);    //设置跳转的jsp页面    //modelAndView.setViewName(&quot;editItem&quot;);    //return modelAndView;    return &quot;editItem&quot;;}</code></pre><h2 id="绑定简单类型"><a href="#绑定简单类型" class="headerlink" title="绑定简单类型"></a>绑定简单类型</h2><p>当请求的参数名称和处理器形参名称一致时会将请求参数与形参进行绑定。从Request取参数的方法可以进一步简化。</p><pre><code>@RequestMapping(&quot;/itemEdit&quot;)public String itemEdit(Integer id, Model model) {    Items items = itemService.getItemById(id);    //向jsp传递数据    model.addAttribute(&quot;item&quot;, items);    //设置跳转的jsp页面    return &quot;editItem&quot;;}</code></pre><h3 id="支持的数据类型"><a href="#支持的数据类型" class="headerlink" title="支持的数据类型"></a>支持的数据类型</h3><p>参数类型推荐使用包装数据类型，因为基础数据类型不可以为null</p><p>整形：Integer、int</p><p>字符串：String</p><p>单精度：Float、float</p><p>双精度：Double、double</p><p>布尔型：Boolean、boolean</p><p>说明：对于布尔类型的参数，请求的参数值为true或false。</p><p>处理器方法：</p><pre><code>public String editItem(Model model,Integer id,Boolean status) throws Exception</code></pre><p>请求url：</p><pre><code>http://localhost:8080/xxx.action?id=2&amp;status=false</code></pre><h3 id="RequestParam"><a href="#RequestParam" class="headerlink" title="@RequestParam"></a>@RequestParam</h3><p>使用@RequestParam常用于处理简单类型的绑定。</p><p>value：参数名字，即入参的请求参数名字，如value=“item_id”表示请求的参数区中的名字为item_id的参数的值将传入；</p><p>required：是否必须，默认是true，表示请求中一定要有相应的参数，否则将报；</p><p>TTP Status 400 - Required Integer parameter ‘XXXX’ is not present</p><p>defaultValue：默认值，表示如果请求中没有同名参数时的默认值</p><p>定义如下：</p><pre><code>public String editItem(@RequestParam(value=&quot;item_id&quot;,required=true) String id) {}</code></pre><p>形参名称为id，但是这里使用value=” item_id”限定请求的参数名为item_id，所以页面传递参数的名必须为item_id。</p><p>注意：如果请求参数中没有item_id将跑出异常：</p><pre><code>HTTP Status 500 - Required Integer parameter &apos;item_id&apos; is not present</code></pre><p>这里通过required=true限定item_id参数为必需传递，如果不传递则报400错误，可以使用defaultvalue设置默认值，即使required=true也可以不传item_id参数值</p><h2 id="绑定pojo类型"><a href="#绑定pojo类型" class="headerlink" title="绑定pojo类型"></a>绑定pojo类型</h2><h3 id="Controller"><a href="#Controller" class="headerlink" title="Controller:"></a>Controller:</h3><pre><code>@RequestMapping(&quot;/updateitem&quot;)public String updateItem(Items items){    itemService.updateItem(items);    return &quot;success&quot;;}</code></pre><h3 id="service"><a href="#service" class="headerlink" title="service"></a>service</h3><pre><code>@Overridepublic void updateItem(Items items) {    //ItemsExample example = new ItemsExample();    //如果example定义了两个字段，数据库共4个字段，则修改数据库的两个字段，其余两个字段改为null    //itemsMapper.updateByExample(items, example);    //成功,但是没有的值置为了null    //itemsMapper.updateByPrimaryKey(items);    //成功,但是没有的值置为了null    //itemsMapper.updateByPrimaryKeyWithBLOBs(items);    //和updateByExample相比此方法可以修改大字段类型，其余性质和updateByExample相同    //itemsMapper.updateByExampleWithBLOBs(items, example);    //如果example定义了两个字段，数据库共4个字段，则修改数据库的两个字段，其余两个字段不动    itemsMapper.updateByPrimaryKeySelective(items);}</code></pre><p>注意：提交的表单中不要有日期类型的数据，否则会报400错误。如果想提交日期类型的数据需要用到后面的自定义参数绑定的内容。</p><h2 id="解决日期参数问题"><a href="#解决日期参数问题" class="headerlink" title="解决日期参数问题:"></a>解决日期参数问题:</h2><h3 id="自定义Converter"><a href="#自定义Converter" class="headerlink" title="自定义Converter"></a>自定义Converter</h3><pre><code>import org.joda.time.DateTime;import org.joda.time.format.DateTimeFormat;import org.joda.time.format.DateTimeFormatter;import org.springframework.core.convert.converter.Converter;import org.springframework.util.StringUtils;import java.util.ArrayList;import java.util.Date;import java.util.List;/** * Created by Rock 2016/12/6. */public class DateConverter implements Converter&lt;String,Date&gt; {private static final List&lt;String&gt; formarts = new ArrayList&lt;&gt;(4);static {    formarts.add(&quot;yyyy-MM&quot;);    formarts.add(&quot;yyyy-MM-dd&quot;);    formarts.add(&quot;yyyy-MM-dd hh:mm&quot;);    formarts.add(&quot;yyyy-MM-dd hh:mm:ss&quot;);}@Overridepublic Date convert(String s) {    if(StringUtils.isEmpty(s)){        return null;    }    try {        String formatter = &quot;&quot;;        if (s.matches(&quot;^\\d{4}-\\d{1,2}$&quot;)) {            formatter = formarts.get(0);        } else if (s.matches(&quot;^\\d{4}-\\d{1,2}-\\d{1,2}$&quot;)) {            formatter = formarts.get(1);        } else if (s.matches(&quot;^\\d{4}-\\d{1,2}-\\d{1,2} {1}\\d{1,2}:\\d{1,2}$&quot;)) {            formatter = formarts.get(2);        } else if (s.matches(&quot;^\\d{4}-\\d{1,2}-\\d{1,2} {1}\\d{1,2}:\\d{1,2}:\\d{1,2}$&quot;)) {            formatter = formarts.get(3);        } else {            throw new IllegalArgumentException(&quot;Invalid boolean value &apos;&quot; + s + &quot;&apos;&quot;);        }        DateTimeFormatter dateTimeFormatter = DateTimeFormat.forPattern(formatter);        DateTime dateTime = DateTime.parse(s,dateTimeFormatter);        return dateTime.toDate();    } catch (Exception e){        return null;    }}}</code></pre><h3 id="在springmvc-xml里面配置"><a href="#在springmvc-xml里面配置" class="headerlink" title="在springmvc.xml里面配置"></a>在springmvc.xml里面配置</h3><pre><code>&lt;!-- 配置注解驱动，如果配置此标签可以不用配置处理器映射器和适配器  --&gt;&lt;!-- &lt;mvc:annotation-driven /&gt; --&gt;&lt;!-- 加载注解驱动 --&gt;&lt;mvc:annotation-driven conversion-service=&quot;conversionService&quot;/&gt;&lt;!-- 转换器配置 --&gt;&lt;bean id=&quot;conversionService&quot;    class=&quot;org.springframework.format.support.FormattingConversionServiceFactoryBean&quot;&gt;    &lt;property name=&quot;converters&quot;&gt;        &lt;set&gt;            &lt;bean class=&quot;cn.lxm.springmvc.convert.DateConverter&quot;/&gt;        &lt;/set&gt;    &lt;/property&gt;&lt;/bean&gt;</code></pre><h2 id="解决post乱码问题"><a href="#解决post乱码问题" class="headerlink" title="解决post乱码问题"></a>解决post乱码问题</h2><p>在web.xml中加入：</p><pre><code>&lt;filter&gt;    &lt;filter-name&gt;CharacterEncodingFilter&lt;/filter-name&gt;    &lt;filter-class&gt;org.springframework.web.filter.CharacterEncodingFilter&lt;/filter-class&gt;    &lt;init-param&gt;        &lt;param-name&gt;encoding&lt;/param-name&gt;        &lt;param-value&gt;utf-8&lt;/param-value&gt;    &lt;/init-param&gt;&lt;/filter&gt;&lt;filter-mapping&gt;    &lt;filter-name&gt;CharacterEncodingFilter&lt;/filter-name&gt;    &lt;url-pattern&gt;/*&lt;/url-pattern&gt;&lt;/filter-mapping&gt;</code></pre><p>以上可以解决post请求乱码问题。</p><p>对于get请求中文参数出现乱码解决方法有两个：</p><p>修改tomcat配置文件添加编码与工程编码一致，如下：</p><pre><code>&lt;Connector URIEncoding=&quot;utf-8&quot; connectionTimeout=&quot;20000&quot; port=&quot;8080&quot; protocol=&quot;HTTP/1.1&quot; redirectPort=&quot;8443&quot;/&gt;</code></pre><p>另外一种方法对参数进行重新编码：</p><pre><code>String userName new String(request.getParamter(&quot;userName&quot;).getBytes(&quot;ISO8859-1&quot;),&quot;utf-8&quot;)</code></pre><p>ISO8859-1是tomcat默认编码，需要将tomcat编码后的内容按utf-8编码</p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;SpringMVC架构&quot;&gt;&lt;a href=&quot;#SpringMVC架构&quot; class=&quot;headerlink&quot; title=&quot;SpringMVC架构&quot;&gt;&lt;/a&gt;SpringMVC架构&lt;/h1&gt;&lt;p&gt;Spring web mvc和Struts2都属于表现层的框架,它是Spring框架的一部分.&lt;/p&gt;
&lt;h2 id=&quot;架构流程&quot;&gt;&lt;a href=&quot;#架构流程&quot; class=&quot;headerlink&quot; title=&quot;架构流程&quot;&gt;&lt;/a&gt;架构流程&lt;/h2&gt;&lt;pre&gt;&lt;code&gt;1、    用户发送请求至前端控制器DispatcherServlet

2、    DispatcherServlet收到请求调用HandlerMapping处理器映射器。

3、    处理器映射器根据请求url找到具体的处理器，生成处理器对象及处理器拦截器(如果有则生成)一并返回给DispatcherServlet。

4、    DispatcherServlet通过HandlerAdapter处理器适配器调用处理器

5、    执行处理器(Controller，也叫后端控制器)。

6、    Controller执行完成返回ModelAndView

7、    HandlerAdapter将controller执行结果ModelAndView返回给DispatcherServlet

8、    DispatcherServlet将ModelAndView传给ViewReslover视图解析器

9、    ViewReslover解析后返回具体View

10、    DispatcherServlet对View进行渲染视图（即将模型数据填充至视图中）。

11、    DispatcherServlet响应用户
&lt;/code&gt;&lt;/pre&gt;
    
    </summary>
    
      <category term="java" scheme="http://yoursite.com/categories/java/"/>
    
    
      <category term="SpringMVC" scheme="http://yoursite.com/tags/SpringMVC/"/>
    
      <category term="SpringWebMVC" scheme="http://yoursite.com/tags/SpringWebMVC/"/>
    
  </entry>
  
  <entry>
    <title>mybatis入门五</title>
    <link href="http://yoursite.com/2018/02/26/mybatis%E5%85%A5%E9%97%A8%E4%BA%94/"/>
    <id>http://yoursite.com/2018/02/26/mybatis入门五/</id>
    <published>2018-02-26T08:21:09.000Z</published>
    <updated>2018-02-27T13:50:56.344Z</updated>
    
    <content type="html"><![CDATA[<h1 id="mybatis整合spring"><a href="#mybatis整合spring" class="headerlink" title="mybatis整合spring"></a>mybatis整合spring</h1><h2 id="整合思路"><a href="#整合思路" class="headerlink" title="整合思路"></a>整合思路</h2><p>1、SqlSessionFactory对象应该放到spring容器中作为单例存在。</p><p>2、传统dao的开发方式中，应该从spring容器中获得sqlsession对象。</p><p>3、Mapper代理形式中，应该从spring容器中直接获得mapper的代理对象。</p><p>4、数据库的连接以及数据库连接池事务管理都交给spring容器来完成。</p><a id="more"></a><h2 id="整合需要的jar包"><a href="#整合需要的jar包" class="headerlink" title="整合需要的jar包"></a>整合需要的jar包</h2><p>1、spring的jar包<br>2、Mybatis的jar包<br>3、Spring+mybatis的整合包。<br>4、Mysql的数据库驱动jar包。<br>5、数据库连接池的jar包。</p><h2 id="整合的步骤"><a href="#整合的步骤" class="headerlink" title="整合的步骤"></a>整合的步骤</h2><p>第一步：创建一个java工程。</p><p>第二步：导入jar包。（上面提到的jar包）</p><p>第三步：mybatis的配置文件SqlMapConfig.xml</p><p>第四步：编写Spring的配置文件</p><pre><code>1、数据库连接及连接池2、事务管理（暂时可以不配置）3、sqlsessionFactory对象，配置到spring容器中4、mapeer代理对象或者是dao实现类配置到spring容器中。</code></pre><p>第五步：编写dao或者mapper文件</p><p>第六步：测试。</p><h3 id="SqlMapConfig-xml"><a href="#SqlMapConfig-xml" class="headerlink" title="SqlMapConfig.xml"></a>SqlMapConfig.xml</h3><pre><code>&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; ?&gt;&lt;!DOCTYPE configurationPUBLIC &quot;-//mybatis.org//DTD Config 3.0//EN&quot;&quot;http://mybatis.org/dtd/mybatis-3-config.dtd&quot;&gt;&lt;configuration&gt;    &lt;typeAliases&gt;        &lt;package name=&quot;cn.lxm.mybatis.pojo&quot;/&gt;    &lt;/typeAliases&gt;    &lt;mappers&gt;        &lt;!-- 使用包扫描扫描mapper.xml            如果在ApplicationContext.xml中配置了扫描包之后,就 不需要此配置         --&gt;        &lt;package name=&quot;cn.lxm.mybatis.mapper&quot;/&gt;    &lt;/mappers&gt;&lt;/configuration&gt;</code></pre><h3 id="applicationContext-xml"><a href="#applicationContext-xml" class="headerlink" title="applicationContext.xml"></a>applicationContext.xml</h3><pre><code>&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot;    xmlns:context=&quot;http://www.springframework.org/schema/context&quot; xmlns:p=&quot;http://www.springframework.org/schema/p&quot;    xmlns:aop=&quot;http://www.springframework.org/schema/aop&quot; xmlns:tx=&quot;http://www.springframework.org/schema/tx&quot;    xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;    xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans-4.0.xsd    http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context-4.0.xsd    http://www.springframework.org/schema/aop http://www.springframework.org/schema/aop/spring-aop-4.0.xsd http://www.springframework.org/schema/tx http://www.springframework.org/schema/tx/spring-tx-4.0.xsd    http://www.springframework.org/schema/util http://www.springframework.org/schema/util/spring-util-4.0.xsd&quot;&gt;    &lt;!-- 加载配置文件 --&gt;    &lt;context:property-placeholder location=&quot;classpath:db.properties&quot; /&gt;    &lt;!-- 数据库连接池 --&gt;    &lt;bean id=&quot;dataSource&quot; class=&quot;org.apache.commons.dbcp.BasicDataSource&quot;        destroy-method=&quot;close&quot;&gt;        &lt;property name=&quot;driverClassName&quot; value=&quot;${jdbc.driver}&quot; /&gt;        &lt;property name=&quot;url&quot; value=&quot;${jdbc.url}&quot; /&gt;        &lt;property name=&quot;username&quot; value=&quot;${jdbc.username}&quot; /&gt;        &lt;property name=&quot;password&quot; value=&quot;${jdbc.password}&quot; /&gt;        &lt;property name=&quot;maxActive&quot; value=&quot;10&quot; /&gt;        &lt;property name=&quot;maxIdle&quot; value=&quot;5&quot; /&gt;    &lt;/bean&gt;    &lt;!-- mapper配置 --&gt;    &lt;!-- 让spring管理sqlsessionfactory 使用mybatis和spring整合包中的 --&gt;    &lt;bean id=&quot;sqlSessionFactory&quot; class=&quot;org.mybatis.spring.SqlSessionFactoryBean&quot;&gt;        &lt;!-- 数据库连接池 --&gt;        &lt;property name=&quot;dataSource&quot; ref=&quot;dataSource&quot; /&gt;        &lt;!-- 加载mybatis的全局配置文件 --&gt;        &lt;property name=&quot;configLocation&quot; value=&quot;classpath:mybatis/SqlMapConfig.xml&quot; /&gt;    &lt;/bean&gt;&lt;/beans&gt;</code></pre><h3 id="db-properties"><a href="#db-properties" class="headerlink" title="db.properties"></a>db.properties</h3><pre><code>jdbc.driver=com.mysql.jdbc.Driverjdbc.url=jdbc:mysql://localhost:3306/mybatis?characterEncoding=utf-8jdbc.username=rootjdbc.password=root</code></pre><h2 id="Dao的开发"><a href="#Dao的开发" class="headerlink" title="Dao的开发"></a>Dao的开发</h2><p>三种dao的实现方式：</p><pre><code>1、传统dao的开发方式2、使用mapper代理形式开发方式3、使用扫描包配置mapper代理。</code></pre><p>这里只介绍第二种和第三种</p><h3 id="Mapper代理形式开发dao"><a href="#Mapper代理形式开发dao" class="headerlink" title="Mapper代理形式开发dao"></a>Mapper代理形式开发dao</h3><h4 id="开发mapper接口"><a href="#开发mapper接口" class="headerlink" title="开发mapper接口"></a>开发mapper接口</h4><p>开发mapper文件</p><p>创建UserMapper.java</p><pre><code>public interface UserMapper {    User findUserById(Integer id) throws Exception;}</code></pre><p>并且在同一目录下创建UserMapper.xml</p><pre><code> &lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; ?&gt;&lt;!DOCTYPE mapperPUBLIC &quot;-//mybatis.org//DTD Mapper 3.0//EN&quot;&quot;http://mybatis.org/dtd/mybatis-3-mapper.dtd&quot;&gt;&lt;mapper namespace=&quot;cn.lxm.mybatis.mapper.UserMapper&quot;&gt;    &lt;!-- 根据id获取用户信息 --&gt;    &lt;select id=&quot;findUserById&quot; parameterType=&quot;int&quot; resultType=&quot;cn.lxm.mybatis.po.User&quot;&gt;        select * from user where id = #{id}    &lt;/select&gt;&lt;/mapper&gt;</code></pre><h4 id="配置mapper代理"><a href="#配置mapper代理" class="headerlink" title="配置mapper代理"></a>配置mapper代理</h4><pre><code>&lt;!-- 配置mapper代理对象 --&gt;&lt;bean class=&quot;org.mybatis.spring.mapper.MapperFactoryBean&quot;&gt;    &lt;property name=&quot;mapperInterface&quot; value=&quot;cn.lxm.mybatis.mapper.UserMapper&quot;/&gt;    &lt;property name=&quot;sqlSessionFactory&quot; ref=&quot;sqlSessionFactory&quot;&gt;&lt;/property&gt;&lt;/bean&gt;</code></pre><h4 id="测试方法"><a href="#测试方法" class="headerlink" title="测试方法"></a>测试方法</h4><pre><code>public class UserMapperTest {    private ApplicationContext applicationContext;    @Before    public void setUp() throws Exception {        applicationContext = new ClassPathXmlApplicationContext(&quot;classpath:spring/applicationContext.xml&quot;);    }    @Test    public void testGetUserById() {        UserMapper userMapper = applicationContext.getBean(UserMapper.class);        User user = userMapper.getUserById(1);        System.out.println(user);    }}</code></pre><h3 id="扫描包形式配置mapper"><a href="#扫描包形式配置mapper" class="headerlink" title="扫描包形式配置mapper"></a>扫描包形式配置mapper</h3><pre><code>&lt;!-- 使用扫描包的形式来创建mapper代理对象 --&gt;&lt;bean class=&quot;org.mybatis.spring.mapper.MapperScannerConfigurer&quot;&gt;    &lt;property name=&quot;basePackage&quot; value=&quot;cn.lxm.mybatis.mapper&quot;&gt;&lt;/property&gt;&lt;/bean&gt;</code></pre><p>如果配置了这个后 ,在SQLMapConfig.xml中的包扫描配置就不需要了</p><h2 id="逆向工程生成代码"><a href="#逆向工程生成代码" class="headerlink" title="逆向工程生成代码"></a>逆向工程生成代码</h2><p>步骤:</p><p>1.导入逆向工程代码,然后修改配置文件generatorConfig.xml</p><pre><code>&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;!DOCTYPE generatorConfiguration  PUBLIC &quot;-//mybatis.org//DTD MyBatis Generator Configuration 1.0//EN&quot;  &quot;http://mybatis.org/dtd/mybatis-generator-config_1_0.dtd&quot;&gt;&lt;generatorConfiguration&gt;    &lt;context id=&quot;testTables&quot; targetRuntime=&quot;MyBatis3&quot;&gt;        &lt;commentGenerator&gt;            &lt;!-- 是否去除自动生成的注释 true：是 ： false:否 --&gt;            &lt;property name=&quot;suppressAllComments&quot; value=&quot;true&quot; /&gt;        &lt;/commentGenerator&gt;        &lt;!--数据库连接的信息：驱动类、连接地址、用户名、密码 --&gt;        &lt;jdbcConnection driverClass=&quot;com.mysql.jdbc.Driver&quot;            connectionURL=&quot;jdbc:mysql://localhost:3306/mybatis&quot; userId=&quot;root&quot;            password=&quot;root&quot;&gt;        &lt;/jdbcConnection&gt;        &lt;!-- &lt;jdbcConnection driverClass=&quot;oracle.jdbc.OracleDriver&quot;            connectionURL=&quot;jdbc:oracle:thin:@127.0.0.1:1521:yycg&quot;             userId=&quot;yycg&quot;            password=&quot;yycg&quot;&gt;        &lt;/jdbcConnection&gt; --&gt;        &lt;!-- 默认false，把JDBC DECIMAL 和 NUMERIC 类型解析为 Integer，为 true时把JDBC DECIMAL 和             NUMERIC 类型解析为java.math.BigDecimal --&gt;        &lt;javaTypeResolver&gt;            &lt;property name=&quot;forceBigDecimals&quot; value=&quot;false&quot; /&gt;        &lt;/javaTypeResolver&gt;        &lt;!-- targetProject:生成PO类的位置 --&gt;        &lt;javaModelGenerator targetPackage=&quot;cn.lxm.mybatis.po&quot;            targetProject=&quot;.\src&quot;&gt;            &lt;!-- enableSubPackages:是否让schema作为包的后缀 --&gt;            &lt;property name=&quot;enableSubPackages&quot; value=&quot;false&quot; /&gt;            &lt;!-- 从数据库返回的值被清理前后的空格 --&gt;            &lt;property name=&quot;trimStrings&quot; value=&quot;true&quot; /&gt;        &lt;/javaModelGenerator&gt;        &lt;!-- targetProject:mapper映射文件生成的位置 --&gt;        &lt;sqlMapGenerator targetPackage=&quot;cn.lxm.mybatis.mapper&quot;             targetProject=&quot;.\src&quot;&gt;            &lt;!-- enableSubPackages:是否让schema作为包的后缀 --&gt;            &lt;property name=&quot;enableSubPackages&quot; value=&quot;false&quot; /&gt;        &lt;/sqlMapGenerator&gt;        &lt;!-- targetPackage：mapper接口生成的位置 --&gt;        &lt;javaClientGenerator type=&quot;XMLMAPPER&quot;            targetPackage=&quot;cn.lxm.mybatis.mapper&quot;             targetProject=&quot;.\src&quot;&gt;            &lt;!-- enableSubPackages:是否让schema作为包的后缀 --&gt;            &lt;property name=&quot;enableSubPackages&quot; value=&quot;false&quot; /&gt;        &lt;/javaClientGenerator&gt;        &lt;!-- 指定数据库表 --&gt;        &lt;table schema=&quot;&quot; tableName=&quot;user&quot;&gt;&lt;/table&gt;        &lt;table schema=&quot;&quot; tableName=&quot;orders&quot;&gt;&lt;/table&gt;        &lt;!-- 有些表的字段需要指定java类型         &lt;table schema=&quot;&quot; tableName=&quot;&quot;&gt;            &lt;columnOverride column=&quot;&quot; javaType=&quot;&quot; /&gt;        &lt;/table&gt; --&gt;    &lt;/context&gt;&lt;/generatorConfiguration&gt;</code></pre>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;mybatis整合spring&quot;&gt;&lt;a href=&quot;#mybatis整合spring&quot; class=&quot;headerlink&quot; title=&quot;mybatis整合spring&quot;&gt;&lt;/a&gt;mybatis整合spring&lt;/h1&gt;&lt;h2 id=&quot;整合思路&quot;&gt;&lt;a href=&quot;#整合思路&quot; class=&quot;headerlink&quot; title=&quot;整合思路&quot;&gt;&lt;/a&gt;整合思路&lt;/h2&gt;&lt;p&gt;1、SqlSessionFactory对象应该放到spring容器中作为单例存在。&lt;/p&gt;
&lt;p&gt;2、传统dao的开发方式中，应该从spring容器中获得sqlsession对象。&lt;/p&gt;
&lt;p&gt;3、Mapper代理形式中，应该从spring容器中直接获得mapper的代理对象。&lt;/p&gt;
&lt;p&gt;4、数据库的连接以及数据库连接池事务管理都交给spring容器来完成。&lt;/p&gt;
    
    </summary>
    
      <category term="java" scheme="http://yoursite.com/categories/java/"/>
    
    
      <category term="mybatis" scheme="http://yoursite.com/tags/mybatis/"/>
    
  </entry>
  
  <entry>
    <title>mybatis入门四</title>
    <link href="http://yoursite.com/2018/02/25/mybatis%E5%85%A5%E9%97%A8%E5%9B%9B/"/>
    <id>http://yoursite.com/2018/02/25/mybatis入门四/</id>
    <published>2018-02-25T08:07:42.000Z</published>
    <updated>2018-02-27T13:50:32.042Z</updated>
    
    <content type="html"><![CDATA[<h1 id="关联查询"><a href="#关联查询" class="headerlink" title="关联查询"></a>关联查询</h1><h2 id="一对一查询"><a href="#一对一查询" class="headerlink" title="一对一查询"></a>一对一查询</h2><p>这里举例是一个订单对应一个用户</p><h3 id="方法一："><a href="#方法一：" class="headerlink" title="方法一："></a>方法一：</h3><p>使用resultType，定义订单信息po类，此po类中包括了订单信息和用户信息：</p><a id="more"></a><h4 id="Sql语句："><a href="#Sql语句：" class="headerlink" title="Sql语句："></a>Sql语句：</h4><pre><code>SELECT   orders.*,  user.username,  user.addressFROM  orders,  user WHERE orders.user_id = user.id</code></pre><h4 id="定义po类"><a href="#定义po类" class="headerlink" title="定义po类"></a>定义po类</h4><p>Po类中应该包括上边sql查询出来的所有字段，如下：</p><pre><code>public class OrdersCustom extends Orders {private String username;// 用户名称private String address;// 用户地址get/set。。。。</code></pre><p>OrdersCustom类继承Orders类后OrdersCustom类包括了Orders类的所有字段，只需要定义用户的信息字段即可。</p><h4 id="Mapper-xml"><a href="#Mapper-xml" class="headerlink" title="Mapper.xml"></a>Mapper.xml</h4><pre><code>&lt;!-- 查询所有订单信息 --&gt;&lt;select id=&quot;findOrdersList&quot; resultType=&quot;cn.lxm.mybatis.po.OrdersCustom&quot;&gt;SELECTorders.*,user.username,user.addressFROMorders,    userWHERE orders.user_id = user.id &lt;/select&gt;</code></pre><h4 id="Mapper接口："><a href="#Mapper接口：" class="headerlink" title="Mapper接口："></a>Mapper接口：</h4><pre><code>public List&lt;OrdersCustom&gt; findOrdersList() throws Exception;</code></pre><h4 id="测试："><a href="#测试：" class="headerlink" title="测试："></a>测试：</h4><pre><code>Public void testfindOrdersList()throws Exception{    //获取session    SqlSession session = sqlSessionFactory.openSession();    //获限mapper接口实例    UserMapper userMapper = session.getMapper(UserMapper.class);    //查询订单信息    List&lt;OrdersCustom&gt; list = userMapper.findOrdersList();    System.out.println(list);    //关闭session    session.close();}</code></pre><h4 id="小结："><a href="#小结：" class="headerlink" title="小结："></a>小结：</h4><pre><code>定义专门的po类作为输出类型，其中定义了sql查询结果集所有的字段。此方法较为简单，企业中使用普遍。</code></pre><h3 id="方法二："><a href="#方法二：" class="headerlink" title="方法二："></a>方法二：</h3><p>使用resultMap，定义专门的resultMap用于映射一对一查询结果。</p><h4 id="Sql语句：-1"><a href="#Sql语句：-1" class="headerlink" title="Sql语句："></a>Sql语句：</h4><pre><code>SELECT   orders.*,  user.username,  user.addressFROM  orders,  user WHERE orders.user_id = user.id</code></pre><h4 id="定义po类-1"><a href="#定义po类-1" class="headerlink" title="定义po类"></a>定义po类</h4><p>在Orders类中加入User属性，user属性中用于存储关联查询的用户信息，因为订单关联查询用户是一对一关系，所以这里使用单个User对象存储关联查询的用户信息。<br>    public class Orders {<br>    private Integer id;</p><pre><code>private Integer userId;private String number;private Date createtime;private String note;private User user;get/set()...</code></pre><h4 id="Mapper-xml-1"><a href="#Mapper-xml-1" class="headerlink" title="Mapper.xml"></a>Mapper.xml</h4><pre><code>&lt;!-- 查询订单关联用户信息使用resultmap --&gt;&lt;resultMap type=&quot;Orders&quot; id=&quot;orderUserResultMap&quot;&gt;    &lt;id column=&quot;id&quot; property=&quot;id&quot;/&gt;    &lt;result column=&quot;user_id&quot; property=&quot;userId&quot;/&gt;    &lt;result column=&quot;number&quot; property=&quot;number&quot;/&gt;    &lt;result column=&quot;createtime&quot; property=&quot;createtime&quot;/&gt;    &lt;result column=&quot;note&quot; property=&quot;note&quot;/&gt;    &lt;!-- 一对一关联映射 --&gt;    &lt;!--     property:Orders对象的user属性    javaType：user属性对应 的类型     --&gt;    &lt;association property=&quot;user&quot; javaType=&quot;cn.lxm.po.User&quot;&gt;        &lt;!-- column:user表的主键对应的列  property：user对象中id属性--&gt;        &lt;id column=&quot;user_id&quot; property=&quot;id&quot;/&gt;        &lt;result column=&quot;username&quot; property=&quot;username&quot;/&gt;        &lt;result column=&quot;address&quot; property=&quot;address&quot;/&gt;    &lt;/association&gt;&lt;/resultMap&gt;&lt;select id=&quot;findOrdersWithUserResultMap&quot; resultMap=&quot;orderUserResultMap&quot;&gt;    SELECT        o.id,        o.user_id,        o.number,        o.createtime,        o.note,        u.username,        u.address    FROM        orders o    JOIN `user` u ON u.id = o.user_id&lt;/select&gt;</code></pre><p>这里resultMap指定orderUserResultMap。</p><p>association：表示进行关联查询单条记录</p><p>property：表示关联查询的结果存储在cn.lxm.mybatis.po.Orders的user属性中</p><p>javaType：表示关联查询的结果类型</p><p>&lt; id property=”id” column=”user_id”/&gt;：查询结果的user_id列对应关联对象的id属性，这里是&lt; id /&gt;表示user_id是关联查询对象的唯一标识。</p><p>&lt; result property=”username” column=”username”/&gt;：查询结果的username列对应关联对象的username属性。</p><h4 id="Mapper接口：-1"><a href="#Mapper接口：-1" class="headerlink" title="Mapper接口："></a>Mapper接口：</h4><pre><code>public List&lt;Orders&gt; findOrdersListResultMap() throws Exception;</code></pre><h4 id="测试：-1"><a href="#测试：-1" class="headerlink" title="测试："></a>测试：</h4><pre><code>Public void testfindOrdersListResultMap()throws Exception{    //获取session    SqlSession session = sqlSessionFactory.openSession();    //获限mapper接口实例    UserMapper userMapper = session.getMapper(UserMapper.class);    //查询订单信息    List&lt;Orders&gt; list = userMapper.findOrdersList2();    System.out.println(list);    //关闭session    session.close();}</code></pre><h4 id="小结：-1"><a href="#小结：-1" class="headerlink" title="小结："></a>小结：</h4><p>使用association完成关联查询，将关联查询信息映射到pojo对象中。</p><h2 id="一对多查询"><a href="#一对多查询" class="headerlink" title="一对多查询"></a>一对多查询</h2><p>案例：查询所有用户信息及用户关联的订单信息。</p><p>用户信息和订单信息为一对多关系。</p><p>使用resultMap实现如下：</p><h3 id="Sql语句：-2"><a href="#Sql语句：-2" class="headerlink" title="Sql语句："></a>Sql语句：</h3><pre><code>SELECTu.*, o.id oid,o.number,o.createtime,o.noteFROM`user` uLEFT JOIN orders o ON u.id = o.user_id</code></pre><h3 id="定义po类-2"><a href="#定义po类-2" class="headerlink" title="定义po类"></a>定义po类</h3><p>在User类中加入List&lt; Orders&gt; orders属性</p><pre><code>public class User {   private int id;   private String username;// 用户姓名   private String sex;// 性别   private Date birthday;// 生日   private String address;// 地址   private List&lt;Orders&gt; orders;   get/set()...</code></pre><h3 id="Mapper-xml-2"><a href="#Mapper-xml-2" class="headerlink" title="Mapper.xml"></a>Mapper.xml</h3><pre><code>&lt;resultMap type=&quot;user&quot; id=&quot;userOrderResultMap&quot;&gt;    &lt;!-- 用户信息映射 --&gt;    &lt;id property=&quot;id&quot; column=&quot;id&quot;/&gt;    &lt;result property=&quot;username&quot; column=&quot;username&quot;/&gt;    &lt;result property=&quot;birthday&quot; column=&quot;birthday&quot;/&gt;    &lt;result property=&quot;sex&quot; column=&quot;sex&quot;/&gt;    &lt;result property=&quot;address&quot; column=&quot;address&quot;/&gt;    &lt;!-- 一对多关联映射 --&gt;    &lt;collection property=&quot;orders&quot; ofType=&quot;orders&quot;&gt;        &lt;id property=&quot;id&quot; column=&quot;oid&quot;/&gt;              &lt;!--用户id已经在user对象中存在，此处可以不设置--&gt;        &lt;!-- &lt;result property=&quot;userId&quot; column=&quot;id&quot;/&gt; --&gt;        &lt;result property=&quot;number&quot; column=&quot;number&quot;/&gt;        &lt;result property=&quot;createtime&quot; column=&quot;createtime&quot;/&gt;        &lt;result property=&quot;note&quot; column=&quot;note&quot;/&gt;    &lt;/collection&gt;&lt;/resultMap&gt;&lt;select id=&quot;getUserOrderList&quot; resultMap=&quot;userOrderResultMap&quot;&gt;    SELECT    u.*, o.id oid,    o.number,    o.createtime,    o.note    FROM    `user` u    LEFT JOIN orders o ON u.id = o.user_id&lt;/select&gt;</code></pre><p>collection部分定义了用户关联的订单信息。表示关联查询结果集</p><p>property=”orders”：关联查询的结果集存储在User对象的上哪个属性。</p><p>ofType=”orders”：指定关联查询的结果集中的对象类型即List中的对象类型。此处可以使用别名，也可以使用全限定名。</p><p>&lt; id /&gt;及&lt; result/&gt;的意义同一对一查询。</p><h3 id="Mapper接口：-2"><a href="#Mapper接口：-2" class="headerlink" title="Mapper接口："></a>Mapper接口：</h3><pre><code>List&lt;User&gt; getUserOrderList();</code></pre><h3 id="测试"><a href="#测试" class="headerlink" title="测试"></a>测试</h3><pre><code>@Testpublic void getUserOrderList() {    SqlSession session = sqlSessionFactory.openSession();    UserMapper userMapper = session.getMapper(UserMapper.class);    List&lt;User&gt; result = userMapper.getUserOrderList();    for (User user : result) {        System.out.println(user);    }    session.close();}</code></pre>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;关联查询&quot;&gt;&lt;a href=&quot;#关联查询&quot; class=&quot;headerlink&quot; title=&quot;关联查询&quot;&gt;&lt;/a&gt;关联查询&lt;/h1&gt;&lt;h2 id=&quot;一对一查询&quot;&gt;&lt;a href=&quot;#一对一查询&quot; class=&quot;headerlink&quot; title=&quot;一对一查询&quot;&gt;&lt;/a&gt;一对一查询&lt;/h2&gt;&lt;p&gt;这里举例是一个订单对应一个用户&lt;/p&gt;
&lt;h3 id=&quot;方法一：&quot;&gt;&lt;a href=&quot;#方法一：&quot; class=&quot;headerlink&quot; title=&quot;方法一：&quot;&gt;&lt;/a&gt;方法一：&lt;/h3&gt;&lt;p&gt;使用resultType，定义订单信息po类，此po类中包括了订单信息和用户信息：&lt;/p&gt;
    
    </summary>
    
      <category term="java" scheme="http://yoursite.com/categories/java/"/>
    
    
      <category term="mybatis" scheme="http://yoursite.com/tags/mybatis/"/>
    
  </entry>
  
  <entry>
    <title>mybatis入门三</title>
    <link href="http://yoursite.com/2018/02/25/mybatis%E5%85%A5%E9%97%A8%E4%B8%89/"/>
    <id>http://yoursite.com/2018/02/25/mybatis入门三/</id>
    <published>2018-02-25T00:58:28.000Z</published>
    <updated>2018-02-25T12:24:16.165Z</updated>
    
    <content type="html"><![CDATA[<h1 id="输入映射和输出映射"><a href="#输入映射和输出映射" class="headerlink" title="输入映射和输出映射"></a>输入映射和输出映射</h1><p>Mapper.xml映射文件中定义了操作数据库的sql，每个sql是一个statement，映射文件是mybatis的核心。<br><a id="more"></a></p><h2 id="parameterType-输入类型"><a href="#parameterType-输入类型" class="headerlink" title="parameterType(输入类型)"></a>parameterType(输入类型)</h2><h3 id="传递简单类型"><a href="#传递简单类型" class="headerlink" title="传递简单类型"></a>传递简单类型</h3><p>参考文章 <a href="http://fashionkillyou.xyz/2018/02/24/mybatis入门一/" title="mybatis入门一" target="_blank" rel="noopener">mybatis入门一</a></p><h3 id="传递pojo对象"><a href="#传递pojo对象" class="headerlink" title="传递pojo对象"></a>传递pojo对象</h3><p>Mybatis使用ognl表达式解析对象字段的值，#{}或者${}括号中的值为pojo属性名称。</p><h3 id="传递pojo包装对象"><a href="#传递pojo包装对象" class="headerlink" title="传递pojo包装对象"></a>传递pojo包装对象</h3><p>开发中通过pojo传递查询条件 ，查询条件是综合的查询条件，不仅包括用户查询条件还包括其它的查询条件（比如将用户购买商品信息也作为查询条件），这时可以使用包装对象传递输入参数。<br>Pojo类中包含pojo。</p><p>需求：根据用户名查询用户信息，查询条件放到QueryVo的user属性中。</p><h4 id="QueryVo"><a href="#QueryVo" class="headerlink" title="QueryVo"></a>QueryVo</h4><pre><code>public class QueryVo {    private User user;    public User getUser() {        return user;    }    public void setUser(User user) {        this.user = user;    }}</code></pre><h4 id="Sql语句"><a href="#Sql语句" class="headerlink" title="Sql语句"></a>Sql语句</h4><p>SELECT * FROM user where username like ‘%刘%’</p><h4 id="Mapper文件"><a href="#Mapper文件" class="headerlink" title="Mapper文件"></a>Mapper文件</h4><pre><code>&lt;!-- 使用包装类型查询用户使用ognl从对象中取属性值，如果是包装对象可以使用.操作符来取内容部的属性--&gt;&lt;select id=&quot;findUserByQueryVo&quot; parameterType=&quot;queryvo&quot; resultType=&quot;user&quot;&gt;    SELECT * FROM user where username like &apos;%${user.username}%&apos;&lt;/select&gt;</code></pre><h4 id="接口"><a href="#接口" class="headerlink" title="接口"></a>接口</h4><pre><code> public interface UserMapper{    User findUserById(int id) throws Exception;    void insertUser(User user) throws Exception;    List&lt;User&gt; findUserByQueryVo(QueryVo queryVo) throws Exception;}</code></pre><h4 id="测试方法"><a href="#测试方法" class="headerlink" title="测试方法"></a>测试方法</h4><pre><code>@Testpublic void testFindUserByQueryVo() throws Exception {    SqlSession sqlSession = sessionFactory.openSession();    //获得mapper的代理对象    UserMapper userMapper = sqlSession.getMapper(UserMapper.class);    //创建QueryVo对象    QueryVo queryVo = new QueryVo();    //创建user对象    User user = new User();    user.setUsername(&quot;刘&quot;);    queryVo.setUser(user);    //根据queryvo查询用户    List&lt;User&gt; list = userMapper.findUserByQueryVo(queryVo);    System.out.println(list);    sqlSession.close();}</code></pre><h2 id="resultType-输出类型"><a href="#resultType-输出类型" class="headerlink" title="resultType(输出类型)"></a>resultType(输出类型)</h2><h3 id="输出简单类型"><a href="#输出简单类型" class="headerlink" title="输出简单类型"></a>输出简单类型</h3><p>参考getnow输出日期类型，看下边的例子输出整型：</p><p>Mapper.xml文件</p><pre><code>&lt;!-- 获取用户列表总数 --&gt;&lt;select id=&quot;findUserCount&quot; parameterType=&quot;user&quot; resultType=&quot;int&quot;&gt;   select count(1) from user&lt;/select&gt;</code></pre><p>Mapper接口</p><pre><code>public int findUserCount(User user) throws Exception;</code></pre><p>调用：</p><pre><code>Public void testFindUserCount() throws Exception{    //获取session    SqlSession session = sqlSessionFactory.openSession();    //获取mapper接口实例    UserMapper userMapper = session.getMapper(UserMapper.class);    User user = new User();    user.setUsername(&quot;管理员&quot;);    //传递Hashmap对象查询用户列表    int count = userMapper.findUserCount(user);    //关闭session    session.close();}</code></pre><p>输出简单类型必须查询出来的结果集有一条记录，最终将第一个字段的值转换为输出类型。<br>使用session的selectOne可查询单条记录。</p><h3 id="输出pojo对象"><a href="#输出pojo对象" class="headerlink" title="输出pojo对象"></a>输出pojo对象</h3><p>参考文章 <a href="http://fashionkillyou.xyz/2018/02/24/mybatis入门一/" title="mybatis入门一" target="_blank" rel="noopener">mybatis入门一</a></p><h3 id="输出pojo列表"><a href="#输出pojo列表" class="headerlink" title="输出pojo列表"></a>输出pojo列表</h3><p>参考文章 <a href="http://fashionkillyou.xyz/2018/02/24/mybatis入门一/" title="mybatis入门一" target="_blank" rel="noopener">mybatis入门一</a></p><h2 id="resultMap"><a href="#resultMap" class="headerlink" title="resultMap"></a>resultMap</h2><p>resultType可以指定pojo将查询结果映射为pojo，但需要pojo的属性名和sql查询的列名一致方可映射成功。</p><p>如果sql查询字段名和pojo的属性名不一致，可以通过resultMap将字段名和属性名作一个对应关系 ，resultMap实质上还需要将查询结果映射到pojo对象中。</p><p>resultMap可以实现将查询结果映射为复杂类型的pojo，比如在查询结果映射对象中包括pojo和list实现一对一查询和一对多查询。</p><h3 id="Mapper-xml定义"><a href="#Mapper-xml定义" class="headerlink" title="Mapper.xml定义"></a>Mapper.xml定义</h3><pre><code> &lt;select id=&quot;findUserListResultMap&quot; parameterType=&quot;queryVo&quot; resultMap=&quot;userListResultMap&quot;&gt;    select id id_,username username_,birthday birthday_ from user&lt;/select&gt;</code></pre><p>使用resultMap指定上边定义的personmap。</p><h3 id="定义resultMap"><a href="#定义resultMap" class="headerlink" title="定义resultMap"></a>定义resultMap</h3><p>由于上边的mapper.xml中sql查询列和Users.java类属性不一致，需要定义resultMap：</p><p>userListResultMap将sql查询列和Users.java类属性对应起来</p><pre><code>&lt;!-- type:最终映射的java对象.id:resultMap的唯一标识 --&gt;&lt;resultMap type=&quot;user&quot; id=&quot;userListResultMap&quot;&gt;&lt;!-- id标签:查询结果集的唯一标识列(主键或唯一标识)    column:SQL查询字段名(列名)    property:pojo的属性名    result标签:普通列 --&gt;    &lt;id property=&quot;id&quot; column=&quot;id_&quot;/&gt;    &lt;result property=&quot;username&quot; column=&quot;username_&quot;/&gt;    &lt;result property=&quot;birthday&quot; column=&quot;birthday_&quot;/&gt;&lt;/resultMap&gt;</code></pre><p>&lt; id /&gt;：此属性表示查询结果集的唯一标识，非常重要。如果是多个字段为复合唯一约束则定义多个&lt; id /&gt;。</p><p>Property：表示User类的属性。</p><p>Column：表示sql查询出来的字段名。</p><p>Column和property放在一块儿表示将sql查询出来的字段映射到指定的pojo类属性上。</p><p>&lt; result /&gt;：普通结果，即pojo的属性。</p><h3 id="Mapper接口定义"><a href="#Mapper接口定义" class="headerlink" title="Mapper接口定义"></a>Mapper接口定义</h3><pre><code>public List&lt;User&gt; findUserListResultMap() throws Exception;</code></pre><h1 id="动态sql"><a href="#动态sql" class="headerlink" title="动态sql"></a>动态sql</h1><p>通过mybatis提供的各种标签方法实现动态拼接sql。</p><h2 id="If"><a href="#If" class="headerlink" title="If"></a>If</h2><pre><code>&lt;!-- 传递pojo综合查询用户信息 --&gt;&lt;select id=&quot;findUserList&quot; parameterType=&quot;user&quot; resultType=&quot;user&quot;&gt;    select * from user     where 1=1     &lt;if test=&quot;id!=null and id!=&apos;&apos;&quot;&gt;    and id=#{id}    &lt;/if&gt;    &lt;if test=&quot;username!=null and username!=&apos;&apos;&quot;&gt;    and username like &apos;%${username}%&apos;    &lt;/if&gt;&lt;/select&gt;</code></pre><p>注意要做不等于空字符串校验。</p><h2 id="Where"><a href="#Where" class="headerlink" title="Where"></a>Where</h2><p>上边的sql也可以改为：</p><pre><code>&lt;select id=&quot;findUserList&quot; parameterType=&quot;user&quot; resultType=&quot;user&quot;&gt;    select * from user     &lt;where&gt;    &lt;if test=&quot;id!=null and id!=&apos;&apos;&quot;&gt;    and id=#{id}    &lt;/if&gt;    &lt;if test=&quot;username!=null and username!=&apos;&apos;&quot;&gt;    and username like &apos;%${username}%&apos;    &lt;/if&gt;    &lt;/where&gt;&lt;/select&gt;</code></pre><p>&lt; where /&gt;可以自动处理第一个and。</p><h2 id="foreach"><a href="#foreach" class="headerlink" title="foreach"></a>foreach</h2><p>向sql传递数组或List，mybatis使用foreach解析，如下：</p><p>需求<br>传入多个id查询用户信息，用下边两个sql实现：</p><pre><code>SELECT * FROM USERS WHERE username LIKE &apos;%张%&apos; AND (id =10 OR id =89 OR id=16)SELECT * FROM USERS WHERE username LIKE &apos;%张%&apos;  id IN (10,89,16)</code></pre><p>在pojo中定义list属性ids存储多个用户id，并添加getter/setter方法</p><pre><code> public class QueryVo {    private User user;    private List&lt;Integer&gt; ids;    public List&lt;Integer&gt; getIds() {        return ids;    }    public void setIds(List&lt;Integer&gt; ids) {        this.ids = ids;    }...</code></pre><p>mapper.xml</p><pre><code>&lt;if test=&quot;ids!=null and ids.size&gt;0&quot;&gt;        &lt;foreach collection=&quot;ids&quot; open=&quot; and id in(&quot; close=&quot;)&quot; item=&quot;id&quot; separator=&quot;,&quot; &gt;            #{id}        &lt;/foreach&gt;&lt;/if&gt;</code></pre><p>测试代码：</p><pre><code>List&lt;Integer&gt; ids = new ArrayList&lt;Integer&gt;();    ids.add(1);//查询id为1的用户    ids.add(10); //查询id为10的用户    queryVo.setIds(ids);    List&lt;User&gt; list = userMapper.findUserList(queryVo);</code></pre><h2 id="Sql片段"><a href="#Sql片段" class="headerlink" title="Sql片段"></a>Sql片段</h2><p>Sql中可将重复的sql提取出来，使用时用include引用即可，最终达到sql重用的目的，如下：</p><pre><code>&lt;!-- 传递pojo综合查询用户信息 --&gt;&lt;select id=&quot;findUserList&quot; parameterType=&quot;user&quot; resultType=&quot;user&quot;&gt;    select * from user     &lt;where&gt;    &lt;if test=&quot;id!=null and id!=&apos;&apos;&quot;&gt;    and id=#{id}    &lt;/if&gt;    &lt;if test=&quot;username!=null and username!=&apos;&apos;&quot;&gt;    and username like &apos;%${username}%&apos;    &lt;/if&gt;    &lt;/where&gt;&lt;/select&gt;</code></pre><p>    将where条件抽取出来：</p><pre><code>&lt;sql id=&quot;query_user_where&quot;&gt;    &lt;if test=&quot;id!=null and id!=&apos;&apos;&quot;&gt;        and id=#{id}    &lt;/if&gt;    &lt;if test=&quot;username!=null and username!=&apos;&apos;&quot;&gt;        and username like &apos;%${username}%&apos;    &lt;/if&gt;&lt;/sql&gt;</code></pre><p>    使用include引用：</p><pre><code>&lt;select id=&quot;findUserList&quot; parameterType=&quot;user&quot; resultType=&quot;user&quot;&gt;    select * from user     &lt;where&gt;    &lt;include refid=&quot;query_user_where&quot;/&gt;    &lt;/where&gt;&lt;/select&gt;</code></pre><p>注意：如果引用其它mapper.xml的sql片段，则在引用时需要加上namespace，如下：</p><pre><code>&lt;include refid=&quot;namespace.sql片段”/&gt;</code></pre><p>如果使用 &gt;或者&lt;符号的时候,因为是在xml文件中这些符号都是有特殊含义的,可以使用CDATA区域 &lt;![CDATA[要写的内容]]&gt;       &lt;![CDATA[&gt;]]&gt;大于   &lt;![CDATA[&lt;]]&gt;</p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;输入映射和输出映射&quot;&gt;&lt;a href=&quot;#输入映射和输出映射&quot; class=&quot;headerlink&quot; title=&quot;输入映射和输出映射&quot;&gt;&lt;/a&gt;输入映射和输出映射&lt;/h1&gt;&lt;p&gt;Mapper.xml映射文件中定义了操作数据库的sql，每个sql是一个statement，映射文件是mybatis的核心。&lt;br&gt;
    
    </summary>
    
      <category term="java" scheme="http://yoursite.com/categories/java/"/>
    
    
      <category term="mybatis" scheme="http://yoursite.com/tags/mybatis/"/>
    
  </entry>
  
  <entry>
    <title>mybatis入门二</title>
    <link href="http://yoursite.com/2018/02/24/mybatis%E5%85%A5%E9%97%A8%E4%BA%8C/"/>
    <id>http://yoursite.com/2018/02/24/mybatis入门二/</id>
    <published>2018-02-24T09:18:11.000Z</published>
    <updated>2018-02-27T13:48:55.433Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Mapper动态代理方式"><a href="#Mapper动态代理方式" class="headerlink" title="Mapper动态代理方式"></a>Mapper动态代理方式</h1><h2 id="开发规范"><a href="#开发规范" class="headerlink" title="开发规范"></a>开发规范</h2><p>Mapper接口开发方法只需要程序员编写Mapper接口（相当于Dao接口），由Mybatis框架根据接口定义创建接口的动态代理对象，代理对象的方法体同上边Dao接口实现类方法。</p><p>Mapper接口开发需要遵循以下规范：<br><a id="more"></a><br>1、    Mapper.xml文件中的namespace与mapper接口的类路径相同。</p><p>2、    Mapper接口方法名和Mapper.xml中定义的每个statement的id相同</p><p>3、    Mapper接口方法的输入参数类型和mapper.xml中定义的每个sql 的parameterType的类型相同</p><p>4、    Mapper接口方法的输出参数类型和mapper.xml中定义的每个sql的resultType的类型相同</p><h2 id="Mapper-xml-映射文件"><a href="#Mapper-xml-映射文件" class="headerlink" title="Mapper.xml(映射文件)"></a>Mapper.xml(映射文件)</h2><p>定义mapper映射文件UserMapper.xml（内容同Users.xml），需要修改namespace的值为 UserMapper接口路径。将UserMapper.xml放在classpath 下mapper目录 下。</p><pre><code>&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; ?&gt;&lt;!DOCTYPE mapperPUBLIC &quot;-//mybatis.org//DTD Mapper 3.0//EN&quot;&quot;http://mybatis.org/dtd/mybatis-3-mapper.dtd&quot;&gt;&lt;mapper namespace=&quot;cn.lxm.mybatis.mapper.UserMapper&quot;&gt;&lt;!-- 根据id获取用户信息 --&gt;&lt;select id=&quot;findUserById&quot; parameterType=&quot;int&quot; resultType=&quot;cn.lxm.mybatis.po.User&quot;&gt;    select * from user where id = #{id}&lt;/select&gt;&lt;!-- 自定义条件查询用户列表 --&gt;&lt;select id=&quot;findUserByUsername&quot; parameterType=&quot;java.lang.String&quot;         resultType=&quot;cn.lxm.mybatis.po.User&quot;&gt;   select * from user where username like &apos;%${value}%&apos; &lt;/select&gt;&lt;!-- 添加用户 --&gt;&lt;insert id=&quot;insertUser&quot; parameterType=&quot;cn.lxm.mybatis.po.User&quot;&gt;&lt;selectKey keyProperty=&quot;id&quot; order=&quot;AFTER&quot; resultType=&quot;java.lang.Integer&quot;&gt;    select LAST_INSERT_ID() &lt;/selectKey&gt;  insert into user(username,birthday,sex,address)   values(#{username},#{birthday},#{sex},#{address})&lt;/insert&gt;&lt;/mapper&gt;</code></pre><h2 id="Mapper-java-接口文件"><a href="#Mapper-java-接口文件" class="headerlink" title="Mapper.java(接口文件)"></a>Mapper.java(接口文件)</h2><pre><code>/** * 用户管理mapper */Public interface UserMapper {//根据用户id查询用户信息public User findUserById(int id) throws Exception;//查询用户列表public List&lt;User&gt; findUserByUsername(String username) throws Exception;//添加用户信息public void insertUser(User user)throws Exception; }</code></pre><p>接口定义有如下特点：</p><p>1、    Mapper接口方法名和Mapper.xml中定义的statement的id相同</p><p>2、    Mapper接口方法的输入参数类型和mapper.xml中定义的statement的parameterType的类型相同</p><p>3、    Mapper接口方法的输出参数类型和mapper.xml中定义的statement的resultType的类型相同</p><h2 id="加载UserMapper-xml文件"><a href="#加载UserMapper-xml文件" class="headerlink" title="加载UserMapper.xml文件"></a>加载UserMapper.xml文件</h2><p>修改SqlMapConfig.xml文件：</p><pre><code>&lt;!-- 加载映射文件 --&gt;&lt;mappers&gt;    &lt;mapper resource=&quot;mapper/UserMapper.xml&quot;/&gt;&lt;/mappers&gt;</code></pre><h2 id="测试"><a href="#测试" class="headerlink" title="测试"></a>测试</h2><pre><code>Public class UserMapperTest extends TestCase {    private SqlSessionFactory sqlSessionFactory;    protected void setUp() throws Exception {        //mybatis配置文件        String resource = &quot;sqlMapConfig.xml&quot;;        InputStream inputStream = Resources.getResourceAsStream(resource);        //使用SqlSessionFactoryBuilder创建sessionFactory        sqlSessionFactory = new SqlSessionFactoryBuilder().build(inputStream);    }    Public void testFindUserById() throws Exception {        //获取session        SqlSession session = sqlSessionFactory.openSession();        //获取mapper接口的代理对象        UserMapper userMapper = session.getMapper(UserMapper.class);        //调用代理对象方法        User user = userMapper.findUserById(1);        System.out.println(user);        //关闭session        session.close();    }    @Test    public void testFindUserByUsername() throws Exception {        SqlSession sqlSession = sqlSessionFactory.openSession();        UserMapper userMapper = sqlSession.getMapper(UserMapper.class);        List&lt;User&gt; list = userMapper.findUserByUsername(&quot;张&quot;);        System.out.println(list.size());    }    Public void testInsertUser() throws Exception {        //获取session        SqlSession session = sqlSessionFactory.openSession();        //获取mapper接口的代理对象        UserMapper userMapper = session.getMapper(UserMapper.class);        //要添加的数据        User user = new User();        user.setUsername(&quot;张三&quot;);        user.setBirthday(new Date());        user.setSex(&quot;1&quot;);        user.setAddress(&quot;北京市&quot;);        //通过mapper接口添加用户        userMapper.insertUser(user);        //提交        session.commit();        //关闭session        session.close();    }}</code></pre><h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><ul><li><p>selectOne和selectList<br>动态代理对象调用sqlSession.selectOne()和sqlSession.selectList()是根据mapper接口方法的返回值决定，如果返回list则调用selectList方法，如果返回单个对象则调用selectOne方法。</p></li><li><p>namespace<br>mybatis官方推荐使用mapper代理方法开发mapper接口，程序员不用编写mapper接口实现类，使用mapper代理方法时，输入参数可以使用pojo包装对象或map对象，保证dao的通用性。</p></li></ul><h2 id="SqlMapConfig-xml配置文件"><a href="#SqlMapConfig-xml配置文件" class="headerlink" title="SqlMapConfig.xml配置文件"></a>SqlMapConfig.xml配置文件</h2><h3 id="配置内容"><a href="#配置内容" class="headerlink" title="配置内容"></a>配置内容</h3><p>SqlMapConfig.xml中配置的内容和顺序如下：</p><pre><code>properties（属性）settings（全局配置参数）typeAliases（类型别名）typeHandlers（类型处理器）objectFactory（对象工厂）plugins（插件）environments（环境集合属性对象）environment（环境子属性对象）transactionManager（事务管理）dataSource（数据源）mappers（映射器）</code></pre><h2 id="properties（属性）"><a href="#properties（属性）" class="headerlink" title="properties（属性）"></a>properties（属性）</h2><p>SqlMapConfig.xml可以引用java属性文件中的配置信息如下：</p><p>在classpath下定义db.properties文件</p><pre><code>jdbc.driver=com.mysql.jdbc.Driverjdbc.url=jdbc:mysql://localhost:3306/mybatis?characterEncoding=utf-8jdbc.username=rootjdbc.password=root</code></pre><p>SqlMapConfig.xml引用如下：</p><pre><code>&lt;properties resource=&quot;db.properties&quot;/&gt;    &lt;environments default=&quot;development&quot;&gt;        &lt;environment id=&quot;development&quot;&gt;            &lt;transactionManager type=&quot;JDBC&quot;/&gt;            &lt;dataSource type=&quot;POOLED&quot;&gt;                &lt;property name=&quot;driver&quot; value=&quot;${jdbc.driver}&quot;/&gt;                &lt;property name=&quot;url&quot; value=&quot;${jdbc.url}&quot;/&gt;                &lt;property name=&quot;username&quot; value=&quot;${jdbc.username}&quot;/&gt;                &lt;property name=&quot;password&quot; value=&quot;${jdbc.password}&quot;/&gt;            &lt;/dataSource&gt;        &lt;/environment&gt;    &lt;/environments&gt;</code></pre><p>注意： MyBatis 将按照下面的顺序来加载属性：</p><ul><li>在 properties 元素体内定义的属性首先被读取。 </li><li>然后会读取properties 元素中resource或 url 加载的属性，它会覆盖已读取的同名属性。 </li></ul><h2 id="typeAliases（类型别名）"><a href="#typeAliases（类型别名）" class="headerlink" title="typeAliases（类型别名）"></a>typeAliases（类型别名）</h2><h3 id="mybatis支持别名："><a href="#mybatis支持别名：" class="headerlink" title="mybatis支持别名："></a>mybatis支持别名：</h3><pre><code>别名    映射的类型_byte     byte _long     long _short     short _int     int _integer     int _double     double _float     float _boolean     boolean string     String byte     Byte long     Long short     Short int     Integer integer     Integer double     Double float     Float boolean     Boolean date     Date decimal     BigDecimal bigdecimal     BigDecimal map    Map</code></pre><h3 id="自定义别名："><a href="#自定义别名：" class="headerlink" title="自定义别名："></a>自定义别名：</h3><p>在SqlMapConfig.xml中配置：<br>    <typealiases><br>        <!-- 单个别名定义 --><br>        <typealias alias="user" type="cn.lxm.mybatis.po.User"><br>        <!-- 批量别名定义，扫描整个包下的类，别名为类名（首字母大写或小写都可以） --><br>        <package name="cn.lxm.mybatis.po"><br>        <package name="其它包"><br>    </package></package></typealias></typealiases><br>这个<typealiases>标签的位置必须放在<environments>标签前面,dtd的约束</environments></typealiases></p><h2 id="mappers（映射器）"><a href="#mappers（映射器）" class="headerlink" title="mappers（映射器）"></a>mappers（映射器）</h2><p>Mapper配置的几种方法：</p><ul><li>&lt; mapper resource=” “ /&gt;</li></ul><p>使用相对于类路径的资源如：</p><pre><code>&lt;mapper resource=&quot;sqlmap/User.xml&quot; /&gt;</code></pre><ul><li>&lt; mapper class=” “ /&gt;</li></ul><p>使用mapper接口类路径如：</p><pre><code>&lt;mapper class=&quot;cn.lxm.mybatis.mapper.UserMapper&quot;/&gt;</code></pre><p>注意：此种方法要求mapper接口名称和mapper映射文件名称相同，且放在同一个目录中。</p><ul><li>&lt; package name=””/&gt;</li></ul><p>注册指定包下的所有mapper接口如：</p><pre><code>&lt;package name=&quot;cn.lxm.mybatis.mapper&quot;/&gt;</code></pre><p>注意：此种方法要求mapper接口名称和mapper映射文件名称相同，且放在同一个目录中。</p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;Mapper动态代理方式&quot;&gt;&lt;a href=&quot;#Mapper动态代理方式&quot; class=&quot;headerlink&quot; title=&quot;Mapper动态代理方式&quot;&gt;&lt;/a&gt;Mapper动态代理方式&lt;/h1&gt;&lt;h2 id=&quot;开发规范&quot;&gt;&lt;a href=&quot;#开发规范&quot; class=&quot;headerlink&quot; title=&quot;开发规范&quot;&gt;&lt;/a&gt;开发规范&lt;/h2&gt;&lt;p&gt;Mapper接口开发方法只需要程序员编写Mapper接口（相当于Dao接口），由Mybatis框架根据接口定义创建接口的动态代理对象，代理对象的方法体同上边Dao接口实现类方法。&lt;/p&gt;
&lt;p&gt;Mapper接口开发需要遵循以下规范：&lt;br&gt;
    
    </summary>
    
      <category term="java" scheme="http://yoursite.com/categories/java/"/>
    
    
      <category term="mybatis" scheme="http://yoursite.com/tags/mybatis/"/>
    
  </entry>
  
  <entry>
    <title>mybatis入门一</title>
    <link href="http://yoursite.com/2018/02/24/mybatis%E5%85%A5%E9%97%A8%E4%B8%80/"/>
    <id>http://yoursite.com/2018/02/24/mybatis入门一/</id>
    <published>2018-02-24T02:09:08.000Z</published>
    <updated>2018-02-27T13:51:22.571Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Mybatis入门程序"><a href="#Mybatis入门程序" class="headerlink" title="Mybatis入门程序"></a>Mybatis入门程序</h1><h2 id="1-mybatis下载"><a href="#1-mybatis下载" class="headerlink" title="1 mybatis下载"></a>1 mybatis下载</h2><p>mybaits的代码由github.com管理，地址：<a href="https://github.com/mybatis/mybatis-3/releases" target="_blank" rel="noopener">https://github.com/mybatis/mybatis-3/releases</a><br><a id="more"></a> </p><p>mybatis-3.2.7.jar—-mybatis的核心包<br>lib—-mybatis的依赖包<br>mybatis-3.2.7.pdf—-mybatis使用手册</p><h2 id="2-工程搭建"><a href="#2-工程搭建" class="headerlink" title="2 工程搭建"></a>2 工程搭建</h2><h3 id="第一步：创建java工程"><a href="#第一步：创建java工程" class="headerlink" title="第一步：创建java工程"></a>第一步：创建java工程</h3><p>使用eclipse创建java工程，jdk使用1.7.0_72。</p><h3 id="第二步：加入jar包"><a href="#第二步：加入jar包" class="headerlink" title="第二步：加入jar包"></a>第二步：加入jar包</h3><p>加入mybatis核心包、依赖包、数据驱动包。</p><h3 id="第三步：log4j-properties"><a href="#第三步：log4j-properties" class="headerlink" title="第三步：log4j.properties"></a>第三步：log4j.properties</h3><p>在classpath下创建log4j.properties如下：</p><pre><code># Global logging configurationlog4j.rootLogger=DEBUG, stdout# Console output...log4j.appender.stdout=org.apache.log4j.ConsoleAppenderlog4j.appender.stdout.layout=org.apache.log4j.PatternLayoutlog4j.appender.stdout.layout.ConversionPattern=%5p [%t] - %m%n</code></pre><p>mybatis默认使用log4j作为输出日志信息。</p><h3 id="第四步：SqlMapConfig-xml"><a href="#第四步：SqlMapConfig-xml" class="headerlink" title="第四步：SqlMapConfig.xml"></a>第四步：SqlMapConfig.xml</h3><p>在classpath下创建SqlMapConfig.xml，如下：</p><pre><code>&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; ?&gt;&lt;!DOCTYPE configurationPUBLIC &quot;-//mybatis.org//DTD Config 3.0//EN&quot;&quot;http://mybatis.org/dtd/mybatis-3-config.dtd&quot;&gt;&lt;configuration&gt;&lt;!-- 和spring整合后 environments配置将废除--&gt;&lt;environments default=&quot;development&quot;&gt;    &lt;environment id=&quot;development&quot;&gt;    &lt;!-- 使用jdbc事务管理--&gt;        &lt;transactionManager type=&quot;JDBC&quot; /&gt;    &lt;!-- 数据库连接池--&gt;        &lt;dataSource type=&quot;POOLED&quot;&gt;            &lt;property name=&quot;driver&quot; value=&quot;com.mysql.jdbc.Driver&quot; /&gt;            &lt;property name=&quot;url&quot; value=&quot;jdbc:mysql://localhost:3306/mybatis?characterEncoding=utf-8&quot; /&gt;            &lt;property name=&quot;username&quot; value=&quot;root&quot; /&gt;            &lt;property name=&quot;password&quot; value=&quot;root&quot; /&gt;        &lt;/dataSource&gt;    &lt;/environment&gt;&lt;/environments&gt;&lt;/configuration&gt;</code></pre><p>SqlMapConfig.xml是mybatis核心配置文件，上边文件的配置内容为数据源、事务管理。</p><h3 id="第五步：po类"><a href="#第五步：po类" class="headerlink" title="第五步：po类"></a>第五步：po类</h3><p>Po类作为mybatis进行sql映射使用，po类通常与数据库表对应，User.java如下：</p><pre><code>Public class User {    private int id;    private String username;// 用户姓名    private String sex;// 性别    private Date birthday;// 生日    private String address;// 地址get/set……</code></pre><h3 id="第六步：sql映射文件"><a href="#第六步：sql映射文件" class="headerlink" title="第六步：sql映射文件"></a>第六步：sql映射文件</h3><p>在classpath下的sqlmap目录下创建sql映射文件Users.xml：</p><pre><code>&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; ?&gt;&lt;!DOCTYPE mapperPUBLIC &quot;-//mybatis.org//DTD Mapper 3.0//EN&quot;&quot;http://mybatis.org/dtd/mybatis-3-mapper.dtd&quot;&gt;&lt;mapper namespace=&quot;test&quot;&gt;&lt;/mapper&gt;</code></pre><p>namespace ：命名空间，用于隔离sql语句，后面会讲另一层非常重要的作用。</p><h3 id="第七步：加载映射文件"><a href="#第七步：加载映射文件" class="headerlink" title="第七步：加载映射文件"></a>第七步：加载映射文件</h3><p>mybatis框架需要加载映射文件，将User.xml添加在SqlMapConfig.xml，如下：</p><pre><code>&lt;mappers&gt;    &lt;mapper resource=&quot;sqlmap/User.xml&quot;/&gt;&lt;/mappers&gt;</code></pre><h2 id="3-根据id查询用户信息"><a href="#3-根据id查询用户信息" class="headerlink" title="3 根据id查询用户信息"></a>3 根据id查询用户信息</h2><h3 id="映射文件："><a href="#映射文件：" class="headerlink" title="映射文件："></a>映射文件：</h3><p>在user.xml中添加：</p><pre><code>&lt;!-- 根据id获取用户信息 - -&gt;&lt;select id=&quot;findUserById&quot; parameterType=&quot;int&quot; resultType=&quot;cn.lxm.mybatis.po.User&quot;&gt;    select * from user where id = #{id}&lt;/select&gt;</code></pre><p>parameterType：定义输入到sql中的映射类型，#{id}表示使用preparedstatement设置占位符号并将输入变量id传到sql。<br>resultType：定义结果映射类型。</p><h3 id="测试程序："><a href="#测试程序：" class="headerlink" title="测试程序："></a>测试程序：</h3><pre><code>public class Mybatis_first {    //会话工厂    private SqlSessionFactory sqlSessionFactory;    @Before    public void createSqlSessionFactory() throws IOException {        // 配置文件        String resource = &quot;SqlMapConfig.xml&quot;;        InputStream inputStream = Resources.getResourceAsStream(resource);        // 使用SqlSessionFactoryBuilder从xml配置文件中创建SqlSessionFactory        sqlSessionFactory = new SqlSessionFactoryBuilder()                .build(inputStream);    }    // 根据 id查询用户信息    @Test    public void testFindUserById() {        // 数据库会话实例        SqlSession sqlSession = null;        try {            // 创建数据库会话实例sqlSession            sqlSession = sqlSessionFactory.openSession();            // 查询单个记录，根据用户id查询用户信息            User user = sqlSession.selectOne(&quot;test.findUserById&quot;, 10);            // 输出用户信息            System.out.println(user);        } catch (Exception e) {            e.printStackTrace();        } finally {            if (sqlSession != null) {                sqlSession.close();            }        }    }}</code></pre><h2 id="4-根据用户名查询用户信息"><a href="#4-根据用户名查询用户信息" class="headerlink" title="4 根据用户名查询用户信息"></a>4 根据用户名查询用户信息</h2><h3 id="映射文件：-1"><a href="#映射文件：-1" class="headerlink" title="映射文件："></a>映射文件：</h3><p>在user.xml中添加：</p><pre><code>&lt;!-- 自定义条件查询用户列表  - -&gt;&lt;select id=&quot;findUserByUsername&quot; parameterType=&quot;java.lang.String&quot;         resultType=&quot;cn.lxm.mybatis.po.User&quot;&gt;   select * from user where username like &apos;%${value}%&apos; &lt;/select&gt;</code></pre><p>parameterType：定义输入到sql中的映射类型，${value}表示使用参数将${value}替换，做字符串的拼接。<br>注意：如果是取简单数据类型的参数，括号中的值必须为value<br>resultType：定义结果映射类型。</p><h3 id="测试程序：-1"><a href="#测试程序：-1" class="headerlink" title="测试程序："></a>测试程序：</h3><pre><code>// 根据用户名称模糊查询用户信息@Testpublic void testFindUserByUsername() {    // 数据库会话实例    SqlSession sqlSession = null;    try {        // 创建数据库会话实例sqlSession        sqlSession = sqlSessionFactory.openSession();        // 查询单个记录，根据用户id查询用户信息        List&lt;User&gt; list = sqlSession.selectList(&quot;test.findUserByUsername&quot;, &quot;张&quot;);        System.out.println(list.size());    } catch (Exception e) {        e.printStackTrace();    } finally {        if (sqlSession != null) {            sqlSession.close();        }    }}</code></pre><h1 id="5小结"><a href="#5小结" class="headerlink" title="5小结"></a>5小结</h1><h2 id="和"><a href="#和" class="headerlink" title="#{}和${}"></a>#{}和${}</h2><p>-#{}表示一个占位符号，通过#{}可以实现preparedStatement向占位符中设置值，自动进行java类型和jdbc类型转换，#{}可以有效防止sql注入。 #{}可以接收简单类型值或pojo属性值。 如果parameterType传输单个简单类型值，#{}括号中可以是value或其它名称。</p><p>-${}表示拼接sql串，通过${}可以将parameterType 传入的内容拼接在sql中且不进行jdbc类型转换， ${}可以接收简单类型值或pojo属性值，如果parameterType传输单个简单类型值，${}括号中只能是value。</p><h2 id="parameterType和resultType"><a href="#parameterType和resultType" class="headerlink" title="parameterType和resultType"></a>parameterType和resultType</h2><p>parameterType：指定输入参数类型，mybatis通过ognl从输入对象中获取参数值拼接在sql中。<br>resultType：指定输出结果类型，mybatis将sql查询结果的一行记录数据映射为resultType指定类型的对象。</p><h2 id="selectOne和selectList"><a href="#selectOne和selectList" class="headerlink" title="selectOne和selectList"></a>selectOne和selectList</h2><p>selectOne查询一条记录，如果使用selectOne查询多条记录则抛出异常：<br>    org.apache.ibatis.exceptions.TooManyResultsException: Expected one result (or null) to be returned by selectOne(), but found: 3<br>    at org.apache.ibatis.session.defaults.DefaultSqlSession.selectOne(DefaultSqlSession.java:70)</p><p>selectList可以查询一条或多条记录。</p><h1 id="6添加用户"><a href="#6添加用户" class="headerlink" title="6添加用户"></a>6添加用户</h1><h2 id="映射文件：-2"><a href="#映射文件：-2" class="headerlink" title="映射文件："></a>映射文件：</h2><p>在SqlMapConfig.xml中添加：<br><!-- 添加用户 --><br>    <insert id="insertUser" parametertype="cn.lxm.mybatis.po.User"><br>      insert into user(username,birthday,sex,address)<br>      values(#{username},#{birthday},#{sex},#{address})<br>    </insert></p><h2 id="测试程序：-2"><a href="#测试程序：-2" class="headerlink" title="测试程序："></a>测试程序：</h2><pre><code>// 添加用户信息@Testpublic void testInsert() {    // 数据库会话实例    SqlSession sqlSession = null;    try {        // 创建数据库会话实例sqlSession        sqlSession = sqlSessionFactory.openSession();        // 添加用户信息        User user = new User();        user.setUsername(&quot;张小明&quot;);        user.setAddress(&quot;河南郑州&quot;);        user.setSex(&quot;1&quot;);        user.setPrice(1999.9f);        sqlSession.insert(&quot;test.insertUser&quot;, user);        //提交事务        sqlSession.commit();    } catch (Exception e) {        e.printStackTrace();    } finally {        if (sqlSession != null) {            sqlSession.close();        }    }}</code></pre><h2 id="mysql自增主键返回"><a href="#mysql自增主键返回" class="headerlink" title="mysql自增主键返回"></a>mysql自增主键返回</h2><p>通过修改sql映射文件，可以将mysql自增主键返回:</p><pre><code>&lt;insert id=&quot;insertUser&quot; parameterType=&quot;cn.lxm.mybatis.po.User&quot;&gt;    &lt;!-- selectKey将主键返回，需要再返回 使用user.getId()获取返回的id值 --&gt;    &lt;selectKey keyProperty=&quot;id&quot; order=&quot;AFTER&quot; resultType=&quot;java.lang.Integer&quot;&gt;        select LAST_INSERT_ID()    &lt;/selectKey&gt;   insert into user(username,birthday,sex,address)    values(#{username},#{birthday},#{sex},#{address});&lt;/insert&gt;</code></pre><p>添加selectKey实现将主键返回</p><p>keyProperty:返回的主键存储在pojo中的哪个属性</p><p>order：selectKey的执行顺序，是相对与insert语句来说，由于mysql的自增原理执行完insert语句之后才将主键生成，所以这里selectKey的执行顺序为after</p><p>resultType:返回的主键是什么类型</p><p>LAST_INSERT_ID():是mysql的函数，返回auto_increment自增列新记录id值。</p><h2 id="oracle自增主键返回"><a href="#oracle自增主键返回" class="headerlink" title="oracle自增主键返回"></a>oracle自增主键返回</h2><pre><code>&lt;insert id=&quot;insertUser&quot; parameterType=&quot;cn.lxm.mybatis.po.User&quot;&gt;    &lt;!-- selectKey将主键返回，需要再返回 --&gt;    &lt;selectKey keyProperty=&quot;id&quot; order=&quot;BEFORE&quot; resultType=&quot;java.lang.Integer&quot;&gt;        select 序列的.nextval()    &lt;/selectKey&gt;   insert into user(id,username,birthday,sex,address)    values(#{id},#{username},#{birthday},#{sex},#{address});&lt;/insert&gt;</code></pre><p>oracle的不是很常用,这里是需要先取出序列里面的主键,然后再插入数据,插入的时候讲取出来的主键放进去.所以这里的order是BEFORE</p><h2 id="Mysql使用-uuid实现主键"><a href="#Mysql使用-uuid实现主键" class="headerlink" title="Mysql使用 uuid实现主键"></a>Mysql使用 uuid实现主键</h2><p>需要增加通过select uuid()得到uuid值</p><pre><code>&lt;insert  id=&quot;insertUser&quot; parameterType=&quot;cn.lxm.mybatis.po.User&quot;&gt;&lt;selectKey resultType=&quot;java.lang.String&quot; order=&quot;BEFORE&quot; keyProperty=&quot;id&quot;&gt;select uuid()&lt;/selectKey&gt;insert into user(id,username,birthday,sex,address)          values(#{id},#{username},#{birthday},#{sex},#{address})&lt;/insert&gt;</code></pre><p>注意这里使用的order是“BEFORE”</p><h1 id="7删除用户"><a href="#7删除用户" class="headerlink" title="7删除用户"></a>7删除用户</h1><h2 id="映射文件：-3"><a href="#映射文件：-3" class="headerlink" title="映射文件："></a>映射文件：</h2><!-- 删除用户 --><pre><code>&lt;delete id=&quot;deleteUserById&quot; parameterType=&quot;int&quot;&gt;    delete from user where id=#{id}&lt;/delete&gt;</code></pre><h2 id="测试程序：-3"><a href="#测试程序：-3" class="headerlink" title="测试程序："></a>测试程序：</h2><pre><code>// 根据id删除用户@Testpublic void testDelete() {    // 数据库会话实例    SqlSession sqlSession = null;    try {        // 创建数据库会话实例sqlSession        sqlSession = sqlSessionFactory.openSession();        // 删除用户        sqlSession.delete(&quot;test.deleteUserById&quot;,18);        // 提交事务        sqlSession.commit();    } catch (Exception e) {        e.printStackTrace();    } finally {        if (sqlSession != null) {            sqlSession.close();        }    }}</code></pre><h1 id="8修改用户"><a href="#8修改用户" class="headerlink" title="8修改用户"></a>8修改用户</h1><h2 id="映射文件"><a href="#映射文件" class="headerlink" title="映射文件"></a>映射文件</h2><!-- 更新用户 --><pre><code>&lt;update id=&quot;updateUser&quot; parameterType=&quot;cn.lxm.mybatis.po.User&quot;&gt;    update user set username=#{username},birthday=#{birthday},sex=#{sex},address=#{address}    where id=#{id}&lt;/update&gt;</code></pre><h2 id="测试程序"><a href="#测试程序" class="headerlink" title="测试程序"></a>测试程序</h2><pre><code>// 更新用户信息@Testpublic void testUpdate() {    // 数据库会话实例    SqlSession sqlSession = null;    try {        // 创建数据库会话实例sqlSession        sqlSession = sqlSessionFactory.openSession();        // 添加用户信息        User user = new User();        user.setId(16);        user.setUsername(&quot;张小明&quot;);        user.setAddress(&quot;河南郑州&quot;);        user.setSex(&quot;1&quot;);        user.setPrice(1999.9f);        sqlSession.update(&quot;test.updateUser&quot;, user);        // 提交事务        sqlSession.commit();    } catch (Exception e) {        e.printStackTrace();    } finally {        if (sqlSession != null) {            sqlSession.close();        }    }}</code></pre><h1 id="9-Mybatis解决jdbc编程的问题"><a href="#9-Mybatis解决jdbc编程的问题" class="headerlink" title="9 Mybatis解决jdbc编程的问题"></a>9 Mybatis解决jdbc编程的问题</h1><ul><li>1、    数据库链接创建、释放频繁造成系统资源浪费从而影响系统性能，如果使用数据库链接池可解决此问题。<br>解决：在SqlMapConfig.xml中配置数据链接池，使用连接池管理数据库链接。</li><li>2、    Sql语句写在代码中造成代码不易维护，实际应用sql变化的可能较大，sql变动需要改变java代码。<br>解决：将Sql语句配置在XXXXmapper.xml文件中与java代码分离。</li><li>3、    向sql语句传参数麻烦，因为sql语句的where条件不一定，可能多也可能少，占位符需要和参数一一对应。<br>解决：Mybatis自动将java对象映射至sql语句，通过statement中的parameterType定义输入参数的类型。</li><li>4、    对结果集解析麻烦，sql变化导致解析代码变化，且解析前需要遍历，如果能将数据库记录封装成pojo对象解析比较方便。<br>解决：Mybatis自动将sql执行结果映射至java对象，通过statement中的resultType定义输出结果的类型。</li></ul><h1 id="10-mybatis与hibernate不同"><a href="#10-mybatis与hibernate不同" class="headerlink" title="10 mybatis与hibernate不同"></a>10 mybatis与hibernate不同</h1><ul><li><p>Mybatis和hibernate不同，它不完全是一个ORM框架，因为MyBatis需要程序员自己编写Sql语句，不过mybatis可以通过XML或注解方式灵活配置要运行的sql语句，并将java对象和sql语句映射生成最终执行的sql，最后将sql执行的结果再映射生成java对象。</p></li><li><p>Mybatis学习门槛低，简单易学，程序员直接编写原生态sql，可严格控制sql执行性能，灵活度高，非常适合对关系数据模型要求不高的软件开发，例如互联网软件、企业运营类软件等，因为这类软件需求变化频繁，一但需求变化要求成果输出迅速。但是灵活的前提是mybatis无法做到数据库无关性，如果需要实现支持多种数据库的软件则需要自定义多套sql映射文件，工作量大。</p></li><li><p>Hibernate对象/关系映射能力强，数据库无关性好，对于关系模型要求高的软件（例如需求固定的定制化软件）如果用hibernate开发可以节省很多代码，提高效率。但是Hibernate的学习门槛高，要精通门槛更高，而且怎么设计O/R映射，在性能和对象模型之间如何权衡，以及怎样用好Hibernate需要具有很强的经验和能力才行。</p></li><li><p>总之，按照用户的需求在有限的资源环境下只要能做出维护性、扩展性良好的软件架构都是好架构，所以框架只有适合才是最好。</p></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;Mybatis入门程序&quot;&gt;&lt;a href=&quot;#Mybatis入门程序&quot; class=&quot;headerlink&quot; title=&quot;Mybatis入门程序&quot;&gt;&lt;/a&gt;Mybatis入门程序&lt;/h1&gt;&lt;h2 id=&quot;1-mybatis下载&quot;&gt;&lt;a href=&quot;#1-mybatis下载&quot; class=&quot;headerlink&quot; title=&quot;1 mybatis下载&quot;&gt;&lt;/a&gt;1 mybatis下载&lt;/h2&gt;&lt;p&gt;mybaits的代码由github.com管理，地址：&lt;a href=&quot;https://github.com/mybatis/mybatis-3/releases&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://github.com/mybatis/mybatis-3/releases&lt;/a&gt;&lt;br&gt;
    
    </summary>
    
      <category term="java" scheme="http://yoursite.com/categories/java/"/>
    
    
      <category term="mybatis" scheme="http://yoursite.com/tags/mybatis/"/>
    
  </entry>
  
  <entry>
    <title>webService天气预报接口</title>
    <link href="http://yoursite.com/2018/02/11/webService%E5%A4%A9%E6%B0%94%E9%A2%84%E6%8A%A5%E6%8E%A5%E5%8F%A3/"/>
    <id>http://yoursite.com/2018/02/11/webService天气预报接口/</id>
    <published>2018-02-11T15:36:17.000Z</published>
    <updated>2018-02-11T15:42:41.163Z</updated>
    
    <content type="html"><![CDATA[<p>一：环境搭建<br>二：根据wsdl文件生成客户端代码<br>三：测试代码<br><a id="more"></a></p><h1 id="一：环境搭建"><a href="#一：环境搭建" class="headerlink" title="一：环境搭建"></a>一：环境搭建</h1><pre><code>1：新建一个java project工程weatherInf2：引入相应的jar包activation.jaraxis-ant.jaraxis.jarcommons-discovery-0.2.jarcommons-logging-1.0.4.jarjaxrpc.jarlog4j-1.2.8.jarmail.jarsaaj.jarwsdl4j-1.5.1.jar下载axis 1.4 src压缩包，解压后到webapp/web-info/lib下取包，具体路径如下：http://download.csdn.net/detail/yyg64/5351114其中mail.jar 以及 activation.jar 可到如下路径下载：http://download.csdn.net/detail/dbhunter/3982583：将天气预报接口wsdl文件拷贝到src目录下http://www.webxml.com.cn/WebServices/WeatherWebService.asmx?wsdl</code></pre><h1 id="二：根据wsdl文件生成客户端代码"><a href="#二：根据wsdl文件生成客户端代码" class="headerlink" title="二：根据wsdl文件生成客户端代码"></a>二：根据wsdl文件生成客户端代码</h1><p>wsdl文件——右键——web services——Generate Client，然后一路next到finish。</p><h1 id="三：测试代码"><a href="#三：测试代码" class="headerlink" title="三：测试代码"></a>三：测试代码</h1><pre><code> 1 /** 2  *  3  */ 4 package com.paic.services; 5  6 import java.rmi.RemoteException; 7  8 import javax.xml.rpc.ServiceException; 9 10 import cn.com.WebXml.WeatherWebServiceLocator;11 import cn.com.WebXml.WeatherWebServiceSoapStub;12 13 /**14  * @author Administrator15  * 16  */17 public class TestWeather {18     public static void main(String[] args) throws ServiceException,19             RemoteException {20         WeatherWebServiceLocator locator = new WeatherWebServiceLocator();21         WeatherWebServiceSoapStub service = (WeatherWebServiceSoapStub) locator22                 .getPort(WeatherWebServiceSoapStub.class);23         invokeGetSupportProvince(service);24         System.out.println(&quot;...................&quot;);25         invokeGetSupportCity(service);26         invokeGetWeatherByOneCity(service);27     }28 29     // 调用获取支持的省份、州接口30     public static void invokeGetSupportProvince(31             WeatherWebServiceSoapStub service) throws RemoteException {32         String[] provices = service.getSupportProvince();33         System.out.println(&quot;总共&quot; + provices.length + &quot;个&quot;);34         int count = 0;35         for (String str : provices) {36             if (0 != count &amp;&amp; count % 5 == 0) {37                 System.out.println();38             }39             System.out.print(str + &quot;\t&quot;);40             count++;41         }42     }43 44     // 调用获取支持查询某个省份内的城市接口45     public static void invokeGetSupportCity(WeatherWebServiceSoapStub service)46             throws RemoteException {47         String provinceName = &quot;江苏&quot;;48         String[] cities = service.getSupportCity(provinceName);49         System.out.println(&quot;总共&quot; + cities.length + &quot;个市&quot;);50         for (int i = 0; i &lt; cities.length; i++) {51             if (0 != i &amp;&amp; i % 5 == 0) {52                 System.out.println();53             }54             System.out.print(cities[i] + &quot;\t&quot;);55         }56     }57 58     // 调用查询某个城市天气的接口59     public static void invokeGetWeatherByOneCity(60             WeatherWebServiceSoapStub service) throws RemoteException {61         String cityName = &quot;南京&quot;;62         String[] weatherInfo = service.getWeatherbyCityName(cityName);63         for (String str : weatherInfo) {64             System.out.println(str);65         }66     }67 }</code></pre>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;一：环境搭建&lt;br&gt;二：根据wsdl文件生成客户端代码&lt;br&gt;三：测试代码&lt;br&gt;
    
    </summary>
    
      <category term="前端" scheme="http://yoursite.com/categories/%E5%89%8D%E7%AB%AF/"/>
    
    
      <category term="webservice" scheme="http://yoursite.com/tags/webservice/"/>
    
  </entry>
  
  <entry>
    <title>Quarze入门知识</title>
    <link href="http://yoursite.com/2018/02/10/Quarze%E5%85%A5%E9%97%A8%E7%9F%A5%E8%AF%86/"/>
    <id>http://yoursite.com/2018/02/10/Quarze入门知识/</id>
    <published>2018-02-10T15:18:51.000Z</published>
    <updated>2018-02-11T15:41:46.157Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Quartz-入门详解"><a href="#Quartz-入门详解" class="headerlink" title="Quartz 入门详解"></a>Quartz 入门详解</h1><h2 id="入门简介："><a href="#入门简介：" class="headerlink" title="入门简介："></a>入门简介：</h2><p>基本上任何公司都会用到调度这个功能， 比如我们公司需要定期执行调度生成报表， 或者比如博客什么的定时更新之类的，都可以靠Quartz来完成。正如官网所说，小到独立应用大到大型电子商务网站， Quartz都能胜任。</p><a id="more"></a><h2 id="Quartz体系结构："><a href="#Quartz体系结构：" class="headerlink" title="Quartz体系结构："></a>Quartz体系结构：</h2><p>明白Quartz怎么用，首先要了解Scheduler(调度器)、Job(任务)和Trigger(触发器)这3个核心的概念。</p><h3 id="1-Job："><a href="#1-Job：" class="headerlink" title="1. Job："></a>1. Job：</h3><p>是一个接口，只定义一个方法execute(JobExecutionContext context)，在实现接口的execute方法中编写所需要定时执行的Job(任务)， JobExecutionContext类提供了调度应用的一些信息。Job运行时的信息保存在JobDataMap实例中；</p><h3 id="2-JobDetail："><a href="#2-JobDetail：" class="headerlink" title="2. JobDetail："></a>2. JobDetail：</h3><p>Quartz每次调度Job时， 都重新创建一个Job实例， 所以它不直接接受一个Job的实例，相反它接收一个Job实现类(JobDetail:描述Job的实现类及其它相关的静态信息，如Job名字、描述、关联监听器等信息)，以便运行时通过newInstance()的反射机制实例化Job。</p><h3 id="3-Trigger："><a href="#3-Trigger：" class="headerlink" title="3. Trigger："></a>3. Trigger：</h3><p>是一个类，描述触发Job执行的时间触发规则。主要有SimpleTrigger和CronTrigger这两个子类。当且仅当需调度一次或者以固定时间间隔周期执行调度，SimpleTrigger是最适合的选择；而CronTrigger则可以通过Cron表达式定义出各种复杂时间规则的调度方案：如工作日周一到周五的15：00~16：00执行调度等；</p><h4 id="Cron表达式的格式："><a href="#Cron表达式的格式：" class="headerlink" title="Cron表达式的格式："></a>Cron表达式的格式：</h4><pre><code>秒 分 时 日 月 周 年(可选)。字段名                 允许的值                        允许的特殊字符秒                         0-59                               , – * /分                         0-59                               , – * /小时                   0-23                                 , – * /日                         1-31                               , – * ? / L W C月                         1-12 or JAN-DEC           , – * /周几                     1-7 or SUN-SAT             , – * ? / L C #      MON  FRI年 (可选字段)     empty, 1970-2099            , – * /“?”字符：表示不确定的值“,”字符：指定数个值“-”字符：指定一个值的范围“/”字符：指定一个值的增加幅度。n/m表示从n开始，每次增加m“L”字符：用在日表示一个月中的最后一天，用在周表示该月最后一个星期X“W”字符：指定离给定日期最近的工作日(周一到周五)“#”字符：表示该月第几个周X。6#3表示该月第3个周五Cron表达式范例：每隔5秒执行一次：*/5 * * * * ?每隔1分钟执行一次：0 */1 * * * ?每天23点执行一次：0 0 23 * * ?每天凌晨1点执行一次：0 0 1 * * ?每月1号凌晨1点执行一次：0 0 1 1 * ?每月最后一天23点执行一次：0 0 23 L * ?每周星期天凌晨1点实行一次：0 0 1 ? * L在26分、29分、33分执行一次：0 26,29,33 * * * ?每天的0点、13点、18点、21点都执行一次：0 0 0,13,18,21 * * ?</code></pre><h3 id="4-Calendar："><a href="#4-Calendar：" class="headerlink" title="4. Calendar："></a>4. Calendar：</h3><p>org.quartz.Calendar和java.util.Calendar不同， 它是一些日历特定时间点的集合（可以简单地将org.quartz.Calendar看作java.util.Calendar的集合——java.util.Calendar代表一个日历时间点，无特殊说明后面的Calendar即指org.quartz.Calendar）。 一个Trigger可以和多个Calendar关联， 以便排除或包含某些时间点。<br>假设，我们安排每周星期一早上10:00执行任务，但是如果碰到法定的节日，任务则不执行，这时就需要在Trigger触发机制的基础上使用Calendar进行定点排除。针对不同时间段类型，Quartz在org.quartz.impl.calendar包下提供了若干个Calendar的实现类，如AnnualCalendar、MonthlyCalendar、WeeklyCalendar分别针对每年、每月和每周进行定义；</p><h3 id="5-Scheduler："><a href="#5-Scheduler：" class="headerlink" title="5. Scheduler："></a>5. Scheduler：</h3><p>代表一个Quartz的独立运行容器， Trigger和JobDetail可以注册到Scheduler中， 两者在Scheduler中拥有各自的组及名称， 组及名称是Scheduler查找定位容器中某一对象的依据， Trigger的组及名称必须唯一， JobDetail的组和名称也必须唯一（但可以和Trigger的组和名称相同，因为它们是不同类型的）。Scheduler定义了多个接口方法， 允许外部通过组及名称访问和控制容器中Trigger和JobDetail。<br>Scheduler可以将Trigger绑定到某一JobDetail中， 这样当Trigger触发时， 对应的Job就被执行。一个Job可以对应多个Trigger， 但一个Trigger只能对应一个Job。可以通过SchedulerFactory创建一个Scheduler实例。Scheduler拥有一个SchedulerContext，它类似于ServletContext，保存着Scheduler上下文信息，Job和Trigger都可以访问SchedulerContext内的信息。SchedulerContext内部通过一个Map，以键值对的方式维护这些上下文数据，SchedulerContext为保存和获取数据提供了多个put()和getXxx()的方法。可以通过Scheduler# getContext()获取对应的SchedulerContext实例；</p><h3 id="6-ThreadPool："><a href="#6-ThreadPool：" class="headerlink" title="6. ThreadPool："></a>6. ThreadPool：</h3><p>Scheduler使用一个线程池作为任务运行的基础设施，任务通过共享线程池中的线程提高运行效率。<br>Job有一个StatefulJob子接口，代表有状态的任务，该接口是一个没有方法的标签接口，其目的是让Quartz知道任务的类型，以便采用不同的执行方案。无状态任务在执行时拥有自己的JobDataMap拷贝，对JobDataMap的更改不会影响下次的执行。而有状态任务共享共享同一个JobDataMap实例，每次任务执行对JobDataMap所做的更改会保存下来，后面的执行可以看到这个更改，也即每次执行任务后都会对后面的执行发生影响。<br>正因为这个原因，无状态的Job可以并发执行，而有状态的StatefulJob不能并发执行，这意味着如果前次的StatefulJob还没有执行完毕，下一次的任务将阻塞等待，直到前次任务执行完毕。有状态任务比无状态任务需要考虑更多的因素，程序往往拥有更高的复杂度，因此除非必要，应该尽量使用无状态的Job。<br>如果Quartz使用了数据库持久化任务调度信息，无状态的JobDataMap仅会在Scheduler注册任务时保持一次，而有状态任务对应的JobDataMap在每次执行任务后都会进行保存。<br>Trigger自身也可以拥有一个JobDataMap，其关联的Job可以通过JobExecutionContext#getTrigger().getJobDataMap()获取Trigger中的JobDataMap。不管是有状态还是无状态的任务，在任务执行期间对Trigger的JobDataMap所做的更改都不会进行持久，也即不会对下次的执行产生影响。<br>Quartz拥有完善的事件和监听体系，大部分组件都拥有事件，如任务执行前事件、任务执行后事件、触发器触发前事件、触发后事件、调度器开始事件、关闭事件等等，可以注册相应的监听器处理感兴趣的事件。<br>下图描述了Scheduler的内部组件结构，SchedulerContext提供Scheduler全局可见的上下文信息，每一个任务都对应一个JobDataMap，虚线表达的JobDataMap表示对应有状态的任务：</p><p>废话不多说， 上代码：</p><ol><li><p>最简单的Job代码(就打印Hello Quartz ！)：<br> package com.wenniuwuren.quartz;  </p><p> import org.quartz.Job;<br> import org.quartz.JobExecutionContext;<br> import org.quartz.JobExecutionException;  </p><p> public class HelloQuartz  implements Job {  </p><p> public void execute(JobExecutionContext arg0) throws JobExecutionException {  </p><pre><code>System.out.println(&quot;Hello Quartz !&quot;);                 </code></pre><p> }<br> }</p></li><li><p>设置触发器<br> package com.wenniuwuren.quartz;  </p><p> import org.quartz.CronScheduleBuilder;<br> import org.quartz.JobBuilder;<br> import org.quartz.JobDetail;<br> import org.quartz.Scheduler;<br> import org.quartz.SchedulerException;<br> import org.quartz.SchedulerFactory;<br> import org.quartz.SimpleScheduleBuilder;<br> import org.quartz.Trigger;<br> import org.quartz.TriggerBuilder;<br> import org.quartz.impl.StdSchedulerFactory;    </p><p> public class SchedulerTest {    </p><pre><code>public static void main(String[] args) throws InterruptedException {    //通过schedulerFactory获取一个调度器    SchedulerFactory schedulerfactory = new StdSchedulerFactory();    Scheduler scheduler=null;    try{        // 通过schedulerFactory获取一个调度器        scheduler = schedulerfactory.getScheduler();         // 创建jobDetail实例，绑定Job实现类         // 指明job的名称，所在组的名称，以及绑定job类        JobDetail job = JobBuilder.newJob(HelloQuartz.class).withIdentity(&quot;JobName&quot;, &quot;JobGroupName&quot;).build();         // 定义调度触发规则         // SimpleTrigger    //      Trigger trigger=TriggerBuilder.newTrigger().withIdentity(&quot;SimpleTrigger&quot;, &quot;SimpleTriggerGroup&quot;)     //                    .withSchedule(SimpleScheduleBuilder.repeatSecondlyForever(3).withRepeatCount(6))     //                    .startNow().build();         //  corn表达式  每五秒执行一次         Trigger trigger=TriggerBuilder.newTrigger().withIdentity(&quot;CronTrigger1&quot;, &quot;CronTriggerGroup&quot;)           .withSchedule(CronScheduleBuilder.cronSchedule(&quot;*/5 * * * * ?&quot;))           .startNow().build();          // 把作业和触发器注册到任务调度中        scheduler.scheduleJob(job, trigger);        // 启动调度        scheduler.start();        Thread.sleep(10000);      // 停止调度      scheduler.shutdown();   }catch(SchedulerException e){            e.printStackTrace();        }        }     }</code></pre><p>输出(设置了sleep10秒， 故在0秒调度一次， 5秒一次， 10秒最后一次)：</p></li></ol>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;Quartz-入门详解&quot;&gt;&lt;a href=&quot;#Quartz-入门详解&quot; class=&quot;headerlink&quot; title=&quot;Quartz 入门详解&quot;&gt;&lt;/a&gt;Quartz 入门详解&lt;/h1&gt;&lt;h2 id=&quot;入门简介：&quot;&gt;&lt;a href=&quot;#入门简介：&quot; class=&quot;headerlink&quot; title=&quot;入门简介：&quot;&gt;&lt;/a&gt;入门简介：&lt;/h2&gt;&lt;p&gt;基本上任何公司都会用到调度这个功能， 比如我们公司需要定期执行调度生成报表， 或者比如博客什么的定时更新之类的，都可以靠Quartz来完成。正如官网所说，小到独立应用大到大型电子商务网站， Quartz都能胜任。&lt;/p&gt;
    
    </summary>
    
      <category term="java" scheme="http://yoursite.com/categories/java/"/>
    
    
      <category term="quarze" scheme="http://yoursite.com/tags/quarze/"/>
    
  </entry>
  
  <entry>
    <title>Oracle知识点总结</title>
    <link href="http://yoursite.com/2018/02/10/Oracle%E7%9F%A5%E8%AF%86%E7%82%B9%E6%80%BB%E7%BB%93/"/>
    <id>http://yoursite.com/2018/02/10/Oracle知识点总结/</id>
    <published>2018-02-10T15:04:18.000Z</published>
    <updated>2018-02-24T01:33:16.315Z</updated>
    
    <content type="html"><![CDATA[<p>ORACLE</p><ol><li>01.单表查询-简单条件和去重</li></ol><p>Oracle 的简单查询和去重<br>（1）–精确查询<br>–需求：查询水表编号为 30408 的业主记录<br>select <em> from T_OWNERS where watermeter = ‘30408’;<br>（2）–模糊查询<br>–需求：查询业主名称包含“刘”的业主记录<br>select </em> from T_OWNERS where name like ‘%刘%’;<br><a id="more"></a><br>（3）–and 运算符<br>–需求：查询业主名称包含“刘”的并且门牌号包含 5 的业主记录<br>select <em> from T_OWNERS where name like ‘%刘%’ and housenumber like ‘%5%’;<br>（4）–or 运算符<br>–需求：查询业主名称包含“刘”的或者门牌号包含 5 的业主记录<br>select </em> from T_OWNERS where name like ‘%刘%’ or housenumber like ‘%5%’;<br>（5）–and 与 or 运算符混合使用<br>–需求：查询业主名称包含“刘”的或者门牌号包含 5 的业主记录，并且地址编号为 3 的记录。<br>select <em> from T_OWNERS where (name like ‘%刘%’ or housenumber like ‘%5%’) and addressid = 3<br>（6）–范围查询<br>–需求：查询台账记录中用水字数大于等于 10000，并且小于等于 20000 的记录我们可以用&gt;= 和&lt;=来实现，语句<br>select </em> from T_ACCOUNT where usenum&gt;=10000 and usenum &lt;=20000<br>select <em> from T_ACCOUNT where usenum between 10000 and 20000<br>（7）–空值查询<br>–需求：查询 T_PRICETABLE 表中 MAXNUM 为空的记录<br>select </em> from T_PRICETABLE where maxnum is null<br>–不为空<br>select * from T_PRICETABLE where maxnum is not null<br>（8）–去掉重复记录<br>–需求：查询业主表中的地址 ID,不重复显示<br>select distinct addressid from T_OWNERS  </p><ol><li><p>02.单表查询-排序和基于伪列查询（开发中经常用到必须掌握）<br>要点：排序和伪列<br>（1）–排序查询<br>–需求：对 T_ACCOUNT 表按使用量进行升序排序(由小到大)<br>select <em> from T_ACCOUNT order by usenum asc –asc可以省略<br>–降序排序<br>–需求：对 T_ACCOUNT 表按使用量进行降序排序（由大到小）<br>select </em> from T_ACCOUNT order by usenum desc</p><p>可以通过数据库表中的多个字段来排序，要求：根据排序的前面字段，有重复，按照书写的顺序来进行排序的。例如： 对业主表，按照地址ID降序排列，地址一样，按照ID升序排列：<br>select * from T_OWNERS t order by t.addressid desc, t.id asc</p></li></ol><p>（2）伪列：Oracle对每张表自动加上两列rowid和rownum成为伪列</p><p>rowid：存储的是物理地址，值是不重复的查询速度比较快<br>–伪列 rowid<br>select rowid,t.<em> from T_OWNERS t –如果想跟其他字段一起显示<br>select rowid from T_OWNERS –可以单独查询rowid<br>select rowid,t.</em> from T_OWNERS t where t.rowid = ‘AAAM1VAAGAAAABNAAA’     –可以根据条件查询</p><p>rownum：每张表Oracle自动给加上的一个序号。<br>–伪列rownum<br>select rownum,t.* from T_OWNERS t –如果想跟其他字段一起显示<br>select rownum from T_OWNERS –可以单独查询rownum</p><ol><li>03.单表查询-聚合统计<br>要点：聚合统计</li></ol><p>–聚合统计<br>（1）–求和 sum<br>–需求：统计 2012 年所有用户的用水量总和<br>select sum(usenum) from T_ACCOUNT where year = ‘2012’<br>（2）–求平均 avg<br>–需求：统计 2012 年所有用水量（字数）的平均值<br>select avg(usenum) from T_ACCOUNT where year = ‘2012’<br>（3）–求最大值 max<br>–需求：统计 2012 年最高用水量（字数）<br>select max(usenum) from T_ACCOUNT where year = ‘2012’<br>（4）–求最小值 min<br>–需求：统计 2012 年最低用水量（字数）<br>select min(usenum) from T_ACCOUNT where year = ‘2012’<br>（5）–统计记录个数 count<br>–需求：统计业主类型 ID 为 1 的业主数量<br>select count(*) from T_OWNERS where ownertypeid = 1<br>（6）– 分组聚合 Group by (select 后面一定是分组聚合的条件或者是聚合函数)<br>–需求：按区域分组统计水费合计数<br>select areaid,sum(money) from T_ACCOUNT group by areaid；<br>（7）– 分组后条件查询 having<br>–需求：查询水费合计大于 16900 的区域及水费合计<br>select areaid,sum(money) from T_ACCOUNT group by areaid having sum(money)&gt;169000<br>    where和having区别？（面试和笔试会遇到）<br>     1.where 不能放在GROUP BY 后面<br>2.HAVING 是跟GROUP BY 连在一起用的，放在GROUP BY 后面，此时的作用相当于WHERE<br>3.WHERE 后面的条件中不能有聚集函数，比如SUM(),AVG()等，而HAVING 可以</p><ol><li>04.内连接<br>要点：内连接查询如果接到一个很复杂的查询需求，这里介绍的是如果分析一个复杂的查询需求。（重点要学习思路）<br>第一步: 找到所需信息所在的所有表<br>第二步: 描述各个表之间的关系(外键 = 主键)<br>（1）–多表内连接查询<br>–（1）需求：查询显示业主编号，业主名称，业主类型名称<br>select os.id 业主编号,os.name 业主名称,ot.name 业主类型<br>from T_OWNERS os,T_OWNERTYPE ot<br>where os.ownertypeid = ot.id</li></ol><p>（2）–（2）需求：查询显示业主编号，业主名称、地址和业主类型<br>select ow.id 业主编号,ow.name 业主名称,ad.name 地址,ot.name 业主类型<br>from t_owners ow, t_ownertype ot,t_address ad<br>where ow.addressid = ad.id and ow.ownertypeid = ot.id</p><p>（3）–（3）需求：查询显示业主编号、业主名称、地址、所属区域、业主分类<br>select ow.id 业主编号,ow.name 业主名称,ad.name 地址,ar.name 所属区域,ot.name 业主类型<br>from t_owners ow, t_ownertype ot,t_address ad,t_area ar<br>where ow.addressid = ad.id and ow.ownertypeid = ot.id and ad.areaid = ar.id</p><p>（4）–（4）需求：查询显示业主编号、业主名称、地址、所属区域、收费员、业主分类<br>select ow.id 业主编号,ow.name 业主名称,ad.name 地址,ar.name 所属区域,op.name 收费员,ot.name 业主类型<br>from t_owners ow, t_ownertype ot,t_address ad,t_area ar,t_operator op<br>where ow.addressid = ad.id and ow.ownertypeid = ot.id and ad.areaid = ar.id and ad.operatorid = op.id</p><ol><li>05.外连接<br>要点：使用sql1999用法  xxx join  … on… 。<br>使用（+）这种写法，oracle数据库专用,移植到其他数据库中会报错。</li></ol><p>（1）–左外连接查询：左边表所有数据全部查出来，右边的表没有匹配的数据显示空。<br>–需求：查询业主的账务记录，显示业主编号、名称、年、月、金额。如果此业主没有账务记录也要列出姓名。<br>–sql1999<br>select ow.id 业主编号,ow.name 业主名称,ac.year 年,ac.month 月,ac.money 金额<br>from t_owners ow left join  t_account ac<br>on ac.owneruuid= ow.id</p><p>–oracle的语法<br>select ow.id 业主编号,ow.name 业主名称,ac.year 年,ac.month 月,ac.money 金额<br>from t_owners ow , t_account ac<br>where ow.id=ac.owneruuid(+);<br>（2）–右外连接查询：右边表所有数据全部查出来，左边的表没有匹配的数据显示空。<br>–需求：查询业主的账务记录，显示业主编号、名称、年、月、金额。如果账务记录没有对应的业主信息，也要列出记录。<br>–sql1999<br>select ow.id 业主编号,ow.name 业主名称,ac.year 年,ac.month 月,ac.money 金额<br>from t_owners ow right join  t_account ac<br>on ac.ownerid = ow.id<br>–oracle的语法<br>select ow.id 业主编号,ow.name 业主名称,ac.year 年,ac.month 月,ac.money 金额<br>from t_owners ow , t_account ac<br>where ow.id(+) = ac.owneruuid;</p><ol><li>06.where子句中的子查询<br>要点：单行子查询where条件后查询的结果只有一行适用于大于，小于，等于等等<br>多行子查询 where条件后查询的结果为多条或者一条，最常用的是in包含的意思。（现实开发经常遇到）</li></ol><p>1、单行子查询<br>（1）–where 子句中的子查询<br>–需求：查询 2012 年 1 月用水量大于平均值的台账记录<br>–查询2012年1月平均用水量<br>select avg(usenum) from t_account  where year=’2012’ and month=’01’;</p><p>（2）–查询2012年1月用水量大于20009.5<br>select * from t_account  where year=’2012’ and month=’01’ and usenum&gt;20009.5;</p><p>（3）–需求：查询 2012 年 1 月用水量大于平均值的台账记录<br>select * from t_account  where year=’2012’ and month=’01’<br>and usenum&gt;(select avg(usenum) from t_account  where year=’2012’ and month=’01’)</p><p>2、多行子查询 in 运算符</p><p>–（1）需求：查询地址编号为 1 、3、4 的业主记录<br>select * from t_owners where addressid in(1,3,4);</p><p>–（2）需求：查询地址含有“花园”的业主的信息<br>–查询地址含有“花园”的地址编号<br>select id from t_address where name like ‘%花园%’</p><p>–最终结果<br>select * from t_owners where addressid in(select id from t_address where name like ‘%花园%’)</p><p>–（3）需求：查询地址不含有“花园”的业主的信息<br>select * from t_owners where addressid not in(select id from t_address where name like ‘%花园%’)</p><ol><li>07.from子句的子查询<br>要点：from后边的子查询当成一个表使用即可。</li></ol><p>（1）–from 子句的子查询为多行子查询<br>–需求：查询显示业主编号，业主名称，业主类型名称，条件为业主类型为”居民”，使用子查询实现。<br>–内连接写法<br>select ow.id 业主编号,ow.name 业主名称,ot.name 业主类型<br>from t_owners ow,t_ownertype ot<br>where ow.ownertypeid = ot.id and ot.name = ‘居民’<br>（2）–子查询写法<br>select * from (<br>select ow.id 业主编号,ow.name 业主名称,ot.name 业主类型<br>from t_owners ow,t_ownertype ot<br>where ow.ownertypeid = ot.id<br>) where 业主类型 = ‘居民’</p><ol><li>08.select子句子查询（实际开发中经常遇到）<br>要点：select子查询后边必须是查询单一字段。因为select后边都是单一的字段<br>（1）–select 子句中的子查询<br>–（1）需求：列出业主信息，包括 ID，名称，所属地址。<br>–内关联写法<br>1、如果只查询id、业主名称那只需要从业主表中进行查询。<br>2、现在我们想得到地址表的名称，那么我们就要到地址表中把名称查询出来。<br>画个表<br>select o.id,o.name,ad.name<br>from t_owners o,t_address ad<br>where o.addressid= ad.id</li></ol><p>（2）–select子查询写法<br>select id,name,(select name from t_address where id=addressid) addressname<br>from t_owners</p><p>–（2）需求：列出业主信息，包括 ID，名称，所属地址，所属区域。<br>–内连接写法<br>select ow.id,ow.name 名称,ad.name 所属地址,ar.name 所属区域<br>from t_owners ow,t_address ad,t_area ar<br>where ow.addressid = ad.id and ad.areaid = ar.id<br>–select子查询写法<br>select id,name,<br>(select name from t_address where id=addressid) addressname,<br>(select (select name from t_area where id=areaid) from t_address where id=addressid) areaname<br>from t_owners;</p><ol><li>09.分页查询<br>要点：</li></ol><p>面试要点：oracle 和mysql分页<br>回答：oracle 用ruwnum三层嵌套，mysql 用limit进行分页。</p><p>（1）–需求：分页查询台账表 T_ACCOUNT，每页 10 条记录<br>–分析：我们在 ORACLE 进行分页查询，需要用到伪列 ROWNUM 和嵌套查询<br>–我们首先显示前 10 条记录<br>select rownum,t.* from t_account t where rownum&lt;=10</p><p>（2）–显示第二页10条内容<br>select <em> from (select rownum r,t.</em> from t_account t)<br>where r&gt;10 and r &lt;=20</p><p>（3）–需求：分页查询台账表 T_ACCOUNT，每页 10 条记录，按使用字数降序排序。<br>–我们查询第 2 页数据，如果基于上边的语句添加排序<br>select <em> from ( select rownum r,t.</em> from (select * from t_account  order by usenum desc) t )<br>where r&gt;10 and r &lt;=20</p><ol><li>10.字符函数<br>要点：伪表dual：Oracle提供用来测试函数的表<br>（1）–（1）求字符串长度 LENGTH<br>select length(‘ABCD’) from dual;<br>（2）–求字符串子串(原字符串，从第几位截取，截取字符数)<br>select substr(‘ABCDEF’,2,2) from dual;</li></ol><p>（3）–字符串拼接<br>select concat(‘ABC’,’D’) from dual;<br>–如果想继续拼接（不推荐使用）<br>select concat(concat(‘ABC’,’D’),’EF’) from dual;<br>–如果想继续拼接（推荐使用）<br>select ‘ABC’||’D’||’EF’ from dual;</p><p>–拼接查询的内容<br>select ow.name||’住在’||ad.name 信息 from t_owners ow,t_address ad where ow.addressid = ad.id;</p><ol><li>11.数值函数<br>要点：数值函数常用的四舍五入（round），数字截取（trunc），求模（mod）<br>根据个人编程习惯采用数值函数。<br>（1）–四舍五入<br>select round(100.567,2) from dual;</li></ol><p>（2）–数字截取<br>select trunc(100.567,2) from dual;<br>（3）–取模<br>select mod(10,3) from dual;</p><ol><li><p>12.日期函数</p><p>要点：日期函数实际开发中只有在特定的需求里会遇到。<br>（1）–取系统当前日期<br>select sysdate from dual;<br>（2）–加月<br>select add_months(sysdate,2) from dual;<br>–减月<br>select add_months(sysdate,-2) from dual;<br>（3）–求当月最后一天<br>select last_day(sysdate) from dual;<br>select last_day(sysdate-4) from dual;<br>（4）–日期截取<br>select trunc(sysdate) from dual;–按日截取（把时间截掉）</p></li></ol><p>select trunc(sysdate,’mm’) from dual;–按月截取（把日截掉）</p><p>select trunc(sysdate,’yyyy’) from dual;–按年截取</p><p>select trunc(sysdate,’hh’) from dual;–按小时截取</p><p>select trunc(sysdate,’mi’) from dual;–按分钟截取</p><p>–没有按秒截取</p><ol><li><p>13.转换函数<br>要点：类似于Java语言的类型转换，特定需求下会使用数据库转换函数。<br>（1）–转换函数<br>–数字转换字符串<br>select to_char(100)||’分’ from dual;<br>select 100||’’ from dual;<br>（2）–日期转字符串<br>select to_char(sysdate,’yyyy-mm-dd’) from dual;<br>select to_char(sysdate,’yyyy’)||’年’||to_char(sysdate,’mm’)||’月’||to_char(sysdate,’dd’)||’日’ from dual;<br>select to_char(sysdate,’yyyy-mm-dd hh:mi:ss’) from dual;<br>（3）–字符串转日期<br>select to_date(‘2017-03-10’,’yyyy-mm-dd’) from dual;<br>（4）–字符串转数字<br>select to_number(‘100’)+10 from dual;<br>select ‘100’+0 from dual;<br>select ‘100’||0 from dual;–拼接后就变成字符串了</p></li><li><p>14.其它函数<br>要点：空值处理nvl对空值进行处理，nvl2可以转换类型。<br>条件判断decode可以根据检测的值不同，取得不同的结果。<br>case when then sql1999标准必须掌握实际开发会经常遇到。</p></li></ol><p>–其他函数<br>（1）–空值处理<br>select nvl(null,0) from dual;<br>–显示价格表中业主类型ID为1的价格记录，如果上限值为NULL,则显示9999999<br>select nvl(maxnum,9999999) from t_pricetable where ownertypeid=1;<br>（2）–NVL2（检测的值，如果不为 null 的值，如果为 null 的值）；<br>select nvl2(null,0,100) from dual;–结果为100<br>select nvl2(20,0,100) from dual;–结果为0<br>–需求：显示价格表中业主类型 ID 为 1 的价格记录，如果上限值为 NULL,显示“不限”.<br>select nvl2(maxnum,to_char(maxnum),’不限’) from t_pricetable where ownertypeid=1;</p><p>（3）–（3）条件判断 decode<br>select decode(100,1,2,3,4,100,200,300,400) from dual;<br>–需求：显示下列信息（不要关联查询业主类型表，直接判断 1 2 3 的值）<br>select name,decode(ownertypeid,1,’居民’,2,’行政事业单位’,3,’商业’,’其他’) from t_owners;<br>（4）–case when then第一种写法 sql1999<br>select name,(case ownertypeid<br>                  when 1 then ‘居民’<br>                  when 2 then ‘行政事业’<br>                  when 3 then ‘商业’<br>                  else ‘其他’<br>             end )from t_owners;<br>–case when then第二种写法 sql1999（灵活）<br>select name,(case<br>                  when ownertypeid=1 then ‘居民’<br>                  when ownertypeid=2 then ‘行政事业’<br>                  when ownertypeid=3 then ‘商业’<br>                  else ‘其他’<br>             end )from t_owners;</p><ol><li>15.行列转换<br>（1）–行列转换<br>–需求：按月份统计 2012 年各个地区的水费<br>select (select name from t_area where id=areaid) 区域,<br>sum(case when month = ‘01’ then money else 0 end) 一月,<br>sum(case when month = ‘02’ then money else 0 end) 二月,<br>sum(case when month = ‘03’ then money else 0 end) 三月,<br>sum(case when month = ‘04’ then money else 0 end) 四月,<br>sum(case when month = ‘05’ then money else 0 end) 五月,<br>sum(case when month = ‘06’ then money else 0 end) 六月,<br>sum(case when month = ‘07’ then money else 0 end) 七月,<br>sum(case when month = ‘08’ then money else 0 end) 八月,<br>sum(case when month = ‘09’ then money else 0 end) 九月,<br>sum(case when month = ‘10’ then money else 0 end) 十月,<br>sum(case when month = ‘11’ then money else 0 end) 十一月,<br>sum(case when month = ‘12’ then money else 0 end) 十二月<br>from t_account where year=’2012’ group by areaid;</li></ol><p>（2）–需求：按季度统计 2012 年各个地区的水费<br>select (select name from t_area where id=areaid) 区域,<br>     sum(case when month &gt;= ‘01’ and month&lt;=’03’ then money else 0 end) 第一季度,<br>     sum(case when month &gt;= ‘04’ and month&lt;=’06’ then money else 0 end) 第二季度,<br>     sum(case when month &gt;= ‘07’ and month&lt;=’09’ then money else 0 end) 第三季度,<br>     sum(case when month &gt;= ‘10’ and month&lt;=’12’ then money else 0 end) 第四季度<br>from t_account where year=’2012’ group by areaid;</p><ol><li>16.分析函数</li></ol><p>（1）–分析函数<br>–值相同，排名相同，序号跳跃<br>select rank() over(order by usenum desc) 排名,t.<em> from t_account t<br>（2）–值相同，排名相同，序号连续<br>select dense_rank() over(order by usenum desc) 排名,t.</em> from t_account t<br>（3）–序号连续，不管值是否相同<br>select row_number() over(order by usenum desc) 排名,t.<em> from t_account t<br>（4）–用分析函数来实现分页<br>select </em> from<br>   (select row_number() over(order by usenum desc) rownumber,t.* from t_account t)<br>where rownumber&gt;10 and rownumber&lt;=20;</p><ol><li>17.集合运算</li></ol><p>（1）–集合运算<br>–并集（包括重复记录）</p><p>select <em> from t_owners where id&gt;5<br>union all<br>select </em> from t_owners where id&lt;8</p><p>（2）–并集（去掉重复记录）<br>select <em> from t_owners where id&gt;5<br>union<br>select </em> from t_owners where id&lt;8<br>（3）–交集（两个结果集的重复部分）</p><p>select <em> from t_owners where id&gt;5<br>intersect<br>select </em> from t_owners where id&lt;8</p><p>（4）–差集  返回的属于第一个集合但是不属于第二个集合的记录</p><p>select <em> from t_owners where id&gt;5<br>minus<br>select </em> from t_owners where id&lt;8</p><p>select <em> from t_owners where id&lt;8<br>minus<br>select </em> from t_owners where id&gt;5</p><p>（5）–差集分页<br>select rownum,t.<em> from t_account t where rownum&lt;=20<br>minus<br>select rownum,t.</em> from t_account t where rownum&lt;=10<br>总结<br>1、    oracle单表查询。<br>2、    oracle的多表连接查询。<br>3、    oracle的嵌套查询。<br>4、    oracle的基本函数。</p><p>41第七阶段day3 ORACLE</p><p>今天主要学习内容：</p><ol><li>Oracle的视图。</li><li>Oracle的序列。</li><li>Oracle的同义词。</li><li><p>Oracle的索引。</p></li><li><p>01.什么是视图<br>1、    要点：对sql语句的一种封装，它是一个虚拟的表。<br>2、    使用场景：对经常需要查询的数据，进行封装。<br>3、    优点：提高工作效率。     </p></li><li>02.创建修改删除视图语法<br>要点：创建视图的基本语法和删除视图。<br>1、CREATE [OR REPLACE] [FORCE] VIEW view_name<br>AS subquery<br>[WITH CHECK OPTION ]<br>[WITH READ ONLY]<br>REPLACE：删除已有视图，重新创建视图。<br>FORCE：不管基表是否存在，都会创建视图。<br>WITH CHECK OPTION：插入或修改的数据行必须满足视图定义的约束。<br>WITH READ ONLY：只读。</li></ol><p>2、删除视图：DROP VIEW view_name</p><ol><li>03.视图案例-简单视图<br>要点：视图中查询的表称之为基表，修改视图实际就是在修改基表中的数据。视图在数据库中实际上就是一条sql语句，查询视图的数据实际就是在查询基表的数据。<br>1、–需求：创建视图 ：业主类型为 1 的业主信息<br>create view view_owners1 as<br>select <em> from t_owners where ownertypeid = 1;<br>2、–查询简单视图<br>select </em> from view_owners1 where addressid = 1;<br>3、–修改视图数据<br>update view_owners1 set name=’范小冰’ where id=1;<br>commit;<br>4、–查询表<br>select * from t_owners where ownertypeid = 1;</li></ol><ol><li>04.视图案例-检查约束的视图<br>要点：视图中添加with check option选项，无法修改视图中基表的条件字段。<br>1、–带检查约束的视图<br>–需求：根据地址表（T_ADDRESS）创建视图 VIEW_ADDRESS2 ,内容为区域 ID为 2 的记录。<br>create view view_address2 as<br>select * from t_address where areaid=2<br>with check option<br>2、–无法修改成功的语句，因为该视图的条件是areaid=2<br>update view_address2 set areaid=3 where id=4;<br>3、–可以修改成功的语句，因为条件不是areaid<br>update view_address2 set name=’河畔花园1’ where id=4;<br>commit;</li><li>05.视图案例-只读视图<br>要点： 视图中添加or replace删除原有视图，重新创建视图，添加with read only视图只能查看不能修改。<br>1、–需求：将上边的视图修改为只读视图<br>create or replace view view_owners1 as<br>select * from t_owners where ownertypeid=1<br>with read only<br>2、–修改只读视图数据<br>update view_owners1 set name=’aaa’ where id=1;</li><li>06.视图案例-带错误的视图<br>要点：视图中添加 force选项可以创建数据库中没有的表。<br>–创建带错误的视图<br>create force view view_test as<br>select * from t_test</li><li>07.视图案例-多表关联的视图<br>要点：复杂视图：视图的 SQL 语句中，有聚合函数或多表关联查询。<br>  键保留表：把主键保留下来的那个表。<br>1、–创建视图，查询显示业主编号，业主名称，业主类型名称<br>create or replace view view_owners as<br>select ow.id 业主编号,ow.name 业主名称,ot.name 业主类型 from t_owners ow,t_ownertype ot<br>where ow.ownertypeid=ot.id<br>2、–查询复杂视图（多表关联）<br>select * from view_owners where 业主类型=’居民’;<br>3、–修改键保留表复杂视图（多表关联）的数据<br>update view_owners set 业主名称=’林玲玲’ where 业主编号=4;<br>commit;<br>4、–修改非键保留表复杂视图（多表关联）的数据<br>update view_owners set 业主类型=’商业’ where 业主编号=4;<br>–键保留表：把主键保留下来的那个表，并且能作为视图的主键</li></ol><p>复杂视图(多表关联) 修改语句只能修改包含外键的表(t_owners-外键:t_ownertypeid)不管视图中是否包含T_owners的主键,都可以修改.提供外键的表t_ownertype不能修改.</p><ol><li>08.视图案例-聚合统计的视图<br>要点：聚合统计视图默认是只读，无法修改数据。<br>1、–需求：创建视图，按年月统计水费金额<br>create view view_accountsum as<br>select year,month,sum(money) money<br>from t_account<br>group by year,month<br>order by year,month<br>2、–查询视图<br>select * from view_accountsum where year=’2012’ and month=’03’<br>3、–不能修改<br>update view_accountsum set money=10000 where year=’2012’ and month=’03’</li><li><p>09.物化视图-概念及语法<br>要点：1、物化视图概念：将视图中查询出来的数据存储到一张表中。<br>2、优点：查询速度比视图要快。<br>3、缺点：占用资源，并且要时时更新数据。<br>4、创建物化视图<br>CREATE METERIALIZED VIEW view_name<br>[BUILD IMMEDIATE | BUILD DEFERRED ]<br>REFRESH [FAST|COMPLETE|FORCE]<br>[<br>ON [COMMIT |DEMAND ] | START WITH (start_time) NEXT<br>(next_time)<br>]<br>AS<br>Subquery<br>METERIALIZED:实体化。<br>BUILD IMMEDIATE: 创建物化视图的时候就生成数据。<br>BUILD DEFERRED: 创建物化视图的时候不生成数据。<br>默认为 BUILD IMMEDIATE<br>FAST：快速刷新，增量刷新。<br>COMPLETE：基表更新，删除物化视图数据，重新生成数据。<br>FORCE：自动选择，能增量刷新就增量，不能增量就完全刷新。<br>默认为FORCE<br>ON COMMIT：基表变化，物化视图就刷新。<br>ON DEMAND：手动刷新<br>默认：ON DEMAND</p></li><li><p>10.物化视图案例-手动刷新的物化视图<br>要点：创建物化视图默认为手动刷新ON DEMAND，基表如果数据发生变化，物化视图中的表不会发生变化，需要手动进行刷新。<br>1、–需求：查询地址 ID,地址名称和所属区域名称<br>create materialized view view_address1 as<br>select ad.id,ad.name,ar.name arname<br>from t_address ad,t_area ar<br>where ad.areaid=ar.id<br>–删除物化视图<br>drop materialized view view_address1;<br>2、–物化视图一般以mv开头<br>create materialized view mv_address1 as<br>select ad.id,ad.name,ar.name arname<br>from t_address ad,t_area ar<br>where ad.areaid=ar.id<br>–查询物化视图<br>select <em> from mv_address1;<br>3、–向基表插入数据<br>insert into t_address values(8,’西三旗’,2,2);<br>commit;<br>–查询t_address<br>select </em> from t_address;<br>4、–执行刷新语句<br>begin<br>DBMS_MVIEW.refresh(‘MV_ADDRESS1’,’C’);<br>end;<br>5、–向基表插入数据<br>insert into t_address values(9,’西四旗’,2,2);<br>commit;<br>6、命令窗口更新刷新数据<br>EXEC DBMS_MVIEW.refresh(‘MV_ADDRESS1’,’C’);</p></li></ol><ol><li>11.物化视图案例-自动刷新的物化视图<br>1、–创建自动刷新的物化视图 -基表发生commit操作，自动刷新物化视图<br>create materialized view mv_address2<br>refresh<br>on commit<br>as<br>select ad.id,ad.name,ar.name arname<br>from t_address ad,t_area ar<br>where ad.areaid=ar.id<br>2、–向基表插入数据<br>insert into t_address values(10,’西5旗’,2,2);<br>commit;<br>3、–查询物化视图<br>select * from mv_address2;</li><li>12.物化视图案例-创建时不生成数据的物化视图<br>要点：增加build deferred创建物化视图时，视图表中不产生数据，需要手动刷新，如果增加on commit那么以后基表进行commit操作，物化视图为自动刷新。<br>1、–创建时不生成数据的物化视图<br>create materialized view mv_address3<br>build deferred<br>refresh<br>on commit<br>as<br>select ad.id,ad.name,ar.name arname<br>from t_address ad,t_area ar<br>where ad.areaid=ar.id<br>2、–查询物化视图<br>select * from mv_address3;<br>3、–向基表插入数据<br>insert into t_address values(11,’西6旗’,2,2);<br>commit;<br>4、–执行刷新语句(第一次必须手动执行刷新)<br>begin<br>DBMS_MVIEW.refresh(‘MV_ADDRESS3’,’C’);<br>end;<br>5、–向基表插入数据<br>insert into t_address values(12,’西7旗’,2,2);<br>commit;</li><li>13.物化视图案例-增量刷新的物化视图（了解）<br>1、–创建增量刷新的物化视图<br>–前提是必须创建物化视图日志：记录基表发生了哪些变化，用这些记录去更新物化视图<br>create materialized view log on t_address with rowid<br>create materialized view log on t_area with rowid<br>–创建物化视图中的语句，必须有基表的rowid<br>create materialized view mv_address4<br>refresh fast<br>as<br>select ad.rowid adrowid,ar.rowid arrowid,ad.id,ad.name,ar.name arname<br>from t_address ad,t_area ar<br>where ad.areaid=ar.id<br>2、–查询物化视图<br>select * from mv_address4;<br>–向基表插入数据<br>insert into t_address values(13,’西8旗’,2,2);<br>commit;<br>–向基表插入数据<br>insert into t_address values(14,’西9旗’,2,2);<br>commit;<br>–删除数据<br>delete from t_address where id=14;<br>commit;<br>3、–执行刷新语句<br>begin<br>DBMS_MVIEW.refresh(‘MV_ADDRESS4’,’C’);<br>end;</li><li>14.序列-什么是序列<br>–创建简单序列<br>create sequence seq_test;<br>–查询序列的下一个值<br>select seq_test.nextval from dual;<br>–查询序列的当前值<br>select seq_test.currval from dual;</li><li><p>15.序列-语法</p></li><li><p>16.序列-案例<br>–有最大值的非循环序列<br>create sequence seq_test1<br>maxvalue 20;<br>–查询序列<br>select seq_test1.nextval from dual;<br>–自定义增长值<br>create sequence seq_test2<br>increment by 10<br>start with 10<br>maxvalue 100<br>–查询序列<br>select seq_test2.nextval from dual;</p></li></ol><p>create sequence seq_test3<br>increment by 10<br>start with 10<br>minvalue 5<br>maxvalue 100<br>–查询序列<br>select seq_test3.nextval from dual;<br>–循环的序列<br>create sequence seq_test4<br>increment by 10<br>start with 10<br>minvalue 10<br>maxvalue 210<br>cycle</p><p>create sequence seq_test5<br>increment by 10<br>start with 10<br>minvalue 10<br>maxvalue 201<br>cycle<br>–查询序列<br>select seq_test4.nextval from dual;<br>select seq_test5.nextval from dual;</p><p>create sequence seq_test5<br>increment by 10<br>start with 10<br>minvalue 10<br>maxvalue 201<br>cycle<br>cache 5<br>–一次缓存数有多少 cache值*增长值   缓存的默认值是20,不设置的话cache为20<br>–一次循环的值不能小于 一次缓存的数<br>–开始值不能小于最小值</p><ol><li><p>17.同义词-概念<br>2、语法：create [public] SYNONYM synooym for object;<br>加上public，数据库所有用户都可以访问别名。<br>不加public，只针对当前用户可以访问。</p></li><li><p>18.同义词-案例<br>–创建私有同义词<br>create synonym owner for t_owners;<br>select <em> from owner;<br>–dba超级管理员身份可以用system用户直接访问<br>select </em> from wateruser.t_owners;<br>–创建共有同义词<br>create public synonym owner2 for t_owners;<br>select * from owner2;</p></li><li>19.索引-什么是索引<br>要点：1、索引是用于加速数据存取的数据对象。<br>2、适用于百万以上数据。<br>3、优点：查询速度比较快。<br>4、缺点：占用资源比较大。</li><li>20.索引-普通索引<br>要点：创建一个普通索引。<br>1、–创建普通索引<br>create index index_owners_name on t_owners(name);<br>select * from t_owners where name=’张哲’;<br>2、–性能测试 创建一个表，向表中插入100万条记录<br>create table t_indextest(id number,name varchar2(30));<br>begin<br>for x in 1..1000000<br>loop<br>insert into t_indextest values(x,’aa’||x);<br>end loop;<br>commit;<br>end;<br>3、–创建索引<br>create index index_test on t_indextest(name);</li></ol><p>select * from t_indextest where id=777777;</p><p>select t.rowid,t.* from t_indextest t where name=’aa777777’;</p><p>select * from t_indextest where rowid=’AAAM3NAAGAAAAkNACz’;</p><ol><li>21.索引-唯一索引和复合索引<br>要点：1、创建唯一索引：此列不能有重复字段。<br>2、复合索引要注意where条件的顺序是什么，创建复合索引的顺序就是什么。<br>–创建唯一索引<br>create unique index index_owners_meter on t_owners(watermeter);</li></ol><p>select * from t_owners where addressid=1 and housenumber=’1-3’;<br>–创建复合索引<br>create index index_owners_ah on t_owners(addressid,housenumber);</p><ol><li>22.索引-反向键索引<br>要点：当某个字段为连续增长的值，适合用反向键索引。<br>create index 索引名称 on 表名(列名) reverse;</li></ol><p>普通索引和反向建索引统称b-tree-*索引</p><ol><li>23.索引-位图索引<br>要点：1、位图索引适合创建在低基数列上，比方说男、女或者颜色、56个民族等等。</li></ol><p>2、语法：create bitmap index 索引名称 on 表名(列名);<br>3、需求：我们在T_owners表的ownertypeid列上建立位图索引。</p><p>   create bitmap index index_owners_typeid on t_owners(ownertypeid)<br>总结<br>（1）    Oracle的视图和物化视图。<br>（2）    Oracle的序列。<br>（3）    Oracle的同义词。<br>（4）    Oracle的索引。<br>42第七阶段day4 ORACLE</p><p>今天主要学习内容：</p><ol><li>Oracle的pl/sql。</li><li>Oracle的存储函数。</li><li>Oracle的存储过程。</li><li>Oracle的触发器。</li></ol><ol><li>01.什么是PLSQL<br>要点：1、plsql就是Oracle的一种编程语言。<br>2、语法：[declare<br>– 声明变量<br>]<br>begin<br>– 代码逻辑<br>[exception<br>– 异常处理<br>]<br>end;          </li><li>02.变量声明与赋值<br>要点：1、如何声明变量。<br>2、如何赋值变量。<br>–声明变量水费单价、水费字数、吨数、金额。<br>–对水费单价、字数、进行赋值 。吨数根据水费字数换算，规则为水费字数除以<br>–1000，并且四舍五入，保留两位小数。计算金额，金额=单价<em>吨数。<br>–输出单价 、数量和金额。<br>declare<br>v_price number(10,2);–单价<br>v_usenum number;–水费字数<br>v_usenum2 number(10,2);–吨数<br>v_money number(10,2);–金额<br>begin<br>v_price:=2.45;–单价赋值<br>v_usenum:=9999;–水费字数<br>v_usenum:=round(v_usenum/1000,2);–吨数<br>v_money:=v_usenum</em>v_price;–金额<br>dbms_output.put_line(‘金额：’||v_money);<br>–DBMS.OUTPUT.put_line(‘金额：’||v_money);<br>end;</li></ol><ol><li>03.变量select into赋值<br>要点：通过select into 将表中的数据赋值给变量，注意查询结果只能是一条记录。<br>declare<br>v_price number(10,2);–单价<br>v_usenum number;–水费字数<br>v_usenum2 number(10,2);–吨数<br>v_money number(10,2);–金额<br>v_num0 number;–上月水表数<br>v_num1 number;–本月水表数<br>begin<br>v_price:=2.45;–单价赋值<br>– v_usenum:=9999;–水费字数<br>select usenum,num0,num1 into v_usenum,v_num0,v_num1 from t_account<br>where year=’2012’ and month=’01’ and owneruuid=1;<br>v_usenum2:=round(v_usenum/1000,2);–吨数<br>v_money:=v_usenum2*v_price;–金额<br>dbms_output.put_line(‘水费字数：’||v_usenum||’金额：’||v_money);<br>–DBMS.OUTPUT.put_line(‘金额：’||v_money);<br>end;</li><li>04.属性类型<br>要点：1、在变量较少的情况下，定义的变量是某个表的某列字段，可以采用 表名.字段名%type。<br>2、在变量较多的情况下，可以采用纪录型，把表名定义成变量 表名%rowtype。<br>–引用某表某列的字段类型<br>declare<br>v_price number(10,2);–单价<br>v_usenum t_account.usenum%type;–水费字数<br>v_usenum2 number(10,2);–吨数<br>v_money number(10,2);–金额<br>v_num0 t_account.num0%type;–上月水表数<br>v_num1 t_account.num1%type;–本月水表数<br>begin<br>v_price:=2.45;–单价赋值<br>– v_usenum:=9999;–水费字数<br>select usenum,num0,num1 into v_usenum,v_num0,v_num1 from t_account<br>where year=’2012’ and month=’01’ and ownerid=1;<br>v_usenum2:=round(v_usenum/1000,2);–吨数<br>v_money:=v_usenum2*v_price;–金额<br>dbms_output.put_line(‘水费字数：’||v_usenum||’金额：’||v_money);<br>–DBMS.OUTPUT.put_line(‘金额：’||v_money);<br>end;<br>–属性类型（记录型 表名%rowtype）</li></ol><p>declare<br> v_price number(10,2);–单价</p><p> v_usenum2 number(10,2);–吨数<br> v_money number(10,2);–金额<br> v_account t_account%rowtype;–台帐行记录类型<br>begin<br>  v_price:=2.45;–单价赋值<br> – v_usenum:=9999;–水费字数<br> select <em> into v_account from t_account<br> where year=’2012’ and month=’01’ and ownerid=1;<br>  v_usenum2:=round(v_account.usenum/1000,2);–吨数<br>  v_money:=v_usenum2</em>v_price;–金额<br>  dbms_output.put_line(‘水费字数：’||v_account.usenum||’金额：’||v_money);<br>  –DBMS.OUTPUT.put_line(‘金额：’||v_money);<br>end;</p><ol><li>05.异常<br>要点：了解预定义异常用法即可。<br>–异常处理1<br>declare<br>v_price number(10,2);–单价<br>v_usenum2 number(10,2);–吨数<br>v_money number(10,2);–金额<br>v_account t_account%rowtype;–台帐行记录类型<br>begin<br>v_price:=2.45;–单价赋值<br>– v_usenum:=9999;–水费字数<br>select <em> into v_account from t_account<br>where year=’2012’ and month=’01’ and ownerid=200;<br>v_usenum2:=round(v_account.usenum/1000,2);–吨数<br>v_money:=v_usenum2</em>v_price;–金额<br>dbms_output.put_line(‘水费字数：’||v_account.usenum||’金额：’||v_money);<br>exception<br>when no_data_found then<br>DBMS_OUTPUT.put_line(‘没有数据’);<br>end;<br>–异常处理2<br>declare<br>v_price number(10,2);–单价<br>v_usenum2 number(10,2);–吨数<br>v_money number(10,2);–金额<br>v_account t_account%rowtype;–台帐行记录类型<br>begin<br>v_price:=2.45;–单价赋值<br>select <em> into v_account from t_account<br>where year=’2012’ ;<br>v_usenum2:=round(v_account.usenum/1000,2);–吨数<br>v_money:=v_usenum2</em>v_price;–金额<br>dbms_output.put_line(‘水费字数：’||v_account.usenum||’金额：’||v_money);<br>exception<br>when no_data_found then<br>DBMS_OUTPUT.put_line(‘没有数据’);<br>when too_many_rows then<br>DBMS_OUTPUT.put_line(‘返回多行’);<br>end;</li><li>06.条件判断<br>要点：了解plsql中的if、else判断语法。</li></ol><p>declare<br> v_price1 number(10,2);–单价<br> v_price2 number(10,2);–单价<br> v_price3 number(10,2);–单价<br> v_usenum2 number(10,2);–吨数<br> v_money number(10,2);–金额<br> v_account t_account%rowtype;–台帐行记录类型<br>begin<br>  v_price1:=2.45;–单价赋值（5吨以下）<br>  v_price2:=3.45;–单价赋值（5-10吨）<br>  v_price3:=4.45;–单价赋值（超过10吨）<br> select <em> into v_account from t_account<br> where year=’2012’ and month=’01’ and ownerid=1;<br>  v_usenum2:=round(v_account.usenum/1000,2);–吨数<br>  –v_money:=v_usenum2</em>v_price;–金额<br>  –阶梯水费计算<br>  if v_usenum2&lt;=5 then<br>    v_money:=v_price1<em>v_usenum2;<br>  elsif v_usenum2&gt;5 and v_usenum2&lt;=10 then<br>    v_money:=v_price1</em>5+v_price2<em>(v_usenum2-5);<br>  else<br>    v_money:=v_price1</em>5+v_price2<em>5 + v_price3</em>(v_usenum2-10);<br>  end if;</p><p>  dbms_output.put_line(‘水费字数：’||v_account.usenum||’金额：’||v_money);<br>  exception<br>    when no_data_found then<br>      DBMS_OUTPUT.put_line(‘没有数据’);<br>    when too_many_rows then<br>      DBMS_OUTPUT.put_line(‘返回多行’);<br>end;</p><ol><li>07.循环<br>要点：循环有三种无条件循环、有条件循环、和for循环。<br>–无条件循环：1到100<br>declare<br>v_num number;<br>begin<br>v_num:=1;<br>loop<br>dbms_output.put_line(v_num);<br>v_num:=v_num+1;<br>if v_num&gt;100 then<br>exit;<br>end if;<br>end loop;<br>end;<br>–有条件循环1到100<br>declare<br>v_num number;<br>begin<br>v_num:=1;<br>while v_num &lt;= 100<br>loop<br>dbms_output.put_line(v_num);<br>v_num:=v_num+1;<br>end loop;<br>end;<br>–for循环1到100<br>begin<br>for v_num in 1 .. 100<br>loop<br>dbms_output.put_line(v_num);<br>end loop;<br>end;</li><li><p>08.游标语法<br>要点：游标是系统为用户开设的一个数据缓冲区,存放 SQL 语句的执行结果。我们可以把游标理解为 PL/SQL 中的结果集。</p></li><li><p>09.游标案例<br>要点：创建游标后面跟着sql语句，然后打开游标循环游标的内容直到游标内容循环结束。关闭游标。<br>–需求：打印业主类型为 1 的价格表<br>declare<br>cursor cur_pricetable is select * from t_pricetable where ownertypeid=1;–声明游标<br>v_pricetable t_pricetable%rowtype;<br>begin<br>open cur_pricetable;–打开游标<br>loop<br>fetch cur_pricetable into v_pricetable;–提取游标<br>exit when cur_pricetable%notfound;–退出循环游标<br>dbms_output.put_line(‘价格：’||v_pricetable.price||<br>‘ 吨位：’||v_pricetable.minnum||’-‘||v_pricetable.maxnum);<br>end loop;<br>close cur_pricetable;–关闭游标<br>end;</p></li></ol><ol><li><p>10.带参数的游标<br>要点：与Java方法相似可以传递参数，声明游标在游标名称后面定义参数，sql语句中使用参数，打开游标时传递参数。<br>–带参数的游标<br>declare<br>cursor cur_pricetable(v_ownertype number) is select * from t_pricetable where ownertypeid=v_ownertype;–声明游标<br>v_pricetable t_pricetable%rowtype;<br>begin<br>open cur_pricetable(1);–打开游标<br>loop<br>fetch cur_pricetable into v_pricetable;–提取游标<br>exit when cur_pricetable%notfound;–退出循环游标<br>dbms_output.put_line(‘价格：’||v_pricetable.price||<br>‘ 吨位：’||v_pricetable.minnum||’-‘||v_pricetable.maxnum);<br>end loop;<br>close cur_pricetable;–关闭游标<br>end;         </p></li><li><p>11.for循环游标<br>要点：for循环可以自动打开关闭游标，自动提取游标，而且还可以自动声明变量。<br>–for循环 带参数的游标<br>declare<br>cursor cur_pricetable(v_ownertype number) is select * from t_pricetable where ownertypeid=v_ownertype;–声明游标<br>begin<br>for v_pricetable in cur_pricetable(1)<br>loop<br>dbms_output.put_line(‘价格：’||v_pricetable.price||<br>‘ 吨位：’||v_pricetable.minnum||’-‘||v_pricetable.maxnum);<br>end loop;<br>end;</p></li><li><p>12.存储函数<br>要点：存储函数也叫自定义函数，可以接收一个或者多个参数，返回一个结果。类似于Java中的方法。<br>1、语法<br>函数名称后面的参数类型不需要写长度大小<br>return 后面的参数也不需要写长度</p></li></ol><p>2、案例<br>–需求： 创建存储函数，根据地址 ID 查询地址名称。<br>create or replace function fn_getaddress<br>(v_id number)<br>return varchar2<br>is<br>  v_name varchar2(30);<br>begin<br>  –查询地址表<br>  select name into v_name from t_address where id=v_id;<br>  return v_name;<br>end;<br>–存储函数测试<br>select fn_getaddress(3) from dual;<br>–存储函数的应用<br>–需求：查询业主 ID，业主名称，业主地址，业主地址使用刚才我们创建的函数来实现。<br>select id,name,fn_getaddress(addressid) from t_owners;</p><ol><li>13.存储过程-什么是存储过程<br>要点：1、存储过程实际上就是供应用程序调用的一种数据函数对象。<br>2、存储函数与存储过程的区别：存储函数一般用来select查询，且返回的只有一个值，存储过程只能供应用程序调用可以返回多个值。且存储过程没有return返回值，可以通过参数设置一个或者多个返回值。<br>3、语法：<br>CREATE [ OR REPLACE ] PROCEDURE 存储过程名称<br>（参数名 类型, 参数名 类型, 参数名 类型）<br>IS|AS<br>变量声明部分;<br>BEGIN<br>逻辑部分<br>[EXCEPTION<br>异常处理部分]<br>END;<br>参数只指定类型，不指定长度<br>过程参数的三种模式：<br>IN 传入参数（默认）<br>OUT 传出参数 ，主要用于返回程序运行结果<br>IN OUT 传入传出参数</li><li>14.不带传出参数的存储过程创建及调用<br>要点：1、根据例子理解如何创建一个不带传出参数的存储过程。<br>2、根据例子理解如果用Oracle调用存储过程。</li></ol><p>–创建业主序列起始值为11<br>create sequence seq_owners start with 11;<br>–不带传出参数的存储过程<br>create or replace procedure pro_owners_add<br>(<br>v_name varchar2,–名称<br>v_addressid number,–地址编号<br>v_housenumber varchar2,–门牌号<br>v_watermeter varchar2,–水表号<br>v_ownertype number–业主类型<br>)<br>is</p><p>begin<br>  insert into t_owners values(seq_owners.nextval,v_name,v_addressid,v_housenumber,v_watermeter,sysdate,v_ownertype);<br>  commit;<br>end;<br>–调用不带传出参数的存储过程<br>call pro_owners_add(‘马大哈’,2,’3232’,’22333’,1);</p><p>begin<br>  pro_owners_add(‘马2哈’,2,’32312’,’223331’,1);<br>end;</p><ol><li>15.JDBC调用不带传出参数的存储过程<br>要点：通过jdbc代码调用存储过程注意调用存储过程使用CallableStatement，sql语句中要用“{call 存储过程名称（？，？,…）}”。</li></ol><ol><li>16.带传出参数的存储过程创建与调用<br>要点：1、根据例子理解如何创建一个带传出参数的存储过程。<br>2、根据例子理解如果用Oracle调用存储过程。</li></ol><p>–创建带传出参数的存储过程<br>create or replace procedure pro_owners_add1<br>(<br>v_name varchar2,–名称<br>v_addressid number,–地址编号<br>v_housenumber varchar2,–门牌号<br>v_watermeter varchar2,–水表号<br>v_ownertypeid number,–业主类型<br>v_id out number<br>)<br>is</p><p>begin<br>  select seq_owners.nextval into v_id from dual;<br>  insert into t_owners values(v_id,v_name,v_addressid,v_housenumber,v_watermeter,sysdate,v_ownertypeid);<br>  commit;<br>end;<br>–调用传出参数的存储过程<br>declare<br>   v_id number;<br>begin<br>   pro_owners_add1(‘马3哈’,2,’32-32’,’2233312’,1,v_id);<br>   dbms_output.put_line(v_id);<br>end;</p><ol><li><p>17.JDBC调用带传出参数的存储过程<br>要点：1、通过代码例子了解如何调用带传出参数的存储过程。<br>2、注意需要传出的参数要再执行sql语句之前注册类型，并且获得传出参数时要再执行完sql语句之后。</p></li><li><p>18.什么是触发器<br>要点：1、触发器：当一个指定的语句执行增删改的操作时。Oracle自动执行了触发器中自定义的数据库函数。<br>2、前置触发器：在增删改操作没有commit之前执行的触发器叫前置触发器。<br>3、后置触发器：在增删改操作commit之后执行的触发器叫后置触发器。</p></li><li>19.触发器语法<br>要点：1、行级触发器：针对表中每行数据变化进行操作。<br>2、语句级触发器：针对每张表进行操作的触发器。<br>3、：old 修改前的数据。Update 和 delete。<br>4、：new 修改后的数据。Insert 和 update。</li></ol><p>5、语法：<br>CREATE [or REPLACE] TRIGGER 触发器名<br>BEFORE | AFTER<br>[DELETE ][[or] INSERT] [[or]UPDATE [OF 列名]]<br>ON 表名<br>[FOR EACH ROW ][WHEN(条件) ]<br>declare<br>……<br>begin<br>PLSQL 块<br>End ；</p><ol><li>20.前置触发器<br>要点：根据例子理解如何创建前置触发器。<br>–需求：当用户输入本月累计表数后，自动计算出本月使用数 。<br>create or replace trigger tri_account_num1<br>before<br>update of num1<br>on t_account<br>for each row<br>declare</li></ol><p>begin<br>  –通过伪记录变量修改usenum字段的值num1（水表现在的数值），num0（上个月使用的水表数）<br>  :new.usenum := :new.num1-:new.num0;<br>end;</p><ol><li>21.后置触发器<br>要点：根据例子理解如何创建后置触发器。<br>–需求：当用户修改了业主信息表的数据时记录修改前与修改后的值<br>–创建后置触发器日志表<br>create table t_owners_log(<br>updatetime date,<br>ownerid number,<br>oldname varchar2(30),<br>newname varchar2(30)<br>);<br>–根据需求创建后置触发器<br>create or replace trigger tri_owners_log<br>after<br>update of name<br>on t_owners<br>for each row<br>declare<br>begin<br>–向日志表插入记录<br>insert into t_owners_log values(sysdate,:new.id,:old.name,:new.name);<br>end;<br>–修改t_owners表中的name<br>update t_owners set name=’林玲玲1’ where id=4;</li></ol>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;ORACLE&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;01.单表查询-简单条件和去重&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;Oracle 的简单查询和去重&lt;br&gt;（1）–精确查询&lt;br&gt;–需求：查询水表编号为 30408 的业主记录&lt;br&gt;select &lt;em&gt; from T_OWNERS where watermeter = ‘30408’;&lt;br&gt;（2）–模糊查询&lt;br&gt;–需求：查询业主名称包含“刘”的业主记录&lt;br&gt;select &lt;/em&gt; from T_OWNERS where name like ‘%刘%’;&lt;br&gt;
    
    </summary>
    
      <category term="数据库" scheme="http://yoursite.com/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    
    
      <category term="oracle" scheme="http://yoursite.com/tags/oracle/"/>
    
  </entry>
  
  <entry>
    <title>第一篇播客</title>
    <link href="http://yoursite.com/2018/02/10/%E7%AC%AC%E4%B8%80%E7%AF%87%E6%92%AD%E5%AE%A2/"/>
    <id>http://yoursite.com/2018/02/10/第一篇播客/</id>
    <published>2018-02-10T11:30:34.000Z</published>
    <updated>2018-02-10T18:17:40.208Z</updated>
    
    <content type="html"><![CDATA[<h3 id="我的第一篇博客"><a href="#我的第一篇博客" class="headerlink" title="我的第一篇博客,"></a>我的第一篇博客,</h3><p> 这是我的第一篇博客,哈哈,今后开启我的博客生涯,写了很多的东西笔记什么的终于可以发到网上了,我很激动很开心,yes!</p><p>One world, a search. A sigh, a life for a person.</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;我的第一篇博客&quot;&gt;&lt;a href=&quot;#我的第一篇博客&quot; class=&quot;headerlink&quot; title=&quot;我的第一篇博客,&quot;&gt;&lt;/a&gt;我的第一篇博客,&lt;/h3&gt;&lt;p&gt; 这是我的第一篇博客,哈哈,今后开启我的博客生涯,写了很多的东西笔记什么的终于可以发到网上了,我
      
    
    </summary>
    
      <category term="杂七杂八" scheme="http://yoursite.com/categories/%E6%9D%82%E4%B8%83%E6%9D%82%E5%85%AB/"/>
    
    
      <category term="test" scheme="http://yoursite.com/tags/test/"/>
    
  </entry>
  
  <entry>
    <title>写文章的步骤</title>
    <link href="http://yoursite.com/2018/02/10/hello-world/"/>
    <id>http://yoursite.com/2018/02/10/hello-world/</id>
    <published>2018-02-10T09:30:04.914Z</published>
    <updated>2018-02-24T08:17:47.553Z</updated>
    
    <content type="html"><![CDATA[<h1 id="创建步骤"><a href="#创建步骤" class="headerlink" title="创建步骤:"></a>创建步骤:</h1><p>1、写一篇文章:<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo new <span class="string">"My New Post"</span></span><br></pre></td></tr></table></figure></p><a id="more"></a><p>2、运行服务:<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure></p><p>3、生成静态页面:<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure></p><p>4、发布到服务器:<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure></p><p>5、开启播客旅程</p><h1 id="next主题优化设置"><a href="#next主题优化设置" class="headerlink" title="next主题优化设置:"></a>next主题优化设置:</h1><h2 id="1、显示网易云的音乐"><a href="#1、显示网易云的音乐" class="headerlink" title="1、显示网易云的音乐:"></a>1、显示网易云的音乐:</h2><p>在C:\lxm\MyBlog\themes\next\layout_macro\sidebar.swig里面137行加上网易云的外链<iframe></iframe></p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;创建步骤&quot;&gt;&lt;a href=&quot;#创建步骤&quot; class=&quot;headerlink&quot; title=&quot;创建步骤:&quot;&gt;&lt;/a&gt;创建步骤:&lt;/h1&gt;&lt;p&gt;1、写一篇文章:&lt;br&gt;&lt;figure class=&quot;highlight bash&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;$ hexo new &lt;span class=&quot;string&quot;&gt;&quot;My New Post&quot;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="杂七杂八" scheme="http://yoursite.com/categories/%E6%9D%82%E4%B8%83%E6%9D%82%E5%85%AB/"/>
    
    
  </entry>
  
</feed>
