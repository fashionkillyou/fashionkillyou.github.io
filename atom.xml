<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Fashionkillyou</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://www.fashionkillyou.xyz/"/>
  <updated>2018-03-18T14:35:18.494Z</updated>
  <id>http://www.fashionkillyou.xyz/</id>
  
  <author>
    <name>liuxinming</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Solr搜索平台</title>
    <link href="http://www.fashionkillyou.xyz/2018/03/18/Solr%E6%90%9C%E7%B4%A2%E5%B9%B3%E5%8F%B0/"/>
    <id>http://www.fashionkillyou.xyz/2018/03/18/Solr搜索平台/</id>
    <published>2018-03-17T16:18:23.000Z</published>
    <updated>2018-03-18T14:35:18.494Z</updated>
    
    <content type="html"><![CDATA[<script src="\assets\js\APlayer.min.js"> </script><h1 id="Solr安装与配置"><a href="#Solr安装与配置" class="headerlink" title="Solr安装与配置"></a>Solr安装与配置</h1><h2 id="什么是Solr"><a href="#什么是Solr" class="headerlink" title="什么是Solr"></a>什么是Solr</h2><p>大多数搜索引擎应用都必须具有某种搜索功能，问题是搜索功能往往是巨大的资源消耗并且它们由于沉重的数据库加载而拖垮你的应用的性能。<br>这就是为什么转移负载到一个外部的搜索服务器是一个不错的主意，Apache Solr是一个流行的开源搜索服务器，它通过使用类似REST的HTTP API，这就确保你能从几乎任何编程语言来使用solr。<br><a id="more"></a><br>Solr是一个开源搜索平台，用于构建搜索应用程序。 它建立在Lucene(全文搜索引擎)之上。 Solr是企业级的，快速的和高度可扩展的。 使用Solr构建的应用程序非常复杂，可提供高性能。</p><p>为了在CNET网络的公司网站上添加搜索功能，Yonik Seely于2004年创建了Solr。并在2006年1月，它成为Apache软件基金会下的一个开源项目。并于2016年发布最新版本Solr 6.0，支持并行SQL查询的执行。</p><p>Solr可以和Hadoop一起使用。由于Hadoop处理大量数据，Solr帮助我们从这么大的源中找到所需的信息。不仅限于搜索，Solr也可以用于存储目的。像其他NoSQL数据库一样，它是一种非关系数据存储和处理技术。</p><p>总之，Solr是一个<strong>可扩展的，可部署，搜索/存储引擎，优化搜索大量以文本为中心的数据</strong>。</p><p>solr和Lucene的区别</p><pre><code>solr是基于Lucene的Lucene是一个全文检索工具包都是一些类库,只能java调用solr是个Apache开源顶级项目,一个服务平台,供不同的语言调用Lucene不支持数值范围的查询语法price:[100 To 200]solr支持数值范围的查询语法price:[100 To 200]</code></pre><h2 id="Solr安装"><a href="#Solr安装" class="headerlink" title="Solr安装"></a>Solr安装</h2><p>准备资料:</p><p>链接：<a href="https://pan.baidu.com/s/14nZ-Uq07QwPrLDeyNWGpMQ" target="_blank" rel="noopener">https://pan.baidu.com/s/14nZ-Uq07QwPrLDeyNWGpMQ</a> </p><p>密码：5n10</p><p>1：安装 Tomcat，解压缩即可。</p><p>2：解压 solr。</p><p>3：把 solr 下的dist目录solr-4.10.3.war部署到 Tomcat\webapps下(为了访问方便,去掉版本号)。</p><p>4：启动 Tomcat解压缩 war 包</p><p>5：把solr下example/lib/ext 目录下的所有的 jar 包，添加到 solr 的工程中(\WEB-INF\lib目录下)。</p><p>6：创建一个 solrhome 。solr 下的/example/solr 目录就是一个 solrhome。复制此目录到D盘改名为solrhome  </p><p>7：关联 solr 及 solrhome。需要修改 solr 工程的 web.xml 文件。(配置文件里面有只需解开注释然后修改成以下内容即可,如果只有war的话启动一下生成即可)</p><pre><code>&lt;env-entry&gt;   &lt;env-entry-name&gt;solr/home&lt;/env-entry-name&gt;   &lt;env-entry-value&gt;d:\solrhome&lt;/env-entry-value&gt;   &lt;env-entry-type&gt;java.lang.String&lt;/env-entry-type&gt;&lt;/env-entry&gt;</code></pre><p>8：启动 Tomcat(如果之前有了tomcat的话,这里必须要将端口号修改.然后访问自己配置的端口号即可)<br><a href="http://IP:8080/solr/" target="_blank" rel="noopener">http://IP:8080/solr/</a></p><h1 id="中文分析器IK-Analyzer"><a href="#中文分析器IK-Analyzer" class="headerlink" title="中文分析器IK Analyzer"></a>中文分析器IK Analyzer</h1><h2 id="IK-Analyzer简介"><a href="#IK-Analyzer简介" class="headerlink" title="IK Analyzer简介"></a>IK Analyzer简介</h2><p>IK Analyzer 是一个开源的，基亍 java 语言开发的轻量级的中文分词工具包。从 2006年 12 月推出 1.0 版开始， IKAnalyzer 已经推出了 4 个大版本。最初，它是以开源项目Luence 为应用主体的，结合词典分词和文法分析算法的中文分词组件。从 3.0 版本开始，IK 发展为面向 Java 的公用分词组件，独立亍 Lucene 项目，同时提供了对 Lucene 的默认优化实现。在 2012 版本中，IK 实现了简单的分词歧义排除算法，标志着 IK 分词器从单纯的词典分词向模拟语义分词衍化。</p><h2 id="IK-Analyzer配置"><a href="#IK-Analyzer配置" class="headerlink" title="IK Analyzer配置"></a>IK Analyzer配置</h2><p>步骤：<br>1、把IKAnalyzer2012FF_u1.jar 添加到 solr 工程的 lib 目录下</p><p>2、创建WEB-INF/classes文件夹  把扩展词典、停用词词典、配置文件放到 solr 工程的 WEB-INF/classes 目录下。</p><pre><code>(扩展词典、停用词词典、配置文件 ext_stopword.dic IKAnalyzer.cfg.xml  mydict.dic)</code></pre><p>3、修改 Solrhome 的collection1\conf\schema.xml 文件，配置一个 FieldType，使用 IKAnalyzer</p><pre><code>&lt;fieldType name=&quot;text_ik&quot; class=&quot;solr.TextField&quot;&gt;     &lt;analyzer class=&quot;org.wltea.analyzer.lucene.IKAnalyzer&quot;/&gt;&lt;/fieldType&gt;</code></pre><h3 id="配置域"><a href="#配置域" class="headerlink" title="配置域"></a>配置域</h3><p>域相当于数据库的表字段，用户存放数据，因此用户根据业务需要去定义相关的Field（域），一般来说，每一种对应着一种数据，用户对同一种数据进行相同的操作。</p><p>域的常用属性：</p><p>•    name：指定域的名称</p><p>•    type：指定域的类型</p><p>•    indexed：是否索引</p><p>•    stored：是否存储</p><p>•    required：是否必须</p><p>•    multiValued：是否多值</p><h4 id="域"><a href="#域" class="headerlink" title="域"></a>域</h4><p>修改solrhome的schema.xml 文件  设置业务系统 Field</p><pre><code>&lt;field name=&quot;item_goodsid&quot; type=&quot;long&quot; indexed=&quot;true&quot; stored=&quot;true&quot;/&gt;&lt;field name=&quot;item_title&quot; type=&quot;text_ik&quot; indexed=&quot;true&quot; stored=&quot;true&quot;/&gt;&lt;field name=&quot;item_price&quot; type=&quot;double&quot; indexed=&quot;true&quot; stored=&quot;true&quot;/&gt;&lt;field name=&quot;item_image&quot; type=&quot;string&quot; indexed=&quot;false&quot; stored=&quot;true&quot; /&gt;&lt;field name=&quot;item_category&quot; type=&quot;string&quot; indexed=&quot;true&quot; stored=&quot;true&quot; /&gt;&lt;field name=&quot;item_seller&quot; type=&quot;text_ik&quot; indexed=&quot;true&quot; stored=&quot;true&quot; /&gt;&lt;field name=&quot;item_brand&quot; type=&quot;string&quot; indexed=&quot;true&quot; stored=&quot;true&quot; /&gt;</code></pre><h4 id="复制域"><a href="#复制域" class="headerlink" title="复制域"></a>复制域</h4><p>复制域的作用在于将某一个Field中的数据复制到另一个域中(<strong>在电商项目的商品搜索中,设置这个复制域可以集成多个条件的查询,将其他域的数据集中到这一个item_keywords域中,方便查询</strong>)</p><pre><code>&lt;field name=&quot;item_keywords&quot; type=&quot;text_ik&quot; indexed=&quot;true&quot; stored=&quot;false&quot; multiValued=&quot;true&quot;/&gt;&lt;copyField source=&quot;item_title&quot; dest=&quot;item_keywords&quot;/&gt;&lt;copyField source=&quot;item_category&quot; dest=&quot;item_keywords&quot;/&gt;&lt;copyField source=&quot;item_seller&quot; dest=&quot;item_keywords&quot;/&gt;&lt;copyField source=&quot;item_brand&quot; dest=&quot;item_keywords&quot;/&gt;</code></pre><h4 id="动态域"><a href="#动态域" class="headerlink" title="动态域"></a>动态域</h4><p>当我们需要动态扩充字段时，我们需要使用动态域。<strong>对于电商项目，规格的值是不确定的，所以我们需要使用动态域来实现。</strong></p><p>配置：</p><pre><code>&lt;dynamicField name=&quot;item_spec_*&quot; type=&quot;string&quot; indexed=&quot;true&quot; stored=&quot;true&quot; /&gt;    </code></pre><h1 id="Spring-Data-Solr入门"><a href="#Spring-Data-Solr入门" class="headerlink" title="Spring Data Solr入门"></a>Spring Data Solr入门</h1><h2 id="Spring-Data-Solr简介"><a href="#Spring-Data-Solr简介" class="headerlink" title="Spring Data Solr简介"></a>Spring Data Solr简介</h2><p>虽然支持任何编程语言的能力具有很大的市场价值，你可能感兴趣的问题是：我如何将Solr的应用集成到Spring中？可以，Spring Data Solr就是为了方便Solr的开发所研制的一个框架，其底层是对SolrJ（官方API）的封装。</p><h2 id="Spring-Data-Solr入门小Demo"><a href="#Spring-Data-Solr入门小Demo" class="headerlink" title="Spring Data Solr入门小Demo"></a>Spring Data Solr入门小Demo</h2><h3 id="搭建工程"><a href="#搭建工程" class="headerlink" title="搭建工程"></a>搭建工程</h3><p>（1）创建maven工程，pom.xml中引入依赖</p><pre><code> &lt;dependencies&gt;  &lt;dependency&gt;      &lt;groupId&gt;org.springframework.data&lt;/groupId&gt;      &lt;artifactId&gt;spring-data-solr&lt;/artifactId&gt;      &lt;version&gt;1.5.5.RELEASE&lt;/version&gt;  &lt;/dependency&gt;   &lt;dependency&gt;      &lt;groupId&gt;org.springframework&lt;/groupId&gt;      &lt;artifactId&gt;spring-test&lt;/artifactId&gt;      &lt;version&gt;4.2.4.RELEASE&lt;/version&gt;  &lt;/dependency&gt;  &lt;dependency&gt;      &lt;groupId&gt;junit&lt;/groupId&gt;      &lt;artifactId&gt;junit&lt;/artifactId&gt;      &lt;version&gt;4.9&lt;/version&gt;  &lt;/dependency&gt;&lt;/dependencies&gt;</code></pre><p>（2）在src/main/resources下创建  applicationContext-solr.xml</p><pre><code>&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot;    xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xmlns:p=&quot;http://www.springframework.org/schema/p&quot;    xmlns:context=&quot;http://www.springframework.org/schema/context&quot;    xmlns:solr=&quot;http://www.springframework.org/schema/data/solr&quot;    xsi:schemaLocation=&quot;http://www.springframework.org/schema/data/solr           http://www.springframework.org/schema/data/solr/spring-solr-1.0.xsd        http://www.springframework.org/schema/beans         http://www.springframework.org/schema/beans/spring-beans.xsd        http://www.springframework.org/schema/context         http://www.springframework.org/schema/context/spring-context.xsd&quot;&gt;    &lt;!-- solr服务器地址 --&gt;    &lt;solr:solr-server id=&quot;solrServer&quot; url=&quot;http://127.0.0.1:8080/solr&quot; /&gt;    &lt;!-- solr模板，使用solr模板可对索引库进行CRUD的操作 --&gt;    &lt;bean id=&quot;solrTemplate&quot; class=&quot;org.springframework.data.solr.core.SolrTemplate&quot;&gt;        &lt;constructor-arg ref=&quot;solrServer&quot; /&gt;    &lt;/bean&gt;&lt;/beans&gt;</code></pre><h3 id="Field-注解"><a href="#Field-注解" class="headerlink" title="@Field 注解"></a>@Field 注解</h3><p>创建 cn.lxm.pojo 包，创建TbItem实体类,属性使用@Field注解标识 。如果属性与配置文件定义的域名称不一致，需要在注解中指定域名称。</p><pre><code>public class TbItem implements Serializable{    @Field    private Long id;    @Field(&quot;item_title&quot;)    private String title;    @Field(&quot;item_price&quot;)private BigDecimal price;    @Field(&quot;item_image&quot;)    private String image;    @Field(&quot;item_goodsid&quot;)    private Long goodsId;    @Field(&quot;item_category&quot;)    private String category;    @Field(&quot;item_brand&quot;)    private String brand;    @Field(&quot;item_seller&quot;)private String seller;.......}</code></pre><h3 id="增加（修改）"><a href="#增加（修改）" class="headerlink" title="增加（修改）"></a>增加（修改）</h3><p>创建测试类TestTemplate.java</p><pre><code>@RunWith(SpringJUnit4ClassRunner.class)@ContextConfiguration(locations=&quot;classpath:applicationContext-solr.xml&quot;)public class TestTemplate {    @Autowired    private SolrTemplate solrTemplate;    @Test    public void testAdd(){        TbItem item=new TbItem();        item.setId(1L);        item.setBrand(&quot;华为&quot;);        item.setCategory(&quot;手机&quot;);        item.setGoodsId(1L);        item.setSeller(&quot;华为2号专卖店&quot;);        item.setTitle(&quot;华为Mate9&quot;);        item.setPrice(new BigDecimal(2000));                solrTemplate.saveBean(item);        solrTemplate.commit();    }}</code></pre><h3 id="按主键查询"><a href="#按主键查询" class="headerlink" title="按主键查询"></a>按主键查询</h3><pre><code>@Testpublic void testFindOne(){    TbItem item = solrTemplate.getById(1, TbItem.class);    System.out.println(item.getTitle());}</code></pre><h3 id="按主键删除"><a href="#按主键删除" class="headerlink" title="按主键删除"></a>按主键删除</h3><pre><code>@Testpublic void testDelete(){    solrTemplate.deleteById(&quot;1&quot;);    solrTemplate.commit();}</code></pre><h3 id="分页查询"><a href="#分页查询" class="headerlink" title="分页查询"></a>分页查询</h3><p>首先循环插入100条测试数据</p><pre><code>@Testpublic void testAddList(){    List&lt;TbItem&gt; list=new ArrayList();    for(int i=0;i&lt;100;i++){        TbItem item=new TbItem();        item.setId(i+1L);        item.setBrand(&quot;华为&quot;);        item.setCategory(&quot;手机&quot;);        item.setGoodsId(1L);        item.setSeller(&quot;华为2号专卖店&quot;);        item.setTitle(&quot;华为Mate&quot;+i);        item.setPrice(new BigDecimal(2000+i));            list.add(item);    }    solrTemplate.saveBeans(list);    solrTemplate.commit();}</code></pre><p>编写分页查询测试代码：</p><pre><code>@Testpublic void testPageQuery(){    Query query=new SimpleQuery(&quot;*:*&quot;);    query.setOffset(20);//开始索引（默认0）    query.setRows(20);//每页记录数(默认10)    ScoredPage&lt;TbItem&gt; page = solrTemplate.queryForPage(query, TbItem.class);    System.out.println(&quot;总记录数：&quot;+page.getTotalElements());    List&lt;TbItem&gt; list = page.getContent();    showList(list);}</code></pre><p>公共代码遍历循环显示查询结果:</p><pre><code>//显示记录数据private void showList(List&lt;TbItem&gt; list){            for(TbItem item:list){        System.out.println(item.getTitle() +item.getPrice());    }        }</code></pre><h3 id="条件查询"><a href="#条件查询" class="headerlink" title="条件查询"></a>条件查询</h3><p> Criteria 用于对条件的封装：</p><pre><code>@Testpublic void testPageQueryMutil(){        Query query=new SimpleQuery(&quot;*:*&quot;);    Criteria criteria=new Criteria(&quot;item_title&quot;).contains(&quot;2&quot;);    criteria=criteria.and(&quot;item_title&quot;).contains(&quot;5&quot;);            query.addCriteria(criteria);    //query.setOffset(20);//开始索引（默认0）    //query.setRows(20);//每页记录数(默认10)    ScoredPage&lt;TbItem&gt; page = solrTemplate.queryForPage(query, TbItem.class);    System.out.println(&quot;总记录数：&quot;+page.getTotalElements());    List&lt;TbItem&gt; list = page.getContent();    showList(list);}</code></pre><h3 id="删除全部数据"><a href="#删除全部数据" class="headerlink" title="删除全部数据"></a>删除全部数据</h3><pre><code>@Testpublic void testDeleteAll(){    Query query=new SimpleQuery(&quot;*:*&quot;);    solrTemplate.delete(query);    solrTemplate.commit();}</code></pre><h3 id="描述-设置高亮显示"><a href="#描述-设置高亮显示" class="headerlink" title="描述 设置高亮显示"></a>描述 设置高亮显示</h3><pre><code>@Testpublic void testHighLight(){    HighlightQuery query = new SimpleHighlightQuery();    //设置高亮的域    HighlightOptions highlightOptions = new HighlightOptions().addField(&quot;item_title&quot;);    //设置高亮显示的前缀    highlightOptions.setSimplePrefix(&quot;&lt;em style=&apos;color:red&apos;&quot;);    //设置高亮显示的后缀    highlightOptions.setSimplePostfix(&quot;&lt;/em&gt;&quot;);    //设置高亮选项    query.setHighlightOptions(highlightOptions);    //设置查询条件    Criteria criteria = new Criteria(&quot;item_title&quot;).contains(&quot;手机&quot;);    query.addCriteria(criteria);    HighlightPage&lt;TbItem&gt; page = solrTemplate.queryForHighlightPage(query, TbItem.class);    //循环高亮入口集合    for (HighlightEntry&lt;TbItem&gt; h : page.getHighlighted()) {        //获取原实体类        TbItem item = h.getEntity();        if(h.getHighlights().size()&gt;0 &amp;&amp; h.getHighlights().get(0).getSnipplets().size()&gt;0){            //设置高亮的结果            item.setTitle(h.getHighlights().get(0).getSnipplets().get(0));        }    }    System.out.println(&quot;总记录数：&quot;+page.getTotalElements());    List&lt;TbItem&gt; list = page.getContent();    showList(list);}</code></pre>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;Solr安装与配置&quot;&gt;&lt;a href=&quot;#Solr安装与配置&quot; class=&quot;headerlink&quot; title=&quot;Solr安装与配置&quot;&gt;&lt;/a&gt;Solr安装与配置&lt;/h1&gt;&lt;h2 id=&quot;什么是Solr&quot;&gt;&lt;a href=&quot;#什么是Solr&quot; class=&quot;headerlink&quot; title=&quot;什么是Solr&quot;&gt;&lt;/a&gt;什么是Solr&lt;/h2&gt;&lt;p&gt;大多数搜索引擎应用都必须具有某种搜索功能，问题是搜索功能往往是巨大的资源消耗并且它们由于沉重的数据库加载而拖垮你的应用的性能。&lt;br&gt;这就是为什么转移负载到一个外部的搜索服务器是一个不错的主意，Apache Solr是一个流行的开源搜索服务器，它通过使用类似REST的HTTP API，这就确保你能从几乎任何编程语言来使用solr。&lt;br&gt;
    
    </summary>
    
      <category term="搜索解决方案" scheme="http://www.fashionkillyou.xyz/categories/%E6%90%9C%E7%B4%A2%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88/"/>
    
    
      <category term="Solr" scheme="http://www.fashionkillyou.xyz/tags/Solr/"/>
    
      <category term="Spring Data Solr" scheme="http://www.fashionkillyou.xyz/tags/Spring-Data-Solr/"/>
    
  </entry>
  
  <entry>
    <title>Spring-Data-Redis总结</title>
    <link href="http://www.fashionkillyou.xyz/2018/03/15/Spring-Data-Redis%E6%80%BB%E7%BB%93/"/>
    <id>http://www.fashionkillyou.xyz/2018/03/15/Spring-Data-Redis总结/</id>
    <published>2018-03-15T09:57:36.000Z</published>
    <updated>2018-03-15T10:41:30.477Z</updated>
    
    <content type="html"><![CDATA[<script src="\assets\js\APlayer.min.js"> </script><h1 id="什么是Redis"><a href="#什么是Redis" class="headerlink" title="什么是Redis"></a>什么是Redis</h1><p>redis是一个非关系型Key-Value数据库,运行在内存中,由ANSI C编写。企业开发通常采用Redis来实现缓存。同类的产品还有memcache 、memcached 、MongoDB等。</p><a id="more"></a><h1 id="什么是Jedis"><a href="#什么是Jedis" class="headerlink" title="什么是Jedis"></a>什么是Jedis</h1><p>Jedis是Redis官方推出的一款面向Java的客户端，提供了很多接口供Java语言调用。可以在Redis官网下载，当然还有一些开源爱好者提供的客户端，如Jredis、SRP等等，推荐使用Jedis。</p><h1 id="Spring-Data-Redis"><a href="#Spring-Data-Redis" class="headerlink" title="Spring Data Redis"></a>Spring Data Redis</h1><p>Spring-data-redis是spring大家族的一部分，提供了在srping应用中通过简单的配置访问redis服务，对reids底层开发包(Jedis,  JRedis, and RJC)进行了高度封装，RedisTemplate提供了redis各种操作、异常处理及序列化，支持发布订阅，并对spring 3.1 cache进行了实现。<br>spring-data-redis针对jedis提供了如下功能：</p><p>1.连接池自动管理，提供了一个高度封装的“RedisTemplate”类</p><p>2.针对jedis客户端中大量api进行了归类封装,将同一类型操作封装为operation接口</p><pre><code>ValueOperations：简单K-V操作SetOperations：set类型数据操作ZSetOperations：zset类型数据操作HashOperations：针对map类型的数据操作ListOperations：针对list类型的数据操作</code></pre><h1 id="使用spring-data-redis"><a href="#使用spring-data-redis" class="headerlink" title="使用spring-data-redis"></a>使用spring-data-redis</h1><h2 id="准备工作"><a href="#准备工作" class="headerlink" title="准备工作:"></a>准备工作:</h2><h3 id="1-构建maven工程-步骤略-如果已有请忽略"><a href="#1-构建maven工程-步骤略-如果已有请忽略" class="headerlink" title="1.构建maven工程(步骤略,如果已有请忽略)"></a>1.构建maven工程(步骤略,如果已有请忽略)</h3><h3 id="2-引入spring相关依赖-引入junit依赖-步骤略-如果已有请忽略"><a href="#2-引入spring相关依赖-引入junit依赖-步骤略-如果已有请忽略" class="headerlink" title="2.引入spring相关依赖,引入junit依赖(步骤略,如果已有请忽略)"></a>2.引入spring相关依赖,引入junit依赖(步骤略,如果已有请忽略)</h3><h3 id="3-引入jedis和SpringDataRedis依赖"><a href="#3-引入jedis和SpringDataRedis依赖" class="headerlink" title="3.引入jedis和SpringDataRedis依赖"></a>3.引入jedis和SpringDataRedis依赖</h3><pre><code>&lt;!-- 缓存 --&gt;&lt;dependency&gt;           &lt;groupId&gt;redis.clients&lt;/groupId&gt;           &lt;artifactId&gt;jedis&lt;/artifactId&gt;           &lt;version&gt;2.8.1&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt;           &lt;groupId&gt;org.springframework.data&lt;/groupId&gt;           &lt;artifactId&gt;spring-data-redis&lt;/artifactId&gt;           &lt;version&gt;1.7.2.RELEASE&lt;/version&gt; &lt;/dependency&gt;</code></pre><h3 id="4-在src-main-resource下创建properties文件夹-建立redis-config-properties"><a href="#4-在src-main-resource下创建properties文件夹-建立redis-config-properties" class="headerlink" title="4.在src/main/resource下创建properties文件夹,建立redis-config.properties"></a>4.在src/main/resource下创建properties文件夹,建立redis-config.properties</h3><p>redis.host用来设置服务器地址</p><p>redis.port用来设置端口号</p><pre><code>redis.host=127.0.0.1 redis.port=6379 redis.pass= redis.database=0 redis.maxIdle=300 redis.maxWait=3000 redis.testOnBorrow=true</code></pre><h3 id="5-在src-main-resources下创建spring文件夹-，创建applicationContext-redis-xml"><a href="#5-在src-main-resources下创建spring文件夹-，创建applicationContext-redis-xml" class="headerlink" title="5.在src/main/resources下创建spring文件夹 ，创建applicationContext-redis.xml"></a>5.在src/main/resources下创建spring文件夹 ，创建applicationContext-redis.xml</h3><pre><code>&lt;context:property-placeholder location=&quot;classpath*:properties/*.properties&quot; /&gt;   &lt;!-- redis 相关配置 --&gt; &lt;bean id=&quot;poolConfig&quot; class=&quot;redis.clients.jedis.JedisPoolConfig&quot;&gt;   &lt;property name=&quot;maxIdle&quot; value=&quot;${redis.maxIdle}&quot; /&gt;    &lt;property name=&quot;maxWaitMillis&quot; value=&quot;${redis.maxWait}&quot; /&gt;   &lt;property name=&quot;testOnBorrow&quot; value=&quot;${redis.testOnBorrow}&quot; /&gt;  &lt;/bean&gt;  &lt;bean id=&quot;JedisConnectionFactory&quot; class=&quot;org.springframework.data.redis.connection.jedis.JedisConnectionFactory&quot;    p:host-name=&quot;${redis.host}&quot; p:port=&quot;${redis.port}&quot; p:password=&quot;${redis.pass}&quot; p:pool-config-ref=&quot;poolConfig&quot;/&gt;  &lt;bean id=&quot;redisTemplate&quot; class=&quot;org.springframework.data.redis.core.RedisTemplate&quot;&gt;   &lt;property name=&quot;connectionFactory&quot; ref=&quot;JedisConnectionFactory&quot; /&gt;  &lt;/bean&gt;</code></pre><p>maxIdle ：最大空闲数</p><p>maxWaitMillis:连接时的最大等待毫秒数</p><p>testOnBorrow：在提取一个jedis实例时，是否提前进行验证操作；如果为true，则得到的jedis实例均是可用的</p><h1 id="测试"><a href="#测试" class="headerlink" title="测试"></a>测试</h1><p>这里只写常用的hash和String两种类型的数据CRUD</p><h2 id="String"><a href="#String" class="headerlink" title="String:"></a>String:</h2><pre><code>@RunWith(SpringJUnit4ClassRunner.class)@ContextConfiguration(locations=&quot;classpath:spring/applicationContext-redis.xml&quot;)public class TestValue {    @Autowired    private RedisTemplate redisTemplate;        @Test    public void setValue(){        redisTemplate.boundValueOps(&quot;name&quot;).set(&quot;itcast&quot;);            }        @Test    public void getValue(){        String str = (String) redisTemplate.boundValueOps(&quot;name&quot;).get();        System.out.println(str);    }        @Test    public void deleteValue(){        redisTemplate.delete(&quot;name&quot;);;    }    }</code></pre><h2 id="Hash类型操作"><a href="#Hash类型操作" class="headerlink" title="Hash类型操作"></a>Hash类型操作</h2><p>创建测试类TestHash</p><p>（1）存入值</p><pre><code>@Testpublic void testSetValue(){    redisTemplate.boundHashOps(&quot;namehash&quot;).put(&quot;a&quot;, &quot;唐僧&quot;);    redisTemplate.boundHashOps(&quot;namehash&quot;).put(&quot;b&quot;, &quot;悟空&quot;);    redisTemplate.boundHashOps(&quot;namehash&quot;).put(&quot;c&quot;, &quot;八戒&quot;);    redisTemplate.boundHashOps(&quot;namehash&quot;).put(&quot;d&quot;, &quot;沙僧&quot;);}</code></pre><p>（2）提取所有的KEY</p><pre><code>@Testpublic void testGetKeys(){    Set s = redisTemplate.boundHashOps(&quot;namehash&quot;).keys();            System.out.println(s);        }</code></pre><p>运行结果：<br>[a, b, c, d]</p><p>（3）提取所有的值</p><pre><code>@Testpublic void testGetValues(){    List values = redisTemplate.boundHashOps(&quot;namehash&quot;).values();    System.out.println(values);        }</code></pre><p>运行结果：<br>[唐僧, 悟空, 八戒, 沙僧]</p><p>（4）根据KEY提取值</p><pre><code>@Testpublic void testGetValueByKey(){    Object object = redisTemplate.boundHashOps(&quot;namehash&quot;).get(&quot;b&quot;);    System.out.println(object);}</code></pre><p>运行结果：<br>悟空</p><p>（5）根据KEY移除值</p><pre><code>@Testpublic void testRemoveValueByKey(){    redisTemplate.boundHashOps(&quot;namehash&quot;).delete(&quot;c&quot;);}</code></pre><p>运行后再次查看集合内容：<br>[唐僧, 悟空, 沙僧]</p><h1 id="小节-缓存同步问题"><a href="#小节-缓存同步问题" class="headerlink" title="小节(缓存同步问题)"></a>小节(缓存同步问题)</h1><p> 在项目中使用redis会涉及到缓存同步的问题,解决这个问题是在进行缓存内容增删改之前要先删除缓存,然后再进行查询数据,这样在更改后的下次查询,在缓存中查不到数据就会去数据库中查询,然后再保存进缓存,这样就实现了缓存的同步.</p><p>在使用时是先要查询缓存,然后判断缓存是否存在所要查询的数据,如果存在的话就直接返回结果,如果没有查询到的话,就去数据库里面查询,然后将查询结果保存进缓存中.</p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;什么是Redis&quot;&gt;&lt;a href=&quot;#什么是Redis&quot; class=&quot;headerlink&quot; title=&quot;什么是Redis&quot;&gt;&lt;/a&gt;什么是Redis&lt;/h1&gt;&lt;p&gt;redis是一个非关系型Key-Value数据库,运行在内存中,由ANSI C编写。企业开发通常采用Redis来实现缓存。同类的产品还有memcache 、memcached 、MongoDB等。&lt;/p&gt;
    
    </summary>
    
      <category term="java" scheme="http://www.fashionkillyou.xyz/categories/java/"/>
    
    
      <category term="redis" scheme="http://www.fashionkillyou.xyz/tags/redis/"/>
    
      <category term="spring-data-redis" scheme="http://www.fashionkillyou.xyz/tags/spring-data-redis/"/>
    
      <category term="jedis" scheme="http://www.fashionkillyou.xyz/tags/jedis/"/>
    
  </entry>
  
  <entry>
    <title>数据库的事务</title>
    <link href="http://www.fashionkillyou.xyz/2018/03/14/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%9A%84%E4%BA%8B%E5%8A%A1/"/>
    <id>http://www.fashionkillyou.xyz/2018/03/14/数据库的事务/</id>
    <published>2018-03-14T08:32:27.000Z</published>
    <updated>2018-03-14T09:18:08.599Z</updated>
    
    <content type="html"><![CDATA[<script src="\assets\js\APlayer.min.js"> </script><h1 id="【事务的概述】"><a href="#【事务的概述】" class="headerlink" title="【事务的概述】"></a>【事务的概述】</h1><h2 id="什么是事务"><a href="#什么是事务" class="headerlink" title="什么是事务:"></a>什么是事务:</h2><p>事务指的是逻辑上的一组操作,组成这组操作的各个逻辑单元要么一起成功,要么一起失败.<br><a id="more"></a><br>MYSQL的事务管理有两种方式:(MYSQL数据库事务默认是自动提交的.Oracle数据库事务默认是不自动提交.)</p><p>1.手动开启事务</p><ul><li>start transaction; – 开启事务</li><li>多条sql;</li><li>commit/rollback;</li></ul><p>2.设置一个自动提交参数</p><ul><li>show variables like ‘%commit%’; – 查看与commit相关参数.</li><li>set autocommit = 0; – 将autocommit参数设置为OFF.</li></ul><h1 id="【JDBC中的事务管理】"><a href="#【JDBC中的事务管理】" class="headerlink" title="【JDBC中的事务管理】"></a>【JDBC中的事务管理】</h1><h2 id="JDBC的事务的管理的API"><a href="#JDBC的事务的管理的API" class="headerlink" title="JDBC的事务的管理的API:"></a>JDBC的事务的管理的API:</h2><p>同一个事务 连接必须得是同一个对象(就是提交和设置的connection必须得是同一个),要加在业务层</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结:"></a>总结:</h2><h3 id="事务特性"><a href="#事务特性" class="headerlink" title="事务特性:"></a>事务特性:</h3><ul><li>原子性：强调事务的不可分割.(要么一起成功,要么一起失败)</li><li>一致性：强调的是事务的执行的前后，数据的完整性要保持一致.(转账前总和2000,转完后总和也得是2000)</li><li>隔离性：一个事务的执行不应该受到其他事务的干扰.</li><li>持久性：事务一旦结束(提交/回滚)数据就持久保持到了数据库.</li><li>如果不考虑事务的隔离性,引发一些安全性问题:</li></ul><p>一类是  读问题:</p><ul><li>不可重复读    :一个事务读到了另一个事务已经提交的update的数据,导致在当前的事务中多次查询结果不一致.</li><li>虚读/幻读    :一个事务读到另一个事务已经提交的insert的数据,导致在</li><li>当前的事务中多次的查询结果不一致.</li></ul><p>一类是  写问题:</p><p>引发两类丢失更新:</p><h3 id="解决引发的读问题"><a href="#解决引发的读问题" class="headerlink" title="解决引发的读问题:"></a>解决引发的读问题:</h3><p>设置事务的隔离级别:</p><ul><li>read uncommitted        :未提交读.脏读，不可重复读，虚读都可能发生.(安全性低,但是效率高)</li><li>read committed        :已提交读.避免脏读.但是不可重复读和虚读有可能发生.</li><li>repeatable read        :可重复读.避免脏读,不可重复读.但是虚读有可能发生.</li><li>serializable            :串行化的.避免脏读，不可重复读，虚读的发生.(安全性高,但是效率低)</li></ul><p><strong>*</strong> MYSQL隔离级别：repeatable read  Oracle隔离级别:read committed</p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;【事务的概述】&quot;&gt;&lt;a href=&quot;#【事务的概述】&quot; class=&quot;headerlink&quot; title=&quot;【事务的概述】&quot;&gt;&lt;/a&gt;【事务的概述】&lt;/h1&gt;&lt;h2 id=&quot;什么是事务&quot;&gt;&lt;a href=&quot;#什么是事务&quot; class=&quot;headerlink&quot; title=&quot;什么是事务:&quot;&gt;&lt;/a&gt;什么是事务:&lt;/h2&gt;&lt;p&gt;事务指的是逻辑上的一组操作,组成这组操作的各个逻辑单元要么一起成功,要么一起失败.&lt;br&gt;
    
    </summary>
    
      <category term="数据库" scheme="http://www.fashionkillyou.xyz/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    
    
      <category term="事务管理" scheme="http://www.fashionkillyou.xyz/tags/%E4%BA%8B%E5%8A%A1%E7%AE%A1%E7%90%86/"/>
    
  </entry>
  
  <entry>
    <title>使用FastDFS+angularJS+HTML5+springMVC进行文件上传</title>
    <link href="http://www.fashionkillyou.xyz/2018/03/12/%E4%BD%BF%E7%94%A8FastDFS-angularJS-HTML5-springMVC%E8%BF%9B%E8%A1%8C%E6%96%87%E4%BB%B6%E4%B8%8A%E4%BC%A0/"/>
    <id>http://www.fashionkillyou.xyz/2018/03/12/使用FastDFS-angularJS-HTML5-springMVC进行文件上传/</id>
    <published>2018-03-11T17:14:11.000Z</published>
    <updated>2018-03-11T18:01:34.932Z</updated>
    
    <content type="html"><![CDATA[<script src="\assets\js\APlayer.min.js"> </script><h1 id="分布式文件服务器FastDFS"><a href="#分布式文件服务器FastDFS" class="headerlink" title="分布式文件服务器FastDFS"></a>分布式文件服务器FastDFS</h1><h2 id="什么是FastDFS"><a href="#什么是FastDFS" class="headerlink" title="什么是FastDFS"></a>什么是FastDFS</h2><p>FastDFS 是用 c 语言编写的一款开源的分布式文件系统。FastDFS 为互联网量身定制，充分考虑了冗余备份、负载均衡、线性扩容等机制，并注重高可用、高性能等指标，使用 FastDFS很容易搭建一套高性能的文件服务器集群提供文件上传、下载等服务。</p><a id="more"></a><p>FastDFS 架构包括 Tracker server 和 Storage server。客户端请求 Tracker server 进行文件上传、下载，通过 Tracker server 调度最终由 Storage server 完成文件上传和下载。</p><p>Tracker server 作用是负载均衡和调度，通过 Tracker server 在文件上传时可以根据一些策略找到 Storage server 提供文件上传服务。可以将 tracker 称为追踪服务器或调度服务器。</p><p>Storage server 作用是文件存储，客户端上传的文件最终存储在 Storage 服务器上，Storageserver 没有实现自己的文件系统而是利用操作系统 的文件系统来管理文件。可以将storage称为存储服务器。</p><p><img src="http://p57l8frp4.bkt.clouddn.com/FastDFS1.png" alt=""></p><p>服务端两个角色：</p><ul><li><p>Tracker：管理集群，tracker 也可以实现集群。每个 tracker 节点地位平等。收集 Storage 集群的状态。</p></li><li><p>Storage：实际保存文件   Storage 分为多个组，每个组之间保存的文件是不同的。每个组内部可以有多个成员，组成员内部保存的内容是一样的，组成员的地位是一致的，没有主从的概念。</p><h2 id="文件上传及下载的流程"><a href="#文件上传及下载的流程" class="headerlink" title="文件上传及下载的流程"></a>文件上传及下载的流程</h2><h3 id="文件上传流程"><a href="#文件上传流程" class="headerlink" title="文件上传流程"></a>文件上传流程</h3></li></ul><p><img src="http://p57l8frp4.bkt.clouddn.com/FastDFS2.png" alt=""></p><p>客户端上传文件后存储服务器将文件 ID 返回给客户端，此文件 ID 用于以后访问该文件的索引信息。文件索引信息包括：组名，虚拟磁盘路径，数据两级目录，文件名。</p><p><img src="http://p57l8frp4.bkt.clouddn.com/FastDFS3.png" alt=""></p><p>组名：文件上传后所在的 storage 组名称，在文件上传成功后有 storage 服务器返回，需要客户端自行保存。</p><ul><li><p>虚拟磁盘路径：storage 配置的虚拟路径，与磁盘选项 store_path*对应。如果配置了<br>store_path0 则是 M00，如果配置了 store_path1 则是 M01，以此类推。</p></li><li><p>数据两级目录：storage 服务器在每个虚拟磁盘路径下创建的两级目录，用于存储数据<br>文件。</p></li><li><p>文件名：与文件上传时不同。是由存储服务器根据特定信息生成，文件名包含：源存储<br>服务器 IP 地址、文件创建时间戳、文件大小、随机数和文件拓展名等信息。</p></li></ul><h3 id="文件下载流程"><a href="#文件下载流程" class="headerlink" title="文件下载流程"></a>文件下载流程</h3><p><img src="http://p57l8frp4.bkt.clouddn.com/FastDFS4.png" alt=""></p><h3 id="最简单的-FastDFS-架构"><a href="#最简单的-FastDFS-架构" class="headerlink" title="最简单的 FastDFS 架构"></a>最简单的 FastDFS 架构</h3><p><img src="http://p57l8frp4.bkt.clouddn.com/FastDFS5.png" alt=""></p><h3 id="FastDFS安装"><a href="#FastDFS安装" class="headerlink" title="FastDFS安装"></a>FastDFS安装</h3><p>请参考一下博客:</p><p><a href="https://www.cnblogs.com/fishbay/archive/2017/09/24/7586772.html" target="_blank" rel="noopener">https://www.cnblogs.com/fishbay/archive/2017/09/24/7586772.html</a></p><p><a href="http://blog.csdn.net/XingJames/article/details/52759876" target="_blank" rel="noopener">http://blog.csdn.net/XingJames/article/details/52759876</a></p><p><a href="https://www.cnblogs.com/jym-sunshine/p/6397470.html" target="_blank" rel="noopener">FastDFS安装全过程记录</a></p><h2 id="代码案例"><a href="#代码案例" class="headerlink" title="代码案例"></a>代码案例</h2><h3 id="依赖的jar包"><a href="#依赖的jar包" class="headerlink" title="依赖的jar包:"></a>依赖的jar包:</h3><pre><code>&lt;!-- 文件上传组件 --&gt;    &lt;dependency&gt;        &lt;groupId&gt;org.csource.fastdfs&lt;/groupId&gt;        &lt;artifactId&gt;fastdfs&lt;/artifactId&gt;    &lt;/dependency&gt;    &lt;dependency&gt;        &lt;groupId&gt;commons-fileupload&lt;/groupId&gt;        &lt;artifactId&gt;commons-fileupload&lt;/artifactId&gt;    &lt;/dependency&gt;</code></pre><h3 id="使用的工具类"><a href="#使用的工具类" class="headerlink" title="使用的工具类:"></a>使用的工具类:</h3><pre><code>package util;import org.csource.common.NameValuePair;import org.csource.fastdfs.ClientGlobal;import org.csource.fastdfs.StorageClient1;import org.csource.fastdfs.StorageServer;import org.csource.fastdfs.TrackerClient;import org.csource.fastdfs.TrackerServer;public class FastDFSClient {    private TrackerClient trackerClient = null;    private TrackerServer trackerServer = null;    private StorageServer storageServer = null;    private StorageClient1 storageClient = null;    public FastDFSClient(String conf) throws Exception {        if (conf.contains(&quot;classpath:&quot;)) {            conf = conf.replace(&quot;classpath:&quot;, this.getClass().getResource(&quot;/&quot;).getPath());        }        ClientGlobal.init(conf);        trackerClient = new TrackerClient();        trackerServer = trackerClient.getConnection();        storageServer = null;        storageClient = new StorageClient1(trackerServer, storageServer);    }    /**     * 上传文件方法     * &lt;p&gt;Title: uploadFile&lt;/p&gt;     * &lt;p&gt;Description: &lt;/p&gt;     * @param fileName 文件全路径     * @param extName 文件扩展名，不包含（.）     * @param metas 文件扩展信息     * @return     * @throws Exception     */    public String uploadFile(String fileName, String extName, NameValuePair[] metas) throws Exception {        String result = storageClient.upload_file1(fileName, extName, metas);        return result;    }    public String uploadFile(String fileName) throws Exception {        return uploadFile(fileName, null, null);    }    public String uploadFile(String fileName, String extName) throws Exception {        return uploadFile(fileName, extName, null);    }    /**     * 上传文件方法     * &lt;p&gt;Title: uploadFile&lt;/p&gt;     * &lt;p&gt;Description: &lt;/p&gt;     * @param fileContent 文件的内容，字节数组     * @param extName 文件扩展名     * @param metas 文件扩展信息     * @return     * @throws Exception     */    public String uploadFile(byte[] fileContent, String extName, NameValuePair[] metas) throws Exception {        String result = storageClient.upload_file1(fileContent, extName, metas);        return result;    }    public String uploadFile(byte[] fileContent) throws Exception {        return uploadFile(fileContent, null, null);    }    public String uploadFile(byte[] fileContent, String extName) throws Exception {        return uploadFile(fileContent, extName, null);    }}</code></pre><h3 id="config下的配置文件-fdfs-client-conf"><a href="#config下的配置文件-fdfs-client-conf" class="headerlink" title="config下的配置文件(fdfs_client.conf):"></a>config下的配置文件(fdfs_client.conf):</h3><p>注意修改</p><p>tracker_server=192.168.25.133:22122为tracker服务器地址</p><pre><code># connect timeout in seconds# default value is 30sconnect_timeout=30# network timeout in seconds# default value is 30snetwork_timeout=60# the base path to store log filesbase_path=/home/fastdfs# tracker_server can ocur more than once, and tracker_server format is#  &quot;host:port&quot;, host can be hostname or ip addresstracker_server=192.168.25.133:22122#standard log level as syslog, case insensitive, value list:### emerg for emergency### alert### crit for critical### error### warn for warning### notice### info### debuglog_level=info# if use connection pool# default value is false# since V4.05use_connection_pool = false# connections whose the idle time exceeds this time will be closed# unit: second# default value is 3600# since V4.05connection_pool_max_idle_time = 3600# if load FastDFS parameters from tracker server# since V4.05# default value is falseload_fdfs_parameters_from_tracker=false# if use storage ID instead of IP address# same as tracker.conf# valid only when load_fdfs_parameters_from_tracker is false# default value is false# since V4.05use_storage_id = false# specify storage ids filename, can use relative or absolute path# same as tracker.conf# valid only when load_fdfs_parameters_from_tracker is false# since V4.05storage_ids_filename = storage_ids.conf#HTTP settingshttp.tracker_server_port=80#use &quot;#include&quot; directive to include HTTP other settiongs##include http.conf</code></pre><h3 id="springmvc-xml中添加配置"><a href="#springmvc-xml中添加配置" class="headerlink" title="springmvc.xml中添加配置"></a>springmvc.xml中添加配置</h3><pre><code>&lt;!-- 配置多媒体解析器 --&gt;&lt;bean id=&quot;multipartResolver&quot; class=&quot;org.springframework.web.multipart.commons.CommonsMultipartResolver&quot;&gt;    &lt;property name=&quot;defaultEncoding&quot; value=&quot;UTF-8&quot;&gt;&lt;/property&gt;    &lt;!-- 设定文件上传的最大值5MB，5*1024*1024 --&gt;    &lt;property name=&quot;maxUploadSize&quot; value=&quot;5242880&quot;&gt;&lt;/property&gt;&lt;/bean&gt;</code></pre><h3 id="controller控制层代码"><a href="#controller控制层代码" class="headerlink" title="controller控制层代码:"></a>controller控制层代码:</h3><pre><code>/** * 文件上传Controller * @author Administrator * */@RestControllerpublic class UploadController {@RequestMapping(&quot;/upload&quot;)public Result upload( MultipartFile file){                    //1、取文件的扩展名    String originalFilename = file.getOriginalFilename();    String extName = originalFilename.substring(originalFilename.lastIndexOf(&quot;.&quot;) + 1);    try {    //2、创建一个 FastDFS 的客户端            FastDFSClient fastDFSClient      = new FastDFSClient(&quot;classpath:config/fdfs_client.conf&quot;);            //3、执行上传处理            String path = fastDFSClient.uploadFile(file.getBytes(), extName);            //4、拼接返回的 url 和 ip 地址，拼装成完整的 url            String url = &quot;文件服务器地址&quot; + path;                        return new Result(true,url);                    } catch (Exception e) {            e.printStackTrace();            return new Result(false, &quot;上传失败&quot;);        }            }    }</code></pre><h3 id="前端Service-js代码"><a href="#前端Service-js代码" class="headerlink" title="前端Service.js代码"></a>前端Service.js代码</h3><pre><code>//文件上传服务层app.service(&quot;uploadService&quot;,function($http){    this.uploadFile=function(){        var formData=new FormData();        formData.append(&quot;file&quot;,file.files[0]);           return $http({            method:&apos;POST&apos;,            url:&quot;../upload.do&quot;,            data: formData,            headers: {&apos;Content-Type&apos;:undefined},            transformRequest: angular.identity        });            }    });</code></pre><p>anjularjs对于post和get请求默认的Content-Type header 是application/json。通过设置‘Content-Type’: undefined，这样浏览器会帮我们把Content-Type 设置为 multipart/form-data.</p><p>通过设置 transformRequest: angular.identity ，anjularjs transformRequest function 将序列化我们的formdata object.</p><h3 id="前端controller-js代码"><a href="#前端controller-js代码" class="headerlink" title="前端controller.js代码"></a>前端controller.js代码</h3><pre><code>app.controller(&apos;myController&apos; ,function($scope,$controller,goodsService,itemCatService,uploadService){/** * 上传图片 */$scope.uploadFile=function(){          uploadService.uploadFile().success(function(response) {                    if(response.success){//如果上传成功，取出url            $scope.image_entity.url=response.message;//设置文件地址        }else{            alert(response.message);        }    }).error(function() {                        alert(&quot;上传发生错误&quot;);    });        }; }</code></pre><h3 id="页面显示"><a href="#页面显示" class="headerlink" title="页面显示"></a>页面显示</h3><pre><code>&lt;div class=&quot;modal-body&quot;&gt;                    &lt;table class=&quot;table table-bordered table-striped&quot;&gt;              &lt;tr&gt;                  &lt;td&gt;图片&lt;/td&gt;                  &lt;td&gt;                    &lt;table&gt;                        &lt;tr&gt;                            &lt;td&gt;                            &lt;input type=&quot;file&quot; id=&quot;file&quot; /&gt;                                                                &lt;button class=&quot;btn btn-primary&quot; type=&quot;button&quot; ng-click=&quot;uploadFile()&quot;&gt;                                       上传                                &lt;/button&gt;                                &lt;/td&gt;                            &lt;td&gt;                                &lt;img  src=&quot;{{image_entity.url}}&quot; width=&quot;200px&quot; height=&quot;200px&quot;&gt;                            &lt;/td&gt;                        &lt;/tr&gt;                                            &lt;/table&gt;                  &lt;/td&gt;              &lt;/tr&gt;                           &lt;/table&gt;                &lt;/div&gt;</code></pre>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;分布式文件服务器FastDFS&quot;&gt;&lt;a href=&quot;#分布式文件服务器FastDFS&quot; class=&quot;headerlink&quot; title=&quot;分布式文件服务器FastDFS&quot;&gt;&lt;/a&gt;分布式文件服务器FastDFS&lt;/h1&gt;&lt;h2 id=&quot;什么是FastDFS&quot;&gt;&lt;a href=&quot;#什么是FastDFS&quot; class=&quot;headerlink&quot; title=&quot;什么是FastDFS&quot;&gt;&lt;/a&gt;什么是FastDFS&lt;/h2&gt;&lt;p&gt;FastDFS 是用 c 语言编写的一款开源的分布式文件系统。FastDFS 为互联网量身定制，充分考虑了冗余备份、负载均衡、线性扩容等机制，并注重高可用、高性能等指标，使用 FastDFS很容易搭建一套高性能的文件服务器集群提供文件上传、下载等服务。&lt;/p&gt;
    
    </summary>
    
      <category term="前端" scheme="http://www.fashionkillyou.xyz/categories/%E5%89%8D%E7%AB%AF/"/>
    
    
      <category term="FastDFS" scheme="http://www.fashionkillyou.xyz/tags/FastDFS/"/>
    
      <category term="angularJS" scheme="http://www.fashionkillyou.xyz/tags/angularJS/"/>
    
      <category term="HTML5" scheme="http://www.fashionkillyou.xyz/tags/HTML5/"/>
    
      <category term="springMVC" scheme="http://www.fashionkillyou.xyz/tags/springMVC/"/>
    
  </entry>
  
  <entry>
    <title>基于angularJS的多选框select2</title>
    <link href="http://www.fashionkillyou.xyz/2018/03/09/%E5%9F%BA%E4%BA%8EangularJS%E7%9A%84%E5%A4%9A%E9%80%89%E6%A1%86select2/"/>
    <id>http://www.fashionkillyou.xyz/2018/03/09/基于angularJS的多选框select2/</id>
    <published>2018-03-09T03:03:38.000Z</published>
    <updated>2018-03-14T00:48:14.410Z</updated>
    
    <content type="html"><![CDATA[<script src="\assets\js\APlayer.min.js"> </script><h1 id="基于angularJS框架下的select2插件的使用"><a href="#基于angularJS框架下的select2插件的使用" class="headerlink" title="基于angularJS框架下的select2插件的使用"></a>基于angularJS框架下的select2插件的使用</h1><a id="more"></a><p><img src="http://p57l8frp4.bkt.clouddn.com/select2.jpg" alt=""></p><h2 id="使用步骤"><a href="#使用步骤" class="headerlink" title="使用步骤:"></a>使用步骤:</h2><h3 id="引入JS文件"><a href="#引入JS文件" class="headerlink" title="引入JS文件"></a>引入JS文件</h3><pre><code>&lt;link rel=&quot;stylesheet&quot; href=&quot;bootstrap/css/bootstrap.min.css&quot;&gt;&lt;script src=&quot;jQuery/jquery-2.2.3.min.js&quot;&gt;&lt;/script&gt;&lt;script src=&quot;bootstrap/js/bootstrap.min.js&quot;&gt;&lt;/script&gt;&lt;!-- 引入angularJS,分页,controller,service --&gt;&lt;script type=&quot;text/javascript&quot; src=&quot;angularjs/angular.min.js&quot;&gt;  &lt;/script&gt;&lt;!-- 引入select2的插件 --&gt;&lt;!-- 这个要在base_pagination.js之后,因为用到了app --&gt;&lt;link rel=&quot;stylesheet&quot; href=&quot;select2/select2.css&quot; /&gt;&lt;link rel=&quot;stylesheet&quot; href=&quot;select2/select2-bootstrap.css&quot; /&gt;&lt;script src=&quot;select2/select2.min.js&quot; type=&quot;text/javascript&quot;&gt;&lt;/script&gt;&lt;script type=&quot;text/javascript&quot; src=&quot;select2/angular-select2.js&quot;&gt;&lt;/script&gt;</code></pre><h3 id="写input的属性"><a href="#写input的属性" class="headerlink" title="写input的属性"></a>写input的属性</h3><pre><code>&lt;input select2 select2-model=&quot;entity.brandIds&quot;  config=&quot;brandList&quot; multiple placeholder=&quot; 选择品牌（可多选） &quot; class=&quot;form-control&quot;&gt;</code></pre><p>multiple 表示可多选</p><p>Config用于配置数据来源</p><p>select2-model用于指定用户选择后提交的变量</p><p>select2 必须加上否则失效</p><h3 id="给定数据源"><a href="#给定数据源" class="headerlink" title="给定数据源"></a>给定数据源</h3><p><strong>注意这个要放置在select插件的前面,因为select2使用到了app</strong></p><pre><code>这里的数据格式默认是{{id:2,text:'华为'}}&lt;script type=&quot;text/javascript&quot;&gt;    var app = angular.module(&apos;app&apos;,[]);    app.controller(&apos;myController&apos;,function($scope){        //列表数据        $scope.brandList={data:[{id:1,text:&apos;联想&apos;},{id:2,text:&apos;华为&apos;},{id:3,text:&apos;小米&apos;}]};    });&lt;/script&gt;</code></pre><p>资源文件:</p><h3 id="简单多选demo"><a href="#简单多选demo" class="headerlink" title="简单多选demo"></a>简单多选demo</h3><p>链接：<a href="https://pan.baidu.com/s/12xz7kcmZGwcTjMH7MJhmDg" target="_blank" rel="noopener">https://pan.baidu.com/s/12xz7kcmZGwcTjMH7MJhmDg</a> </p><p>密码：0aq2</p><h3 id="完整说明文档"><a href="#完整说明文档" class="headerlink" title="完整说明文档"></a>完整说明文档</h3><p>链接：<a href="https://pan.baidu.com/s/1XSHqbbx3ikZRlkIFgXgMGQ" target="_blank" rel="noopener">https://pan.baidu.com/s/1XSHqbbx3ikZRlkIFgXgMGQ</a> </p><p>密码：66gc</p><h3 id="官网"><a href="#官网" class="headerlink" title="官网"></a>官网</h3><p><a href="https://select2.org/" target="_blank" rel="noopener">https://select2.org</a>/</p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;基于angularJS框架下的select2插件的使用&quot;&gt;&lt;a href=&quot;#基于angularJS框架下的select2插件的使用&quot; class=&quot;headerlink&quot; title=&quot;基于angularJS框架下的select2插件的使用&quot;&gt;&lt;/a&gt;基于angularJS框架下的select2插件的使用&lt;/h1&gt;
    
    </summary>
    
      <category term="前端" scheme="http://www.fashionkillyou.xyz/categories/%E5%89%8D%E7%AB%AF/"/>
    
    
      <category term="angularJS" scheme="http://www.fashionkillyou.xyz/tags/angularJS/"/>
    
      <category term="select2" scheme="http://www.fashionkillyou.xyz/tags/select2/"/>
    
  </entry>
  
  <entry>
    <title>使用Mybatis的PageHelper插件进行分页</title>
    <link href="http://www.fashionkillyou.xyz/2018/03/07/%E4%BD%BF%E7%94%A8Mybatis%E7%9A%84PageHelper%E6%8F%92%E4%BB%B6%E8%BF%9B%E8%A1%8C%E5%88%86%E9%A1%B5/"/>
    <id>http://www.fashionkillyou.xyz/2018/03/07/使用Mybatis的PageHelper插件进行分页/</id>
    <published>2018-03-07T12:39:39.000Z</published>
    <updated>2018-03-16T04:03:34.016Z</updated>
    
    <content type="html"><![CDATA[<script src="\assets\js\APlayer.min.js"> </script><h1 id="PageHelper插件进行分页"><a href="#PageHelper插件进行分页" class="headerlink" title="PageHelper插件进行分页"></a>PageHelper插件进行分页</h1><h2 id="实现效果"><a href="#实现效果" class="headerlink" title="实现效果"></a>实现效果</h2><a id="more"></a><p> <img src="http://p57l8frp4.bkt.clouddn.com/PageHelper.png" alt=""></p><p>##准备内容<br>本文是建立在以下框架之上:</p><ul><li>前端使用的是angularJS框架+BootStrap</li><li>后台是SpringMVC+Spring+Mybatis</li></ul><p>前期的搭建请看(<a href="https://github.com/pagehelper/Mybatis-PageHelper/blob/master/wikis/zh/HowToUse.md" title="官方文档" target="_blank" rel="noopener">官方文档</a>)</p><p>推荐博客:</p><p><a href="http://blog.csdn.net/maoyuanming0806/article/details/77720754" target="_blank" rel="noopener">http://blog.csdn.net/maoyuanming0806/article/details/77720754</a></p><p><a href="http://blog.csdn.net/FansUnion/article/details/40304187" target="_blank" rel="noopener">http://blog.csdn.net/FansUnion/article/details/40304187</a></p><h2 id="后端代码"><a href="#后端代码" class="headerlink" title="后端代码"></a>后端代码</h2><h3 id="分页结果封装实体"><a href="#分页结果封装实体" class="headerlink" title="分页结果封装实体"></a>分页结果封装实体</h3><p>创建类PageResult用于在controller中返回分页数据</p><pre><code>package entity;import java.util.List;/** * 分页结果封装对象 * @author Administrator * */public class PageResult implements Serializable{    private long total;//总记录数    private List rows;//当前页结果            public PageResult(long total, List rows) {        super();        this.total = total;        this.rows = rows;    }     //getter  and setter .....}</code></pre><h3 id="服务接口层"><a href="#服务接口层" class="headerlink" title="服务接口层"></a>服务接口层</h3><p>在service的接口BrandService.java 增加方法定义</p><pre><code>/** * 返回分页列表 * @return */public PageResult findPage(int pageNum,int pageSize);</code></pre><h3 id="服务实现层"><a href="#服务实现层" class="headerlink" title="服务实现层"></a>服务实现层</h3><p>service的实现类BrandServiceImpl.java中实现该方法</p><pre><code>@Overridepublic PageResult findPage(int pageNum, int pageSize) {    PageHelper.startPage(pageNum, pageSize);            Page&lt;TbBrand&gt; page=   (Page&lt;TbBrand&gt;) brandMapper.selectByExample(null);    return new PageResult(page.getTotal(), page.getResult());}</code></pre><p>PageHelper为MyBatis分页插件</p><h3 id="控制层"><a href="#控制层" class="headerlink" title="控制层"></a>控制层</h3><p>在控制层BrandController.java新增方法</p><pre><code>/** * 返回全部列表 * @return */@RequestMapping(&quot;/findPage&quot;)public PageResult  findPage(int page,int rows){                return brandService.findPage(page, rows);}</code></pre><h2 id="前端代码"><a href="#前端代码" class="headerlink" title="前端代码"></a>前端代码</h2><h3 id="HTML"><a href="#HTML" class="headerlink" title="HTML"></a>HTML</h3><p>在brand.html引入分页组件</p><pre><code>&lt;!-- 分页组件开始 --&gt;&lt;script src=&quot;../plugins/angularjs/pagination.js&quot;&gt;&lt;/script&gt;&lt;link rel=&quot;stylesheet&quot; href=&quot;../plugins/angularjs/pagination.css&quot;&gt;&lt;!-- 分页组件结束 --&gt;</code></pre><p>构建app模块时引入pagination模块</p><pre><code>var app=angular.module(&apos;pinyougou&apos;,[&apos;pagination&apos;]);</code></pre><p>页面的表格下放置分页组件</p><pre><code> &lt;!-- 分页 --&gt;&lt;tm-pagination conf=&quot;paginationConf&quot;&gt;&lt;/tm-pagination&gt;</code></pre><h3 id="JS代码"><a href="#JS代码" class="headerlink" title="JS代码"></a>JS代码</h3><pre><code>//重新加载列表 数据$scope.reloadList=function(){     //切换页码      $scope.findPage( $scope.paginationConf.currentPage, $scope.paginationConf.itemsPerPage);}//分页控件配置 $scope.paginationConf = {         currentPage: 1,         totalItems: 10,         itemsPerPage: 10,         perPageOptions: [10, 20, 30, 40, 50],         onChange: function(){                     $scope.reloadList();//重新加载         }}; //分页$scope.findPage=function(page,rows){        $http.get(&apos;../brand/findPage.do?page=&apos;+page+&apos;&amp;rows=&apos;+rows).success(            function(response){                $scope.list=response.rows;                    $scope.paginationConf.totalItems=response.total;//更新总记录数            }                );}</code></pre><p>paginationConf 变量各属性的意义：</p><ul><li><p>currentPage：当前页码</p></li><li><p>totalItems:总条数</p></li><li><p>itemsPerPage:</p></li><li><p>perPageOptions：页码选项</p></li><li><p>onChange：更改页面时触发事件</p></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;PageHelper插件进行分页&quot;&gt;&lt;a href=&quot;#PageHelper插件进行分页&quot; class=&quot;headerlink&quot; title=&quot;PageHelper插件进行分页&quot;&gt;&lt;/a&gt;PageHelper插件进行分页&lt;/h1&gt;&lt;h2 id=&quot;实现效果&quot;&gt;&lt;a href=&quot;#实现效果&quot; class=&quot;headerlink&quot; title=&quot;实现效果&quot;&gt;&lt;/a&gt;实现效果&lt;/h2&gt;
    
    </summary>
    
    
      <category term="Mybatis" scheme="http://www.fashionkillyou.xyz/tags/Mybatis/"/>
    
      <category term="PageHelper" scheme="http://www.fashionkillyou.xyz/tags/PageHelper/"/>
    
  </entry>
  
  <entry>
    <title>AngularJS框架</title>
    <link href="http://www.fashionkillyou.xyz/2018/03/07/AngularJS%E6%A1%86%E6%9E%B6/"/>
    <id>http://www.fashionkillyou.xyz/2018/03/07/AngularJS框架/</id>
    <published>2018-03-07T04:45:07.000Z</published>
    <updated>2018-03-18T11:56:47.968Z</updated>
    
    <content type="html"><![CDATA[<script src="\assets\js\APlayer.min.js"> </script><h1 id="AngularJS简介"><a href="#AngularJS简介" class="headerlink" title="AngularJS简介"></a>AngularJS简介</h1><p><img src="http://p57l8frp4.bkt.clouddn.com/angularJS.png" alt=""></p><p>AngularJS  诞生于2009年，由Misko Hevery 等人创建，后为Google所收购。是一款优秀的前端JS框架，已经被用于Google的多款产品当中。AngularJS有着诸多特性，最为核心的是：MVC、模块化、自动化双向数据绑定、依赖注入等等。<br>  <a id="more"></a></p><h2 id="AngularJS四大特征"><a href="#AngularJS四大特征" class="headerlink" title="AngularJS四大特征"></a>AngularJS四大特征</h2><h3 id="MVC-模式"><a href="#MVC-模式" class="headerlink" title="MVC    模式"></a>MVC    模式</h3><p>Angular遵循软件工程的MVC模式,并鼓励展现，数据，和逻辑组件之间的松耦合.通过依赖注入（dependency injection），Angular为客户端的Web应用带来了传统服务端的服务，例如独立于视图的控制。 因此，后端减少了许多负担，产生了更轻的Web应用。<br> <img src="http://p57l8frp4.bkt.clouddn.com/angularJS1.png" alt=""></p><ul><li>Model:数据,其实就是angular变量($scope.XX);</li><li>View: 数据的呈现,Html+Directive(指令);</li><li>Controller:操作数据,就是function,数据的增删改查;</li></ul><h3 id="双向绑定"><a href="#双向绑定" class="headerlink" title="双向绑定"></a>双向绑定</h3><p>AngularJS是建立在这样的信念上的：即声明式编程应该用于构建用户界面以及编写软件构建，而指令式编程非常适合来表示业务逻辑。框架采用并扩展了传统HTML，通过双向的数据绑定来适应动态内容，双向的数据绑定允许模型和视图之间的自动同步。因此，AngularJS使得对DOM的操作不再重要并提升了可测试性。<br> <img src="http://p57l8frp4.bkt.clouddn.com/angularJS2.png" alt=""></p><h3 id="依赖注入"><a href="#依赖注入" class="headerlink" title="依赖注入"></a>依赖注入</h3><p>依赖注入(Dependency Injection,简称DI)是一种设计模式, 指某个对象依赖的其他对象无需手工创建，只需要“吼一嗓子”，则此对象在创建时，其依赖的对象由框架来自动创建并注入进来,其实就是最少知识法则;模块中所有的service和provider两类对象，都可以根据形参名称实现DI.</p><h3 id="模块化设计"><a href="#模块化设计" class="headerlink" title="模块化设计"></a>模块化设计</h3><p>高内聚低耦合法则</p><ul><li><p>官方提供的模块           ng、ngRoute、ngAnimate</p></li><li><p>用户自定义的模块     angular.module(‘模块名’,[ ])</p></li></ul><h2 id="入门小Demo"><a href="#入门小Demo" class="headerlink" title="入门小Demo"></a>入门小Demo</h2><h3 id="表达式"><a href="#表达式" class="headerlink" title="表达式"></a>表达式</h3><pre><code>&lt;html&gt;&lt;head&gt;    &lt;title&gt;入门小Demo-1&lt;/title&gt;    &lt;script src=&quot;angular.min.js&quot;&gt;&lt;/script&gt;&lt;/head&gt;&lt;body ng-app&gt;{{100+100}}&lt;/body&gt;&lt;/html&gt;</code></pre><p>执行结果如下：</p><p>表达式的写法是 表达式可以是变量或是运算式</p><ul><li>ng-app 指令 作用是告诉子元素一下的指令是归angularJs的,angularJs会识别的</li><li>ng-app 指令定义了 AngularJS 应用程序的 根元素。</li><li>ng-app 指令在网页加载完毕时会自动引导（自动初始化）应用程序。</li></ul><h3 id="双向绑定-1"><a href="#双向绑定-1" class="headerlink" title="双向绑定"></a>双向绑定</h3><pre><code>&lt;html&gt;&lt;head&gt;    &lt;title&gt;入门小Demo-1  双向绑定&lt;/title&gt;    &lt;script src=&quot;angular.min.js&quot;&gt;&lt;/script&gt;&lt;/head&gt;&lt;body ng-app&gt;请输入你的姓名：&lt;input ng-model=&quot;myname&quot;&gt;&lt;br&gt;{{myname}},你好&lt;/body&gt;&lt;/html&gt;</code></pre><p>运行效果如下：</p><p>ng-model 指令用于绑定变量,这样用户在文本框输入的内容会绑定到变量上，而表达式可以实时地输出变量。</p><h3 id="初始化指令"><a href="#初始化指令" class="headerlink" title="初始化指令"></a>初始化指令</h3><p>我们如果希望有些变量具有初始值，可以使用ng-init指令来对变量初始化</p><pre><code>&lt;html&gt;&lt;head&gt;    &lt;title&gt;入门小Demo-3  初始化&lt;/title&gt;    &lt;script src=&quot;angular.min.js&quot;&gt;&lt;/script&gt;&lt;/head&gt;&lt;body ng-app   ng-init=&quot;myname=&apos;陈大海&apos;&quot;&gt;请输入你的姓名：&lt;input ng-model=&quot;myname&quot;&gt;&lt;br&gt;{{myname}},你好&lt;/body&gt;&lt;/html&gt;</code></pre><h3 id="控制器"><a href="#控制器" class="headerlink" title="控制器"></a>控制器</h3><pre><code>&lt;html&gt;&lt;head&gt;    &lt;title&gt;入门小Demo-3  初始化&lt;/title&gt;    &lt;script src=&quot;angular.min.js&quot;&gt;&lt;/script&gt;    &lt;script&gt;        var app=angular.module(&apos;myApp&apos;,[]); //定义了一个叫myApp的模块        //定义控制器        app.controller(&apos;myController&apos;,function($scope){            $scope.add=function(){                return parseInt($scope.x)+parseInt($scope.y);            }        });    &lt;/script&gt;&lt;/head&gt;&lt;body ng-app=&quot;myApp&quot; ng-controller=&quot;myController&quot;&gt;x:&lt;input ng-model=&quot;x&quot; &gt;y:&lt;input ng-model=&quot;y&quot; &gt;运算结果：{{add()}}&lt;/body&gt;&lt;/html&gt;</code></pre><p>运行结果如下：</p><p>ng-controller用于指定所使用的控制器。</p><p>理解 $scope：</p><p>$scope 的使用贯穿整个 AngularJS App 应用,它与数据模型相关联,同时也是表达式执行的上下文.有了$scope 就在视图和控制器之间建立了一个通道,基于作用域视图在修改数据时会立刻更新 $scope,同样的$scope 发生改变时也会立刻重新渲染视图.</p><h3 id="事件指令"><a href="#事件指令" class="headerlink" title="事件指令"></a>事件指令</h3><pre><code>&lt;html&gt;&lt;head&gt;    &lt;title&gt;入门小Demo-5  事件指令&lt;/title&gt;    &lt;script src=&quot;angular.min.js&quot;&gt;&lt;/script&gt;        &lt;script&gt;        var app=angular.module(&apos;myApp&apos;,[]); //定义了一个叫myApp的模块        //定义控制器        app.controller(&apos;myController&apos;,function($scope){                        $scope.add=function(){                $scope.z= parseInt($scope.x)+parseInt($scope.y);            }                    });        &lt;/script&gt;&lt;/head&gt;&lt;body ng-app=&quot;myApp&quot; ng-controller=&quot;myController&quot;&gt;x:&lt;input ng-model=&quot;x&quot; &gt;y:&lt;input ng-model=&quot;y&quot; &gt;&lt;button ng-click=&quot;add()&quot;&gt;运算&lt;/button&gt;结果：{{z}}&lt;/body&gt;&lt;/html&gt;</code></pre><p>运行结果：</p><p>ng-click  是最常用的单击事件指令，再点击时触发控制器的某个方法</p><h3 id="循环数组"><a href="#循环数组" class="headerlink" title="循环数组"></a>循环数组</h3><pre><code>&lt;html&gt;&lt;head&gt;    &lt;title&gt;入门小Demo-6  循环数据&lt;/title&gt;    &lt;script src=&quot;angular.min.js&quot;&gt;&lt;/script&gt;    &lt;script&gt;        var app=angular.module(&apos;myApp&apos;,[]); //定义了一个叫myApp的模块        //定义控制器        app.controller(&apos;myController&apos;,function($scope){            $scope.list= [100,192,203,434 ];//定义数组        });    &lt;/script&gt;&lt;/head&gt;&lt;body ng-app=&quot;myApp&quot; ng-controller=&quot;myController&quot;&gt;&lt;table&gt;&lt;tr ng-repeat=&quot;x in list&quot;&gt;    &lt;td&gt;{{x}}&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/body&gt;&lt;/html&gt;</code></pre><p>这里的ng-repeat指令用于循环数组变量。<br>运行结果如下：</p><h3 id="循环对象数组"><a href="#循环对象数组" class="headerlink" title="循环对象数组"></a>循环对象数组</h3><pre><code>&lt;html&gt;&lt;head&gt;    &lt;title&gt;入门小Demo-7  循环对象数组&lt;/title&gt;    &lt;script src=&quot;angular.min.js&quot;&gt;&lt;/script&gt;        &lt;script&gt;        var app=angular.module(&apos;myApp&apos;,[]); //定义了一个叫myApp的模块        //定义控制器        app.controller(&apos;myController&apos;,function($scope){                    $scope.list= [                {name:&apos;张三&apos;,shuxue:100,yuwen:93},                {name:&apos;李四&apos;,shuxue:88,yuwen:87},                {name:&apos;王五&apos;,shuxue:77,yuwen:56}            ];//定义数组                    });        &lt;/script&gt;    &lt;/head&gt;&lt;body ng-app=&quot;myApp&quot; ng-controller=&quot;myController&quot;&gt;&lt;table&gt;&lt;tr&gt;    &lt;td&gt;姓名&lt;/td&gt;    &lt;td&gt;数学&lt;/td&gt;    &lt;td&gt;语文&lt;/td&gt;&lt;/tr&gt;&lt;tr ng-repeat=&quot;entity in list&quot;&gt;    &lt;td&gt;{{entity.name}}&lt;/td&gt;    &lt;td&gt;{{entity.shuxue}}&lt;/td&gt;    &lt;td&gt;{{entity.yuwen}}&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/body&gt;&lt;/html&gt;</code></pre><p>运行结果如下：</p><h3 id="内置服务"><a href="#内置服务" class="headerlink" title="内置服务"></a>内置服务</h3><p>我们的数据一般都是从后端获取的，那么如何获取数据呢？我们一般使用内置服务$http来实现。注意：以下代码需要在tomcat中运行。</p><pre><code>&lt;html&gt;&lt;head&gt;    &lt;title&gt;入门小Demo-8  内置服务&lt;/title&gt;    &lt;meta charset=&quot;utf-8&quot; /&gt;    &lt;script src=&quot;angular.min.js&quot;&gt;&lt;/script&gt;        &lt;script&gt;        var app=angular.module(&apos;myApp&apos;,[]); //定义了一个叫myApp的模块        //定义控制器        app.controller(&apos;myController&apos;,function($scope,$http){                    $scope.findAll=function(){                $http.get(&apos;data.json&apos;).success(                    function(response){                        $scope.list=response;                    }                                    );                            }                    });        &lt;/script&gt;    &lt;/head&gt;&lt;body ng-app=&quot;myApp&quot; ng-controller=&quot;myController&quot; ng-init=&quot;findAll()&quot;&gt;&lt;table&gt;&lt;tr&gt;    &lt;td&gt;姓名&lt;/td&gt;    &lt;td&gt;数学&lt;/td&gt;    &lt;td&gt;语文&lt;/td&gt;&lt;/tr&gt;&lt;tr ng-repeat=&quot;entity in list&quot;&gt;    &lt;td&gt;{{entity.name}}&lt;/td&gt;    &lt;td&gt;{{entity.shuxue}}&lt;/td&gt;    &lt;td&gt;{{entity.yuwen}}&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/body&gt;&lt;/html&gt;建立文件 data.json[    {&quot;name&quot;:&quot;张三&quot;,&quot;shuxue&quot;:100,&quot;yuwen&quot;:93},    {&quot;name&quot;:&quot;李四&quot;,&quot;shuxue&quot;:88,&quot;yuwen&quot;:87},    {&quot;name&quot;:&quot;王五&quot;,&quot;shuxue&quot;:77,&quot;yuwen&quot;:56},    {&quot;name&quot;:&quot;赵六&quot;,&quot;shuxue&quot;:67,&quot;yuwen&quot;:86}]</code></pre><h1 id="常用的指令"><a href="#常用的指令" class="headerlink" title="常用的指令"></a>常用的指令</h1><p>名称       描述</p><p><strong>ngApp    定义应用程序的根元素。</strong></p><p>ngBind    绑定 HTML 元素到应用程序数据</p><p><strong>ngBindhtml    绑定 HTML 元素的 innerHTML 到应用程序数据，并移除 HTML 字符串中危险字<br>符</strong></p><p>ngBindtemplate    规定要使用模板替换的文本内容</p><p>ngBlur    规定 blur 事件的行为</p><p>ngChange    规定在内容改变时要执行的表达式</p><p><strong>ngChecked    规定元素是否被选中</strong></p><p>ngClass    指定 HTML 元素使用的 CSS 类</p><p>ngClasseven    类似 ng-class，但只在偶数行起作用</p><p>ngClassodd    类似 ng-class，但只在奇数行起作用</p><p><strong>ngClick    定义元素被点击时的行为</strong></p><p>ngCloak    在应用正要加载时防止其闪烁</p><p>ngController    定义应用的控制器对象</p><p>ngCopy    规定拷贝事件的行为</p><p>ngCsp    修改内容的安全策略</p><p>ngCut    规定剪切事件的行为</p><p>ngDblclick    规定双击事件的行为</p><p>ngDisabled    规定一个元素是否被禁用</p><p>ngFocus    规定聚焦事件的行为</p><p>ngHide    隐藏或显示 HTML 元素</p><p>ngHref    为 元素指定链接</p><p><strong>ngIf    判断语句，如果值为falsh，所在的div层不显示</strong></p><p>ngInclude    在应用中包含 HTML 文件</p><p>ngInit    定义应用的初始化值</p><p>ngKeydown    规定按下按键事件的行为</p><p>ngKeypress    规定按下按键事件的行为</p><p>ngKeyup    规定松开按键事件的行为</p><p>ngList    将文本转换为列表 (数组)</p><p><strong>ngModel    绑定 HTML 控制器的值到应用数据</strong></p><p>ngModeloptions    规定如何更新模型</p><p>ngMousedown    规定按下鼠标按键时的行为</p><p>ngMouseenter    规定鼠标指针穿过元素时的行为</p><p>ngMouseleave    规定鼠标指针离开元素时的行为</p><p>ngMousemove    规定鼠标指针在指定的元素中移动时的行为</p><p>ngMouseover    规定鼠标指针位于元素上方时的行为</p><p>ngMouseup    规定当在元素上松开鼠标按钮时的行为</p><p>ngNonbindable    规定元素或子元素不能绑定数据</p><p>ngOpen    指定元素的 open 属性</p><p><strong>ngOptions    在 &lt; select&gt; 列表中指定 &lt; options&gt;</strong></p><p>ngPaste    规定粘贴事件的行为</p><p>ngReadonly    指定元素的 readonly 属性</p><p><strong>ngRepeat    定义集合中每项数据的模板</strong></p><p>ngSelected    指定元素的 selected 属性</p><p>ngShow    显示或隐藏 HTML 元素</p><p>ngSrc    指定  元素的 src 属性</p><p>ngSrcset    指定  元素的 srcset 属性</p><p>ngStyle    指定元素的 style 属性</p><p>ngSubmit    规定 onsubmit 事件发生时执行的表达式</p><p>ngSwitch    规定显示或隐藏子元素的条件</p><p><strong>ngValue    规定input元素的值</strong></p><h1 id="服务"><a href="#服务" class="headerlink" title="服务"></a>服务</h1><p>名称    描述</p><p>$http    $http是Angular的一个核心服务，它有利于浏览器通过XMLHttpRequest 对象或者 JSONP和远程HTTP服务器交互。</p><p>$controller    </p><p>$filter    ()</p><pre><code>// 定义过滤器app.filter(&apos;trustHtml&apos;,[&apos;$sce&apos;,function($sce){    return function(data){//传入参数时被过滤的内容        return $sce.trustAsHtml(data);//返回的是过滤后的内容（信任html的转换）    }    } ]);</code></pre><p>页面:<br>    <div class="attr" ng-bind-html="item.title | trustHtml"></div></p><p>$location    $location服务解析浏览器地址中的url（基于window.location）并且使url在应用程序中可用。将地址栏中的网址的变化反映到$location服务和$location的变化反映到浏览器地址栏。</p><p>$sce    $sce 服务是AngularJs提供的一种严格上下文转义服务。</p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;AngularJS简介&quot;&gt;&lt;a href=&quot;#AngularJS简介&quot; class=&quot;headerlink&quot; title=&quot;AngularJS简介&quot;&gt;&lt;/a&gt;AngularJS简介&lt;/h1&gt;&lt;p&gt;&lt;img src=&quot;http://p57l8frp4.bkt.clouddn.com/angularJS.png&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;p&gt;AngularJS  诞生于2009年，由Misko Hevery 等人创建，后为Google所收购。是一款优秀的前端JS框架，已经被用于Google的多款产品当中。AngularJS有着诸多特性，最为核心的是：MVC、模块化、自动化双向数据绑定、依赖注入等等。&lt;br&gt;
    
    </summary>
    
      <category term="前端" scheme="http://www.fashionkillyou.xyz/categories/%E5%89%8D%E7%AB%AF/"/>
    
    
      <category term="AngularJS" scheme="http://www.fashionkillyou.xyz/tags/AngularJS/"/>
    
  </entry>
  
  <entry>
    <title>Dubbox框架入门小demo</title>
    <link href="http://www.fashionkillyou.xyz/2018/03/05/Dubbox%E6%A1%86%E6%9E%B6%E5%85%A5%E9%97%A8%E5%B0%8Fdemo/"/>
    <id>http://www.fashionkillyou.xyz/2018/03/05/Dubbox框架入门小demo/</id>
    <published>2018-03-05T12:02:42.000Z</published>
    <updated>2018-03-05T16:42:05.235Z</updated>
    
    <content type="html"><![CDATA[<script src="\assets\js\APlayer.min.js"> </script><h1 id="Dubbox框架"><a href="#Dubbox框架" class="headerlink" title="Dubbox框架"></a>Dubbox框架</h1><h2 id="Dubbox简介"><a href="#Dubbox简介" class="headerlink" title="Dubbox简介"></a>Dubbox简介</h2><p>Dubbox 是一个<strong>分布式服务框架</strong>，其前身是阿里巴巴开源项目Dubbo ，被国内电商及互联网项目中使用，后期阿里巴巴停止了该项目的维护，当当网便在Dubbo基础上进行优化，并继续维护，为了与原有的Dubbo区分，故将其命名为Dubbox。<br><a id="more"></a><br>Dubbox 致力于提供高性能和透明化的RPC远程服务调用方案，以及SOA服务治理方案。简单的说，dubbox就是个服务框架，如果没有分布式的需求，其实是不需要用的，只有在分布式的时候，才有dubbox这样的分布式服务框架的需求，并且本质上是个服务调用的东东，说白了就是个远程服务调用的分布式框架。</p><p>###节点角色说明：<br>• Provider: 暴露服务的服务提供方。</p><p>• Consumer: 调用远程服务的服务消费方。</p><p>• Registry: 服务注册与发现的注册中心。</p><p>• Monitor: 统计服务的调用次调和调用时间的监控中心。</p><p>• Container: 服务运行容器。</p><h3 id="调用关系说明："><a href="#调用关系说明：" class="headerlink" title="调用关系说明："></a>调用关系说明：</h3><p>• 0. 服务容器负责启动，加载，运行服务提供者。</p><p>• 1. 服务提供者在启动时，向注册中心注册自己提供的服务。</p><p>• 2. 服务消费者在启动时，向注册中心订阅自己所需的服务。</p><p>• 3. 注册中心返回服务提供者地址列表给消费者，如果有变更，注册中心将基于长连接推<br>送变更数据给消费者。</p><p>• 4. 服务消费者，从提供者地址列表中，基于软负载均衡算法，选一台提供者进行调用，<br>如果调用失败，再选另一台调用。</p><p>• 5. 服务消费者和提供者，在内存中累计调用次数和调用时间，定时每分钟发送一次统计<br>数据到监控中心。</p><h2 id="注册中心Zookeeper"><a href="#注册中心Zookeeper" class="headerlink" title="注册中心Zookeeper"></a>注册中心Zookeeper</h2><h3 id="Zookeeper-介绍"><a href="#Zookeeper-介绍" class="headerlink" title="Zookeeper 介绍"></a>Zookeeper 介绍</h3><p>官方推荐使用 zookeeper 注册中心。注册中心负责服务地址的注册与查找，相当于目录服务，服务提供者和消费者只在启动时与注册中心交互，注册中心不转发请求，压力较小。</p><p>Zookeeper 是 Apacahe Hadoop 的子项目，是一个树型的目录服务，支持变更推送，适合作为Dubbox 服务的注册中心，工业强度较高，可用于生产环境。</p><h3 id="Zookeeper-在Linux系统的安装"><a href="#Zookeeper-在Linux系统的安装" class="headerlink" title="Zookeeper 在Linux系统的安装"></a>Zookeeper 在Linux系统的安装</h3><p>安装步骤：</p><p>第一步：安装 jdk(这里请自行百度,如何在Linux中安装jdk)</p><p>第二步：把 zookeeper 的压缩包（…\dubbox\zookeeper-3.4.6.tar.gz）上传到 linux 系统。</p><pre><code>Alt+P 进入SFTP ，输入put d:\zookeeper-3.4.6.tar.gz 上传(这里d:是你放置压缩包的位置)</code></pre><p>第三步：解压缩压缩包</p><pre><code>tar -zxvf zookeeper-3.4.6.tar.gz</code></pre><p>第四步：进入 zookeeper-3.4.6 目录，创建 data 文件夹。</p><pre><code>mkdir data</code></pre><p>第五步：进入conf目录 ，把 zoo_sample.cfg 改名为 zoo.cfg</p><pre><code>cd confmv zoo_sample.cfg zoo.cfg</code></pre><p>第六步：打开zoo.cfg ,  修改 data 属性：</p><pre><code>dataDir=/root/zookeeper-3.4.6/data</code></pre><h3 id="Zookeeper-服务启动"><a href="#Zookeeper-服务启动" class="headerlink" title="Zookeeper 服务启动"></a>Zookeeper 服务启动</h3><p>进入bin目录，启动服务输入命令</p><pre><code>./zkServer.sh start</code></pre><p>关闭服务输入命令</p><pre><code>./zkServer.sh stop</code></pre><p>查看状态：</p><pre><code>./zkServer.sh status</code></pre><h3 id="Dubbox本地-JAR包部署与安装"><a href="#Dubbox本地-JAR包部署与安装" class="headerlink" title="Dubbox本地 JAR包部署与安装"></a>Dubbox本地 JAR包部署与安装</h3><p>Dubbox的jar包并没有部署到Maven的中央仓库中，大家在Maven的中央仓库中可以查找到Dubbo的最终版本是2.5.3 , 阿里巴巴解散了Dubbo团队后由当当网继续维护此项目，并改名为 Dubbox ,坐标不变，版本变更了，但是并没有提交到中央仓库。</p><p>我们现在需要手动将Dubbox的jar包安装到我的本地仓库中。</p><p>先将dubbo-2.8.4.jar包放到d:\setup, 然后输入命令</p><pre><code>mvn install:install-file -Dfile=d:\setup\dubbo-2.8.4.jar -DgroupId=com.alibaba -DartifactId=dubbo -Dversion=2.8.4 -Dpackaging=jar</code></pre><h3 id="配置离线约束"><a href="#配置离线约束" class="headerlink" title="配置离线约束"></a>配置离线约束</h3><p>地址：</p><pre><code>http://code.alibabatech.com/schema/dubbo/dubbo.xsd </code></pre><h2 id="入门小Demo"><a href="#入门小Demo" class="headerlink" title="入门小Demo"></a>入门小Demo</h2><h3 id="服务提供者开发"><a href="#服务提供者开发" class="headerlink" title="服务提供者开发"></a>服务提供者开发</h3><p>开发步骤：</p><p>（1）创建Maven工程（WAR）dubboxdemo-service  ，在pom.xml中引入依赖</p><pre><code>&lt;project xmlns=&quot;http://maven.apache.org/POM/4.0.0&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xsi:schemaLocation=&quot;http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd&quot;&gt;  &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt;  &lt;groupId&gt;cn.lxm.dubboxdemo&lt;/groupId&gt;  &lt;artifactId&gt;dubboxdemo-service&lt;/artifactId&gt;  &lt;version&gt;0.0.1-SNAPSHOT&lt;/version&gt;  &lt;packaging&gt;war&lt;/packaging&gt;     &lt;properties&gt;                &lt;spring.version&gt;4.2.4.RELEASE&lt;/spring.version&gt;   &lt;/properties&gt;        &lt;dependencies&gt;        &lt;!-- Spring --&gt;        &lt;dependency&gt;            &lt;groupId&gt;org.springframework&lt;/groupId&gt;            &lt;artifactId&gt;spring-context&lt;/artifactId&gt;            &lt;version&gt;${spring.version}&lt;/version&gt;        &lt;/dependency&gt;        &lt;dependency&gt;            &lt;groupId&gt;org.springframework&lt;/groupId&gt;            &lt;artifactId&gt;spring-beans&lt;/artifactId&gt;            &lt;version&gt;${spring.version}&lt;/version&gt;        &lt;/dependency&gt;        &lt;dependency&gt;            &lt;groupId&gt;org.springframework&lt;/groupId&gt;            &lt;artifactId&gt;spring-webmvc&lt;/artifactId&gt;            &lt;version&gt;${spring.version}&lt;/version&gt;        &lt;/dependency&gt;        &lt;dependency&gt;            &lt;groupId&gt;org.springframework&lt;/groupId&gt;            &lt;artifactId&gt;spring-jdbc&lt;/artifactId&gt;            &lt;version&gt;${spring.version}&lt;/version&gt;        &lt;/dependency&gt;        &lt;dependency&gt;            &lt;groupId&gt;org.springframework&lt;/groupId&gt;            &lt;artifactId&gt;spring-aspects&lt;/artifactId&gt;            &lt;version&gt;${spring.version}&lt;/version&gt;        &lt;/dependency&gt;        &lt;dependency&gt;            &lt;groupId&gt;org.springframework&lt;/groupId&gt;            &lt;artifactId&gt;spring-jms&lt;/artifactId&gt;            &lt;version&gt;${spring.version}&lt;/version&gt;        &lt;/dependency&gt;        &lt;dependency&gt;            &lt;groupId&gt;org.springframework&lt;/groupId&gt;            &lt;artifactId&gt;spring-context-support&lt;/artifactId&gt;            &lt;version&gt;${spring.version}&lt;/version&gt;        &lt;/dependency&gt;            &lt;!-- dubbo相关 --&gt;        &lt;dependency&gt;            &lt;groupId&gt;com.alibaba&lt;/groupId&gt;            &lt;artifactId&gt;dubbo&lt;/artifactId&gt;            &lt;version&gt;2.8.4&lt;/version&gt;                    &lt;/dependency&gt;        &lt;dependency&gt;            &lt;groupId&gt;org.apache.zookeeper&lt;/groupId&gt;            &lt;artifactId&gt;zookeeper&lt;/artifactId&gt;            &lt;version&gt;3.4.6&lt;/version&gt;        &lt;/dependency&gt;        &lt;dependency&gt;            &lt;groupId&gt;com.github.sgroschupf&lt;/groupId&gt;            &lt;artifactId&gt;zkclient&lt;/artifactId&gt;            &lt;version&gt;0.1&lt;/version&gt;        &lt;/dependency&gt;                &lt;dependency&gt;            &lt;groupId&gt;javassist&lt;/groupId&gt;            &lt;artifactId&gt;javassist&lt;/artifactId&gt;            &lt;version&gt;3.11.0.GA&lt;/version&gt;        &lt;/dependency&gt;            &lt;/dependencies&gt;   &lt;build&gt;        &lt;plugins&gt;          &lt;plugin&gt;                &lt;groupId&gt;org.apache.maven.plugins&lt;/groupId&gt;                &lt;artifactId&gt;maven-compiler-plugin&lt;/artifactId&gt;                &lt;version&gt;2.3.2&lt;/version&gt;                &lt;configuration&gt;                    &lt;source&gt;1.7&lt;/source&gt;                    &lt;target&gt;1.7&lt;/target&gt;                &lt;/configuration&gt;            &lt;/plugin&gt;            &lt;plugin&gt;                &lt;groupId&gt;org.apache.tomcat.maven&lt;/groupId&gt;                &lt;artifactId&gt;tomcat7-maven-plugin&lt;/artifactId&gt;                &lt;configuration&gt;                    &lt;!-- 指定端口 --&gt;                    &lt;port&gt;8081&lt;/port&gt;                    &lt;!-- 请求路径 --&gt;                    &lt;path&gt;/&lt;/path&gt;                &lt;/configuration&gt;            &lt;/plugin&gt;      &lt;/plugins&gt;      &lt;/build&gt;&lt;/project&gt;</code></pre><p>（2）在工程的webapps下创建WEB-INF文件夹，创建web.xml</p><pre><code>&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;web-app xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;    xmlns=&quot;http://java.sun.com/xml/ns/javaee&quot;    xsi:schemaLocation=&quot;http://java.sun.com/xml/ns/javaee http://java.sun.com/xml/ns/javaee/web-app_2_5.xsd&quot;    version=&quot;2.5&quot;&gt;        &lt;!-- 加载spring容器 --&gt;    &lt;context-param&gt;        &lt;param-name&gt;contextConfigLocation&lt;/param-name&gt;        &lt;param-value&gt;classpath:applicationContext*.xml&lt;/param-value&gt;    &lt;/context-param&gt;    &lt;listener&gt;        &lt;listener-class&gt;org.springframework.web.context.ContextLoaderListener&lt;/listener-class&gt;    &lt;/listener&gt;    &lt;/web-app&gt;</code></pre><p>（3）创建业务接口<br>创建包cn.lxm.dubbodemo.service，用于存放业务接口，创建接口</p><pre><code>package cn.lxm.dubbodemo.service;/** * 业务接口 * @author Administrator * */public interface UserService {        public String getName();    }</code></pre><p>（4）创建业务实现类<br>创建包cn.lxm.dubbodemo.service.impl ，用于存放业务实现类。创建业务实现类：</p><pre><code>package cn.lxm.dubbodemo.service.impl;import com.alibaba.dubbo.config.annotation.Service;import cn.lxm.dubbodemo.service.UserService;@Servicepublic class UserServiceImpl implements UserService {    public String getName() {                return &quot;lxm&quot;;    }}</code></pre><p>注意：Service注解与原来不同，需要引入com.alibaba包下的</p><p>（5）编写配置文件<br>在src/main/resources下创建applicationContext-service.xml ,内容如下：</p><pre><code>&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot;    xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xmlns:p=&quot;http://www.springframework.org/schema/p&quot;    xmlns:context=&quot;http://www.springframework.org/schema/context&quot;    xmlns:dubbo=&quot;http://code.alibabatech.com/schema/dubbo&quot; xmlns:mvc=&quot;http://www.springframework.org/schema/mvc&quot;    xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd        http://www.springframework.org/schema/mvc http://www.springframework.org/schema/mvc/spring-mvc.xsd        http://code.alibabatech.com/schema/dubbo http://code.alibabatech.com/schema/dubbo/dubbo.xsd        http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context.xsd&quot;&gt;    &lt;dubbo:application name=&quot;dubboxdemo-service&quot;/&gt;  &lt;dubbo:registry address=&quot;zookeeper://192.168.25.132:2181&quot;/&gt; &lt;dubbo:annotation package=&quot;cn.lxm.dubboxdemo.service&quot; /&gt; &lt;/beans&gt;</code></pre><p>注意：dubbo:annotation用于扫描@Service注解。</p><h3 id="服务消费者开发"><a href="#服务消费者开发" class="headerlink" title="服务消费者开发"></a>服务消费者开发</h3><p>开发步骤：</p><p>（1）创建Maven工程（WAR）dubboxdemo-web ，在pom.xml引入依赖 ，同“dubboxdemo-service”工程。区别就是把tomcat插件的运行端口改为8082 。</p><p>（2）在webapps目录下创建WEB-INF 目录，并创建web.xml </p><pre><code>&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;web-app xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;    xmlns=&quot;http://java.sun.com/xml/ns/javaee&quot;    xsi:schemaLocation=&quot;http://java.sun.com/xml/ns/javaee http://java.sun.com/xml/ns/javaee/web-app_2_5.xsd&quot;    version=&quot;2.5&quot;&gt;       &lt;!-- 解决post乱码 --&gt;    &lt;filter&gt;        &lt;filter-name&gt;CharacterEncodingFilter&lt;/filter-name&gt;        &lt;filter-class&gt;org.springframework.web.filter.CharacterEncodingFilter&lt;/filter-class&gt;        &lt;init-param&gt;            &lt;param-name&gt;encoding&lt;/param-name&gt;            &lt;param-value&gt;utf-8&lt;/param-value&gt;        &lt;/init-param&gt;        &lt;init-param&gt;              &lt;param-name&gt;forceEncoding&lt;/param-name&gt;              &lt;param-value&gt;true&lt;/param-value&gt;          &lt;/init-param&gt;      &lt;/filter&gt;    &lt;filter-mapping&gt;        &lt;filter-name&gt;CharacterEncodingFilter&lt;/filter-name&gt;        &lt;url-pattern&gt;/*&lt;/url-pattern&gt;    &lt;/filter-mapping&gt;          &lt;servlet&gt;      &lt;servlet-name&gt;springmvc&lt;/servlet-name&gt;      &lt;servlet-class&gt;org.springframework.web.servlet.DispatcherServlet&lt;/servlet-class&gt;      &lt;!-- 指定加载的配置文件 ，通过参数contextConfigLocation加载--&gt;      &lt;init-param&gt;          &lt;param-name&gt;contextConfigLocation&lt;/param-name&gt;          &lt;param-value&gt;classpath:applicationContext-web.xml&lt;/param-value&gt;      &lt;/init-param&gt;  &lt;/servlet&gt;    &lt;servlet-mapping&gt;      &lt;servlet-name&gt;springmvc&lt;/servlet-name&gt;      &lt;url-pattern&gt;*.do&lt;/url-pattern&gt;  &lt;/servlet-mapping&gt;&lt;/web-app&gt;</code></pre><p>（3）拷贝业务接口<br>将“dubboxdemo-service”工程的cn.lxm.dubboxdemo.service 包以及下面的接口拷贝至此工程。</p><p>（4）编写Controller </p><pre><code>package cn.lxm.dubboxdemo.controller;import org.springframework.beans.factory.annotation.Autowired;import org.springframework.stereotype.Controller;import org.springframework.web.bind.annotation.RequestMapping;import org.springframework.web.bind.annotation.ResponseBody;import cn.lxm.dubbodemo.service.UserService;@Controller@RequestMapping(&quot;/user&quot;)public class UserController {    @Reference    private UserService userService;        @RequestMapping(&quot;/showName&quot;)    @ResponseBody    public String showName(){        return userService.getName();    }        }</code></pre><p>（5）编写spring配置文件<br>在src/main/resources下创建applicationContext-web.xml  </p><pre><code>&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot;    xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xmlns:p=&quot;http://www.springframework.org/schema/p&quot;    xmlns:context=&quot;http://www.springframework.org/schema/context&quot;    xmlns:dubbo=&quot;http://code.alibabatech.com/schema/dubbo&quot; xmlns:mvc=&quot;http://www.springframework.org/schema/mvc&quot;    xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd        http://www.springframework.org/schema/mvc http://www.springframework.org/schema/mvc/spring-mvc.xsd        http://code.alibabatech.com/schema/dubbo http://code.alibabatech.com/schema/dubbo/dubbo.xsd        http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context.xsd&quot;&gt;    &lt;mvc:annotation-driven &gt;        &lt;mvc:message-converters register-defaults=&quot;false&quot;&gt;            &lt;bean class=&quot;org.springframework.http.converter.StringHttpMessageConverter&quot;&gt;                  &lt;constructor-arg value=&quot;UTF-8&quot; /&gt;            &lt;/bean&gt;          &lt;/mvc:message-converters&gt;        &lt;/mvc:annotation-driven&gt;    &lt;!-- 引用dubbo 服务 --&gt;    &lt;dubbo:application name=&quot;dubboxdemo-web&quot; /&gt;    &lt;dubbo:registry address=&quot;zookeeper://192.168.25.132:2181&quot;/&gt;     &lt;dubbo:annotation package=&quot;cn.lxm.dubboxdemo.controller&quot; /&gt;&lt;/beans&gt;</code></pre><p>（6）测试运行</p><p>tomcat7:run<br>在浏览器输入<a href="http://localhost:8082/user/showName.do，查看浏览器输出结果" target="_blank" rel="noopener">http://localhost:8082/user/showName.do，查看浏览器输出结果</a></p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;Dubbox框架&quot;&gt;&lt;a href=&quot;#Dubbox框架&quot; class=&quot;headerlink&quot; title=&quot;Dubbox框架&quot;&gt;&lt;/a&gt;Dubbox框架&lt;/h1&gt;&lt;h2 id=&quot;Dubbox简介&quot;&gt;&lt;a href=&quot;#Dubbox简介&quot; class=&quot;headerlink&quot; title=&quot;Dubbox简介&quot;&gt;&lt;/a&gt;Dubbox简介&lt;/h2&gt;&lt;p&gt;Dubbox 是一个&lt;strong&gt;分布式服务框架&lt;/strong&gt;，其前身是阿里巴巴开源项目Dubbo ，被国内电商及互联网项目中使用，后期阿里巴巴停止了该项目的维护，当当网便在Dubbo基础上进行优化，并继续维护，为了与原有的Dubbo区分，故将其命名为Dubbox。&lt;br&gt;
    
    </summary>
    
      <category term="java" scheme="http://www.fashionkillyou.xyz/categories/java/"/>
    
    
      <category term="Dubbox" scheme="http://www.fashionkillyou.xyz/tags/Dubbox/"/>
    
      <category term="分布式服务框架" scheme="http://www.fashionkillyou.xyz/tags/%E5%88%86%E5%B8%83%E5%BC%8F%E6%9C%8D%E5%8A%A1%E6%A1%86%E6%9E%B6/"/>
    
      <category term="Dubbo" scheme="http://www.fashionkillyou.xyz/tags/Dubbo/"/>
    
  </entry>
  
  <entry>
    <title>Lucene全文检索入门</title>
    <link href="http://www.fashionkillyou.xyz/2018/03/03/Lucene%E5%85%A8%E6%96%87%E6%A3%80%E7%B4%A2%E5%85%A5%E9%97%A8/"/>
    <id>http://www.fashionkillyou.xyz/2018/03/03/Lucene全文检索入门/</id>
    <published>2018-03-03T13:02:41.000Z</published>
    <updated>2018-03-17T16:21:20.427Z</updated>
    
    <content type="html"><![CDATA[<script src="\assets\js\APlayer.min.js"> </script><p>#Lucene概述</p><h2 id="什么是Lucene"><a href="#什么是Lucene" class="headerlink" title="什么是Lucene"></a>什么是Lucene</h2><ul><li><p>Lucene是一套用于全文检索和搜寻的开源程序库，由Apache软件基金会支持和提供</p></li><li><p>Lucene提供了一个简单却强大的应用程序接口（API），能够做全文索引和搜寻，在Java开发环境里Lucene是一个成熟的免费开放源代码工具</p></li><li><p>Lucene并不是现成的搜索引擎产品，但可以用来制作搜索引擎产品</p></li><li><p>官网：<a href="http://lucene.apache.org/" target="_blank" rel="noopener">http://lucene.apache.org/</a></p></li></ul><p># </p><p>待更新…</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;script src=&quot;\assets\js\APlayer.min.js&quot;&gt; &lt;/script&gt;&lt;p&gt;#Lucene概述&lt;/p&gt;
&lt;h2 id=&quot;什么是Lucene&quot;&gt;&lt;a href=&quot;#什么是Lucene&quot; class=&quot;headerlink&quot; title=&quot;什么是Luce
      
    
    </summary>
    
      <category term="搜索解决方案" scheme="http://www.fashionkillyou.xyz/categories/%E6%90%9C%E7%B4%A2%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88/"/>
    
    
      <category term="Lucene" scheme="http://www.fashionkillyou.xyz/tags/Lucene/"/>
    
      <category term="全文检索" scheme="http://www.fashionkillyou.xyz/tags/%E5%85%A8%E6%96%87%E6%A3%80%E7%B4%A2/"/>
    
  </entry>
  
  <entry>
    <title>使用formfill.js快速填充表单</title>
    <link href="http://www.fashionkillyou.xyz/2018/03/02/%E4%BD%BF%E7%94%A8formfill-js%E5%BF%AB%E9%80%9F%E5%A1%AB%E5%85%85%E8%A1%A8%E5%8D%95/"/>
    <id>http://www.fashionkillyou.xyz/2018/03/02/使用formfill-js快速填充表单/</id>
    <published>2018-03-02T13:26:17.000Z</published>
    <updated>2018-03-02T16:12:15.573Z</updated>
    
    <content type="html"><![CDATA[<script src="\assets\js\APlayer.min.js"> </script><h1 id="form表单的快速回显"><a href="#form表单的快速回显" class="headerlink" title="form表单的快速回显"></a>form表单的快速回显</h1><p>做项目开发的时候在写修改的页面时,如果字段很多的话,数据回显塞值挺麻烦的,所以最近找了一个formfill.js快速填充表单的js</p><p>使用起来很简单,首先引用js文件<br><a id="more"></a><br>百度云盘下载:</p><p>链接：<a href="https://pan.baidu.com/s/1mjSDRtA" target="_blank" rel="noopener">https://pan.baidu.com/s/1mjSDRtA</a></p><p>密码：5ljt</p><pre><code>&lt;script src=&quot;../js/jquery.formautofill.js&quot;&gt;&lt;/script&gt;</code></pre><p>使用:</p><pre><code>var data = {&quot;name&quot;:&quot;haha&quot;,&quot;password&quot;:&quot;123&quot;}$(&quot;#formId&quot;).autofill(data);</code></pre><h1 id="英文解释"><a href="#英文解释" class="headerlink" title="英文解释:"></a>英文解释:</h1><h1 id="jQuery-form-autofill"><a href="#jQuery-form-autofill" class="headerlink" title="jQuery form autofill"></a>jQuery form autofill</h1><p>jQuery plugin to simply autofill an empty form with data.</p><h2 id="Documentation"><a href="#Documentation" class="headerlink" title="Documentation"></a>Documentation</h2><p><a href="http://labs.creative-area.net/jquery.formautofill/doc/" target="_blank" rel="noopener">See complete documentation and demo</a></p><h2 id="Usage"><a href="#Usage" class="headerlink" title="Usage"></a>Usage</h2><p>You have a <strong>form</strong></p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">form</span> <span class="attr">id</span>=<span class="string">"f"</span>&gt;</span></span><br><span class="line">    name <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"text"</span> <span class="attr">name</span>=<span class="string">"name"</span>&gt;</span></span><br><span class="line">    email <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"text"</span> <span class="attr">name</span>=<span class="string">"email"</span>&gt;</span></span><br><span class="line">    love jQuery</span><br><span class="line">    <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"radio"</span> <span class="attr">name</span>=<span class="string">"lovejquery"</span> <span class="attr">value</span>=<span class="string">"yes"</span>&gt;</span> yes</span><br><span class="line">    <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"radio"</span> <span class="attr">name</span>=<span class="string">"lovejquery"</span> <span class="attr">value</span>=<span class="string">"no"</span>&gt;</span> no</span><br><span class="line"><span class="tag">&lt;/<span class="name">form</span>&gt;</span></span><br></pre></td></tr></table></figure><p>And <strong>data</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> data = &#123;</span><br><span class="line">    <span class="string">"name"</span>: <span class="string">"John Doe"</span>,</span><br><span class="line">    <span class="string">"email"</span>: <span class="string">"johndoe@mail.com"</span>,</span><br><span class="line">    <span class="string">"lovejquery"</span>: <span class="string">"yes"</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>Autofill</strong> the form with data ? just do</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$(<span class="string">"#f"</span>).autofill( data );</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;form表单的快速回显&quot;&gt;&lt;a href=&quot;#form表单的快速回显&quot; class=&quot;headerlink&quot; title=&quot;form表单的快速回显&quot;&gt;&lt;/a&gt;form表单的快速回显&lt;/h1&gt;&lt;p&gt;做项目开发的时候在写修改的页面时,如果字段很多的话,数据回显塞值挺麻烦的,所以最近找了一个formfill.js快速填充表单的js&lt;/p&gt;
&lt;p&gt;使用起来很简单,首先引用js文件&lt;br&gt;
    
    </summary>
    
      <category term="前端" scheme="http://www.fashionkillyou.xyz/categories/%E5%89%8D%E7%AB%AF/"/>
    
    
      <category term="jquery" scheme="http://www.fashionkillyou.xyz/tags/jquery/"/>
    
      <category term="formautofill" scheme="http://www.fashionkillyou.xyz/tags/formautofill/"/>
    
  </entry>
  
  <entry>
    <title>SpringMVC架构入门二</title>
    <link href="http://www.fashionkillyou.xyz/2018/03/01/SpringMVC%E6%9E%B6%E6%9E%84%E5%85%A5%E9%97%A8%E4%BA%8C/"/>
    <id>http://www.fashionkillyou.xyz/2018/03/01/SpringMVC架构入门二/</id>
    <published>2018-02-28T16:10:20.000Z</published>
    <updated>2018-03-16T04:01:45.057Z</updated>
    
    <content type="html"><![CDATA[<script src="\assets\js\APlayer.min.js"> </script><h1 id="高级参数绑定"><a href="#高级参数绑定" class="headerlink" title="高级参数绑定"></a>高级参数绑定</h1><h2 id="绑定数组"><a href="#绑定数组" class="headerlink" title="绑定数组"></a>绑定数组</h2><p>Controller方法中可以用String[]接收，或者pojo的String[]属性接收。两种方式任选其一即可。<br><a id="more"></a><br>使用String[]:</p><pre><code>@RequestMapping(&quot;/queryitem&quot;)public String queryItem(Query queryVo, String[] ids) {    System.out.println(queryVo.getItems().getName());    System.out.println(queryVo.getItems().getPrice());    System.out.println(ids.toString());    return null;}</code></pre><p>pojo的String[]:</p><pre><code>public class Query{    private Items items;    private String[] ids;    get/set...}</code></pre><h2 id="将表单的数据绑定到List"><a href="#将表单的数据绑定到List" class="headerlink" title="将表单的数据绑定到List"></a>将表单的数据绑定到List</h2><p>List中存放对象，并将定义的List放在包装类中，使用包装pojo对象接收。</p><pre><code>public class Query{    private Items items;    private String[] ids;    private List&lt;Items&gt; itemList;    get/set...}</code></pre><p>jsp页面:</p><pre><code>&lt;tr&gt;    &lt;td&gt;        &lt;input type=&quot;text&quot; name=&quot; itemsList[0].id&quot; value=&quot;${item.id}&quot;/&gt;    &lt;/td&gt;    &lt;td&gt;        &lt;input type=&quot;text&quot; name=&quot; itemsList[0].name&quot; value=&quot;${item.name }&quot;/&gt;    &lt;/td&gt;    &lt;td&gt;        &lt;input type=&quot;text&quot; name=&quot; itemsList[0].price&quot; value=&quot;${item.price}&quot;/&gt;    &lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;    &lt;td&gt;        &lt;input type=&quot;text&quot; name=&quot; itemsList[1].id&quot; value=&quot;${item.id}&quot;/&gt;    &lt;/td&gt;    &lt;td&gt;        &lt;input type=&quot;text&quot; name=&quot; itemsList[1].name&quot; value=&quot;${item.name }&quot;/&gt;    &lt;/td&gt;    &lt;td&gt;        &lt;input type=&quot;text&quot; name=&quot; itemsList[1].price&quot; value=&quot;${item.price}&quot;/&gt;    &lt;/td&gt;&lt;/tr&gt;</code></pre><p>Name属性必须是包装pojo的list属性+下标+元素属性。</p><p>Jsp做如下改造：</p><pre><code>&lt;c:forEach items=&quot;${itemList }&quot; var=&quot;item&quot;&gt;&lt;tr&gt;    &lt;td&gt;        &lt;input name=&quot;ids&quot; value=&quot;${item.id}&quot; type=&quot;checkbox&quot;&gt;&lt;/td&gt;    &lt;td&gt;        &lt;input name=&quot;id&quot; value=&quot;${item.id}&quot; type=&quot;hidden&quot;&gt;        &lt;input name=&quot;name&quot; value=&quot;${item.name }&quot; type=&quot;text&quot;&gt;    &lt;/td&gt;    &lt;td&gt;        &lt;input name=&quot;name&quot; value=&quot;${item.price }&quot; type=&quot;text&quot;&gt;&lt;/td&gt;    &lt;td&gt;        &lt;input name=&quot;name&quot; value=&quot;&lt;fmt:formatDate value=&quot;${item.createtime}&quot; pattern=&quot;yyyy-MM-dd HH:mm:ss&quot;/&gt;&quot; type=&quot;text&quot;&gt;&lt;/td&gt;    &lt;td&gt;        &lt;input name=&quot;name&quot; value=&quot;${item.detail }&quot; type=&quot;text&quot;&gt;&lt;/td&gt;    &lt;td&gt;        &lt;a href=&quot;${pageContext.request.contextPath }/itemEdit.action?id=${item.id}&quot;&gt;修改&lt;/a&gt;    &lt;/td&gt;&lt;/tr&gt;&lt;/c:forEach&gt;</code></pre><p>varStatus属性常用参数总结下：</p><pre><code>${status.index}      输出行号，从0开始。${status.count}      输出行号，从1开始。${status.current}   当前这次迭代的（集合中的）项${status.first}  判断当前项是否为集合中的第一项，返回值为true或false${status.last}   判断当前项是否为集合中的最后一项，返回值为true或falsebegin、end、step分别表示：起始序号，结束序号，跳跃步伐。</code></pre><p>Contrller</p><pre><code>@RequestMapping(&quot;/queryitem&quot;)public String queryItem(QueryVo queryVo, String[] ids) {    System.out.println(queryVo.getItems().getName());    System.out.println(queryVo.getItems().getPrice());    System.out.println(ids.toString());    return null;}</code></pre><p>注意：接收List类型的数据必须是pojo的属性，方法的形参为List类型无法正确接收到数据。</p><h1 id="RequestMapping"><a href="#RequestMapping" class="headerlink" title="@RequestMapping"></a>@RequestMapping</h1><p>通过RequestMapping注解可以定义不同的处理器映射规则。</p><h2 id="URL路径映射"><a href="#URL路径映射" class="headerlink" title="URL路径映射"></a>URL路径映射</h2><p>@RequestMapping(value=”/item”)或@RequestMapping(“/item）<br>value的值是数组，可以将多个url映射到同一个方法</p><h2 id="窄化请求映射"><a href="#窄化请求映射" class="headerlink" title="窄化请求映射"></a>窄化请求映射</h2><p>在class上添加@RequestMapping(url)指定通用请求前缀， 限制此类下的所有方法请求url必须以请求前缀开头，通过此方法对url进行分类管理。</p><p>如下：</p><pre><code>@RequestMapping放在类名上边，设置请求前缀 @Controller@RequestMapping(&quot;/item&quot;)</code></pre><p>方法名上边设置请求映射url：</p><pre><code>@RequestMapping放在方法名上边，如下：@RequestMapping(&quot;/queryItem &quot;)</code></pre><p>访问地址为：/item/queryItem</p><h2 id="请求方法限定"><a href="#请求方法限定" class="headerlink" title="请求方法限定"></a>请求方法限定</h2><h3 id="限定GET方法"><a href="#限定GET方法" class="headerlink" title="限定GET方法"></a>限定GET方法</h3><pre><code>@RequestMapping(method = RequestMethod.GET)</code></pre><p>如果通过Post访问则报错：<br>HTTP Status 405 - Request method ‘POST’ not supported</p><p>例如：</p><pre><code>@RequestMapping(value=&quot;/editItem&quot;,method=RequestMethod.GET)</code></pre><h3 id="限定POST方法"><a href="#限定POST方法" class="headerlink" title="限定POST方法"></a>限定POST方法</h3><pre><code>@RequestMapping(method = RequestMethod.POST)</code></pre><p>如果通过Post访问则报错：<br>HTTP Status 405 - Request method ‘GET’ not supported</p><h3 id="GET和POST都可以"><a href="#GET和POST都可以" class="headerlink" title="GET和POST都可以"></a>GET和POST都可以</h3><pre><code>@RequestMapping(method={RequestMethod.GET,RequestMethod.POST})</code></pre><h1 id="controller方法返回值"><a href="#controller方法返回值" class="headerlink" title="controller方法返回值"></a>controller方法返回值</h1><h2 id="返回ModelAndView"><a href="#返回ModelAndView" class="headerlink" title="返回ModelAndView"></a>返回ModelAndView</h2><p>controller方法中定义ModelAndView对象并返回，对象中可添加model数据、指定view。</p><h2 id="返回void"><a href="#返回void" class="headerlink" title="返回void"></a>返回void</h2><p>在controller方法形参上可以定义request和response，使用request或response指定响应结果：</p><p>1、使用request转向页面，如下：</p><pre><code>request.getRequestDispatcher(&quot;页面路径&quot;).forward(request, response);</code></pre><p>2、也可以通过response页面重定向：</p><pre><code>response.sendRedirect(&quot;url&quot;)</code></pre><p>3、也可以通过response指定响应结果，例如响应json数据如下：</p><pre><code>response.setCharacterEncoding(&quot;utf-8&quot;);response.setContentType(&quot;application/json;charset=utf-8&quot;);response.getWriter().write(&quot;json串&quot;);</code></pre><h2 id="返回字符串"><a href="#返回字符串" class="headerlink" title="返回字符串"></a>返回字符串</h2><h3 id="逻辑视图名"><a href="#逻辑视图名" class="headerlink" title="逻辑视图名"></a>逻辑视图名</h3><p>controller方法返回字符串可以指定逻辑视图名，通过视图解析器解析为物理视图地址。</p><pre><code>//指定逻辑视图名，经过视图解析器解析为jsp物理路径：/WEB-INF/jsp/item/editItem.jspreturn &quot;item/editItem&quot;;</code></pre><h3 id="Redirect重定向"><a href="#Redirect重定向" class="headerlink" title="Redirect重定向"></a>Redirect重定向</h3><p>Contrller方法返回结果重定向到一个url地址，如下商品修改提交后重定向到商品查询方法，参数无法带到商品查询方法中。</p><pre><code>//重定向到queryItem.action地址,request无法带过去return &quot;redirect:queryItem.action&quot;;</code></pre><p>redirect方式相当于“response.sendRedirect()”，转发后浏览器的地址栏变为转发后的地址，因为转发即执行了一个新的request和response。<br>由于新发起一个request原来的参数在转发时就不能传递到下一个url，如果要传参数可以/item/queryItem.action后边加参数，如下：</p><pre><code>/item/queryItem?...&amp;…..</code></pre><p>如果使用了model的话,他会自动给你拼接数据,就是自动在后面拼接?</p><h3 id="forward转发"><a href="#forward转发" class="headerlink" title="forward转发"></a>forward转发</h3><p>controller方法执行后继续执行另一个controller方法，如下商品修改提交后转向到商品修改页面，修改商品的id参数可以带到商品修改方法中。</p><pre><code>//结果转发到editItem.action，request可以带过去return &quot;forward:editItem.action&quot;;</code></pre><p>forward方式相当于“request.getRequestDispatcher().forward(request,response)”，转发后浏览器地址栏还是原来的地址。转发并没有执行新的request和response，而是和转发前的请求共用一个request和response。所以转发前请求的参数在转发后仍然可以读取到。</p><h1 id="异常处理器"><a href="#异常处理器" class="headerlink" title="异常处理器"></a>异常处理器</h1><p>springmvc在处理请求过程中出现异常信息交由异常处理器进行处理，自定义异常处理器可以实现一个系统的异常处理逻辑。</p><h2 id="异常处理思路"><a href="#异常处理思路" class="headerlink" title="异常处理思路"></a>异常处理思路</h2><p>系统中异常包括两类：预期异常和运行时异常RuntimeException，前者通过捕获异常从而获取异常信息，后者主要通过规范代码开发、测试通过手段减少运行时异常的发生。</p><p>系统的dao、service、controller出现都通过throws Exception向上抛出，最后由springmvc前端控制器交由异常处理器进行异常处理</p><p>步骤:写异常处理器类,然后在springmvc.xml中配置,然后写异常错误页面</p><h2 id="自定义异常处理器"><a href="#自定义异常处理器" class="headerlink" title="自定义异常处理器"></a>自定义异常处理器</h2><pre><code>public class CustomExceptionResolver implements HandlerExceptionResolver {    @Override    public ModelAndView resolveException(HttpServletRequest request,            HttpServletResponse response, Object handler, Exception ex) {        ex.printStackTrace();        CustomException customException = null;        //如果抛出的是系统自定义异常则直接转换        if(ex instanceof CustomException){            customException = (CustomException)ex;        }else{            //如果抛出的不是系统自定义异常则重新构造一个系统错误异常。            customException = new CustomException(&quot;系统错误，请与系统管理 员联系！&quot;);        }        ModelAndView modelAndView = new ModelAndView();        modelAndView.addObject(&quot;message&quot;, customException.getMessage());        modelAndView.setViewName(&quot;error&quot;);        return modelAndView;    }}</code></pre><p>###取异常堆栈：</p><pre><code>//错误信息存储在堆栈中,取异常堆栈将其显示在控制台上,或输出到日志文件中       try {        } catch (Exception e) {            StringWriter s = new StringWriter();            PrintWriter printWriter = new PrintWriter(s);            e.printStackTrace(printWriter);            s.toString();        }</code></pre><h2 id="错误页面"><a href="#错误页面" class="headerlink" title="错误页面"></a>错误页面</h2><pre><code>&lt;%@ page language=&quot;java&quot; contentType=&quot;text/html; charset=UTF-8&quot;    pageEncoding=&quot;UTF-8&quot;%&gt;&lt;%@ taglib uri=&quot;http://java.sun.com/jsp/jstl/core&quot; prefix=&quot;c&quot; %&gt;&lt;%@ taglib uri=&quot;http://java.sun.com/jsp/jstl/fmt&quot;  prefix=&quot;fmt&quot;%&gt; &lt;!DOCTYPE html PUBLIC &quot;-//W3C//DTD HTML 4.01 Transitional//EN&quot; &quot;http://www.w3.org/TR/html4/loose.dtd&quot;&gt;&lt;html&gt;&lt;head&gt;&lt;meta http-equiv=&quot;Content-Type&quot; content=&quot;text/html; charset=UTF-8&quot;&gt;&lt;title&gt;错误页面&lt;/title&gt;&lt;/head&gt;&lt;body&gt;您的操作出现错误如下：&lt;br/&gt;${message }&lt;/body&gt;&lt;/html&gt;</code></pre><h2 id="异常处理器配置"><a href="#异常处理器配置" class="headerlink" title="异常处理器配置"></a>异常处理器配置</h2><p>在springmvc.xml中添加：</p><pre><code>&lt;!-- 全局异常处理器 --&gt;&lt;bean class=&quot;com.lxm.springmvc.exception.GlobalExceptionResolver&quot;/&gt;</code></pre><h2 id="测试异常"><a href="#测试异常" class="headerlink" title="测试异常"></a>测试异常</h2><p>在需要抛出异常的地方加上throw new CustomerException(“出错信息”);然后方法上向上抛出就可以了</p><pre><code>@RequestMapping(&quot;/itemEdit&quot;)public String getEditItem(@RequestParam(value=&quot;id&quot;,required=true)Integer id,Model model) throws CustomerException{    Items items = itemService.getItemById(id);    if(items == null){        throw new CustomerException(&quot;商品信息不存在!&quot;);    }    model.addAttribute(&quot;item&quot;,items);    return &quot;editItem&quot;;}</code></pre><h1 id="上传图片"><a href="#上传图片" class="headerlink" title="上传图片"></a>上传图片</h1><h2 id="配置虚拟目录"><a href="#配置虚拟目录" class="headerlink" title="配置虚拟目录"></a>配置虚拟目录</h2><p>在tomcat上配置图片虚拟目录，在tomcat下conf/server.xml中添加：</p><pre><code>&lt;Context docBase=&quot;F:\develop\upload\temp&quot; path=&quot;/pic&quot; reloadable=&quot;false&quot;/&gt;</code></pre><p>访问<a href="http://localhost:8080/pic即可访问F:\develop\upload\temp下的图片。" target="_blank" rel="noopener">http://localhost:8080/pic即可访问F:\develop\upload\temp下的图片。</a></p><p>也可以通过eclipse配置：</p><p>1:在tomcat服务配置里面有个modules,<br>点击AddExternalWebModule</p><p>2:然后在Documentbase里面填写虚拟路径的绝对路径(例如:F:\develop\upload\temp),</p><p>3:在Path里面填写虚拟路径(例如:/pic)</p><p>4:AutoReload(这个根据需要自行设定,以下是作用,一般设置为disabled就可以)</p><pre><code>在eclipse中集成tomca来开发时,如果使用run as模式启动项目的话,tomcat配置Auto reloading enabled,我们修改java文件,项目会重新加载,修改的内容会生效.如果使用debug as 模式启动项目的话,tomcat不要配置Auto reloading enabled,我们修改的java文件,也会生效.注意:在debug模式下,tomcat配置了Auto reloading enabled,当修改了java文件,项目会报错.</code></pre><h2 id="jar包"><a href="#jar包" class="headerlink" title="jar包"></a>jar包</h2><p>CommonsMultipartResolver解析器依赖:</p><pre><code>commons-fileuploadcommons-io</code></pre><h2 id="配置解析器"><a href="#配置解析器" class="headerlink" title="配置解析器"></a>配置解析器</h2><p>springmvc.xml</p><pre><code>&lt;!-- 文件上传 --&gt;&lt;bean id=&quot;multipartResolver&quot;    class=&quot;org.springframework.web.multipart.commons.CommonsMultipartResolver&quot;&gt;    &lt;!-- 设置上传文件的最大尺寸为5MB --&gt;    &lt;property name=&quot;maxUploadSize&quot;&gt;        &lt;value&gt;5242880&lt;/value&gt;    &lt;/property&gt;&lt;/bean&gt;</code></pre><h2 id="图片上传"><a href="#图片上传" class="headerlink" title="图片上传"></a>图片上传</h2><p>controller：</p><pre><code>@RequestMapping(&quot;/updateitem&quot;)public String updateItem(Items items,MultipartFile pictureFile) throws Exception, IOException{    //把图片保存到图片目录下    //为每个文件生成一个新的文件名    String picName = UUID.randomUUID().toString();    //去文件的扩展名    String oriName = pictureFile.getOriginalFilename();    System.out.println(&quot;oriName&quot;+oriName);    if(oriName!=null &amp;&amp; oriName!=&quot;&quot;){        String extName = oriName.substring(oriName.lastIndexOf(&quot;.&quot;));        System.out.println(&quot;extName&quot;+extName);        //保存文件 d:\picture\temp        pictureFile.transferTo(new File(&quot;d:\\picture\\temp\\&quot;+picName+extName));        //把文件名保存到数据库        items.setPic(picName+extName);    }    itemService.updateItem(items);//        return &quot;forward:/itemList.action?items=&quot;+items;//转发是可以传递对象的    return &quot;forward:/itemList.action&quot;;}</code></pre><h2 id="页面："><a href="#页面：" class="headerlink" title="页面："></a>页面：</h2><pre><code>form添加enctype=&quot;multipart/form-data&quot;：&lt;form id=&quot;itemForm&quot;action=&quot;${pageContext.request.contextPath }/item/editItemSubmit.action&quot;    method=&quot;post&quot; enctype=&quot;multipart/form-data&quot;&gt;    &lt;input type=&quot;hidden&quot; name=&quot;pic&quot; value=&quot;${item.pic }&quot; /&gt;file的name与controller形参一致：&lt;tr&gt;    &lt;td&gt;商品图片&lt;/td&gt;    &lt;td&gt;&lt;c:if test=&quot;${item.pic !=null}&quot;&gt;            &lt;img src=&quot;/pic/${item.pic}&quot; width=100 height=100 /&gt;            &lt;br /&gt;        &lt;/c:if&gt; &lt;input type=&quot;file&quot; name=&quot;pictureFile&quot; /&gt;&lt;/td&gt;&lt;/tr&gt;</code></pre><h1 id="json数据交互"><a href="#json数据交互" class="headerlink" title="json数据交互"></a>json数据交互</h1><h2 id="RequestBody"><a href="#RequestBody" class="headerlink" title="@RequestBody"></a>@RequestBody</h2><p>作用：</p><p>@RequestBody注解用于读取http请求的内容(字符串)，通过springmvc提供的HttpMessageConverter接口将读到的内容转换为json、xml等格式的数据并绑定到controller方法的参数上。</p><p>List.action?id=1&amp;name=zhangsan&amp;age=12</p><p>本例子应用：</p><p>@RequestBody注解实现接收http请求的json数据，将json数据转换为java对象</p><h2 id="ResponseBody"><a href="#ResponseBody" class="headerlink" title="@ResponseBody"></a>@ResponseBody</h2><p>作用：</p><p>该注解用于将Controller的方法返回的对象，通过HttpMessageConverter接口转换为指定格式的数据如：json,xml等，通过Response响应给客户端</p><p>本例子应用：</p><p>@ResponseBody注解实现将controller方法返回对象转换为json响应给客户端</p><h2 id="请求json，响应json实现："><a href="#请求json，响应json实现：" class="headerlink" title="请求json，响应json实现："></a>请求json，响应json实现：</h2><h3 id="环境准备"><a href="#环境准备" class="headerlink" title="环境准备"></a>环境准备</h3><p>Springmvc默认用MappingJacksonHttpMessageConverter对json数据进行转换，需要加入jackson的包，</p><pre><code>jackson-annotations-2.4.0.jarjackson-core-2.4.2.jarjackson-databind-2.4.2.jar</code></pre><h3 id="配置json转换器"><a href="#配置json转换器" class="headerlink" title="配置json转换器"></a>配置json转换器</h3><p>在注解适配器中加入messageConverters</p><pre><code>&lt;!--注解适配器 --&gt;&lt;bean class=&quot;org.springframework.web.servlet.mvc.method.annotation.RequestMappingHandlerAdapter&quot;&gt;    &lt;property name=&quot;messageConverters&quot;&gt;    &lt;list&gt;    &lt;bean class=&quot;org.springframework.http.converter.json.MappingJacksonHttpMessageConverter&quot;&gt;&lt;/bean&gt;    &lt;/list&gt;    &lt;/property&gt;&lt;/bean&gt;</code></pre><p>注意：如果使用<mvc:annotation-driven> 则不用定义上边的内容。</mvc:annotation-driven></p><h3 id="controller编写"><a href="#controller编写" class="headerlink" title="controller编写"></a>controller编写</h3><pre><code>// 商品修改提交json信息，响应json信息@RequestMapping(&quot;/editItemSubmit_RequestJson&quot;)public @ResponseBody Items editItemSubmit_RequestJson(@RequestBody Items items) throws Exception {    System.out.println(items);    //itemService.saveItem(items);    return items;}</code></pre><h3 id="页面js方法编写："><a href="#页面js方法编写：" class="headerlink" title="页面js方法编写："></a>页面js方法编写：</h3><p>引入 js：<br>    <script type="text/javascript" src="${pageContext.request.contextPath }/js/jquery-1.4.4.min.js"></script></p><pre><code>//请求json响应jsonfunction request_json(){    $.ajax({        type:&quot;post&quot;,        url:&quot;${pageContext.request.contextPath }/item/editItemSubmit_RequestJson.action&quot;,        contentType:&quot;application/json;charset=utf-8&quot;,        data:&apos;{&quot;name&quot;:&quot;测试商品&quot;,&quot;price&quot;:99.9}&apos;,        success:function(data){            alert(data);        }    });}</code></pre>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;高级参数绑定&quot;&gt;&lt;a href=&quot;#高级参数绑定&quot; class=&quot;headerlink&quot; title=&quot;高级参数绑定&quot;&gt;&lt;/a&gt;高级参数绑定&lt;/h1&gt;&lt;h2 id=&quot;绑定数组&quot;&gt;&lt;a href=&quot;#绑定数组&quot; class=&quot;headerlink&quot; title=&quot;绑定数组&quot;&gt;&lt;/a&gt;绑定数组&lt;/h2&gt;&lt;p&gt;Controller方法中可以用String[]接收，或者pojo的String[]属性接收。两种方式任选其一即可。&lt;br&gt;
    
    </summary>
    
      <category term="SSM" scheme="http://www.fashionkillyou.xyz/categories/SSM/"/>
    
    
      <category term="SpringMVC" scheme="http://www.fashionkillyou.xyz/tags/SpringMVC/"/>
    
      <category term="SpringWebMVC" scheme="http://www.fashionkillyou.xyz/tags/SpringWebMVC/"/>
    
  </entry>
  
  <entry>
    <title>SpringMVC架构入门一</title>
    <link href="http://www.fashionkillyou.xyz/2018/02/27/SpringMVC%E6%9E%B6%E6%9E%84%E5%85%A5%E9%97%A8%E4%B8%80/"/>
    <id>http://www.fashionkillyou.xyz/2018/02/27/SpringMVC架构入门一/</id>
    <published>2018-02-27T10:58:33.000Z</published>
    <updated>2018-03-16T04:01:31.022Z</updated>
    
    <content type="html"><![CDATA[<script src="\assets\js\APlayer.min.js"> </script><h1 id="SpringMVC架构"><a href="#SpringMVC架构" class="headerlink" title="SpringMVC架构"></a>SpringMVC架构</h1><p>Spring web mvc和Struts2都属于表现层的框架,它是Spring框架的一部分.</p><h2 id="架构流程"><a href="#架构流程" class="headerlink" title="架构流程"></a>架构流程</h2><pre><code>1、    用户发送请求至前端控制器DispatcherServlet2、    DispatcherServlet收到请求调用HandlerMapping处理器映射器。3、    处理器映射器根据请求url找到具体的处理器，生成处理器对象及处理器拦截器(如果有则生成)一并返回给DispatcherServlet。4、    DispatcherServlet通过HandlerAdapter处理器适配器调用处理器5、    执行处理器(Controller，也叫后端控制器)。6、    Controller执行完成返回ModelAndView7、    HandlerAdapter将controller执行结果ModelAndView返回给DispatcherServlet8、    DispatcherServlet将ModelAndView传给ViewReslover视图解析器9、    ViewReslover解析后返回具体View10、    DispatcherServlet对View进行渲染视图（即将模型数据填充至视图中）。11、    DispatcherServlet响应用户</code></pre><a id="more"></a><p><img src="http://p57l8frp4.bkt.clouddn.com/springmvc%E6%89%A7%E8%A1%8C%E6%B5%81%E7%A8%8B%E5%9B%BE2.jpg" alt=""></p><h2 id="组件说明"><a href="#组件说明" class="headerlink" title="组件说明"></a>组件说明</h2><p>以下组件通常使用框架提供实现：</p><ul><li><p>DispatcherServlet：前端控制器</p><p>  用户请求到达前端控制器，它就相当于mvc模式中的c，dispatcherServlet是整个流程控制的中心，由它调用其它组件处理用户的请求，dispatcherServlet的存在降低了组件之间的耦合性。</p></li><li><p>HandlerMapping：处理器映射器</p><p>  HandlerMapping负责根据用户请求找到Handler即处理器，springmvc提供了不同的映射器实现不同的映射方式，例如：配置文件方式，实现接口方式，注解方式等。</p></li><li><p>Handler：处理器</p><p>  Handler 是继DispatcherServlet前端控制器的后端控制器，在DispatcherServlet的控制下Handler对具体的用户请求进行处理。<br>  由于Handler涉及到具体的用户业务请求，所以一般情况需要程序员根据业务需求开发Handler。</p></li><li><p>HandlAdapter：处理器适配器</p><p>  通过HandlerAdapter对处理器进行执行，这是适配器模式的应用，通过扩展适配器可以对更多类型的处理器进行执行。</p></li><li><p>View Resolver：视图解析器</p><p>  View Resolver负责将处理结果生成View视图，View Resolver首先根据逻辑视图名解析成物理视图名即具体的页面地址，再生成View视图对象，最后对View进行渲染将处理结果通过页面展示给用户。 </p></li><li><p>View：视图</p><p>  springmvc框架提供了很多的View视图类型的支持，包括：jstlView、freemarkerView、pdfView等。我们最常用的视图就是jsp。<br>  一般情况下需要通过页面标签或页面模版技术将模型数据通过页面展示给用户，需要由程序员根据业务需求开发具体的页面。</p></li></ul><p>说明：在springmvc的各个组件中，<strong>处理器映射器</strong>、<strong>处理器适配器</strong>、<strong>视图解析器</strong>称为springmvc的三大组件。</p><p>需要用户开放的组件有<strong>handler、view</strong></p><h2 id="注解映射器和适配器"><a href="#注解映射器和适配器" class="headerlink" title="注解映射器和适配器"></a>注解映射器和适配器</h2><h3 id="组件扫描器"><a href="#组件扫描器" class="headerlink" title="组件扫描器"></a>组件扫描器</h3><p>使用组件扫描器省去在spring容器配置每个controller类的繁琐。使用<context:component-scan>自动扫描标记@controller的控制器类，配置如下：</context:component-scan></p><pre><code>&lt;!-- 扫描controller注解,多个包中间使用半角逗号分隔 --&gt;&lt;context:component-scan base-package=&quot;cn.lxm.springmvc.controller.first&quot;/&gt;</code></pre><h3 id="RequestMappingHandlerMapping"><a href="#RequestMappingHandlerMapping" class="headerlink" title="RequestMappingHandlerMapping"></a>RequestMappingHandlerMapping</h3><p>注解式处理器映射器，对类中标记@ResquestMapping的方法进行映射，根据ResquestMapping定义的url匹配ResquestMapping标记的方法，匹配成功返回HandlerMethod对象给前端控制器，HandlerMethod对象中封装url对应的方法Method。 </p><p>从spring3.1版本开始，废除了DefaultAnnotationHandlerMapping的使用，推荐使用RequestMappingHandlerMapping完成注解式处理器映射。</p><p>配置如下：</p><pre><code>&lt;!--注解映射器 --&gt;&lt;bean class=&quot;org.springframework.web.servlet.mvc.method.annotation.RequestMappingHandlerMapping&quot;/&gt;</code></pre><p>注解描述：<br>@RequestMapping：定义请求url到处理器功能方法的映射</p><h3 id="RequestMappingHandlerAdapter"><a href="#RequestMappingHandlerAdapter" class="headerlink" title="RequestMappingHandlerAdapter"></a>RequestMappingHandlerAdapter</h3><p>注解式处理器适配器，对标记@ResquestMapping的方法进行适配。</p><p>从spring3.1版本开始，废除了AnnotationMethodHandlerAdapter的使用，推荐使用RequestMappingHandlerAdapter完成注解式处理器适配。</p><p>配置如下：</p><pre><code>&lt;!--注解适配器 --&gt;&lt;bean class=&quot;org.springframework.web.servlet.mvc.method.annotation.RequestMappingHandlerAdapter&quot;/&gt;</code></pre><h3 id=""><a href="#" class="headerlink" title=""></a><mvc:annotation-driven></mvc:annotation-driven></h3><p>springmvc使用<mvc:annotation-driven>自动加载RequestMappingHandlerMapping和RequestMappingHandlerAdapter，可用在springmvc.xml配置文件中使用<mvc:annotation-driven>替代注解处理器和适配器的配置。</mvc:annotation-driven></mvc:annotation-driven></p><h2 id="视图解析器"><a href="#视图解析器" class="headerlink" title="视图解析器"></a>视图解析器</h2><p>在springmvc.xml文件配置如下：</p><pre><code>&lt;bean class=&quot;org.springframework.web.servlet.view.InternalResourceViewResolver&quot;&gt;    &lt;property name=&quot;viewClass&quot;        value=&quot;org.springframework.web.servlet.view.JstlView&quot; /&gt;    &lt;property name=&quot;prefix&quot; value=&quot;/WEB-INF/jsp/&quot; /&gt;    &lt;property name=&quot;suffix&quot; value=&quot;.jsp&quot; /&gt;&lt;/bean&gt;</code></pre><p>InternalResourceViewResolver：支持JSP视图解析</p><p>viewClass：JstlView表示JSP模板页面需要使用JSTL标签库，所以classpath中必须包含jstl的相关jar 包。此属性可以不设置，默认为JstlView。</p><p>prefix 和suffix：查找视图页面的前缀和后缀，最终视图的地址为：<br>前缀+逻辑视图名+后缀，逻辑视图名需要在controller中返回ModelAndView指定，比如逻辑视图名为hello，则最终返回的jsp视图地址 “WEB-INF/jsp/hello.jsp”</p><h1 id="整合mybatis"><a href="#整合mybatis" class="headerlink" title="整合mybatis"></a>整合mybatis</h1><p>ssm框架:springmvc + spring + mybatis</p><p>控制层采用springmvc、持久层使用mybatis实现。</p><h2 id="准备jar包"><a href="#准备jar包" class="headerlink" title="准备jar包"></a>准备jar包</h2><p>spring（包括springmvc）、mybatis、mybatis-spring整合包、数据库驱动、第三方连接池。</p><h2 id="整合思路"><a href="#整合思路" class="headerlink" title="整合思路"></a>整合思路</h2><h3 id="Dao层："><a href="#Dao层：" class="headerlink" title="Dao层："></a>Dao层：</h3><p>1、SqlMapConfig.xml</p><pre><code>空文件即可。需要文件头。</code></pre><p>2、applicationContext-dao.xml。</p><pre><code>a)    数据库连接池b)    SqlSessionFactory对象，需要spring和mybatis整合包下的。c)    配置mapper文件扫描器。</code></pre><h3 id="Service层："><a href="#Service层：" class="headerlink" title="Service层："></a>Service层：</h3><p>1、applicationContext-service.xml</p><pre><code>包扫描器，扫描@service注解的类。</code></pre><p>2、applicationContext-trans.xml</p><pre><code>配置事务。</code></pre><h3 id="表现层："><a href="#表现层：" class="headerlink" title="表现层："></a>表现层：</h3><p>Springmvc.xml</p><pre><code>1、包扫描器，扫描@Controller注解的类。2、配置注解驱动。3、视图解析器</code></pre><p>Web.xml</p><pre><code>配置前端控制器。</code></pre><h1 id="参数绑定"><a href="#参数绑定" class="headerlink" title="参数绑定"></a>参数绑定</h1><h2 id="Controller参数绑定"><a href="#Controller参数绑定" class="headerlink" title="Controller参数绑定"></a>Controller参数绑定</h2><p>要根据id查询商品数据，需要从请求的参数中把请求的id取出来。Id应该包含在Request对象中。可以从Request对象中取id。</p><pre><code>@RequestMapping(&quot;/itemEdit&quot;)public ModelAndView itemEdit(HttpServletRequest request) {    //从Request中取id    String strId = request.getParameter(&quot;id&quot;);    Integer id = null;    //如果id有值则转换成int类型    if (strId != null &amp;&amp; !&quot;&quot;.equals(strId)) {        id = new Integer(strId);    } else {        //出错        return null;    }    Items items = itemService.getItemById(id);    //创建ModelAndView    ModelAndView modelAndView = new ModelAndView();    //向jsp传递数据    modelAndView.addObject(&quot;item&quot;, items);    //设置跳转的jsp页面    modelAndView.setViewName(&quot;editItem&quot;);    return modelAndView;}</code></pre><p>如果想获得Request对象只需要在Controller方法的形参中添加一个参数即可。Springmvc框架会自动把Request对象传递给方法。</p><h2 id="Service"><a href="#Service" class="headerlink" title="Service"></a>Service</h2><pre><code>@Overridepublic Items getItemById(int id) {    Items items = itemsMapper.selectByPrimaryKey(id);    return items;}</code></pre><h2 id="默认支持的参数类型"><a href="#默认支持的参数类型" class="headerlink" title="默认支持的参数类型"></a>默认支持的参数类型</h2><p>处理器形参中添加如下类型的参数处理适配器会默认识别并进行赋值。</p><h3 id="HttpServletRequest"><a href="#HttpServletRequest" class="headerlink" title="HttpServletRequest"></a>HttpServletRequest</h3><p>通过request对象获取请求信息</p><h3 id="HttpServletResponse"><a href="#HttpServletResponse" class="headerlink" title="HttpServletResponse"></a>HttpServletResponse</h3><p>通过response处理响应信息</p><h3 id="HttpSession"><a href="#HttpSession" class="headerlink" title="HttpSession"></a>HttpSession</h3><p>通过session对象得到session中存放的对象</p><h3 id="Model-ModelMap"><a href="#Model-ModelMap" class="headerlink" title="Model/ModelMap"></a>Model/ModelMap</h3><p>ModelMap是Model接口的实现类，通过Model或ModelMap向页面传递数据，如下：</p><pre><code>//调用service查询商品信息Items item = itemService.findItemById(id);model.addAttribute(&quot;item&quot;, item);</code></pre><p>页面通过${item.XXXX}获取item对象的属性值。</p><p>使用Model和ModelMap的效果一样，如果直接使用Model，springmvc会实例化ModelMap。</p><p>如果使用Model则可以不使用ModelAndView对象，Model对象可以向页面传递数据，View对象则可以使用String返回值替代。不管是Model还是ModelAndView，其本质都是使用Request对象向jsp传递数据。<br>如果使用Model则方法可以改造成：</p><pre><code>@RequestMapping(&quot;/itemEdit&quot;)public String itemEdit(HttpServletRequest request, Model model) {    //从Request中取id    String strId = request.getParameter(&quot;id&quot;);    Integer id = null;    //如果id有值则转换成int类型    if (strId != null &amp;&amp; !&quot;&quot;.equals(strId)) {        id = new Integer(strId);    } else {        //出错        return null;    }    Items items = itemService.getItemById(id);    //创建ModelAndView    //ModelAndView modelAndView = new ModelAndView();    //向jsp传递数据    //modelAndView.addObject(&quot;item&quot;, items);    model.addAttribute(&quot;item&quot;, items);    //设置跳转的jsp页面    //modelAndView.setViewName(&quot;editItem&quot;);    //return modelAndView;    return &quot;editItem&quot;;}</code></pre><h2 id="绑定简单类型"><a href="#绑定简单类型" class="headerlink" title="绑定简单类型"></a>绑定简单类型</h2><p>当请求的参数名称和处理器形参名称一致时会将请求参数与形参进行绑定。从Request取参数的方法可以进一步简化。</p><pre><code>@RequestMapping(&quot;/itemEdit&quot;)public String itemEdit(Integer id, Model model) {    Items items = itemService.getItemById(id);    //向jsp传递数据    model.addAttribute(&quot;item&quot;, items);    //设置跳转的jsp页面    return &quot;editItem&quot;;}</code></pre><h3 id="支持的数据类型"><a href="#支持的数据类型" class="headerlink" title="支持的数据类型"></a>支持的数据类型</h3><p>参数类型推荐使用包装数据类型，因为基础数据类型不可以为null</p><p>整形：Integer、int</p><p>字符串：String</p><p>单精度：Float、float</p><p>双精度：Double、double</p><p>布尔型：Boolean、boolean</p><p>说明：对于布尔类型的参数，请求的参数值为true或false。</p><p>处理器方法：</p><pre><code>public String editItem(Model model,Integer id,Boolean status) throws Exception</code></pre><p>请求url：</p><pre><code>http://localhost:8080/xxx.action?id=2&amp;status=false</code></pre><h3 id="RequestParam"><a href="#RequestParam" class="headerlink" title="@RequestParam"></a>@RequestParam</h3><p>使用@RequestParam常用于处理简单类型的绑定。</p><p>value：参数名字，即入参的请求参数名字，如value=“item_id”表示请求的参数区中的名字为item_id的参数的值将传入；</p><p>required：是否必须，默认是true，表示请求中一定要有相应的参数，否则将报；</p><p>TTP Status 400 - Required Integer parameter ‘XXXX’ is not present</p><p>defaultValue：默认值，表示如果请求中没有同名参数时的默认值</p><p>定义如下：</p><pre><code>public String editItem(@RequestParam(value=&quot;item_id&quot;,required=true) String id) {}</code></pre><p>形参名称为id，但是这里使用value=” item_id”限定请求的参数名为item_id，所以页面传递参数的名必须为item_id。</p><p>注意：如果请求参数中没有item_id将跑出异常：</p><pre><code>HTTP Status 500 - Required Integer parameter &apos;item_id&apos; is not present</code></pre><p>这里通过required=true限定item_id参数为必需传递，如果不传递则报400错误，可以使用defaultvalue设置默认值，即使required=true也可以不传item_id参数值</p><h2 id="绑定pojo类型"><a href="#绑定pojo类型" class="headerlink" title="绑定pojo类型"></a>绑定pojo类型</h2><h3 id="Controller"><a href="#Controller" class="headerlink" title="Controller:"></a>Controller:</h3><pre><code>@RequestMapping(&quot;/updateitem&quot;)public String updateItem(Items items){    itemService.updateItem(items);    return &quot;success&quot;;}</code></pre><h3 id="service"><a href="#service" class="headerlink" title="service"></a>service</h3><pre><code>@Overridepublic void updateItem(Items items) {    //ItemsExample example = new ItemsExample();    //如果example定义了两个字段，数据库共4个字段，则修改数据库的两个字段，其余两个字段改为null    //itemsMapper.updateByExample(items, example);    //成功,但是没有的值置为了null    //itemsMapper.updateByPrimaryKey(items);    //成功,但是没有的值置为了null    //itemsMapper.updateByPrimaryKeyWithBLOBs(items);    //和updateByExample相比此方法可以修改大字段类型，其余性质和updateByExample相同    //itemsMapper.updateByExampleWithBLOBs(items, example);    //如果example定义了两个字段，数据库共4个字段，则修改数据库的两个字段，其余两个字段不动    itemsMapper.updateByPrimaryKeySelective(items);}</code></pre><p>注意：提交的表单中不要有日期类型的数据，否则会报400错误。如果想提交日期类型的数据需要用到后面的自定义参数绑定的内容。</p><h2 id="解决日期参数问题"><a href="#解决日期参数问题" class="headerlink" title="解决日期参数问题:"></a>解决日期参数问题:</h2><h3 id="自定义Converter"><a href="#自定义Converter" class="headerlink" title="自定义Converter"></a>自定义Converter</h3><pre><code>import org.joda.time.DateTime;import org.joda.time.format.DateTimeFormat;import org.joda.time.format.DateTimeFormatter;import org.springframework.core.convert.converter.Converter;import org.springframework.util.StringUtils;import java.util.ArrayList;import java.util.Date;import java.util.List;/** * Created by Rock 2016/12/6. */public class DateConverter implements Converter&lt;String,Date&gt; {private static final List&lt;String&gt; formarts = new ArrayList&lt;&gt;(4);static {    formarts.add(&quot;yyyy-MM&quot;);    formarts.add(&quot;yyyy-MM-dd&quot;);    formarts.add(&quot;yyyy-MM-dd HH:mm&quot;);    formarts.add(&quot;yyyy-MM-dd HH:mm:ss&quot;);}@Overridepublic Date convert(String s) {    if(StringUtils.isEmpty(s)){        return null;    }    try {        String formatter = &quot;&quot;;        if (s.matches(&quot;^\\d{4}-\\d{1,2}$&quot;)) {            formatter = formarts.get(0);        } else if (s.matches(&quot;^\\d{4}-\\d{1,2}-\\d{1,2}$&quot;)) {            formatter = formarts.get(1);        } else if (s.matches(&quot;^\\d{4}-\\d{1,2}-\\d{1,2} {1}\\d{1,2}:\\d{1,2}$&quot;)) {            formatter = formarts.get(2);        } else if (s.matches(&quot;^\\d{4}-\\d{1,2}-\\d{1,2} {1}\\d{1,2}:\\d{1,2}:\\d{1,2}$&quot;)) {            formatter = formarts.get(3);        } else {            throw new IllegalArgumentException(&quot;Invalid boolean value &apos;&quot; + s + &quot;&apos;&quot;);        }        DateFormat dateFormat = new SimpleDateFormat(formatter);        Date date = dateFormat.parse(s);        return date;    } catch (Exception e){        return null;    }}}</code></pre><h3 id="在springmvc-xml里面配置"><a href="#在springmvc-xml里面配置" class="headerlink" title="在springmvc.xml里面配置"></a>在springmvc.xml里面配置</h3><pre><code>&lt;!-- 配置注解驱动，如果配置此标签可以不用配置处理器映射器和适配器  --&gt;&lt;!-- &lt;mvc:annotation-driven /&gt; --&gt;&lt;!-- 加载注解驱动 --&gt;&lt;mvc:annotation-driven conversion-service=&quot;conversionService&quot;/&gt;&lt;!-- 转换器配置 --&gt;&lt;bean id=&quot;conversionService&quot;    class=&quot;org.springframework.format.support.FormattingConversionServiceFactoryBean&quot;&gt;    &lt;property name=&quot;converters&quot;&gt;        &lt;set&gt;            &lt;bean class=&quot;cn.lxm.springmvc.convert.DateConverter&quot;/&gt;        &lt;/set&gt;    &lt;/property&gt;&lt;/bean&gt;</code></pre><h2 id="解决post乱码问题"><a href="#解决post乱码问题" class="headerlink" title="解决post乱码问题"></a>解决post乱码问题</h2><p>在web.xml中加入：</p><pre><code>&lt;filter&gt;    &lt;filter-name&gt;CharacterEncodingFilter&lt;/filter-name&gt;    &lt;filter-class&gt;org.springframework.web.filter.CharacterEncodingFilter&lt;/filter-class&gt;    &lt;init-param&gt;        &lt;param-name&gt;encoding&lt;/param-name&gt;        &lt;param-value&gt;utf-8&lt;/param-value&gt;    &lt;/init-param&gt;&lt;/filter&gt;&lt;filter-mapping&gt;    &lt;filter-name&gt;CharacterEncodingFilter&lt;/filter-name&gt;    &lt;url-pattern&gt;/*&lt;/url-pattern&gt;&lt;/filter-mapping&gt;</code></pre><p>以上可以解决post请求乱码问题。</p><p>对于get请求中文参数出现乱码解决方法有两个：</p><p>修改tomcat配置文件添加编码与工程编码一致，如下：</p><pre><code>&lt;Connector URIEncoding=&quot;utf-8&quot; connectionTimeout=&quot;20000&quot; port=&quot;8080&quot; protocol=&quot;HTTP/1.1&quot; redirectPort=&quot;8443&quot;/&gt;</code></pre><p>另外一种方法对参数进行重新编码：</p><pre><code>String userName new String(request.getParamter(&quot;userName&quot;).getBytes(&quot;ISO8859-1&quot;),&quot;utf-8&quot;)</code></pre><p>ISO8859-1是tomcat默认编码，需要将tomcat编码后的内容按utf-8编码</p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;SpringMVC架构&quot;&gt;&lt;a href=&quot;#SpringMVC架构&quot; class=&quot;headerlink&quot; title=&quot;SpringMVC架构&quot;&gt;&lt;/a&gt;SpringMVC架构&lt;/h1&gt;&lt;p&gt;Spring web mvc和Struts2都属于表现层的框架,它是Spring框架的一部分.&lt;/p&gt;
&lt;h2 id=&quot;架构流程&quot;&gt;&lt;a href=&quot;#架构流程&quot; class=&quot;headerlink&quot; title=&quot;架构流程&quot;&gt;&lt;/a&gt;架构流程&lt;/h2&gt;&lt;pre&gt;&lt;code&gt;1、    用户发送请求至前端控制器DispatcherServlet

2、    DispatcherServlet收到请求调用HandlerMapping处理器映射器。

3、    处理器映射器根据请求url找到具体的处理器，生成处理器对象及处理器拦截器(如果有则生成)一并返回给DispatcherServlet。

4、    DispatcherServlet通过HandlerAdapter处理器适配器调用处理器

5、    执行处理器(Controller，也叫后端控制器)。

6、    Controller执行完成返回ModelAndView

7、    HandlerAdapter将controller执行结果ModelAndView返回给DispatcherServlet

8、    DispatcherServlet将ModelAndView传给ViewReslover视图解析器

9、    ViewReslover解析后返回具体View

10、    DispatcherServlet对View进行渲染视图（即将模型数据填充至视图中）。

11、    DispatcherServlet响应用户
&lt;/code&gt;&lt;/pre&gt;
    
    </summary>
    
      <category term="SSM" scheme="http://www.fashionkillyou.xyz/categories/SSM/"/>
    
    
      <category term="SpringMVC" scheme="http://www.fashionkillyou.xyz/tags/SpringMVC/"/>
    
      <category term="SpringWebMVC" scheme="http://www.fashionkillyou.xyz/tags/SpringWebMVC/"/>
    
  </entry>
  
  <entry>
    <title>mybatis五</title>
    <link href="http://www.fashionkillyou.xyz/2018/02/26/mybatis%E4%BA%94/"/>
    <id>http://www.fashionkillyou.xyz/2018/02/26/mybatis五/</id>
    <published>2018-02-26T08:21:09.000Z</published>
    <updated>2018-03-16T04:02:20.069Z</updated>
    
    <content type="html"><![CDATA[<script src="\assets\js\APlayer.min.js"> </script><h1 id="mybatis整合spring"><a href="#mybatis整合spring" class="headerlink" title="mybatis整合spring"></a>mybatis整合spring</h1><h2 id="整合思路"><a href="#整合思路" class="headerlink" title="整合思路"></a>整合思路</h2><p>1、SqlSessionFactory对象应该放到spring容器中作为单例存在。</p><p>2、传统dao的开发方式中，应该从spring容器中获得sqlsession对象。</p><p>3、Mapper代理形式中，应该从spring容器中直接获得mapper的代理对象。</p><p>4、数据库的连接以及数据库连接池事务管理都交给spring容器来完成。</p><a id="more"></a><h2 id="整合需要的jar包"><a href="#整合需要的jar包" class="headerlink" title="整合需要的jar包"></a>整合需要的jar包</h2><p>1、spring的jar包<br>2、Mybatis的jar包<br>3、Spring+mybatis的整合包。<br>4、Mysql的数据库驱动jar包。<br>5、数据库连接池的jar包。</p><h2 id="整合的步骤"><a href="#整合的步骤" class="headerlink" title="整合的步骤"></a>整合的步骤</h2><p>第一步：创建一个java工程。</p><p>第二步：导入jar包。（上面提到的jar包）</p><p>第三步：mybatis的配置文件SqlMapConfig.xml</p><p>第四步：编写Spring的配置文件</p><pre><code>1、数据库连接及连接池2、事务管理（暂时可以不配置）3、sqlsessionFactory对象，配置到spring容器中4、mapeer代理对象或者是dao实现类配置到spring容器中。</code></pre><p>第五步：编写dao或者mapper文件</p><p>第六步：测试。</p><h3 id="SqlMapConfig-xml"><a href="#SqlMapConfig-xml" class="headerlink" title="SqlMapConfig.xml"></a>SqlMapConfig.xml</h3><pre><code>&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; ?&gt;&lt;!DOCTYPE configurationPUBLIC &quot;-//mybatis.org//DTD Config 3.0//EN&quot;&quot;http://mybatis.org/dtd/mybatis-3-config.dtd&quot;&gt;&lt;configuration&gt;    &lt;typeAliases&gt;        &lt;package name=&quot;cn.lxm.mybatis.pojo&quot;/&gt;    &lt;/typeAliases&gt;    &lt;mappers&gt;        &lt;!-- 使用包扫描扫描mapper.xml            如果在ApplicationContext.xml中配置了扫描包之后,就 不需要此配置         --&gt;        &lt;package name=&quot;cn.lxm.mybatis.mapper&quot;/&gt;    &lt;/mappers&gt;&lt;/configuration&gt;</code></pre><h3 id="applicationContext-xml"><a href="#applicationContext-xml" class="headerlink" title="applicationContext.xml"></a>applicationContext.xml</h3><pre><code>&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot;    xmlns:context=&quot;http://www.springframework.org/schema/context&quot; xmlns:p=&quot;http://www.springframework.org/schema/p&quot;    xmlns:aop=&quot;http://www.springframework.org/schema/aop&quot; xmlns:tx=&quot;http://www.springframework.org/schema/tx&quot;    xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;    xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans-4.0.xsd    http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context-4.0.xsd    http://www.springframework.org/schema/aop http://www.springframework.org/schema/aop/spring-aop-4.0.xsd http://www.springframework.org/schema/tx http://www.springframework.org/schema/tx/spring-tx-4.0.xsd    http://www.springframework.org/schema/util http://www.springframework.org/schema/util/spring-util-4.0.xsd&quot;&gt;    &lt;!-- 加载配置文件 --&gt;    &lt;context:property-placeholder location=&quot;classpath:db.properties&quot; /&gt;    &lt;!-- 数据库连接池 --&gt;    &lt;bean id=&quot;dataSource&quot; class=&quot;org.apache.commons.dbcp.BasicDataSource&quot;        destroy-method=&quot;close&quot;&gt;        &lt;property name=&quot;driverClassName&quot; value=&quot;${jdbc.driver}&quot; /&gt;        &lt;property name=&quot;url&quot; value=&quot;${jdbc.url}&quot; /&gt;        &lt;property name=&quot;username&quot; value=&quot;${jdbc.username}&quot; /&gt;        &lt;property name=&quot;password&quot; value=&quot;${jdbc.password}&quot; /&gt;        &lt;property name=&quot;maxActive&quot; value=&quot;10&quot; /&gt;        &lt;property name=&quot;maxIdle&quot; value=&quot;5&quot; /&gt;    &lt;/bean&gt;    &lt;!-- mapper配置 --&gt;    &lt;!-- 让spring管理sqlsessionfactory 使用mybatis和spring整合包中的 --&gt;    &lt;bean id=&quot;sqlSessionFactory&quot; class=&quot;org.mybatis.spring.SqlSessionFactoryBean&quot;&gt;        &lt;!-- 数据库连接池 --&gt;        &lt;property name=&quot;dataSource&quot; ref=&quot;dataSource&quot; /&gt;        &lt;!-- 加载mybatis的全局配置文件 --&gt;        &lt;property name=&quot;configLocation&quot; value=&quot;classpath:mybatis/SqlMapConfig.xml&quot; /&gt;    &lt;/bean&gt;&lt;/beans&gt;</code></pre><h3 id="db-properties"><a href="#db-properties" class="headerlink" title="db.properties"></a>db.properties</h3><pre><code>jdbc.driver=com.mysql.jdbc.Driverjdbc.url=jdbc:mysql://localhost:3306/mybatis?characterEncoding=utf-8jdbc.username=rootjdbc.password=root</code></pre><h2 id="Dao的开发"><a href="#Dao的开发" class="headerlink" title="Dao的开发"></a>Dao的开发</h2><p>三种dao的实现方式：</p><pre><code>1、传统dao的开发方式2、使用mapper代理形式开发方式3、使用扫描包配置mapper代理。</code></pre><p>这里只介绍第二种和第三种</p><h3 id="Mapper代理形式开发dao"><a href="#Mapper代理形式开发dao" class="headerlink" title="Mapper代理形式开发dao"></a>Mapper代理形式开发dao</h3><h4 id="开发mapper接口"><a href="#开发mapper接口" class="headerlink" title="开发mapper接口"></a>开发mapper接口</h4><p>开发mapper文件</p><p>创建UserMapper.java</p><pre><code>public interface UserMapper {    User findUserById(Integer id) throws Exception;}</code></pre><p>并且在同一目录下创建UserMapper.xml</p><pre><code> &lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; ?&gt;&lt;!DOCTYPE mapperPUBLIC &quot;-//mybatis.org//DTD Mapper 3.0//EN&quot;&quot;http://mybatis.org/dtd/mybatis-3-mapper.dtd&quot;&gt;&lt;mapper namespace=&quot;cn.lxm.mybatis.mapper.UserMapper&quot;&gt;    &lt;!-- 根据id获取用户信息 --&gt;    &lt;select id=&quot;findUserById&quot; parameterType=&quot;int&quot; resultType=&quot;cn.lxm.mybatis.po.User&quot;&gt;        select * from user where id = #{id}    &lt;/select&gt;&lt;/mapper&gt;</code></pre><h4 id="配置mapper代理"><a href="#配置mapper代理" class="headerlink" title="配置mapper代理"></a>配置mapper代理</h4><pre><code>&lt;!-- 配置mapper代理对象 --&gt;&lt;bean class=&quot;org.mybatis.spring.mapper.MapperFactoryBean&quot;&gt;    &lt;property name=&quot;mapperInterface&quot; value=&quot;cn.lxm.mybatis.mapper.UserMapper&quot;/&gt;    &lt;property name=&quot;sqlSessionFactory&quot; ref=&quot;sqlSessionFactory&quot;&gt;&lt;/property&gt;&lt;/bean&gt;</code></pre><h4 id="测试方法"><a href="#测试方法" class="headerlink" title="测试方法"></a>测试方法</h4><pre><code>public class UserMapperTest {    private ApplicationContext applicationContext;    @Before    public void setUp() throws Exception {        applicationContext = new ClassPathXmlApplicationContext(&quot;classpath:spring/applicationContext.xml&quot;);    }    @Test    public void testGetUserById() {        UserMapper userMapper = applicationContext.getBean(UserMapper.class);        User user = userMapper.getUserById(1);        System.out.println(user);    }}</code></pre><h3 id="扫描包形式配置mapper"><a href="#扫描包形式配置mapper" class="headerlink" title="扫描包形式配置mapper"></a>扫描包形式配置mapper</h3><pre><code>&lt;!-- 使用扫描包的形式来创建mapper代理对象 --&gt;&lt;bean class=&quot;org.mybatis.spring.mapper.MapperScannerConfigurer&quot;&gt;    &lt;property name=&quot;basePackage&quot; value=&quot;cn.lxm.mybatis.mapper&quot;&gt;&lt;/property&gt;&lt;/bean&gt;</code></pre><p>如果配置了这个后 ,在SQLMapConfig.xml中的包扫描配置就不需要了</p><h2 id="逆向工程生成代码"><a href="#逆向工程生成代码" class="headerlink" title="逆向工程生成代码"></a>逆向工程生成代码</h2><p>步骤:</p><p>1.导入逆向工程代码,然后修改配置文件generatorConfig.xml</p><pre><code>&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;!DOCTYPE generatorConfiguration  PUBLIC &quot;-//mybatis.org//DTD MyBatis Generator Configuration 1.0//EN&quot;  &quot;http://mybatis.org/dtd/mybatis-generator-config_1_0.dtd&quot;&gt;&lt;generatorConfiguration&gt;    &lt;context id=&quot;testTables&quot; targetRuntime=&quot;MyBatis3&quot;&gt;        &lt;commentGenerator&gt;            &lt;!-- 是否去除自动生成的注释 true：是 ： false:否 --&gt;            &lt;property name=&quot;suppressAllComments&quot; value=&quot;true&quot; /&gt;        &lt;/commentGenerator&gt;        &lt;!--数据库连接的信息：驱动类、连接地址、用户名、密码 --&gt;        &lt;jdbcConnection driverClass=&quot;com.mysql.jdbc.Driver&quot;            connectionURL=&quot;jdbc:mysql://localhost:3306/mybatis&quot; userId=&quot;root&quot;            password=&quot;root&quot;&gt;        &lt;/jdbcConnection&gt;        &lt;!-- &lt;jdbcConnection driverClass=&quot;oracle.jdbc.OracleDriver&quot;            connectionURL=&quot;jdbc:oracle:thin:@127.0.0.1:1521:yycg&quot;             userId=&quot;yycg&quot;            password=&quot;yycg&quot;&gt;        &lt;/jdbcConnection&gt; --&gt;        &lt;!-- 默认false，把JDBC DECIMAL 和 NUMERIC 类型解析为 Integer，为 true时把JDBC DECIMAL 和             NUMERIC 类型解析为java.math.BigDecimal --&gt;        &lt;javaTypeResolver&gt;            &lt;property name=&quot;forceBigDecimals&quot; value=&quot;false&quot; /&gt;        &lt;/javaTypeResolver&gt;        &lt;!-- targetProject:生成PO类的位置 --&gt;        &lt;javaModelGenerator targetPackage=&quot;cn.lxm.mybatis.po&quot;            targetProject=&quot;.\src&quot;&gt;            &lt;!-- enableSubPackages:是否让schema作为包的后缀 --&gt;            &lt;property name=&quot;enableSubPackages&quot; value=&quot;false&quot; /&gt;            &lt;!-- 从数据库返回的值被清理前后的空格 --&gt;            &lt;property name=&quot;trimStrings&quot; value=&quot;true&quot; /&gt;        &lt;/javaModelGenerator&gt;        &lt;!-- targetProject:mapper映射文件生成的位置 --&gt;        &lt;sqlMapGenerator targetPackage=&quot;cn.lxm.mybatis.mapper&quot;             targetProject=&quot;.\src&quot;&gt;            &lt;!-- enableSubPackages:是否让schema作为包的后缀 --&gt;            &lt;property name=&quot;enableSubPackages&quot; value=&quot;false&quot; /&gt;        &lt;/sqlMapGenerator&gt;        &lt;!-- targetPackage：mapper接口生成的位置 --&gt;        &lt;javaClientGenerator type=&quot;XMLMAPPER&quot;            targetPackage=&quot;cn.lxm.mybatis.mapper&quot;             targetProject=&quot;.\src&quot;&gt;            &lt;!-- enableSubPackages:是否让schema作为包的后缀 --&gt;            &lt;property name=&quot;enableSubPackages&quot; value=&quot;false&quot; /&gt;        &lt;/javaClientGenerator&gt;        &lt;!-- 指定数据库表 --&gt;        &lt;table schema=&quot;&quot; tableName=&quot;user&quot;&gt;&lt;/table&gt;        &lt;table schema=&quot;&quot; tableName=&quot;orders&quot;&gt;&lt;/table&gt;        &lt;!-- 有些表的字段需要指定java类型         &lt;table schema=&quot;&quot; tableName=&quot;&quot;&gt;            &lt;columnOverride column=&quot;&quot; javaType=&quot;&quot; /&gt;        &lt;/table&gt; --&gt;    &lt;/context&gt;&lt;/generatorConfiguration&gt;</code></pre>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;mybatis整合spring&quot;&gt;&lt;a href=&quot;#mybatis整合spring&quot; class=&quot;headerlink&quot; title=&quot;mybatis整合spring&quot;&gt;&lt;/a&gt;mybatis整合spring&lt;/h1&gt;&lt;h2 id=&quot;整合思路&quot;&gt;&lt;a href=&quot;#整合思路&quot; class=&quot;headerlink&quot; title=&quot;整合思路&quot;&gt;&lt;/a&gt;整合思路&lt;/h2&gt;&lt;p&gt;1、SqlSessionFactory对象应该放到spring容器中作为单例存在。&lt;/p&gt;
&lt;p&gt;2、传统dao的开发方式中，应该从spring容器中获得sqlsession对象。&lt;/p&gt;
&lt;p&gt;3、Mapper代理形式中，应该从spring容器中直接获得mapper的代理对象。&lt;/p&gt;
&lt;p&gt;4、数据库的连接以及数据库连接池事务管理都交给spring容器来完成。&lt;/p&gt;
    
    </summary>
    
      <category term="SSM" scheme="http://www.fashionkillyou.xyz/categories/SSM/"/>
    
    
      <category term="mybatis" scheme="http://www.fashionkillyou.xyz/tags/mybatis/"/>
    
  </entry>
  
  <entry>
    <title>mybatis四</title>
    <link href="http://www.fashionkillyou.xyz/2018/02/25/mybatis%E5%9B%9B/"/>
    <id>http://www.fashionkillyou.xyz/2018/02/25/mybatis四/</id>
    <published>2018-02-25T08:07:42.000Z</published>
    <updated>2018-03-16T04:02:17.660Z</updated>
    
    <content type="html"><![CDATA[<script src="\assets\js\APlayer.min.js"> </script><h1 id="关联查询"><a href="#关联查询" class="headerlink" title="关联查询"></a>关联查询</h1><h2 id="一对一查询"><a href="#一对一查询" class="headerlink" title="一对一查询"></a>一对一查询</h2><p>这里举例是一个订单对应一个用户</p><h3 id="方法一："><a href="#方法一：" class="headerlink" title="方法一："></a>方法一：</h3><p>使用resultType，定义订单信息po类，此po类中包括了订单信息和用户信息：</p><a id="more"></a><h4 id="Sql语句："><a href="#Sql语句：" class="headerlink" title="Sql语句："></a>Sql语句：</h4><pre><code>SELECT   orders.*,  user.username,  user.addressFROM  orders,  user WHERE orders.user_id = user.id</code></pre><h4 id="定义po类"><a href="#定义po类" class="headerlink" title="定义po类"></a>定义po类</h4><p>Po类中应该包括上边sql查询出来的所有字段，如下：</p><pre><code>public class OrdersCustom extends Orders {private String username;// 用户名称private String address;// 用户地址get/set。。。。</code></pre><p>OrdersCustom类继承Orders类后OrdersCustom类包括了Orders类的所有字段，只需要定义用户的信息字段即可。</p><h4 id="Mapper-xml"><a href="#Mapper-xml" class="headerlink" title="Mapper.xml"></a>Mapper.xml</h4><pre><code>&lt;!-- 查询所有订单信息 --&gt;&lt;select id=&quot;findOrdersList&quot; resultType=&quot;cn.lxm.mybatis.po.OrdersCustom&quot;&gt;SELECTorders.*,user.username,user.addressFROMorders,    userWHERE orders.user_id = user.id &lt;/select&gt;</code></pre><h4 id="Mapper接口："><a href="#Mapper接口：" class="headerlink" title="Mapper接口："></a>Mapper接口：</h4><pre><code>public List&lt;OrdersCustom&gt; findOrdersList() throws Exception;</code></pre><h4 id="测试："><a href="#测试：" class="headerlink" title="测试："></a>测试：</h4><pre><code>Public void testfindOrdersList()throws Exception{    //获取session    SqlSession session = sqlSessionFactory.openSession();    //获限mapper接口实例    UserMapper userMapper = session.getMapper(UserMapper.class);    //查询订单信息    List&lt;OrdersCustom&gt; list = userMapper.findOrdersList();    System.out.println(list);    //关闭session    session.close();}</code></pre><h4 id="小结："><a href="#小结：" class="headerlink" title="小结："></a>小结：</h4><pre><code>定义专门的po类作为输出类型，其中定义了sql查询结果集所有的字段。此方法较为简单，企业中使用普遍。</code></pre><h3 id="方法二："><a href="#方法二：" class="headerlink" title="方法二："></a>方法二：</h3><p>使用resultMap，定义专门的resultMap用于映射一对一查询结果。</p><h4 id="Sql语句：-1"><a href="#Sql语句：-1" class="headerlink" title="Sql语句："></a>Sql语句：</h4><pre><code>SELECT   orders.*,  user.username,  user.addressFROM  orders,  user WHERE orders.user_id = user.id</code></pre><h4 id="定义po类-1"><a href="#定义po类-1" class="headerlink" title="定义po类"></a>定义po类</h4><p>在Orders类中加入User属性，user属性中用于存储关联查询的用户信息，因为订单关联查询用户是一对一关系，所以这里使用单个User对象存储关联查询的用户信息。<br>    public class Orders {<br>    private Integer id;</p><pre><code>private Integer userId;private String number;private Date createtime;private String note;private User user;get/set()...</code></pre><h4 id="Mapper-xml-1"><a href="#Mapper-xml-1" class="headerlink" title="Mapper.xml"></a>Mapper.xml</h4><pre><code>&lt;!-- 查询订单关联用户信息使用resultmap --&gt;&lt;resultMap type=&quot;Orders&quot; id=&quot;orderUserResultMap&quot;&gt;    &lt;id column=&quot;id&quot; property=&quot;id&quot;/&gt;    &lt;result column=&quot;user_id&quot; property=&quot;userId&quot;/&gt;    &lt;result column=&quot;number&quot; property=&quot;number&quot;/&gt;    &lt;result column=&quot;createtime&quot; property=&quot;createtime&quot;/&gt;    &lt;result column=&quot;note&quot; property=&quot;note&quot;/&gt;    &lt;!-- 一对一关联映射 --&gt;    &lt;!--     property:Orders对象的user属性    javaType：user属性对应 的类型     --&gt;    &lt;association property=&quot;user&quot; javaType=&quot;cn.lxm.po.User&quot;&gt;        &lt;!-- column:user表的主键对应的列  property：user对象中id属性--&gt;        &lt;id column=&quot;user_id&quot; property=&quot;id&quot;/&gt;        &lt;result column=&quot;username&quot; property=&quot;username&quot;/&gt;        &lt;result column=&quot;address&quot; property=&quot;address&quot;/&gt;    &lt;/association&gt;&lt;/resultMap&gt;&lt;select id=&quot;findOrdersWithUserResultMap&quot; resultMap=&quot;orderUserResultMap&quot;&gt;    SELECT        o.id,        o.user_id,        o.number,        o.createtime,        o.note,        u.username,        u.address    FROM        orders o    JOIN `user` u ON u.id = o.user_id&lt;/select&gt;</code></pre><p>这里resultMap指定orderUserResultMap。</p><p>association：表示进行关联查询单条记录</p><p>property：表示关联查询的结果存储在cn.lxm.mybatis.po.Orders的user属性中</p><p>javaType：表示关联查询的结果类型</p><p>&lt; id property=”id” column=”user_id”/&gt;：查询结果的user_id列对应关联对象的id属性，这里是&lt; id /&gt;表示user_id是关联查询对象的唯一标识。</p><p>&lt; result property=”username” column=”username”/&gt;：查询结果的username列对应关联对象的username属性。</p><h4 id="Mapper接口：-1"><a href="#Mapper接口：-1" class="headerlink" title="Mapper接口："></a>Mapper接口：</h4><pre><code>public List&lt;Orders&gt; findOrdersListResultMap() throws Exception;</code></pre><h4 id="测试：-1"><a href="#测试：-1" class="headerlink" title="测试："></a>测试：</h4><pre><code>Public void testfindOrdersListResultMap()throws Exception{    //获取session    SqlSession session = sqlSessionFactory.openSession();    //获限mapper接口实例    UserMapper userMapper = session.getMapper(UserMapper.class);    //查询订单信息    List&lt;Orders&gt; list = userMapper.findOrdersList2();    System.out.println(list);    //关闭session    session.close();}</code></pre><h4 id="小结：-1"><a href="#小结：-1" class="headerlink" title="小结："></a>小结：</h4><p>使用association完成关联查询，将关联查询信息映射到pojo对象中。</p><h2 id="一对多查询"><a href="#一对多查询" class="headerlink" title="一对多查询"></a>一对多查询</h2><p>案例：查询所有用户信息及用户关联的订单信息。</p><p>用户信息和订单信息为一对多关系。</p><p>使用resultMap实现如下：</p><h3 id="Sql语句：-2"><a href="#Sql语句：-2" class="headerlink" title="Sql语句："></a>Sql语句：</h3><pre><code>SELECTu.*, o.id oid,o.number,o.createtime,o.noteFROM`user` uLEFT JOIN orders o ON u.id = o.user_id</code></pre><h3 id="定义po类-2"><a href="#定义po类-2" class="headerlink" title="定义po类"></a>定义po类</h3><p>在User类中加入List&lt; Orders&gt; orders属性</p><pre><code>public class User {   private int id;   private String username;// 用户姓名   private String sex;// 性别   private Date birthday;// 生日   private String address;// 地址   private List&lt;Orders&gt; orders;   get/set()...</code></pre><h3 id="Mapper-xml-2"><a href="#Mapper-xml-2" class="headerlink" title="Mapper.xml"></a>Mapper.xml</h3><pre><code>&lt;resultMap type=&quot;user&quot; id=&quot;userOrderResultMap&quot;&gt;    &lt;!-- 用户信息映射 --&gt;    &lt;id property=&quot;id&quot; column=&quot;id&quot;/&gt;    &lt;result property=&quot;username&quot; column=&quot;username&quot;/&gt;    &lt;result property=&quot;birthday&quot; column=&quot;birthday&quot;/&gt;    &lt;result property=&quot;sex&quot; column=&quot;sex&quot;/&gt;    &lt;result property=&quot;address&quot; column=&quot;address&quot;/&gt;    &lt;!-- 一对多关联映射 --&gt;    &lt;collection property=&quot;orders&quot; ofType=&quot;orders&quot;&gt;        &lt;id property=&quot;id&quot; column=&quot;oid&quot;/&gt;              &lt;!--用户id已经在user对象中存在，此处可以不设置--&gt;        &lt;!-- &lt;result property=&quot;userId&quot; column=&quot;id&quot;/&gt; --&gt;        &lt;result property=&quot;number&quot; column=&quot;number&quot;/&gt;        &lt;result property=&quot;createtime&quot; column=&quot;createtime&quot;/&gt;        &lt;result property=&quot;note&quot; column=&quot;note&quot;/&gt;    &lt;/collection&gt;&lt;/resultMap&gt;&lt;select id=&quot;getUserOrderList&quot; resultMap=&quot;userOrderResultMap&quot;&gt;    SELECT    u.*, o.id oid,    o.number,    o.createtime,    o.note    FROM    `user` u    LEFT JOIN orders o ON u.id = o.user_id&lt;/select&gt;</code></pre><p>collection部分定义了用户关联的订单信息。表示关联查询结果集</p><p>property=”orders”：关联查询的结果集存储在User对象的上哪个属性。</p><p>ofType=”orders”：指定关联查询的结果集中的对象类型即List中的对象类型。此处可以使用别名，也可以使用全限定名。</p><p>&lt; id /&gt;及&lt; result/&gt;的意义同一对一查询。</p><h3 id="Mapper接口：-2"><a href="#Mapper接口：-2" class="headerlink" title="Mapper接口："></a>Mapper接口：</h3><pre><code>List&lt;User&gt; getUserOrderList();</code></pre><h3 id="测试"><a href="#测试" class="headerlink" title="测试"></a>测试</h3><pre><code>@Testpublic void getUserOrderList() {    SqlSession session = sqlSessionFactory.openSession();    UserMapper userMapper = session.getMapper(UserMapper.class);    List&lt;User&gt; result = userMapper.getUserOrderList();    for (User user : result) {        System.out.println(user);    }    session.close();}</code></pre>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;关联查询&quot;&gt;&lt;a href=&quot;#关联查询&quot; class=&quot;headerlink&quot; title=&quot;关联查询&quot;&gt;&lt;/a&gt;关联查询&lt;/h1&gt;&lt;h2 id=&quot;一对一查询&quot;&gt;&lt;a href=&quot;#一对一查询&quot; class=&quot;headerlink&quot; title=&quot;一对一查询&quot;&gt;&lt;/a&gt;一对一查询&lt;/h2&gt;&lt;p&gt;这里举例是一个订单对应一个用户&lt;/p&gt;
&lt;h3 id=&quot;方法一：&quot;&gt;&lt;a href=&quot;#方法一：&quot; class=&quot;headerlink&quot; title=&quot;方法一：&quot;&gt;&lt;/a&gt;方法一：&lt;/h3&gt;&lt;p&gt;使用resultType，定义订单信息po类，此po类中包括了订单信息和用户信息：&lt;/p&gt;
    
    </summary>
    
      <category term="SSM" scheme="http://www.fashionkillyou.xyz/categories/SSM/"/>
    
    
      <category term="mybatis" scheme="http://www.fashionkillyou.xyz/tags/mybatis/"/>
    
  </entry>
  
  <entry>
    <title>mybatis三</title>
    <link href="http://www.fashionkillyou.xyz/2018/02/25/mybatis%E4%B8%89/"/>
    <id>http://www.fashionkillyou.xyz/2018/02/25/mybatis三/</id>
    <published>2018-02-25T00:58:28.000Z</published>
    <updated>2018-03-16T04:02:15.451Z</updated>
    
    <content type="html"><![CDATA[<script src="\assets\js\APlayer.min.js"> </script><h1 id="输入映射和输出映射"><a href="#输入映射和输出映射" class="headerlink" title="输入映射和输出映射"></a>输入映射和输出映射</h1><p>Mapper.xml映射文件中定义了操作数据库的sql，每个sql是一个statement，映射文件是mybatis的核心。<br><a id="more"></a></p><h2 id="parameterType-输入类型"><a href="#parameterType-输入类型" class="headerlink" title="parameterType(输入类型)"></a>parameterType(输入类型)</h2><h3 id="传递简单类型"><a href="#传递简单类型" class="headerlink" title="传递简单类型"></a>传递简单类型</h3><p>参考文章 <a href="http://fashionkillyou.xyz/2018/02/24/mybatis入门一/" title="mybatis入门一" target="_blank" rel="noopener">mybatis入门一</a></p><h3 id="传递pojo对象"><a href="#传递pojo对象" class="headerlink" title="传递pojo对象"></a>传递pojo对象</h3><p>Mybatis使用ognl表达式解析对象字段的值，#{}或者${}括号中的值为pojo属性名称。</p><h3 id="传递pojo包装对象"><a href="#传递pojo包装对象" class="headerlink" title="传递pojo包装对象"></a>传递pojo包装对象</h3><p>开发中通过pojo传递查询条件 ，查询条件是综合的查询条件，不仅包括用户查询条件还包括其它的查询条件（比如将用户购买商品信息也作为查询条件），这时可以使用包装对象传递输入参数。<br>Pojo类中包含pojo。</p><p>需求：根据用户名查询用户信息，查询条件放到QueryVo的user属性中。</p><h4 id="QueryVo"><a href="#QueryVo" class="headerlink" title="QueryVo"></a>QueryVo</h4><pre><code>public class QueryVo {    private User user;    public User getUser() {        return user;    }    public void setUser(User user) {        this.user = user;    }}</code></pre><h4 id="Sql语句"><a href="#Sql语句" class="headerlink" title="Sql语句"></a>Sql语句</h4><p>SELECT * FROM user where username like ‘%刘%’</p><h4 id="Mapper文件"><a href="#Mapper文件" class="headerlink" title="Mapper文件"></a>Mapper文件</h4><pre><code>&lt;!-- 使用包装类型查询用户使用ognl从对象中取属性值，如果是包装对象可以使用.操作符来取内容部的属性--&gt;&lt;select id=&quot;findUserByQueryVo&quot; parameterType=&quot;queryvo&quot; resultType=&quot;user&quot;&gt;    SELECT * FROM user where username like &apos;%${user.username}%&apos;&lt;/select&gt;</code></pre><h4 id="接口"><a href="#接口" class="headerlink" title="接口"></a>接口</h4><pre><code> public interface UserMapper{    User findUserById(int id) throws Exception;    void insertUser(User user) throws Exception;    List&lt;User&gt; findUserByQueryVo(QueryVo queryVo) throws Exception;}</code></pre><h4 id="测试方法"><a href="#测试方法" class="headerlink" title="测试方法"></a>测试方法</h4><pre><code>@Testpublic void testFindUserByQueryVo() throws Exception {    SqlSession sqlSession = sessionFactory.openSession();    //获得mapper的代理对象    UserMapper userMapper = sqlSession.getMapper(UserMapper.class);    //创建QueryVo对象    QueryVo queryVo = new QueryVo();    //创建user对象    User user = new User();    user.setUsername(&quot;刘&quot;);    queryVo.setUser(user);    //根据queryvo查询用户    List&lt;User&gt; list = userMapper.findUserByQueryVo(queryVo);    System.out.println(list);    sqlSession.close();}</code></pre><h2 id="resultType-输出类型"><a href="#resultType-输出类型" class="headerlink" title="resultType(输出类型)"></a>resultType(输出类型)</h2><h3 id="输出简单类型"><a href="#输出简单类型" class="headerlink" title="输出简单类型"></a>输出简单类型</h3><p>参考getnow输出日期类型，看下边的例子输出整型：</p><p>Mapper.xml文件</p><pre><code>&lt;!-- 获取用户列表总数 --&gt;&lt;select id=&quot;findUserCount&quot; parameterType=&quot;user&quot; resultType=&quot;int&quot;&gt;   select count(1) from user&lt;/select&gt;</code></pre><p>Mapper接口</p><pre><code>public int findUserCount(User user) throws Exception;</code></pre><p>调用：</p><pre><code>Public void testFindUserCount() throws Exception{    //获取session    SqlSession session = sqlSessionFactory.openSession();    //获取mapper接口实例    UserMapper userMapper = session.getMapper(UserMapper.class);    User user = new User();    user.setUsername(&quot;管理员&quot;);    //传递Hashmap对象查询用户列表    int count = userMapper.findUserCount(user);    //关闭session    session.close();}</code></pre><p>输出简单类型必须查询出来的结果集有一条记录，最终将第一个字段的值转换为输出类型。<br>使用session的selectOne可查询单条记录。</p><h3 id="输出pojo对象"><a href="#输出pojo对象" class="headerlink" title="输出pojo对象"></a>输出pojo对象</h3><p>参考文章 <a href="http://fashionkillyou.xyz/2018/02/24/mybatis入门一/" title="mybatis入门一" target="_blank" rel="noopener">mybatis入门一</a></p><h3 id="输出pojo列表"><a href="#输出pojo列表" class="headerlink" title="输出pojo列表"></a>输出pojo列表</h3><p>参考文章 <a href="http://fashionkillyou.xyz/2018/02/24/mybatis入门一/" title="mybatis入门一" target="_blank" rel="noopener">mybatis入门一</a></p><h2 id="resultMap"><a href="#resultMap" class="headerlink" title="resultMap"></a>resultMap</h2><p>resultType可以指定pojo将查询结果映射为pojo，但需要pojo的属性名和sql查询的列名一致方可映射成功。</p><p>如果sql查询字段名和pojo的属性名不一致，可以通过resultMap将字段名和属性名作一个对应关系 ，resultMap实质上还需要将查询结果映射到pojo对象中。</p><p>resultMap可以实现将查询结果映射为复杂类型的pojo，比如在查询结果映射对象中包括pojo和list实现一对一查询和一对多查询。</p><h3 id="Mapper-xml定义"><a href="#Mapper-xml定义" class="headerlink" title="Mapper.xml定义"></a>Mapper.xml定义</h3><pre><code> &lt;select id=&quot;findUserListResultMap&quot; parameterType=&quot;queryVo&quot; resultMap=&quot;userListResultMap&quot;&gt;    select id id_,username username_,birthday birthday_ from user&lt;/select&gt;</code></pre><p>使用resultMap指定上边定义的personmap。</p><h3 id="定义resultMap"><a href="#定义resultMap" class="headerlink" title="定义resultMap"></a>定义resultMap</h3><p>由于上边的mapper.xml中sql查询列和Users.java类属性不一致，需要定义resultMap：</p><p>userListResultMap将sql查询列和Users.java类属性对应起来</p><pre><code>&lt;!-- type:最终映射的java对象.id:resultMap的唯一标识 --&gt;&lt;resultMap type=&quot;user&quot; id=&quot;userListResultMap&quot;&gt;&lt;!-- id标签:查询结果集的唯一标识列(主键或唯一标识)    column:SQL查询字段名(列名)    property:pojo的属性名    result标签:普通列 --&gt;    &lt;id property=&quot;id&quot; column=&quot;id_&quot;/&gt;    &lt;result property=&quot;username&quot; column=&quot;username_&quot;/&gt;    &lt;result property=&quot;birthday&quot; column=&quot;birthday_&quot;/&gt;&lt;/resultMap&gt;</code></pre><p>&lt; id /&gt;：此属性表示查询结果集的唯一标识，非常重要。如果是多个字段为复合唯一约束则定义多个&lt; id /&gt;。</p><p>Property：表示User类的属性。</p><p>Column：表示sql查询出来的字段名。</p><p>Column和property放在一块儿表示将sql查询出来的字段映射到指定的pojo类属性上。</p><p>&lt; result /&gt;：普通结果，即pojo的属性。</p><h3 id="Mapper接口定义"><a href="#Mapper接口定义" class="headerlink" title="Mapper接口定义"></a>Mapper接口定义</h3><pre><code>public List&lt;User&gt; findUserListResultMap() throws Exception;</code></pre><h1 id="动态sql"><a href="#动态sql" class="headerlink" title="动态sql"></a>动态sql</h1><p>通过mybatis提供的各种标签方法实现动态拼接sql。</p><h2 id="If"><a href="#If" class="headerlink" title="If"></a>If</h2><pre><code>&lt;!-- 传递pojo综合查询用户信息 --&gt;&lt;select id=&quot;findUserList&quot; parameterType=&quot;user&quot; resultType=&quot;user&quot;&gt;    select * from user     where 1=1     &lt;if test=&quot;id!=null and id!=&apos;&apos;&quot;&gt;    and id=#{id}    &lt;/if&gt;    &lt;if test=&quot;username!=null and username!=&apos;&apos;&quot;&gt;    and username like &apos;%${username}%&apos;    &lt;/if&gt;&lt;/select&gt;</code></pre><p>注意要做不等于空字符串校验。</p><h2 id="Where"><a href="#Where" class="headerlink" title="Where"></a>Where</h2><p>上边的sql也可以改为：</p><pre><code>&lt;select id=&quot;findUserList&quot; parameterType=&quot;user&quot; resultType=&quot;user&quot;&gt;    select * from user     &lt;where&gt;    &lt;if test=&quot;id!=null and id!=&apos;&apos;&quot;&gt;    and id=#{id}    &lt;/if&gt;    &lt;if test=&quot;username!=null and username!=&apos;&apos;&quot;&gt;    and username like &apos;%${username}%&apos;    &lt;/if&gt;    &lt;/where&gt;&lt;/select&gt;</code></pre><p>&lt; where /&gt;可以自动处理第一个and。</p><h2 id="foreach"><a href="#foreach" class="headerlink" title="foreach"></a>foreach</h2><p>向sql传递数组或List，mybatis使用foreach解析，如下：</p><p>需求<br>传入多个id查询用户信息，用下边两个sql实现：</p><pre><code>SELECT * FROM USERS WHERE username LIKE &apos;%张%&apos; AND (id =10 OR id =89 OR id=16)SELECT * FROM USERS WHERE username LIKE &apos;%张%&apos;  id IN (10,89,16)</code></pre><p>在pojo中定义list属性ids存储多个用户id，并添加getter/setter方法</p><pre><code> public class QueryVo {    private User user;    private List&lt;Integer&gt; ids;    public List&lt;Integer&gt; getIds() {        return ids;    }    public void setIds(List&lt;Integer&gt; ids) {        this.ids = ids;    }...</code></pre><p>mapper.xml</p><pre><code>&lt;if test=&quot;ids!=null and ids.size&gt;0&quot;&gt;        &lt;foreach collection=&quot;ids&quot; open=&quot; and id in(&quot; close=&quot;)&quot; item=&quot;id&quot; separator=&quot;,&quot; &gt;            #{id}        &lt;/foreach&gt;&lt;/if&gt;</code></pre><p>测试代码：</p><pre><code>List&lt;Integer&gt; ids = new ArrayList&lt;Integer&gt;();    ids.add(1);//查询id为1的用户    ids.add(10); //查询id为10的用户    queryVo.setIds(ids);    List&lt;User&gt; list = userMapper.findUserList(queryVo);</code></pre><h2 id="Sql片段"><a href="#Sql片段" class="headerlink" title="Sql片段"></a>Sql片段</h2><p>Sql中可将重复的sql提取出来，使用时用include引用即可，最终达到sql重用的目的，如下：</p><pre><code>&lt;!-- 传递pojo综合查询用户信息 --&gt;&lt;select id=&quot;findUserList&quot; parameterType=&quot;user&quot; resultType=&quot;user&quot;&gt;    select * from user     &lt;where&gt;    &lt;if test=&quot;id!=null and id!=&apos;&apos;&quot;&gt;    and id=#{id}    &lt;/if&gt;    &lt;if test=&quot;username!=null and username!=&apos;&apos;&quot;&gt;    and username like &apos;%${username}%&apos;    &lt;/if&gt;    &lt;/where&gt;&lt;/select&gt;</code></pre><p>    将where条件抽取出来：</p><pre><code>&lt;sql id=&quot;query_user_where&quot;&gt;    &lt;if test=&quot;id!=null and id!=&apos;&apos;&quot;&gt;        and id=#{id}    &lt;/if&gt;    &lt;if test=&quot;username!=null and username!=&apos;&apos;&quot;&gt;        and username like &apos;%${username}%&apos;    &lt;/if&gt;&lt;/sql&gt;</code></pre><p>    使用include引用：</p><pre><code>&lt;select id=&quot;findUserList&quot; parameterType=&quot;user&quot; resultType=&quot;user&quot;&gt;    select * from user     &lt;where&gt;    &lt;include refid=&quot;query_user_where&quot;/&gt;    &lt;/where&gt;&lt;/select&gt;</code></pre><p>注意：如果引用其它mapper.xml的sql片段，则在引用时需要加上namespace，如下：</p><pre><code>&lt;include refid=&quot;namespace.sql片段”/&gt;</code></pre><p>如果使用 &gt;或者&lt;符号的时候,因为是在xml文件中这些符号都是有特殊含义的,可以使用CDATA区域 &lt;![CDATA[要写的内容]]&gt;       &lt;![CDATA[&gt;]]&gt;大于   &lt;![CDATA[&lt;]]&gt;</p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;输入映射和输出映射&quot;&gt;&lt;a href=&quot;#输入映射和输出映射&quot; class=&quot;headerlink&quot; title=&quot;输入映射和输出映射&quot;&gt;&lt;/a&gt;输入映射和输出映射&lt;/h1&gt;&lt;p&gt;Mapper.xml映射文件中定义了操作数据库的sql，每个sql是一个statement，映射文件是mybatis的核心。&lt;br&gt;
    
    </summary>
    
      <category term="SSM" scheme="http://www.fashionkillyou.xyz/categories/SSM/"/>
    
    
      <category term="mybatis" scheme="http://www.fashionkillyou.xyz/tags/mybatis/"/>
    
  </entry>
  
  <entry>
    <title>mybatis二</title>
    <link href="http://www.fashionkillyou.xyz/2018/02/24/mybatis%E4%BA%8C/"/>
    <id>http://www.fashionkillyou.xyz/2018/02/24/mybatis二/</id>
    <published>2018-02-24T09:18:11.000Z</published>
    <updated>2018-03-16T04:02:12.962Z</updated>
    
    <content type="html"><![CDATA[<script src="\assets\js\APlayer.min.js"> </script><h1 id="Mapper动态代理方式"><a href="#Mapper动态代理方式" class="headerlink" title="Mapper动态代理方式"></a>Mapper动态代理方式</h1><h2 id="开发规范"><a href="#开发规范" class="headerlink" title="开发规范"></a>开发规范</h2><p>Mapper接口开发方法只需要程序员编写Mapper接口（相当于Dao接口），由Mybatis框架根据接口定义创建接口的动态代理对象，代理对象的方法体同上边Dao接口实现类方法。</p><p>Mapper接口开发需要遵循以下规范：<br><a id="more"></a><br>1、    Mapper.xml文件中的namespace与mapper接口的类路径相同。</p><p>2、    Mapper接口方法名和Mapper.xml中定义的每个statement的id相同</p><p>3、    Mapper接口方法的输入参数类型和mapper.xml中定义的每个sql 的parameterType的类型相同</p><p>4、    Mapper接口方法的输出参数类型和mapper.xml中定义的每个sql的resultType的类型相同</p><h2 id="Mapper-xml-映射文件"><a href="#Mapper-xml-映射文件" class="headerlink" title="Mapper.xml(映射文件)"></a>Mapper.xml(映射文件)</h2><p>定义mapper映射文件UserMapper.xml（内容同Users.xml），需要修改namespace的值为 UserMapper接口路径。将UserMapper.xml放在classpath 下mapper目录 下。</p><pre><code>&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; ?&gt;&lt;!DOCTYPE mapperPUBLIC &quot;-//mybatis.org//DTD Mapper 3.0//EN&quot;&quot;http://mybatis.org/dtd/mybatis-3-mapper.dtd&quot;&gt;&lt;mapper namespace=&quot;cn.lxm.mybatis.mapper.UserMapper&quot;&gt;&lt;!-- 根据id获取用户信息 --&gt;&lt;select id=&quot;findUserById&quot; parameterType=&quot;int&quot; resultType=&quot;cn.lxm.mybatis.po.User&quot;&gt;    select * from user where id = #{id}&lt;/select&gt;&lt;!-- 自定义条件查询用户列表 --&gt;&lt;select id=&quot;findUserByUsername&quot; parameterType=&quot;java.lang.String&quot;         resultType=&quot;cn.lxm.mybatis.po.User&quot;&gt;   select * from user where username like &apos;%${value}%&apos; &lt;/select&gt;&lt;!-- 添加用户 --&gt;&lt;insert id=&quot;insertUser&quot; parameterType=&quot;cn.lxm.mybatis.po.User&quot;&gt;&lt;selectKey keyProperty=&quot;id&quot; order=&quot;AFTER&quot; resultType=&quot;java.lang.Integer&quot;&gt;    select LAST_INSERT_ID() &lt;/selectKey&gt;  insert into user(username,birthday,sex,address)   values(#{username},#{birthday},#{sex},#{address})&lt;/insert&gt;&lt;/mapper&gt;</code></pre><h2 id="Mapper-java-接口文件"><a href="#Mapper-java-接口文件" class="headerlink" title="Mapper.java(接口文件)"></a>Mapper.java(接口文件)</h2><pre><code>/** * 用户管理mapper */Public interface UserMapper {//根据用户id查询用户信息public User findUserById(int id) throws Exception;//查询用户列表public List&lt;User&gt; findUserByUsername(String username) throws Exception;//添加用户信息public void insertUser(User user)throws Exception; }</code></pre><p>接口定义有如下特点：</p><p>1、    Mapper接口方法名和Mapper.xml中定义的statement的id相同</p><p>2、    Mapper接口方法的输入参数类型和mapper.xml中定义的statement的parameterType的类型相同</p><p>3、    Mapper接口方法的输出参数类型和mapper.xml中定义的statement的resultType的类型相同</p><h2 id="加载UserMapper-xml文件"><a href="#加载UserMapper-xml文件" class="headerlink" title="加载UserMapper.xml文件"></a>加载UserMapper.xml文件</h2><p>修改SqlMapConfig.xml文件：</p><pre><code>&lt;!-- 加载映射文件 --&gt;&lt;mappers&gt;    &lt;mapper resource=&quot;mapper/UserMapper.xml&quot;/&gt;&lt;/mappers&gt;</code></pre><h2 id="测试"><a href="#测试" class="headerlink" title="测试"></a>测试</h2><pre><code>Public class UserMapperTest extends TestCase {    private SqlSessionFactory sqlSessionFactory;    protected void setUp() throws Exception {        //mybatis配置文件        String resource = &quot;sqlMapConfig.xml&quot;;        InputStream inputStream = Resources.getResourceAsStream(resource);        //使用SqlSessionFactoryBuilder创建sessionFactory        sqlSessionFactory = new SqlSessionFactoryBuilder().build(inputStream);    }    Public void testFindUserById() throws Exception {        //获取session        SqlSession session = sqlSessionFactory.openSession();        //获取mapper接口的代理对象        UserMapper userMapper = session.getMapper(UserMapper.class);        //调用代理对象方法        User user = userMapper.findUserById(1);        System.out.println(user);        //关闭session        session.close();    }    @Test    public void testFindUserByUsername() throws Exception {        SqlSession sqlSession = sqlSessionFactory.openSession();        UserMapper userMapper = sqlSession.getMapper(UserMapper.class);        List&lt;User&gt; list = userMapper.findUserByUsername(&quot;张&quot;);        System.out.println(list.size());    }    Public void testInsertUser() throws Exception {        //获取session        SqlSession session = sqlSessionFactory.openSession();        //获取mapper接口的代理对象        UserMapper userMapper = session.getMapper(UserMapper.class);        //要添加的数据        User user = new User();        user.setUsername(&quot;张三&quot;);        user.setBirthday(new Date());        user.setSex(&quot;1&quot;);        user.setAddress(&quot;北京市&quot;);        //通过mapper接口添加用户        userMapper.insertUser(user);        //提交        session.commit();        //关闭session        session.close();    }}</code></pre><h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><ul><li><p>selectOne和selectList<br>动态代理对象调用sqlSession.selectOne()和sqlSession.selectList()是根据mapper接口方法的返回值决定，如果返回list则调用selectList方法，如果返回单个对象则调用selectOne方法。</p></li><li><p>namespace<br>mybatis官方推荐使用mapper代理方法开发mapper接口，程序员不用编写mapper接口实现类，使用mapper代理方法时，输入参数可以使用pojo包装对象或map对象，保证dao的通用性。</p></li></ul><h2 id="SqlMapConfig-xml配置文件"><a href="#SqlMapConfig-xml配置文件" class="headerlink" title="SqlMapConfig.xml配置文件"></a>SqlMapConfig.xml配置文件</h2><h3 id="配置内容"><a href="#配置内容" class="headerlink" title="配置内容"></a>配置内容</h3><p>SqlMapConfig.xml中配置的内容和顺序如下：</p><pre><code>properties（属性）settings（全局配置参数）typeAliases（类型别名）typeHandlers（类型处理器）objectFactory（对象工厂）plugins（插件）environments（环境集合属性对象）environment（环境子属性对象）transactionManager（事务管理）dataSource（数据源）mappers（映射器）</code></pre><h2 id="properties（属性）"><a href="#properties（属性）" class="headerlink" title="properties（属性）"></a>properties（属性）</h2><p>SqlMapConfig.xml可以引用java属性文件中的配置信息如下：</p><p>在classpath下定义db.properties文件</p><pre><code>jdbc.driver=com.mysql.jdbc.Driverjdbc.url=jdbc:mysql://localhost:3306/mybatis?characterEncoding=utf-8jdbc.username=rootjdbc.password=root</code></pre><p>SqlMapConfig.xml引用如下：</p><pre><code>&lt;properties resource=&quot;db.properties&quot;/&gt;    &lt;environments default=&quot;development&quot;&gt;        &lt;environment id=&quot;development&quot;&gt;            &lt;transactionManager type=&quot;JDBC&quot;/&gt;            &lt;dataSource type=&quot;POOLED&quot;&gt;                &lt;property name=&quot;driver&quot; value=&quot;${jdbc.driver}&quot;/&gt;                &lt;property name=&quot;url&quot; value=&quot;${jdbc.url}&quot;/&gt;                &lt;property name=&quot;username&quot; value=&quot;${jdbc.username}&quot;/&gt;                &lt;property name=&quot;password&quot; value=&quot;${jdbc.password}&quot;/&gt;            &lt;/dataSource&gt;        &lt;/environment&gt;    &lt;/environments&gt;</code></pre><p>注意： MyBatis 将按照下面的顺序来加载属性：</p><ul><li>在 properties 元素体内定义的属性首先被读取。 </li><li>然后会读取properties 元素中resource或 url 加载的属性，它会覆盖已读取的同名属性。 </li></ul><h2 id="typeAliases（类型别名）"><a href="#typeAliases（类型别名）" class="headerlink" title="typeAliases（类型别名）"></a>typeAliases（类型别名）</h2><h3 id="mybatis支持别名："><a href="#mybatis支持别名：" class="headerlink" title="mybatis支持别名："></a>mybatis支持别名：</h3><pre><code>别名    映射的类型_byte     byte _long     long _short     short _int     int _integer     int _double     double _float     float _boolean     boolean string     String byte     Byte long     Long short     Short int     Integer integer     Integer double     Double float     Float boolean     Boolean date     Date decimal     BigDecimal bigdecimal     BigDecimal map    Map</code></pre><h3 id="自定义别名："><a href="#自定义别名：" class="headerlink" title="自定义别名："></a>自定义别名：</h3><p>在SqlMapConfig.xml中配置：<br>    <typealiases><br>        <!-- 单个别名定义 --><br>        <typealias alias="user" type="cn.lxm.mybatis.po.User"><br>        <!-- 批量别名定义，扫描整个包下的类，别名为类名（首字母大写或小写都可以） --><br>        <package name="cn.lxm.mybatis.po"><br>        <package name="其它包"><br>    </package></package></typealias></typealiases><br>这个<typealiases>标签的位置必须放在<environments>标签前面,dtd的约束</environments></typealiases></p><h2 id="mappers（映射器）"><a href="#mappers（映射器）" class="headerlink" title="mappers（映射器）"></a>mappers（映射器）</h2><p>Mapper配置的几种方法：</p><ul><li>&lt; mapper resource=” “ /&gt;</li></ul><p>使用相对于类路径的资源如：</p><pre><code>&lt;mapper resource=&quot;sqlmap/User.xml&quot; /&gt;</code></pre><ul><li>&lt; mapper class=” “ /&gt;</li></ul><p>使用mapper接口类路径如：</p><pre><code>&lt;mapper class=&quot;cn.lxm.mybatis.mapper.UserMapper&quot;/&gt;</code></pre><p>注意：此种方法要求mapper接口名称和mapper映射文件名称相同，且放在同一个目录中。</p><ul><li>&lt; package name=””/&gt;</li></ul><p>注册指定包下的所有mapper接口如：</p><pre><code>&lt;package name=&quot;cn.lxm.mybatis.mapper&quot;/&gt;</code></pre><p>注意：此种方法要求mapper接口名称和mapper映射文件名称相同，且放在同一个目录中。</p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;Mapper动态代理方式&quot;&gt;&lt;a href=&quot;#Mapper动态代理方式&quot; class=&quot;headerlink&quot; title=&quot;Mapper动态代理方式&quot;&gt;&lt;/a&gt;Mapper动态代理方式&lt;/h1&gt;&lt;h2 id=&quot;开发规范&quot;&gt;&lt;a href=&quot;#开发规范&quot; class=&quot;headerlink&quot; title=&quot;开发规范&quot;&gt;&lt;/a&gt;开发规范&lt;/h2&gt;&lt;p&gt;Mapper接口开发方法只需要程序员编写Mapper接口（相当于Dao接口），由Mybatis框架根据接口定义创建接口的动态代理对象，代理对象的方法体同上边Dao接口实现类方法。&lt;/p&gt;
&lt;p&gt;Mapper接口开发需要遵循以下规范：&lt;br&gt;
    
    </summary>
    
      <category term="SSM" scheme="http://www.fashionkillyou.xyz/categories/SSM/"/>
    
    
      <category term="mybatis" scheme="http://www.fashionkillyou.xyz/tags/mybatis/"/>
    
  </entry>
  
  <entry>
    <title>mybatis一</title>
    <link href="http://www.fashionkillyou.xyz/2018/02/24/mybatis%E4%B8%80/"/>
    <id>http://www.fashionkillyou.xyz/2018/02/24/mybatis一/</id>
    <published>2018-02-24T02:09:08.000Z</published>
    <updated>2018-03-16T04:02:22.629Z</updated>
    
    <content type="html"><![CDATA[<script src="\assets\js\APlayer.min.js"> </script><h1 id="Mybatis入门程序"><a href="#Mybatis入门程序" class="headerlink" title="Mybatis入门程序"></a>Mybatis入门程序</h1><h2 id="1-mybatis下载"><a href="#1-mybatis下载" class="headerlink" title="1 mybatis下载"></a>1 mybatis下载</h2><p>mybaits的代码由github.com管理，地址：<a href="https://github.com/mybatis/mybatis-3/releases" target="_blank" rel="noopener">https://github.com/mybatis/mybatis-3/releases</a><br><a id="more"></a> </p><p>mybatis-3.2.7.jar—-mybatis的核心包<br>lib—-mybatis的依赖包<br>mybatis-3.2.7.pdf—-mybatis使用手册</p><h2 id="2-工程搭建"><a href="#2-工程搭建" class="headerlink" title="2 工程搭建"></a>2 工程搭建</h2><h3 id="第一步：创建java工程"><a href="#第一步：创建java工程" class="headerlink" title="第一步：创建java工程"></a>第一步：创建java工程</h3><p>使用eclipse创建java工程，jdk使用1.7.0_72。</p><h3 id="第二步：加入jar包"><a href="#第二步：加入jar包" class="headerlink" title="第二步：加入jar包"></a>第二步：加入jar包</h3><p>加入mybatis核心包、依赖包、数据驱动包。</p><h3 id="第三步：log4j-properties"><a href="#第三步：log4j-properties" class="headerlink" title="第三步：log4j.properties"></a>第三步：log4j.properties</h3><p>在classpath下创建log4j.properties如下：</p><pre><code># Global logging configurationlog4j.rootLogger=DEBUG, stdout# Console output...log4j.appender.stdout=org.apache.log4j.ConsoleAppenderlog4j.appender.stdout.layout=org.apache.log4j.PatternLayoutlog4j.appender.stdout.layout.ConversionPattern=%5p [%t] - %m%n</code></pre><p>mybatis默认使用log4j作为输出日志信息。</p><h3 id="第四步：SqlMapConfig-xml"><a href="#第四步：SqlMapConfig-xml" class="headerlink" title="第四步：SqlMapConfig.xml"></a>第四步：SqlMapConfig.xml</h3><p>在classpath下创建SqlMapConfig.xml，如下：</p><pre><code>&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; ?&gt;&lt;!DOCTYPE configurationPUBLIC &quot;-//mybatis.org//DTD Config 3.0//EN&quot;&quot;http://mybatis.org/dtd/mybatis-3-config.dtd&quot;&gt;&lt;configuration&gt;&lt;!-- 和spring整合后 environments配置将废除--&gt;&lt;environments default=&quot;development&quot;&gt;    &lt;environment id=&quot;development&quot;&gt;    &lt;!-- 使用jdbc事务管理--&gt;        &lt;transactionManager type=&quot;JDBC&quot; /&gt;    &lt;!-- 数据库连接池--&gt;        &lt;dataSource type=&quot;POOLED&quot;&gt;            &lt;property name=&quot;driver&quot; value=&quot;com.mysql.jdbc.Driver&quot; /&gt;            &lt;property name=&quot;url&quot; value=&quot;jdbc:mysql://localhost:3306/mybatis?characterEncoding=utf-8&quot; /&gt;            &lt;property name=&quot;username&quot; value=&quot;root&quot; /&gt;            &lt;property name=&quot;password&quot; value=&quot;root&quot; /&gt;        &lt;/dataSource&gt;    &lt;/environment&gt;&lt;/environments&gt;&lt;/configuration&gt;</code></pre><p>SqlMapConfig.xml是mybatis核心配置文件，上边文件的配置内容为数据源、事务管理。</p><h3 id="第五步：po类"><a href="#第五步：po类" class="headerlink" title="第五步：po类"></a>第五步：po类</h3><p>Po类作为mybatis进行sql映射使用，po类通常与数据库表对应，User.java如下：</p><pre><code>Public class User {    private int id;    private String username;// 用户姓名    private String sex;// 性别    private Date birthday;// 生日    private String address;// 地址get/set……</code></pre><h3 id="第六步：sql映射文件"><a href="#第六步：sql映射文件" class="headerlink" title="第六步：sql映射文件"></a>第六步：sql映射文件</h3><p>在classpath下的sqlmap目录下创建sql映射文件Users.xml：</p><pre><code>&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; ?&gt;&lt;!DOCTYPE mapperPUBLIC &quot;-//mybatis.org//DTD Mapper 3.0//EN&quot;&quot;http://mybatis.org/dtd/mybatis-3-mapper.dtd&quot;&gt;&lt;mapper namespace=&quot;test&quot;&gt;&lt;/mapper&gt;</code></pre><p>namespace ：命名空间，用于隔离sql语句，后面会讲另一层非常重要的作用。</p><h3 id="第七步：加载映射文件"><a href="#第七步：加载映射文件" class="headerlink" title="第七步：加载映射文件"></a>第七步：加载映射文件</h3><p>mybatis框架需要加载映射文件，将User.xml添加在SqlMapConfig.xml，如下：</p><pre><code>&lt;mappers&gt;    &lt;mapper resource=&quot;sqlmap/User.xml&quot;/&gt;&lt;/mappers&gt;</code></pre><h2 id="3-根据id查询用户信息"><a href="#3-根据id查询用户信息" class="headerlink" title="3 根据id查询用户信息"></a>3 根据id查询用户信息</h2><h3 id="映射文件："><a href="#映射文件：" class="headerlink" title="映射文件："></a>映射文件：</h3><p>在user.xml中添加：</p><pre><code>&lt;!-- 根据id获取用户信息 - -&gt;&lt;select id=&quot;findUserById&quot; parameterType=&quot;int&quot; resultType=&quot;cn.lxm.mybatis.po.User&quot;&gt;    select * from user where id = #{id}&lt;/select&gt;</code></pre><p>parameterType：定义输入到sql中的映射类型，#{id}表示使用preparedstatement设置占位符号并将输入变量id传到sql。<br>resultType：定义结果映射类型。</p><h3 id="测试程序："><a href="#测试程序：" class="headerlink" title="测试程序："></a>测试程序：</h3><pre><code>public class Mybatis_first {    //会话工厂    private SqlSessionFactory sqlSessionFactory;    @Before    public void createSqlSessionFactory() throws IOException {        // 配置文件        String resource = &quot;SqlMapConfig.xml&quot;;        InputStream inputStream = Resources.getResourceAsStream(resource);        // 使用SqlSessionFactoryBuilder从xml配置文件中创建SqlSessionFactory        sqlSessionFactory = new SqlSessionFactoryBuilder()                .build(inputStream);    }    // 根据 id查询用户信息    @Test    public void testFindUserById() {        // 数据库会话实例        SqlSession sqlSession = null;        try {            // 创建数据库会话实例sqlSession            sqlSession = sqlSessionFactory.openSession();            // 查询单个记录，根据用户id查询用户信息            User user = sqlSession.selectOne(&quot;test.findUserById&quot;, 10);            // 输出用户信息            System.out.println(user);        } catch (Exception e) {            e.printStackTrace();        } finally {            if (sqlSession != null) {                sqlSession.close();            }        }    }}</code></pre><h2 id="4-根据用户名查询用户信息"><a href="#4-根据用户名查询用户信息" class="headerlink" title="4 根据用户名查询用户信息"></a>4 根据用户名查询用户信息</h2><h3 id="映射文件：-1"><a href="#映射文件：-1" class="headerlink" title="映射文件："></a>映射文件：</h3><p>在user.xml中添加：</p><pre><code>&lt;!-- 自定义条件查询用户列表  - -&gt;&lt;select id=&quot;findUserByUsername&quot; parameterType=&quot;java.lang.String&quot;         resultType=&quot;cn.lxm.mybatis.po.User&quot;&gt;   select * from user where username like &apos;%${value}%&apos; &lt;/select&gt;</code></pre><p>parameterType：定义输入到sql中的映射类型，${value}表示使用参数将${value}替换，做字符串的拼接。<br>注意：如果是取简单数据类型的参数，括号中的值必须为value<br>resultType：定义结果映射类型。</p><h3 id="测试程序：-1"><a href="#测试程序：-1" class="headerlink" title="测试程序："></a>测试程序：</h3><pre><code>// 根据用户名称模糊查询用户信息@Testpublic void testFindUserByUsername() {    // 数据库会话实例    SqlSession sqlSession = null;    try {        // 创建数据库会话实例sqlSession        sqlSession = sqlSessionFactory.openSession();        // 查询单个记录，根据用户id查询用户信息        List&lt;User&gt; list = sqlSession.selectList(&quot;test.findUserByUsername&quot;, &quot;张&quot;);        System.out.println(list.size());    } catch (Exception e) {        e.printStackTrace();    } finally {        if (sqlSession != null) {            sqlSession.close();        }    }}</code></pre><h1 id="5小结"><a href="#5小结" class="headerlink" title="5小结"></a>5小结</h1><h2 id="和"><a href="#和" class="headerlink" title="#{}和${}"></a>#{}和${}</h2><p>-#{}表示一个占位符号，通过#{}可以实现preparedStatement向占位符中设置值，自动进行java类型和jdbc类型转换，#{}可以有效防止sql注入。 #{}可以接收简单类型值或pojo属性值。 如果parameterType传输单个简单类型值，#{}括号中可以是value或其它名称。</p><p>-${}表示拼接sql串，通过${}可以将parameterType 传入的内容拼接在sql中且不进行jdbc类型转换， ${}可以接收简单类型值或pojo属性值，如果parameterType传输单个简单类型值，${}括号中只能是value。</p><h2 id="parameterType和resultType"><a href="#parameterType和resultType" class="headerlink" title="parameterType和resultType"></a>parameterType和resultType</h2><p>parameterType：指定输入参数类型，mybatis通过ognl从输入对象中获取参数值拼接在sql中。<br>resultType：指定输出结果类型，mybatis将sql查询结果的一行记录数据映射为resultType指定类型的对象。</p><h2 id="selectOne和selectList"><a href="#selectOne和selectList" class="headerlink" title="selectOne和selectList"></a>selectOne和selectList</h2><p>selectOne查询一条记录，如果使用selectOne查询多条记录则抛出异常：<br>    org.apache.ibatis.exceptions.TooManyResultsException: Expected one result (or null) to be returned by selectOne(), but found: 3<br>    at org.apache.ibatis.session.defaults.DefaultSqlSession.selectOne(DefaultSqlSession.java:70)</p><p>selectList可以查询一条或多条记录。</p><h1 id="6添加用户"><a href="#6添加用户" class="headerlink" title="6添加用户"></a>6添加用户</h1><h2 id="映射文件：-2"><a href="#映射文件：-2" class="headerlink" title="映射文件："></a>映射文件：</h2><p>在SqlMapConfig.xml中添加：<br><!-- 添加用户 --><br>    <insert id="insertUser" parametertype="cn.lxm.mybatis.po.User"><br>      insert into user(username,birthday,sex,address)<br>      values(#{username},#{birthday},#{sex},#{address})<br>    </insert></p><h2 id="测试程序：-2"><a href="#测试程序：-2" class="headerlink" title="测试程序："></a>测试程序：</h2><pre><code>// 添加用户信息@Testpublic void testInsert() {    // 数据库会话实例    SqlSession sqlSession = null;    try {        // 创建数据库会话实例sqlSession        sqlSession = sqlSessionFactory.openSession();        // 添加用户信息        User user = new User();        user.setUsername(&quot;张小明&quot;);        user.setAddress(&quot;河南郑州&quot;);        user.setSex(&quot;1&quot;);        user.setPrice(1999.9f);        sqlSession.insert(&quot;test.insertUser&quot;, user);        //提交事务        sqlSession.commit();    } catch (Exception e) {        e.printStackTrace();    } finally {        if (sqlSession != null) {            sqlSession.close();        }    }}</code></pre><h2 id="mysql自增主键返回"><a href="#mysql自增主键返回" class="headerlink" title="mysql自增主键返回"></a>mysql自增主键返回</h2><p>通过修改sql映射文件，可以将mysql自增主键返回:</p><pre><code>&lt;insert id=&quot;insertUser&quot; parameterType=&quot;cn.lxm.mybatis.po.User&quot;&gt;    &lt;!-- selectKey将主键返回，需要再返回 使用user.getId()获取返回的id值 --&gt;    &lt;selectKey keyProperty=&quot;id&quot; order=&quot;AFTER&quot; resultType=&quot;java.lang.Integer&quot;&gt;        select LAST_INSERT_ID()    &lt;/selectKey&gt;   insert into user(username,birthday,sex,address)    values(#{username},#{birthday},#{sex},#{address});&lt;/insert&gt;</code></pre><p>添加selectKey实现将主键返回</p><p>keyProperty:返回的主键存储在pojo中的哪个属性</p><p>order：selectKey的执行顺序，是相对与insert语句来说，由于mysql的自增原理执行完insert语句之后才将主键生成，所以这里selectKey的执行顺序为after</p><p>resultType:返回的主键是什么类型</p><p>LAST_INSERT_ID():是mysql的函数，返回auto_increment自增列新记录id值。</p><h2 id="oracle自增主键返回"><a href="#oracle自增主键返回" class="headerlink" title="oracle自增主键返回"></a>oracle自增主键返回</h2><pre><code>&lt;insert id=&quot;insertUser&quot; parameterType=&quot;cn.lxm.mybatis.po.User&quot;&gt;    &lt;!-- selectKey将主键返回，需要再返回 --&gt;    &lt;selectKey keyProperty=&quot;id&quot; order=&quot;BEFORE&quot; resultType=&quot;java.lang.Integer&quot;&gt;        select 序列的.nextval()    &lt;/selectKey&gt;   insert into user(id,username,birthday,sex,address)    values(#{id},#{username},#{birthday},#{sex},#{address});&lt;/insert&gt;</code></pre><p>oracle的不是很常用,这里是需要先取出序列里面的主键,然后再插入数据,插入的时候讲取出来的主键放进去.所以这里的order是BEFORE</p><h2 id="Mysql使用-uuid实现主键"><a href="#Mysql使用-uuid实现主键" class="headerlink" title="Mysql使用 uuid实现主键"></a>Mysql使用 uuid实现主键</h2><p>需要增加通过select uuid()得到uuid值</p><pre><code>&lt;insert  id=&quot;insertUser&quot; parameterType=&quot;cn.lxm.mybatis.po.User&quot;&gt;&lt;selectKey resultType=&quot;java.lang.String&quot; order=&quot;BEFORE&quot; keyProperty=&quot;id&quot;&gt;select uuid()&lt;/selectKey&gt;insert into user(id,username,birthday,sex,address)          values(#{id},#{username},#{birthday},#{sex},#{address})&lt;/insert&gt;</code></pre><p>注意这里使用的order是“BEFORE”</p><h1 id="7删除用户"><a href="#7删除用户" class="headerlink" title="7删除用户"></a>7删除用户</h1><h2 id="映射文件：-3"><a href="#映射文件：-3" class="headerlink" title="映射文件："></a>映射文件：</h2><!-- 删除用户 --><pre><code>&lt;delete id=&quot;deleteUserById&quot; parameterType=&quot;int&quot;&gt;    delete from user where id=#{id}&lt;/delete&gt;</code></pre><h2 id="测试程序：-3"><a href="#测试程序：-3" class="headerlink" title="测试程序："></a>测试程序：</h2><pre><code>// 根据id删除用户@Testpublic void testDelete() {    // 数据库会话实例    SqlSession sqlSession = null;    try {        // 创建数据库会话实例sqlSession        sqlSession = sqlSessionFactory.openSession();        // 删除用户        sqlSession.delete(&quot;test.deleteUserById&quot;,18);        // 提交事务        sqlSession.commit();    } catch (Exception e) {        e.printStackTrace();    } finally {        if (sqlSession != null) {            sqlSession.close();        }    }}</code></pre><h1 id="8修改用户"><a href="#8修改用户" class="headerlink" title="8修改用户"></a>8修改用户</h1><h2 id="映射文件"><a href="#映射文件" class="headerlink" title="映射文件"></a>映射文件</h2><!-- 更新用户 --><pre><code>&lt;update id=&quot;updateUser&quot; parameterType=&quot;cn.lxm.mybatis.po.User&quot;&gt;    update user set username=#{username},birthday=#{birthday},sex=#{sex},address=#{address}    where id=#{id}&lt;/update&gt;</code></pre><h2 id="测试程序"><a href="#测试程序" class="headerlink" title="测试程序"></a>测试程序</h2><pre><code>// 更新用户信息@Testpublic void testUpdate() {    // 数据库会话实例    SqlSession sqlSession = null;    try {        // 创建数据库会话实例sqlSession        sqlSession = sqlSessionFactory.openSession();        // 添加用户信息        User user = new User();        user.setId(16);        user.setUsername(&quot;张小明&quot;);        user.setAddress(&quot;河南郑州&quot;);        user.setSex(&quot;1&quot;);        user.setPrice(1999.9f);        sqlSession.update(&quot;test.updateUser&quot;, user);        // 提交事务        sqlSession.commit();    } catch (Exception e) {        e.printStackTrace();    } finally {        if (sqlSession != null) {            sqlSession.close();        }    }}</code></pre><h1 id="9-Mybatis解决jdbc编程的问题"><a href="#9-Mybatis解决jdbc编程的问题" class="headerlink" title="9 Mybatis解决jdbc编程的问题"></a>9 Mybatis解决jdbc编程的问题</h1><ul><li>1、    数据库链接创建、释放频繁造成系统资源浪费从而影响系统性能，如果使用数据库链接池可解决此问题。<br>解决：在SqlMapConfig.xml中配置数据链接池，使用连接池管理数据库链接。</li><li>2、    Sql语句写在代码中造成代码不易维护，实际应用sql变化的可能较大，sql变动需要改变java代码。<br>解决：将Sql语句配置在XXXXmapper.xml文件中与java代码分离。</li><li>3、    向sql语句传参数麻烦，因为sql语句的where条件不一定，可能多也可能少，占位符需要和参数一一对应。<br>解决：Mybatis自动将java对象映射至sql语句，通过statement中的parameterType定义输入参数的类型。</li><li>4、    对结果集解析麻烦，sql变化导致解析代码变化，且解析前需要遍历，如果能将数据库记录封装成pojo对象解析比较方便。<br>解决：Mybatis自动将sql执行结果映射至java对象，通过statement中的resultType定义输出结果的类型。</li></ul><h1 id="10-mybatis与hibernate不同"><a href="#10-mybatis与hibernate不同" class="headerlink" title="10 mybatis与hibernate不同"></a>10 mybatis与hibernate不同</h1><ul><li><p>Mybatis和hibernate不同，它不完全是一个ORM框架，因为MyBatis需要程序员自己编写Sql语句，不过mybatis可以通过XML或注解方式灵活配置要运行的sql语句，并将java对象和sql语句映射生成最终执行的sql，最后将sql执行的结果再映射生成java对象。</p></li><li><p>Mybatis学习门槛低，简单易学，程序员直接编写原生态sql，可严格控制sql执行性能，灵活度高，非常适合对关系数据模型要求不高的软件开发，例如互联网软件、企业运营类软件等，因为这类软件需求变化频繁，一但需求变化要求成果输出迅速。但是灵活的前提是mybatis无法做到数据库无关性，如果需要实现支持多种数据库的软件则需要自定义多套sql映射文件，工作量大。</p></li><li><p>Hibernate对象/关系映射能力强，数据库无关性好，对于关系模型要求高的软件（例如需求固定的定制化软件）如果用hibernate开发可以节省很多代码，提高效率。但是Hibernate的学习门槛高，要精通门槛更高，而且怎么设计O/R映射，在性能和对象模型之间如何权衡，以及怎样用好Hibernate需要具有很强的经验和能力才行。</p></li><li><p>总之，按照用户的需求在有限的资源环境下只要能做出维护性、扩展性良好的软件架构都是好架构，所以框架只有适合才是最好。</p></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;Mybatis入门程序&quot;&gt;&lt;a href=&quot;#Mybatis入门程序&quot; class=&quot;headerlink&quot; title=&quot;Mybatis入门程序&quot;&gt;&lt;/a&gt;Mybatis入门程序&lt;/h1&gt;&lt;h2 id=&quot;1-mybatis下载&quot;&gt;&lt;a href=&quot;#1-mybatis下载&quot; class=&quot;headerlink&quot; title=&quot;1 mybatis下载&quot;&gt;&lt;/a&gt;1 mybatis下载&lt;/h2&gt;&lt;p&gt;mybaits的代码由github.com管理，地址：&lt;a href=&quot;https://github.com/mybatis/mybatis-3/releases&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://github.com/mybatis/mybatis-3/releases&lt;/a&gt;&lt;br&gt;
    
    </summary>
    
      <category term="SSM" scheme="http://www.fashionkillyou.xyz/categories/SSM/"/>
    
    
      <category term="mybatis" scheme="http://www.fashionkillyou.xyz/tags/mybatis/"/>
    
  </entry>
  
  <entry>
    <title>webService天气预报接口</title>
    <link href="http://www.fashionkillyou.xyz/2018/02/11/webService%E5%A4%A9%E6%B0%94%E9%A2%84%E6%8A%A5%E6%8E%A5%E5%8F%A3/"/>
    <id>http://www.fashionkillyou.xyz/2018/02/11/webService天气预报接口/</id>
    <published>2018-02-11T15:36:17.000Z</published>
    <updated>2018-02-11T15:42:41.163Z</updated>
    
    <content type="html"><![CDATA[<script src="\assets\js\APlayer.min.js"> </script><p>一：环境搭建<br>二：根据wsdl文件生成客户端代码<br>三：测试代码<br><a id="more"></a></p><h1 id="一：环境搭建"><a href="#一：环境搭建" class="headerlink" title="一：环境搭建"></a>一：环境搭建</h1><pre><code>1：新建一个java project工程weatherInf2：引入相应的jar包activation.jaraxis-ant.jaraxis.jarcommons-discovery-0.2.jarcommons-logging-1.0.4.jarjaxrpc.jarlog4j-1.2.8.jarmail.jarsaaj.jarwsdl4j-1.5.1.jar下载axis 1.4 src压缩包，解压后到webapp/web-info/lib下取包，具体路径如下：http://download.csdn.net/detail/yyg64/5351114其中mail.jar 以及 activation.jar 可到如下路径下载：http://download.csdn.net/detail/dbhunter/3982583：将天气预报接口wsdl文件拷贝到src目录下http://www.webxml.com.cn/WebServices/WeatherWebService.asmx?wsdl</code></pre><h1 id="二：根据wsdl文件生成客户端代码"><a href="#二：根据wsdl文件生成客户端代码" class="headerlink" title="二：根据wsdl文件生成客户端代码"></a>二：根据wsdl文件生成客户端代码</h1><p>wsdl文件——右键——web services——Generate Client，然后一路next到finish。</p><h1 id="三：测试代码"><a href="#三：测试代码" class="headerlink" title="三：测试代码"></a>三：测试代码</h1><pre><code> 1 /** 2  *  3  */ 4 package com.paic.services; 5  6 import java.rmi.RemoteException; 7  8 import javax.xml.rpc.ServiceException; 9 10 import cn.com.WebXml.WeatherWebServiceLocator;11 import cn.com.WebXml.WeatherWebServiceSoapStub;12 13 /**14  * @author Administrator15  * 16  */17 public class TestWeather {18     public static void main(String[] args) throws ServiceException,19             RemoteException {20         WeatherWebServiceLocator locator = new WeatherWebServiceLocator();21         WeatherWebServiceSoapStub service = (WeatherWebServiceSoapStub) locator22                 .getPort(WeatherWebServiceSoapStub.class);23         invokeGetSupportProvince(service);24         System.out.println(&quot;...................&quot;);25         invokeGetSupportCity(service);26         invokeGetWeatherByOneCity(service);27     }28 29     // 调用获取支持的省份、州接口30     public static void invokeGetSupportProvince(31             WeatherWebServiceSoapStub service) throws RemoteException {32         String[] provices = service.getSupportProvince();33         System.out.println(&quot;总共&quot; + provices.length + &quot;个&quot;);34         int count = 0;35         for (String str : provices) {36             if (0 != count &amp;&amp; count % 5 == 0) {37                 System.out.println();38             }39             System.out.print(str + &quot;\t&quot;);40             count++;41         }42     }43 44     // 调用获取支持查询某个省份内的城市接口45     public static void invokeGetSupportCity(WeatherWebServiceSoapStub service)46             throws RemoteException {47         String provinceName = &quot;江苏&quot;;48         String[] cities = service.getSupportCity(provinceName);49         System.out.println(&quot;总共&quot; + cities.length + &quot;个市&quot;);50         for (int i = 0; i &lt; cities.length; i++) {51             if (0 != i &amp;&amp; i % 5 == 0) {52                 System.out.println();53             }54             System.out.print(cities[i] + &quot;\t&quot;);55         }56     }57 58     // 调用查询某个城市天气的接口59     public static void invokeGetWeatherByOneCity(60             WeatherWebServiceSoapStub service) throws RemoteException {61         String cityName = &quot;南京&quot;;62         String[] weatherInfo = service.getWeatherbyCityName(cityName);63         for (String str : weatherInfo) {64             System.out.println(str);65         }66     }67 }</code></pre>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;一：环境搭建&lt;br&gt;二：根据wsdl文件生成客户端代码&lt;br&gt;三：测试代码&lt;br&gt;
    
    </summary>
    
      <category term="前端" scheme="http://www.fashionkillyou.xyz/categories/%E5%89%8D%E7%AB%AF/"/>
    
    
      <category term="webservice" scheme="http://www.fashionkillyou.xyz/tags/webservice/"/>
    
  </entry>
  
  <entry>
    <title>Quarze入门知识</title>
    <link href="http://www.fashionkillyou.xyz/2018/02/10/Quarze%E5%85%A5%E9%97%A8%E7%9F%A5%E8%AF%86/"/>
    <id>http://www.fashionkillyou.xyz/2018/02/10/Quarze入门知识/</id>
    <published>2018-02-10T15:18:51.000Z</published>
    <updated>2018-02-11T15:41:46.157Z</updated>
    
    <content type="html"><![CDATA[<script src="\assets\js\APlayer.min.js"> </script><h1 id="Quartz-入门详解"><a href="#Quartz-入门详解" class="headerlink" title="Quartz 入门详解"></a>Quartz 入门详解</h1><h2 id="入门简介："><a href="#入门简介：" class="headerlink" title="入门简介："></a>入门简介：</h2><p>基本上任何公司都会用到调度这个功能， 比如我们公司需要定期执行调度生成报表， 或者比如博客什么的定时更新之类的，都可以靠Quartz来完成。正如官网所说，小到独立应用大到大型电子商务网站， Quartz都能胜任。</p><a id="more"></a><h2 id="Quartz体系结构："><a href="#Quartz体系结构：" class="headerlink" title="Quartz体系结构："></a>Quartz体系结构：</h2><p>明白Quartz怎么用，首先要了解Scheduler(调度器)、Job(任务)和Trigger(触发器)这3个核心的概念。</p><h3 id="1-Job："><a href="#1-Job：" class="headerlink" title="1. Job："></a>1. Job：</h3><p>是一个接口，只定义一个方法execute(JobExecutionContext context)，在实现接口的execute方法中编写所需要定时执行的Job(任务)， JobExecutionContext类提供了调度应用的一些信息。Job运行时的信息保存在JobDataMap实例中；</p><h3 id="2-JobDetail："><a href="#2-JobDetail：" class="headerlink" title="2. JobDetail："></a>2. JobDetail：</h3><p>Quartz每次调度Job时， 都重新创建一个Job实例， 所以它不直接接受一个Job的实例，相反它接收一个Job实现类(JobDetail:描述Job的实现类及其它相关的静态信息，如Job名字、描述、关联监听器等信息)，以便运行时通过newInstance()的反射机制实例化Job。</p><h3 id="3-Trigger："><a href="#3-Trigger：" class="headerlink" title="3. Trigger："></a>3. Trigger：</h3><p>是一个类，描述触发Job执行的时间触发规则。主要有SimpleTrigger和CronTrigger这两个子类。当且仅当需调度一次或者以固定时间间隔周期执行调度，SimpleTrigger是最适合的选择；而CronTrigger则可以通过Cron表达式定义出各种复杂时间规则的调度方案：如工作日周一到周五的15：00~16：00执行调度等；</p><h4 id="Cron表达式的格式："><a href="#Cron表达式的格式：" class="headerlink" title="Cron表达式的格式："></a>Cron表达式的格式：</h4><pre><code>秒 分 时 日 月 周 年(可选)。字段名                 允许的值                        允许的特殊字符秒                         0-59                               , – * /分                         0-59                               , – * /小时                   0-23                                 , – * /日                         1-31                               , – * ? / L W C月                         1-12 or JAN-DEC           , – * /周几                     1-7 or SUN-SAT             , – * ? / L C #      MON  FRI年 (可选字段)     empty, 1970-2099            , – * /“?”字符：表示不确定的值“,”字符：指定数个值“-”字符：指定一个值的范围“/”字符：指定一个值的增加幅度。n/m表示从n开始，每次增加m“L”字符：用在日表示一个月中的最后一天，用在周表示该月最后一个星期X“W”字符：指定离给定日期最近的工作日(周一到周五)“#”字符：表示该月第几个周X。6#3表示该月第3个周五Cron表达式范例：每隔5秒执行一次：*/5 * * * * ?每隔1分钟执行一次：0 */1 * * * ?每天23点执行一次：0 0 23 * * ?每天凌晨1点执行一次：0 0 1 * * ?每月1号凌晨1点执行一次：0 0 1 1 * ?每月最后一天23点执行一次：0 0 23 L * ?每周星期天凌晨1点实行一次：0 0 1 ? * L在26分、29分、33分执行一次：0 26,29,33 * * * ?每天的0点、13点、18点、21点都执行一次：0 0 0,13,18,21 * * ?</code></pre><h3 id="4-Calendar："><a href="#4-Calendar：" class="headerlink" title="4. Calendar："></a>4. Calendar：</h3><p>org.quartz.Calendar和java.util.Calendar不同， 它是一些日历特定时间点的集合（可以简单地将org.quartz.Calendar看作java.util.Calendar的集合——java.util.Calendar代表一个日历时间点，无特殊说明后面的Calendar即指org.quartz.Calendar）。 一个Trigger可以和多个Calendar关联， 以便排除或包含某些时间点。<br>假设，我们安排每周星期一早上10:00执行任务，但是如果碰到法定的节日，任务则不执行，这时就需要在Trigger触发机制的基础上使用Calendar进行定点排除。针对不同时间段类型，Quartz在org.quartz.impl.calendar包下提供了若干个Calendar的实现类，如AnnualCalendar、MonthlyCalendar、WeeklyCalendar分别针对每年、每月和每周进行定义；</p><h3 id="5-Scheduler："><a href="#5-Scheduler：" class="headerlink" title="5. Scheduler："></a>5. Scheduler：</h3><p>代表一个Quartz的独立运行容器， Trigger和JobDetail可以注册到Scheduler中， 两者在Scheduler中拥有各自的组及名称， 组及名称是Scheduler查找定位容器中某一对象的依据， Trigger的组及名称必须唯一， JobDetail的组和名称也必须唯一（但可以和Trigger的组和名称相同，因为它们是不同类型的）。Scheduler定义了多个接口方法， 允许外部通过组及名称访问和控制容器中Trigger和JobDetail。<br>Scheduler可以将Trigger绑定到某一JobDetail中， 这样当Trigger触发时， 对应的Job就被执行。一个Job可以对应多个Trigger， 但一个Trigger只能对应一个Job。可以通过SchedulerFactory创建一个Scheduler实例。Scheduler拥有一个SchedulerContext，它类似于ServletContext，保存着Scheduler上下文信息，Job和Trigger都可以访问SchedulerContext内的信息。SchedulerContext内部通过一个Map，以键值对的方式维护这些上下文数据，SchedulerContext为保存和获取数据提供了多个put()和getXxx()的方法。可以通过Scheduler# getContext()获取对应的SchedulerContext实例；</p><h3 id="6-ThreadPool："><a href="#6-ThreadPool：" class="headerlink" title="6. ThreadPool："></a>6. ThreadPool：</h3><p>Scheduler使用一个线程池作为任务运行的基础设施，任务通过共享线程池中的线程提高运行效率。<br>Job有一个StatefulJob子接口，代表有状态的任务，该接口是一个没有方法的标签接口，其目的是让Quartz知道任务的类型，以便采用不同的执行方案。无状态任务在执行时拥有自己的JobDataMap拷贝，对JobDataMap的更改不会影响下次的执行。而有状态任务共享共享同一个JobDataMap实例，每次任务执行对JobDataMap所做的更改会保存下来，后面的执行可以看到这个更改，也即每次执行任务后都会对后面的执行发生影响。<br>正因为这个原因，无状态的Job可以并发执行，而有状态的StatefulJob不能并发执行，这意味着如果前次的StatefulJob还没有执行完毕，下一次的任务将阻塞等待，直到前次任务执行完毕。有状态任务比无状态任务需要考虑更多的因素，程序往往拥有更高的复杂度，因此除非必要，应该尽量使用无状态的Job。<br>如果Quartz使用了数据库持久化任务调度信息，无状态的JobDataMap仅会在Scheduler注册任务时保持一次，而有状态任务对应的JobDataMap在每次执行任务后都会进行保存。<br>Trigger自身也可以拥有一个JobDataMap，其关联的Job可以通过JobExecutionContext#getTrigger().getJobDataMap()获取Trigger中的JobDataMap。不管是有状态还是无状态的任务，在任务执行期间对Trigger的JobDataMap所做的更改都不会进行持久，也即不会对下次的执行产生影响。<br>Quartz拥有完善的事件和监听体系，大部分组件都拥有事件，如任务执行前事件、任务执行后事件、触发器触发前事件、触发后事件、调度器开始事件、关闭事件等等，可以注册相应的监听器处理感兴趣的事件。<br>下图描述了Scheduler的内部组件结构，SchedulerContext提供Scheduler全局可见的上下文信息，每一个任务都对应一个JobDataMap，虚线表达的JobDataMap表示对应有状态的任务：</p><p>废话不多说， 上代码：</p><ol><li><p>最简单的Job代码(就打印Hello Quartz ！)：<br> package com.wenniuwuren.quartz;  </p><p> import org.quartz.Job;<br> import org.quartz.JobExecutionContext;<br> import org.quartz.JobExecutionException;  </p><p> public class HelloQuartz  implements Job {  </p><p> public void execute(JobExecutionContext arg0) throws JobExecutionException {  </p><pre><code>System.out.println(&quot;Hello Quartz !&quot;);                 </code></pre><p> }<br> }</p></li><li><p>设置触发器<br> package com.wenniuwuren.quartz;  </p><p> import org.quartz.CronScheduleBuilder;<br> import org.quartz.JobBuilder;<br> import org.quartz.JobDetail;<br> import org.quartz.Scheduler;<br> import org.quartz.SchedulerException;<br> import org.quartz.SchedulerFactory;<br> import org.quartz.SimpleScheduleBuilder;<br> import org.quartz.Trigger;<br> import org.quartz.TriggerBuilder;<br> import org.quartz.impl.StdSchedulerFactory;    </p><p> public class SchedulerTest {    </p><pre><code>public static void main(String[] args) throws InterruptedException {    //通过schedulerFactory获取一个调度器    SchedulerFactory schedulerfactory = new StdSchedulerFactory();    Scheduler scheduler=null;    try{        // 通过schedulerFactory获取一个调度器        scheduler = schedulerfactory.getScheduler();         // 创建jobDetail实例，绑定Job实现类         // 指明job的名称，所在组的名称，以及绑定job类        JobDetail job = JobBuilder.newJob(HelloQuartz.class).withIdentity(&quot;JobName&quot;, &quot;JobGroupName&quot;).build();         // 定义调度触发规则         // SimpleTrigger    //      Trigger trigger=TriggerBuilder.newTrigger().withIdentity(&quot;SimpleTrigger&quot;, &quot;SimpleTriggerGroup&quot;)     //                    .withSchedule(SimpleScheduleBuilder.repeatSecondlyForever(3).withRepeatCount(6))     //                    .startNow().build();         //  corn表达式  每五秒执行一次         Trigger trigger=TriggerBuilder.newTrigger().withIdentity(&quot;CronTrigger1&quot;, &quot;CronTriggerGroup&quot;)           .withSchedule(CronScheduleBuilder.cronSchedule(&quot;*/5 * * * * ?&quot;))           .startNow().build();          // 把作业和触发器注册到任务调度中        scheduler.scheduleJob(job, trigger);        // 启动调度        scheduler.start();        Thread.sleep(10000);      // 停止调度      scheduler.shutdown();   }catch(SchedulerException e){            e.printStackTrace();        }        }     }</code></pre><p>输出(设置了sleep10秒， 故在0秒调度一次， 5秒一次， 10秒最后一次)：</p></li></ol>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;Quartz-入门详解&quot;&gt;&lt;a href=&quot;#Quartz-入门详解&quot; class=&quot;headerlink&quot; title=&quot;Quartz 入门详解&quot;&gt;&lt;/a&gt;Quartz 入门详解&lt;/h1&gt;&lt;h2 id=&quot;入门简介：&quot;&gt;&lt;a href=&quot;#入门简介：&quot; class=&quot;headerlink&quot; title=&quot;入门简介：&quot;&gt;&lt;/a&gt;入门简介：&lt;/h2&gt;&lt;p&gt;基本上任何公司都会用到调度这个功能， 比如我们公司需要定期执行调度生成报表， 或者比如博客什么的定时更新之类的，都可以靠Quartz来完成。正如官网所说，小到独立应用大到大型电子商务网站， Quartz都能胜任。&lt;/p&gt;
    
    </summary>
    
      <category term="java" scheme="http://www.fashionkillyou.xyz/categories/java/"/>
    
    
      <category term="quarze" scheme="http://www.fashionkillyou.xyz/tags/quarze/"/>
    
  </entry>
  
  <entry>
    <title>Oracle知识点总结</title>
    <link href="http://www.fashionkillyou.xyz/2018/02/10/Oracle%E7%9F%A5%E8%AF%86%E7%82%B9%E6%80%BB%E7%BB%93/"/>
    <id>http://www.fashionkillyou.xyz/2018/02/10/Oracle知识点总结/</id>
    <published>2018-02-10T15:04:18.000Z</published>
    <updated>2018-03-16T17:47:50.545Z</updated>
    
    <content type="html"><![CDATA[<script src="\assets\js\APlayer.min.js"> </script><h1 id="ORACLE"><a href="#ORACLE" class="headerlink" title="ORACLE"></a>ORACLE</h1><h2 id="01-单表查询-简单条件和去重"><a href="#01-单表查询-简单条件和去重" class="headerlink" title="01.单表查询-简单条件和去重"></a>01.单表查询-简单条件和去重</h2><h3 id="Oracle-的简单查询和去重"><a href="#Oracle-的简单查询和去重" class="headerlink" title="Oracle 的简单查询和去重"></a>Oracle 的简单查询和去重</h3><p>（1）–精确查询</p><p>–需求：查询水表编号为 30408 的业主记录<br>select * from T_OWNERS where watermeter = ‘30408’;</p><p>（2）–模糊查询</p><p>–需求：查询业主名称包含“刘”的业主记录<br>select * from T_OWNERS where name like ‘%刘%’;<br><a id="more"></a>  </p><p>（3）–and 运算符</p><p>–需求：查询业主名称包含“刘”的并且门牌号包含 5 的业主记录<br>select * from T_OWNERS where name like ‘%刘%’ and housenumber like ‘%5%’;</p><p>（4）–or 运算符</p><p>–需求：查询业主名称包含“刘”的或者门牌号包含 5 的业主记录<br>select * from T_OWNERS where name like ‘%刘%’ or housenumber like ‘%5%’;</p><p>（5）–and 与 or 运算符混合使用</p><p>–需求：查询业主名称包含“刘”的或者门牌号包含 5 的业主记录，并且地址编号为 3 的记录。<br>select * from T_OWNERS where (name like ‘%刘%’ or housenumber like ‘%5%’) and addressid = 3</p><p>（6）–范围查询</p><p>–需求：查询台账记录中用水字数大于等于 10000，并且小于等于 20000 的记录我们可以用&gt;= 和&lt;=来实现，语句<br>select <em> from T_ACCOUNT where usenum&gt;=10000 and usenum &lt;=20000<br>select </em> from T_ACCOUNT where usenum between 10000 and 20000</p><p>（7）–空值查询</p><p>–需求：查询 T_PRICETABLE 表中 MAXNUM 为空的记录<br>select <em> from T_PRICETABLE where maxnum is null<br>–不为空<br>select </em> from T_PRICETABLE where maxnum is not null</p><p>（8）–去掉重复记录</p><p>–需求：查询业主表中的地址 ID,不重复显示<br>select distinct addressid from T_OWNERS  </p><h2 id="02-单表查询-排序和基于伪列查询（开发中经常用到必须掌握）"><a href="#02-单表查询-排序和基于伪列查询（开发中经常用到必须掌握）" class="headerlink" title="02.单表查询-排序和基于伪列查询（开发中经常用到必须掌握）"></a>02.单表查询-排序和基于伪列查询（开发中经常用到必须掌握）</h2><p>   要点：排序和伪列</p><p>（1）–排序查询</p><p>–需求：对 T_ACCOUNT 表按使用量进行升序排序(由小到大)<br>select <em> from T_ACCOUNT order by usenum asc –asc可以省略<br>–降序排序<br>–需求：对 T_ACCOUNT 表按使用量进行降序排序（由大到小）<br>select </em> from T_ACCOUNT order by usenum desc</p><p>可以通过数据库表中的多个字段来排序，要求：根据排序的前面字段，有重复，按照书写的顺序来进行排序的。例如： 对业主表，按照地址ID降序排列，地址一样，按照ID升序排列：<br>select * from T_OWNERS t order by t.addressid desc, t.id asc</p><p>（2）伪列：Oracle对每张表自动加上两列rowid和rownum成为伪列</p><p>rowid：存储的是物理地址，值是不重复的查询速度比较快<br>–伪列 rowid<br>select rowid,t.<em> from T_OWNERS t –如果想跟其他字段一起显示<br>select rowid from T_OWNERS –可以单独查询rowid<br>select rowid,t.</em> from T_OWNERS t where t.rowid = ‘AAAM1VAAGAAAABNAAA’     –可以根据条件查询</p><p>rownum：每张表Oracle自动给加上的一个序号。<br>–伪列rownum<br>select rownum,t.* from T_OWNERS t –如果想跟其他字段一起显示<br>select rownum from T_OWNERS –可以单独查询rownum</p><h1 id="03-单表查询-聚合统计"><a href="#03-单表查询-聚合统计" class="headerlink" title="03.单表查询-聚合统计"></a>03.单表查询-聚合统计</h1><p>要点：聚合统计</p><p>–聚合统计</p><p>（1）–求和 sum</p><p>–需求：统计 2012 年所有用户的用水量总和<br>select sum(usenum) from T_ACCOUNT where year = ‘2012’</p><p>（2）–求平均 avg</p><p>–需求：统计 2012 年所有用水量（字数）的平均值<br>select avg(usenum) from T_ACCOUNT where year = ‘2012’</p><p>（3）–求最大值 max</p><p>–需求：统计 2012 年最高用水量（字数）<br>select max(usenum) from T_ACCOUNT where year = ‘2012’</p><p>（4）–求最小值 min</p><p>–需求：统计 2012 年最低用水量（字数）<br>select min(usenum) from T_ACCOUNT where year = ‘2012’</p><p>（5）–统计记录个数 count</p><p>–需求：统计业主类型 ID 为 1 的业主数量<br>select count(*) from T_OWNERS where ownertypeid = 1</p><p>（6）– 分组聚合 Group by (select 后面一定是分组聚合的条件或者是聚合函数)</p><p>–需求：按区域分组统计水费合计数<br>select areaid,sum(money) from T_ACCOUNT group by areaid；</p><p>（7）– 分组后条件查询 having</p><p>–需求：查询水费合计大于 16900 的区域及水费合计<br>select areaid,sum(money) from T_ACCOUNT group by areaid having sum(money)&gt;169000<br>where和having区别？<br>    1.where 不能放在GROUP BY 后面<br>2.HAVING 是跟GROUP BY 连在一起用的，放在GROUP BY 后面，此时的作用相当于WHERE<br>3.WHERE 后面的条件中不能有聚集函数，比如SUM(),AVG()等，而HAVING 可以</p><h1 id="04-内连接"><a href="#04-内连接" class="headerlink" title="04.内连接"></a>04.内连接</h1><p>要点：内连接查询如果接到一个很复杂的查询需求，这里介绍的是如果分析一个复杂的查询需求。（重点要学习思路）<br>第一步: 找到所需信息所在的所有表<br>第二步: 描述各个表之间的关系(外键 = 主键)</p><p>（1）–多表内连接查询</p><p>–（1）需求：查询显示业主编号，业主名称，业主类型名称<br>select os.id 业主编号,os.name 业主名称,ot.name 业主类型<br>from T_OWNERS os,T_OWNERTYPE ot<br>where os.ownertypeid = ot.id</p><p>（2）–（2）需求：查询显示业主编号，业主名称、地址和业主类型<br>select ow.id 业主编号,ow.name 业主名称,ad.name 地址,ot.name 业主类型<br>from t_owners ow, t_ownertype ot,t_address ad<br>where ow.addressid = ad.id and ow.ownertypeid = ot.id</p><p>（3）–（3）需求：查询显示业主编号、业主名称、地址、所属区域、业主分类<br>select ow.id 业主编号,ow.name 业主名称,ad.name 地址,ar.name 所属区域,ot.name 业主类型<br>from t_owners ow, t_ownertype ot,t_address ad,t_area ar<br>where ow.addressid = ad.id and ow.ownertypeid = ot.id and ad.areaid = ar.id</p><p>（4）–（4）需求：查询显示业主编号、业主名称、地址、所属区域、收费员、业主分类<br>select ow.id 业主编号,ow.name 业主名称,ad.name 地址,ar.name 所属区域,op.name 收费员,ot.name 业主类型<br>from t_owners ow, t_ownertype ot,t_address ad,t_area ar,t_operator op<br>where ow.addressid = ad.id and ow.ownertypeid = ot.id and ad.areaid = ar.id and ad.operatorid = op.id</p><h1 id="05-外连接"><a href="#05-外连接" class="headerlink" title="05.外连接"></a>05.外连接</h1><p>要点：使用sql1999用法  xxx join  … on… 。<br>使用（+）这种写法，oracle数据库专用,移植到其他数据库中会报错。</p><p>（1）–左外连接查询：左边表所有数据全部查出来，右边的表没有匹配的数据显示空。<br>–需求：查询业主的账务记录，显示业主编号、名称、年、月、金额。如果此业主没有账务记录也要列出姓名。<br>–sql1999<br>select ow.id 业主编号,ow.name 业主名称,ac.year 年,ac.month 月,ac.money 金额<br>from t_owners ow left join  t_account ac<br>on ac.owneruuid= ow.id</p><p>–oracle的语法<br>select ow.id 业主编号,ow.name 业主名称,ac.year 年,ac.month 月,ac.money 金额<br>from t_owners ow , t_account ac<br>where ow.id=ac.owneruuid(+);<br>（2）–右外连接查询：右边表所有数据全部查出来，左边的表没有匹配的数据显示空。<br>–需求：查询业主的账务记录，显示业主编号、名称、年、月、金额。如果账务记录没有对应的业主信息，也要列出记录。<br>–sql1999<br>select ow.id 业主编号,ow.name 业主名称,ac.year 年,ac.month 月,ac.money 金额<br>from t_owners ow right join  t_account ac<br>on ac.ownerid = ow.id<br>–oracle的语法<br>select ow.id 业主编号,ow.name 业主名称,ac.year 年,ac.month 月,ac.money 金额<br>from t_owners ow , t_account ac<br>where ow.id(+) = ac.owneruuid;</p><h1 id="06-where子句中的子查询"><a href="#06-where子句中的子查询" class="headerlink" title="06.where子句中的子查询"></a>06.where子句中的子查询</h1><p>要点：单行子查询where条件后查询的结果只有一行适用于大于，小于，等于等等<br>多行子查询 where条件后查询的结果为多条或者一条，最常用的是in包含的意思。（现实开发经常遇到）</p><p>1、单行子查询<br>（1）–where 子句中的子查询<br>–需求：查询 2012 年 1 月用水量大于平均值的台账记录<br>–查询2012年1月平均用水量<br>select avg(usenum) from t_account  where year=’2012’ and month=’01’;</p><p>（2）–查询2012年1月用水量大于20009.5<br>select * from t_account  where year=’2012’ and month=’01’ and usenum&gt;20009.5;</p><p>（3）–需求：查询 2012 年 1 月用水量大于平均值的台账记录<br>select * from t_account  where year=’2012’ and month=’01’<br>and usenum&gt;(select avg(usenum) from t_account  where year=’2012’ and month=’01’)</p><p>2、多行子查询 in 运算符</p><p>–（1）需求：查询地址编号为 1 、3、4 的业主记录<br>select * from t_owners where addressid in(1,3,4);</p><p>–（2）需求：查询地址含有“花园”的业主的信息<br>–查询地址含有“花园”的地址编号<br>select id from t_address where name like ‘%花园%’</p><p>–最终结果<br>select * from t_owners where addressid in(select id from t_address where name like ‘%花园%’)</p><p>–（3）需求：查询地址不含有“花园”的业主的信息<br>select * from t_owners where addressid not in(select id from t_address where name like ‘%花园%’)</p><h1 id="07-from子句的子查询"><a href="#07-from子句的子查询" class="headerlink" title="07.from子句的子查询"></a>07.from子句的子查询</h1><p>要点：from后边的子查询当成一个表使用即可。</p><p>（1）–from 子句的子查询为多行子查询<br>–需求：查询显示业主编号，业主名称，业主类型名称，条件为业主类型为”居民”，使用子查询实现。<br>–内连接写法<br>select ow.id 业主编号,ow.name 业主名称,ot.name 业主类型<br>from t_owners ow,t_ownertype ot<br>where ow.ownertypeid = ot.id and ot.name = ‘居民’<br>（2）–子查询写法<br>select * from (<br>select ow.id 业主编号,ow.name 业主名称,ot.name 业主类型<br>from t_owners ow,t_ownertype ot<br>where ow.ownertypeid = ot.id<br>) where 业主类型 = ‘居民’</p><h1 id="08-select子句子查询（实际开发中经常遇到）"><a href="#08-select子句子查询（实际开发中经常遇到）" class="headerlink" title="08.select子句子查询（实际开发中经常遇到）"></a>08.select子句子查询（实际开发中经常遇到）</h1><p>要点：select子查询后边必须是查询单一字段。因为select后边都是单一的字段<br>（1）–select 子句中的子查询<br>–（1）需求：列出业主信息，包括 ID，名称，所属地址。<br>–内关联写法<br>1、如果只查询id、业主名称那只需要从业主表中进行查询。<br>2、现在我们想得到地址表的名称，那么我们就要到地址表中把名称查询出来。<br>画个表<br>select o.id,o.name,ad.name<br>from t_owners o,t_address ad<br>where o.addressid= ad.id</p><p>（2）–select子查询写法<br>select id,name,(select name from t_address where id=addressid) addressname<br>from t_owners</p><p>–（2）需求：列出业主信息，包括 ID，名称，所属地址，所属区域。<br>–内连接写法<br>select ow.id,ow.name 名称,ad.name 所属地址,ar.name 所属区域<br>from t_owners ow,t_address ad,t_area ar<br>where ow.addressid = ad.id and ad.areaid = ar.id<br>–select子查询写法<br>select id,name,<br>(select name from t_address where id=addressid) addressname,<br>(select (select name from t_area where id=areaid) from t_address where id=addressid) areaname<br>from t_owners;</p><h1 id="09-分页查询"><a href="#09-分页查询" class="headerlink" title="09.分页查询"></a>09.分页查询</h1><p>要点：</p><p>面试要点：oracle 和mysql分页<br>回答：oracle 用ruwnum三层嵌套，mysql 用limit进行分页。</p><p>（1）–需求：分页查询台账表 T_ACCOUNT，每页 10 条记录<br>–分析：我们在 ORACLE 进行分页查询，需要用到伪列 ROWNUM 和嵌套查询<br>–我们首先显示前 10 条记录<br>select rownum,t.* from t_account t where rownum&lt;=10</p><p>（2）–显示第二页10条内容<br>select <em> from (select rownum r,t.</em> from t_account t)<br>where r&gt;10 and r &lt;=20</p><p>（3）–需求：分页查询台账表 T_ACCOUNT，每页 10 条记录，按使用字数降序排序。<br>–我们查询第 2 页数据，如果基于上边的语句添加排序<br>select <em> from ( select rownum r,t.</em> from (select * from t_account  order by usenum desc) t )<br>where r&gt;10 and r &lt;=20</p><h1 id="10-字符函数"><a href="#10-字符函数" class="headerlink" title="10.字符函数"></a>10.字符函数</h1><pre><code>要点：伪表dual：Oracle提供用来测试函数的表</code></pre><p>（1）–（1）求字符串长度 LENGTH<br>select length(‘ABCD’) from dual;<br>（2）–求字符串子串(原字符串，从第几位截取，截取字符数)<br>select substr(‘ABCDEF’,2,2) from dual;</p><p>（3）–字符串拼接<br>select concat(‘ABC’,’D’) from dual;<br>–如果想继续拼接（不推荐使用）<br>select concat(concat(‘ABC’,’D’),’EF’) from dual;<br>–如果想继续拼接（推荐使用）<br>select ‘ABC’||’D’||’EF’ from dual;</p><p>–拼接查询的内容<br>select ow.name||’住在’||ad.name 信息 from t_owners ow,t_address ad where ow.addressid = ad.id;</p><h1 id="11-数值函数"><a href="#11-数值函数" class="headerlink" title="11.数值函数"></a>11.数值函数</h1><p>要点：数值函数常用的四舍五入（round），数字截取（trunc），求模（mod）<br>根据个人编程习惯采用数值函数。<br>（1）–四舍五入<br>select round(100.567,2) from dual;</p><p>（2）–数字截取<br>select trunc(100.567,2) from dual;<br>（3）–取模<br>select mod(10,3) from dual;</p><h1 id="12-日期函数"><a href="#12-日期函数" class="headerlink" title="12.日期函数"></a>12.日期函数</h1><pre><code>要点：日期函数实际开发中只有在特定的需求里会遇到。</code></pre><p>（1）–取系统当前日期<br>select sysdate from dual;<br>（2）–加月<br>select add_months(sysdate,2) from dual;<br>–减月<br>select add_months(sysdate,-2) from dual;<br>（3）–求当月最后一天<br>select last_day(sysdate) from dual;<br>select last_day(sysdate-4) from dual;<br>（4）–日期截取<br>select trunc(sysdate) from dual;–按日截取（把时间截掉）</p><p>select trunc(sysdate,’mm’) from dual;–按月截取（把日截掉）</p><p>select trunc(sysdate,’yyyy’) from dual;–按年截取</p><p>select trunc(sysdate,’hh’) from dual;–按小时截取</p><p>select trunc(sysdate,’mi’) from dual;–按分钟截取</p><p>–没有按秒截取</p><h1 id="13-转换函数"><a href="#13-转换函数" class="headerlink" title="13.转换函数"></a>13.转换函数</h1><p>要点：类似于Java语言的类型转换，特定需求下会使用数据库转换函数。<br>（1）–转换函数<br>–数字转换字符串<br>select to_char(100)||’分’ from dual;<br>select 100||’’ from dual;<br>（2）–日期转字符串<br>select to_char(sysdate,’yyyy-mm-dd’) from dual;<br>select to_char(sysdate,’yyyy’)||’年’||to_char(sysdate,’mm’)||’月’||to_char(sysdate,’dd’)||’日’ from dual;<br>select to_char(sysdate,’yyyy-mm-dd hh:mi:ss’) from dual;<br>（3）–字符串转日期<br>select to_date(‘2017-03-10’,’yyyy-mm-dd’) from dual;<br>（4）–字符串转数字<br>select to_number(‘100’)+10 from dual;<br>select ‘100’+0 from dual;<br>select ‘100’||0 from dual;–拼接后就变成字符串了</p><h1 id="14-其它函数"><a href="#14-其它函数" class="headerlink" title="14.其它函数"></a>14.其它函数</h1><p>要点：空值处理nvl对空值进行处理，nvl2可以转换类型。<br>条件判断decode可以根据检测的值不同，取得不同的结果。<br>case when then sql1999标准必须掌握实际开发会经常遇到。</p><p>–其他函数<br>（1）–空值处理<br>select nvl(null,0) from dual;<br>–显示价格表中业主类型ID为1的价格记录，如果上限值为NULL,则显示9999999<br>select nvl(maxnum,9999999) from t_pricetable where ownertypeid=1;<br>（2）–NVL2（检测的值，如果不为 null 的值，如果为 null 的值）；<br>select nvl2(null,0,100) from dual;–结果为100<br>select nvl2(20,0,100) from dual;–结果为0<br>–需求：显示价格表中业主类型 ID 为 1 的价格记录，如果上限值为 NULL,显示“不限”.<br>select nvl2(maxnum,to_char(maxnum),’不限’) from t_pricetable where ownertypeid=1;</p><p>（3）–（3）条件判断 decode<br>select decode(100,1,2,3,4,100,200,300,400) from dual;<br>–需求：显示下列信息（不要关联查询业主类型表，直接判断 1 2 3 的值）<br>select name,decode(ownertypeid,1,’居民’,2,’行政事业单位’,3,’商业’,’其他’) from t_owners;<br>（4）–case when then第一种写法 sql1999<br>select name,(case ownertypeid<br>                  when 1 then ‘居民’<br>                  when 2 then ‘行政事业’<br>                  when 3 then ‘商业’<br>                  else ‘其他’<br>             end )from t_owners;<br>–case when then第二种写法 sql1999（灵活）<br>select name,(case<br>                  when ownertypeid=1 then ‘居民’<br>                  when ownertypeid=2 then ‘行政事业’<br>                  when ownertypeid=3 then ‘商业’<br>                  else ‘其他’<br>             end )from t_owners;</p><h1 id="15-行列转换"><a href="#15-行列转换" class="headerlink" title="15.行列转换"></a>15.行列转换</h1><p>（1）–行列转换<br>–需求：按月份统计 2012 年各个地区的水费<br>select (select name from t_area where id=areaid) 区域,<br>     sum(case when month = ‘01’ then money else 0 end) 一月,<br>     sum(case when month = ‘02’ then money else 0 end) 二月,<br>     sum(case when month = ‘03’ then money else 0 end) 三月,<br>     sum(case when month = ‘04’ then money else 0 end) 四月,<br>     sum(case when month = ‘05’ then money else 0 end) 五月,<br>     sum(case when month = ‘06’ then money else 0 end) 六月,<br>     sum(case when month = ‘07’ then money else 0 end) 七月,<br>     sum(case when month = ‘08’ then money else 0 end) 八月,<br>     sum(case when month = ‘09’ then money else 0 end) 九月,<br>     sum(case when month = ‘10’ then money else 0 end) 十月,<br>     sum(case when month = ‘11’ then money else 0 end) 十一月,<br>     sum(case when month = ‘12’ then money else 0 end) 十二月<br>from t_account where year=’2012’ group by areaid;</p><p>（2）–需求：按季度统计 2012 年各个地区的水费<br>select (select name from t_area where id=areaid) 区域,<br>     sum(case when month &gt;= ‘01’ and month&lt;=’03’ then money else 0 end) 第一季度,<br>     sum(case when month &gt;= ‘04’ and month&lt;=’06’ then money else 0 end) 第二季度,<br>     sum(case when month &gt;= ‘07’ and month&lt;=’09’ then money else 0 end) 第三季度,<br>     sum(case when month &gt;= ‘10’ and month&lt;=’12’ then money else 0 end) 第四季度<br>from t_account where year=’2012’ group by areaid;</p><h1 id="16-分析函数"><a href="#16-分析函数" class="headerlink" title="16.分析函数"></a>16.分析函数</h1><p>（1）–分析函数<br>–值相同，排名相同，序号跳跃<br>select rank() over(order by usenum desc) 排名,t.<em> from t_account t<br>（2）–值相同，排名相同，序号连续<br>select dense_rank() over(order by usenum desc) 排名,t.</em> from t_account t<br>（3）–序号连续，不管值是否相同<br>select row_number() over(order by usenum desc) 排名,t.<em> from t_account t<br>（4）–用分析函数来实现分页<br>select </em> from<br>   (select row_number() over(order by usenum desc) rownumber,t.* from t_account t)<br>where rownumber&gt;10 and rownumber&lt;=20;</p><h1 id="17-集合运算"><a href="#17-集合运算" class="headerlink" title="17.集合运算"></a>17.集合运算</h1><p>（1）–集合运算<br>–并集（包括重复记录）</p><p>select <em> from t_owners where id&gt;5<br>union all<br>select </em> from t_owners where id&lt;8</p><p>（2）–并集（去掉重复记录）<br>select <em> from t_owners where id&gt;5<br>union<br>select </em> from t_owners where id&lt;8<br>（3）–交集（两个结果集的重复部分）</p><p>select <em> from t_owners where id&gt;5<br>intersect<br>select </em> from t_owners where id&lt;8</p><p>（4）–差集  返回的属于第一个集合但是不属于第二个集合的记录</p><p>select <em> from t_owners where id&gt;5<br>minus<br>select </em> from t_owners where id&lt;8</p><p>select <em> from t_owners where id&lt;8<br>minus<br>select </em> from t_owners where id&gt;5</p><p>（5）–差集分页<br>select rownum,t.<em> from t_account t where rownum&lt;=20<br>minus<br>select rownum,t.</em> from t_account t where rownum&lt;=10<br>总结<br>1、    oracle单表查询。<br>2、    oracle的多表连接查询。<br>3、    oracle的嵌套查询。<br>4、    oracle的基本函数。</p><h1 id="01-什么是视图"><a href="#01-什么是视图" class="headerlink" title="01.什么是视图"></a>01.什么是视图</h1><p>1、    要点：对sql语句的一种封装，它是一个虚拟的表。<br>2、    使用场景：对经常需要查询的数据，进行封装。<br>3、    优点：提高工作效率。     </p><h1 id="02-创建修改删除视图语法"><a href="#02-创建修改删除视图语法" class="headerlink" title="02.创建修改删除视图语法"></a>02.创建修改删除视图语法</h1><p>要点：创建视图的基本语法和删除视图。<br>1、CREATE [OR REPLACE] [FORCE] VIEW view_name<br>AS subquery<br>[WITH CHECK OPTION ]<br>[WITH READ ONLY]<br>REPLACE：删除已有视图，重新创建视图。<br>FORCE：不管基表是否存在，都会创建视图。<br>WITH CHECK OPTION：插入或修改的数据行必须满足视图定义的约束。<br>WITH READ ONLY：只读。</p><p>2、删除视图：DROP VIEW view_name</p><h1 id="03-视图案例-简单视图"><a href="#03-视图案例-简单视图" class="headerlink" title="03.视图案例-简单视图"></a>03.视图案例-简单视图</h1><p>要点：视图中查询的表称之为基表，修改视图实际就是在修改基表中的数据。视图在数据库中实际上就是一条sql语句，查询视图的数据实际就是在查询基表的数据。<br>1、–需求：创建视图 ：业主类型为 1 的业主信息<br>create view view_owners1 as<br>select <em> from t_owners where ownertypeid = 1;<br>2、–查询简单视图<br>select </em> from view_owners1 where addressid = 1;<br>3、–修改视图数据<br>update view_owners1 set name=’范小冰’ where id=1;<br>commit;<br>4、–查询表<br>select * from t_owners where ownertypeid = 1;</p><h1 id="04-视图案例-检查约束的视图"><a href="#04-视图案例-检查约束的视图" class="headerlink" title="04.视图案例-检查约束的视图"></a>04.视图案例-检查约束的视图</h1><p>要点：视图中添加with check option选项，无法修改视图中基表的条件字段。<br>1、–带检查约束的视图<br>–需求：根据地址表（T_ADDRESS）创建视图 VIEW_ADDRESS2 ,内容为区域 ID为 2 的记录。<br>create view view_address2 as<br>select * from t_address where areaid=2<br>with check option<br>2、–无法修改成功的语句，因为该视图的条件是areaid=2<br>update view_address2 set areaid=3 where id=4;<br>3、–可以修改成功的语句，因为条件不是areaid<br>update view_address2 set name=’河畔花园1’ where id=4;<br>commit;</p><h1 id="05-视图案例-只读视图"><a href="#05-视图案例-只读视图" class="headerlink" title="05.视图案例-只读视图"></a>05.视图案例-只读视图</h1><p>要点： 视图中添加or replace删除原有视图，重新创建视图，添加with read only视图只能查看不能修改。<br>1、–需求：将上边的视图修改为只读视图<br>create or replace view view_owners1 as<br>select * from t_owners where ownertypeid=1<br>with read only<br>2、–修改只读视图数据<br>update view_owners1 set name=’aaa’ where id=1;</p><h1 id="06-视图案例-带错误的视图"><a href="#06-视图案例-带错误的视图" class="headerlink" title="06.视图案例-带错误的视图"></a>06.视图案例-带错误的视图</h1><p>要点：视图中添加 force选项可以创建数据库中没有的表。<br>–创建带错误的视图<br>create force view view_test as<br>select * from t_test</p><h1 id="07-视图案例-多表关联的视图"><a href="#07-视图案例-多表关联的视图" class="headerlink" title="07.视图案例-多表关联的视图"></a>07.视图案例-多表关联的视图</h1><p>要点：复杂视图：视图的 SQL 语句中，有聚合函数或多表关联查询。<br>键保留表：把主键保留下来的那个表。<br>1、–创建视图，查询显示业主编号，业主名称，业主类型名称<br>create or replace view view_owners as<br>select ow.id 业主编号,ow.name 业主名称,ot.name 业主类型 from t_owners ow,t_ownertype ot<br>where ow.ownertypeid=ot.id<br>2、–查询复杂视图（多表关联）<br>select * from view_owners where 业主类型=’居民’;<br>3、–修改键保留表复杂视图（多表关联）的数据<br>update view_owners set 业主名称=’林玲玲’ where 业主编号=4;<br>commit;<br>4、–修改非键保留表复杂视图（多表关联）的数据<br>update view_owners set 业主类型=’商业’ where 业主编号=4;<br>–键保留表：把主键保留下来的那个表，并且能作为视图的主键</p><p>复杂视图(多表关联) 修改语句只能修改包含外键的表(t_owners-外键:t_ownertypeid)不管视图中是否包含T_owners的主键,都可以修改.提供外键的表t_ownertype不能修改.</p><h1 id="08-视图案例-聚合统计的视图"><a href="#08-视图案例-聚合统计的视图" class="headerlink" title="08.视图案例-聚合统计的视图"></a>08.视图案例-聚合统计的视图</h1><p>要点：聚合统计视图默认是只读，无法修改数据。<br>1、–需求：创建视图，按年月统计水费金额<br>create view view_accountsum as<br>select year,month,sum(money) money<br>from t_account<br>group by year,month<br>order by year,month<br>2、–查询视图<br>select * from view_accountsum where year=’2012’ and month=’03’<br>3、–不能修改<br>update view_accountsum set money=10000 where year=’2012’ and month=’03’</p><h1 id="09-物化视图-概念及语法"><a href="#09-物化视图-概念及语法" class="headerlink" title="09.物化视图-概念及语法"></a>09.物化视图-概念及语法</h1><p>要点：1、物化视图概念：将视图中查询出来的数据存储到一张表中。<br>2、优点：查询速度比视图要快。<br>3、缺点：占用资源，并且要时时更新数据。<br>4、创建物化视图<br>CREATE METERIALIZED VIEW view_name<br>[BUILD IMMEDIATE | BUILD DEFERRED ]<br>REFRESH [FAST|COMPLETE|FORCE]<br>[<br>ON [COMMIT |DEMAND ] | START WITH (start_time) NEXT<br>(next_time)<br>]<br>AS<br>Subquery<br>METERIALIZED:实体化。<br>BUILD IMMEDIATE: 创建物化视图的时候就生成数据。<br>BUILD DEFERRED: 创建物化视图的时候不生成数据。<br>默认为 BUILD IMMEDIATE<br>FAST：快速刷新，增量刷新。<br>COMPLETE：基表更新，删除物化视图数据，重新生成数据。<br>FORCE：自动选择，能增量刷新就增量，不能增量就完全刷新。<br>默认为FORCE<br>ON COMMIT：基表变化，物化视图就刷新。<br>ON DEMAND：手动刷新<br>默认：ON DEMAND</p><h1 id="10-物化视图案例-手动刷新的物化视图"><a href="#10-物化视图案例-手动刷新的物化视图" class="headerlink" title="10.物化视图案例-手动刷新的物化视图"></a>10.物化视图案例-手动刷新的物化视图</h1><p>要点：创建物化视图默认为手动刷新ON DEMAND，基表如果数据发生变化，物化视图中的表不会发生变化，需要手动进行刷新。<br>1、–需求：查询地址 ID,地址名称和所属区域名称<br>create materialized view view_address1 as<br>select ad.id,ad.name,ar.name arname<br>from t_address ad,t_area ar<br>where ad.areaid=ar.id<br>–删除物化视图<br>drop materialized view view_address1;<br>2、–物化视图一般以mv开头<br>create materialized view mv_address1 as<br>select ad.id,ad.name,ar.name arname<br>from t_address ad,t_area ar<br>where ad.areaid=ar.id<br>–查询物化视图<br>select <em> from mv_address1;<br>3、–向基表插入数据<br>insert into t_address values(8,’西三旗’,2,2);<br>commit;<br>–查询t_address<br>select </em> from t_address;<br>4、–执行刷新语句<br>begin<br>  DBMS_MVIEW.refresh(‘MV_ADDRESS1’,’C’);<br>end;<br>5、–向基表插入数据<br>insert into t_address values(9,’西四旗’,2,2);<br>commit;<br>6、命令窗口更新刷新数据<br>EXEC DBMS_MVIEW.refresh(‘MV_ADDRESS1’,’C’);</p><h1 id="11-物化视图案例-自动刷新的物化视图"><a href="#11-物化视图案例-自动刷新的物化视图" class="headerlink" title="11.物化视图案例-自动刷新的物化视图"></a>11.物化视图案例-自动刷新的物化视图</h1><p>1、–创建自动刷新的物化视图 -基表发生commit操作，自动刷新物化视图<br>create materialized view mv_address2<br>refresh<br>on commit<br>as<br>select ad.id,ad.name,ar.name arname<br>from t_address ad,t_area ar<br>where ad.areaid=ar.id<br>2、–向基表插入数据<br>insert into t_address values(10,’西5旗’,2,2);<br>commit;<br>3、–查询物化视图<br>select * from mv_address2;</p><h1 id="12-物化视图案例-创建时不生成数据的物化视图"><a href="#12-物化视图案例-创建时不生成数据的物化视图" class="headerlink" title="12.物化视图案例-创建时不生成数据的物化视图"></a>12.物化视图案例-创建时不生成数据的物化视图</h1><p>要点：增加build deferred创建物化视图时，视图表中不产生数据，需要手动刷新，如果增加on commit那么以后基表进行commit操作，物化视图为自动刷新。<br>1、–创建时不生成数据的物化视图<br>create materialized view mv_address3<br>build deferred<br>refresh<br>on commit<br>as<br>select ad.id,ad.name,ar.name arname<br>from t_address ad,t_area ar<br>where ad.areaid=ar.id<br>2、–查询物化视图<br>select * from mv_address3;<br>3、–向基表插入数据<br>insert into t_address values(11,’西6旗’,2,2);<br>commit;<br>4、–执行刷新语句(第一次必须手动执行刷新)<br>begin<br>  DBMS_MVIEW.refresh(‘MV_ADDRESS3’,’C’);<br>end;<br>5、–向基表插入数据<br>insert into t_address values(12,’西7旗’,2,2);<br>commit;</p><h1 id="13-物化视图案例-增量刷新的物化视图（了解）"><a href="#13-物化视图案例-增量刷新的物化视图（了解）" class="headerlink" title="13.物化视图案例-增量刷新的物化视图（了解）"></a>13.物化视图案例-增量刷新的物化视图（了解）</h1><p>1、–创建增量刷新的物化视图<br>–前提是必须创建物化视图日志：记录基表发生了哪些变化，用这些记录去更新物化视图<br>create materialized view log on t_address with rowid<br>create materialized view log on t_area with rowid<br>–创建物化视图中的语句，必须有基表的rowid<br>create materialized view mv_address4<br>refresh fast<br>as<br>select ad.rowid adrowid,ar.rowid arrowid,ad.id,ad.name,ar.name arname<br>from t_address ad,t_area ar<br>where ad.areaid=ar.id<br>2、–查询物化视图<br>select * from mv_address4;<br>–向基表插入数据<br>insert into t_address values(13,’西8旗’,2,2);<br>commit;<br>–向基表插入数据<br>insert into t_address values(14,’西9旗’,2,2);<br>commit;<br>–删除数据<br>delete from t_address where id=14;<br>commit;<br>3、–执行刷新语句<br>begin<br>  DBMS_MVIEW.refresh(‘MV_ADDRESS4’,’C’);<br>end;</p><h1 id="14-序列-什么是序列"><a href="#14-序列-什么是序列" class="headerlink" title="14.序列-什么是序列"></a>14.序列-什么是序列</h1><p>–创建简单序列<br>create sequence seq_test;<br>–查询序列的下一个值<br>select seq_test.nextval from dual;<br>–查询序列的当前值<br>select seq_test.currval from dual;</p><h1 id="15-序列-语法"><a href="#15-序列-语法" class="headerlink" title="15.序列-语法"></a>15.序列-语法</h1><h1 id="16-序列-案例"><a href="#16-序列-案例" class="headerlink" title="16.序列-案例"></a>16.序列-案例</h1><p>–有最大值的非循环序列<br>create sequence seq_test1<br>maxvalue 20;<br>–查询序列<br>select seq_test1.nextval from dual;<br>–自定义增长值<br>create sequence seq_test2<br>increment by 10<br>start with 10<br>maxvalue 100<br>–查询序列<br>select seq_test2.nextval from dual;</p><p>create sequence seq_test3<br>increment by 10<br>start with 10<br>minvalue 5<br>maxvalue 100<br>–查询序列<br>select seq_test3.nextval from dual;<br>–循环的序列<br>create sequence seq_test4<br>increment by 10<br>start with 10<br>minvalue 10<br>maxvalue 210<br>cycle</p><p>create sequence seq_test5<br>increment by 10<br>start with 10<br>minvalue 10<br>maxvalue 201<br>cycle<br>–查询序列<br>select seq_test4.nextval from dual;<br>select seq_test5.nextval from dual;</p><p>create sequence seq_test5<br>increment by 10<br>start with 10<br>minvalue 10<br>maxvalue 201<br>cycle<br>cache 5<br>–一次缓存数有多少 cache值*增长值   缓存的默认值是20,不设置的话cache为20<br>–一次循环的值不能小于 一次缓存的数<br>–开始值不能小于最小值</p><h1 id="17-同义词-概念"><a href="#17-同义词-概念" class="headerlink" title="17.同义词-概念"></a>17.同义词-概念</h1><p>2、语法：create [public] SYNONYM synooym for object;<br>加上public，数据库所有用户都可以访问别名。<br>不加public，只针对当前用户可以访问。</p><h1 id="18-同义词-案例"><a href="#18-同义词-案例" class="headerlink" title="18.同义词-案例"></a>18.同义词-案例</h1><p>–创建私有同义词<br>create synonym owner for t_owners;<br>select <em> from owner;<br>–dba超级管理员身份可以用system用户直接访问<br>select </em> from wateruser.t_owners;<br>–创建共有同义词<br>create public synonym owner2 for t_owners;<br>select * from owner2;</p><h1 id="19-索引-什么是索引"><a href="#19-索引-什么是索引" class="headerlink" title="19.索引-什么是索引"></a>19.索引-什么是索引</h1><p>要点：1、索引是用于加速数据存取的数据对象。<br>2、适用于百万以上数据。<br>3、优点：查询速度比较快。<br>4、缺点：占用资源比较大。</p><h1 id="20-索引-普通索引"><a href="#20-索引-普通索引" class="headerlink" title="20.索引-普通索引"></a>20.索引-普通索引</h1><p>要点：创建一个普通索引。<br>1、–创建普通索引<br>create index index_owners_name on t_owners(name);<br>select * from t_owners where name=’张哲’;<br>2、–性能测试 创建一个表，向表中插入100万条记录<br>create table t_indextest(id number,name varchar2(30));<br>begin<br>  for x in 1..1000000<br>    loop<br>      insert into t_indextest values(x,’aa’||x);<br>      end loop;<br>      commit;<br>end;<br>3、–创建索引<br>create index index_test on t_indextest(name);</p><p>select * from t_indextest where id=777777;</p><p>select t.rowid,t.* from t_indextest t where name=’aa777777’;</p><p>select * from t_indextest where rowid=’AAAM3NAAGAAAAkNACz’;</p><h1 id="21-索引-唯一索引和复合索引"><a href="#21-索引-唯一索引和复合索引" class="headerlink" title="21.索引-唯一索引和复合索引"></a>21.索引-唯一索引和复合索引</h1><p>要点：1、创建唯一索引：此列不能有重复字段。<br>2、复合索引要注意where条件的顺序是什么，创建复合索引的顺序就是什么。<br>–创建唯一索引<br>create unique index index_owners_meter on t_owners(watermeter);</p><p>select * from t_owners where addressid=1 and housenumber=’1-3’;<br>–创建复合索引<br>create index index_owners_ah on t_owners(addressid,housenumber);</p><h1 id="22-索引-反向键索引"><a href="#22-索引-反向键索引" class="headerlink" title="22.索引-反向键索引"></a>22.索引-反向键索引</h1><p>要点：当某个字段为连续增长的值，适合用反向键索引。<br>create index 索引名称 on 表名(列名) reverse;</p><p>普通索引和反向建索引统称b-tree-*索引</p><h1 id="23-索引-位图索引"><a href="#23-索引-位图索引" class="headerlink" title="23.索引-位图索引"></a>23.索引-位图索引</h1><p>要点：1、位图索引适合创建在低基数列上，比方说男、女或者颜色、56个民族等等。</p><p>2、语法：create bitmap index 索引名称 on 表名(列名);<br>3、需求：我们在T_owners表的ownertypeid列上建立位图索引。</p><p>   create bitmap index index_owners_typeid on t_owners(ownertypeid)<br>总结<br>（1）    Oracle的视图和物化视图。<br>（2）    Oracle的序列。<br>（3）    Oracle的同义词。<br>（4）    Oracle的索引。</p><h1 id="01-什么是PLSQL"><a href="#01-什么是PLSQL" class="headerlink" title="01.什么是PLSQL"></a>01.什么是PLSQL</h1><p>要点：1、plsql就是Oracle的一种编程语言。<br>2、语法：[declare<br>– 声明变量<br>]<br>begin<br>– 代码逻辑<br>[exception<br>– 异常处理<br>]<br>end;          </p><h1 id="02-变量声明与赋值"><a href="#02-变量声明与赋值" class="headerlink" title="02.变量声明与赋值"></a>02.变量声明与赋值</h1><p>  要点：1、如何声明变量。<br>2、如何赋值变量。<br>–声明变量水费单价、水费字数、吨数、金额。<br>–对水费单价、字数、进行赋值 。吨数根据水费字数换算，规则为水费字数除以<br>–1000，并且四舍五入，保留两位小数。计算金额，金额=单价<em>吨数。<br>–输出单价 、数量和金额。<br>declare<br> v_price number(10,2);–单价<br> v_usenum number;–水费字数<br> v_usenum2 number(10,2);–吨数<br> v_money number(10,2);–金额<br>begin<br>  v_price:=2.45;–单价赋值<br>  v_usenum:=9999;–水费字数<br>  v_usenum:=round(v_usenum/1000,2);–吨数<br>  v_money:=v_usenum</em>v_price;–金额<br>  dbms_output.put_line(‘金额：’||v_money);<br>  –DBMS.OUTPUT.put_line(‘金额：’||v_money);<br>end;</p><h1 id="03-变量select-into赋值"><a href="#03-变量select-into赋值" class="headerlink" title="03.变量select into赋值"></a>03.变量select into赋值</h1><p>要点：通过select into 将表中的数据赋值给变量，注意查询结果只能是一条记录。<br>declare<br> v_price number(10,2);–单价<br> v_usenum number;–水费字数<br> v_usenum2 number(10,2);–吨数<br> v_money number(10,2);–金额<br> v_num0 number;–上月水表数<br> v_num1 number;–本月水表数<br>begin<br>  v_price:=2.45;–单价赋值<br> – v_usenum:=9999;–水费字数<br> select usenum,num0,num1 into v_usenum,v_num0,v_num1 from t_account<br> where year=’2012’ and month=’01’ and owneruuid=1;<br>  v_usenum2:=round(v_usenum/1000,2);–吨数<br>  v_money:=v_usenum2*v_price;–金额<br>  dbms_output.put_line(‘水费字数：’||v_usenum||’金额：’||v_money);<br>  –DBMS.OUTPUT.put_line(‘金额：’||v_money);<br>end;</p><h1 id="04-属性类型"><a href="#04-属性类型" class="headerlink" title="04.属性类型"></a>04.属性类型</h1><p>要点：1、在变量较少的情况下，定义的变量是某个表的某列字段，可以采用 表名.字段名%type。<br>2、在变量较多的情况下，可以采用纪录型，把表名定义成变量 表名%rowtype。<br>–引用某表某列的字段类型<br>declare<br> v_price number(10,2);–单价<br> v_usenum t_account.usenum%type;–水费字数<br> v_usenum2 number(10,2);–吨数<br> v_money number(10,2);–金额<br> v_num0 t_account.num0%type;–上月水表数<br> v_num1 t_account.num1%type;–本月水表数<br>begin<br>  v_price:=2.45;–单价赋值<br> – v_usenum:=9999;–水费字数<br> select usenum,num0,num1 into v_usenum,v_num0,v_num1 from t_account<br> where year=’2012’ and month=’01’ and ownerid=1;<br>  v_usenum2:=round(v_usenum/1000,2);–吨数<br>  v_money:=v_usenum2*v_price;–金额<br>  dbms_output.put_line(‘水费字数：’||v_usenum||’金额：’||v_money);<br>  –DBMS.OUTPUT.put_line(‘金额：’||v_money);<br>end;<br>–属性类型（记录型 表名%rowtype）</p><p>declare<br> v_price number(10,2);–单价</p><p> v_usenum2 number(10,2);–吨数<br> v_money number(10,2);–金额<br> v_account t_account%rowtype;–台帐行记录类型<br>begin<br>  v_price:=2.45;–单价赋值<br> – v_usenum:=9999;–水费字数<br> select <em> into v_account from t_account<br> where year=’2012’ and month=’01’ and ownerid=1;<br>  v_usenum2:=round(v_account.usenum/1000,2);–吨数<br>  v_money:=v_usenum2</em>v_price;–金额<br>  dbms_output.put_line(‘水费字数：’||v_account.usenum||’金额：’||v_money);<br>  –DBMS.OUTPUT.put_line(‘金额：’||v_money);<br>end;</p><h1 id="05-异常"><a href="#05-异常" class="headerlink" title="05.异常"></a>05.异常</h1><p>要点：了解预定义异常用法即可。<br>–异常处理1<br>declare<br> v_price number(10,2);–单价<br> v_usenum2 number(10,2);–吨数<br> v_money number(10,2);–金额<br> v_account t_account%rowtype;–台帐行记录类型<br>begin<br>  v_price:=2.45;–单价赋值<br> – v_usenum:=9999;–水费字数<br> select <em> into v_account from t_account<br> where year=’2012’ and month=’01’ and ownerid=200;<br>  v_usenum2:=round(v_account.usenum/1000,2);–吨数<br>  v_money:=v_usenum2</em>v_price;–金额<br>  dbms_output.put_line(‘水费字数：’||v_account.usenum||’金额：’||v_money);<br>  exception<br>    when no_data_found then<br>      DBMS_OUTPUT.put_line(‘没有数据’);<br>end;<br>–异常处理2<br>declare<br> v_price number(10,2);–单价<br> v_usenum2 number(10,2);–吨数<br> v_money number(10,2);–金额<br> v_account t_account%rowtype;–台帐行记录类型<br>begin<br>  v_price:=2.45;–单价赋值<br> select <em> into v_account from t_account<br> where year=’2012’ ;<br>  v_usenum2:=round(v_account.usenum/1000,2);–吨数<br>  v_money:=v_usenum2</em>v_price;–金额<br>  dbms_output.put_line(‘水费字数：’||v_account.usenum||’金额：’||v_money);<br>  exception<br>    when no_data_found then<br>      DBMS_OUTPUT.put_line(‘没有数据’);<br>    when too_many_rows then<br>      DBMS_OUTPUT.put_line(‘返回多行’);<br>end;</p><h1 id="06-条件判断"><a href="#06-条件判断" class="headerlink" title="06.条件判断"></a>06.条件判断</h1><p>要点：了解plsql中的if、else判断语法。</p><p>declare<br> v_price1 number(10,2);–单价<br> v_price2 number(10,2);–单价<br> v_price3 number(10,2);–单价<br> v_usenum2 number(10,2);–吨数<br> v_money number(10,2);–金额<br> v_account t_account%rowtype;–台帐行记录类型<br>begin<br>  v_price1:=2.45;–单价赋值（5吨以下）<br>  v_price2:=3.45;–单价赋值（5-10吨）<br>  v_price3:=4.45;–单价赋值（超过10吨）<br> select <em> into v_account from t_account<br> where year=’2012’ and month=’01’ and ownerid=1;<br>  v_usenum2:=round(v_account.usenum/1000,2);–吨数<br>  –v_money:=v_usenum2</em>v_price;–金额<br>  –阶梯水费计算<br>  if v_usenum2&lt;=5 then<br>    v_money:=v_price1<em>v_usenum2;<br>  elsif v_usenum2&gt;5 and v_usenum2&lt;=10 then<br>    v_money:=v_price1</em>5+v_price2<em>(v_usenum2-5);<br>  else<br>    v_money:=v_price1</em>5+v_price2<em>5 + v_price3</em>(v_usenum2-10);<br>  end if;</p><p>  dbms_output.put_line(‘水费字数：’||v_account.usenum||’金额：’||v_money);<br>  exception<br>    when no_data_found then<br>      DBMS_OUTPUT.put_line(‘没有数据’);<br>    when too_many_rows then<br>      DBMS_OUTPUT.put_line(‘返回多行’);<br>end;</p><h1 id="07-循环"><a href="#07-循环" class="headerlink" title="07.循环"></a>07.循环</h1><p>要点：循环有三种无条件循环、有条件循环、和for循环。<br>–无条件循环：1到100<br>declare<br>   v_num number;<br>begin<br>  v_num:=1;<br>  loop<br>    dbms_output.put_line(v_num);<br>    v_num:=v_num+1;<br>    if v_num&gt;100 then<br>      exit;<br>      end if;<br>  end loop;<br>end;<br>–有条件循环1到100<br>declare<br>   v_num number;<br>begin<br>   v_num:=1;<br>   while v_num &lt;= 100<br>   loop<br>    dbms_output.put_line(v_num);<br>    v_num:=v_num+1;<br>   end loop;<br>end;<br>–for循环1到100<br>begin<br>  for v_num in 1 .. 100<br>  loop<br>    dbms_output.put_line(v_num);<br>  end loop;<br>end;</p><h1 id="08-游标语法"><a href="#08-游标语法" class="headerlink" title="08.游标语法"></a>08.游标语法</h1><p>要点：游标是系统为用户开设的一个数据缓冲区,存放 SQL 语句的执行结果。我们可以把游标理解为 PL/SQL 中的结果集。</p><h1 id="09-游标案例"><a href="#09-游标案例" class="headerlink" title="09.游标案例"></a>09.游标案例</h1><p>要点：创建游标后面跟着sql语句，然后打开游标循环游标的内容直到游标内容循环结束。关闭游标。<br>–需求：打印业主类型为 1 的价格表<br>declare<br>  cursor cur_pricetable is select * from t_pricetable where ownertypeid=1;–声明游标<br>  v_pricetable t_pricetable%rowtype;<br>begin<br>  open cur_pricetable;–打开游标<br>  loop<br>    fetch cur_pricetable into v_pricetable;–提取游标<br>    exit when cur_pricetable%notfound;–退出循环游标<br>    dbms_output.put_line(‘价格：’||v_pricetable.price||<br>    ‘ 吨位：’||v_pricetable.minnum||’-‘||v_pricetable.maxnum);<br>  end loop;<br>  close cur_pricetable;–关闭游标<br>end;</p><h1 id="10-带参数的游标"><a href="#10-带参数的游标" class="headerlink" title="10.带参数的游标"></a>10.带参数的游标</h1><pre><code>要点：与Java方法相似可以传递参数，声明游标在游标名称后面定义参数，sql语句中使用参数，打开游标时传递参数。</code></pre><p>–带参数的游标<br>declare<br>  cursor cur_pricetable(v_ownertype number) is select * from t_pricetable where ownertypeid=v_ownertype;–声明游标<br>  v_pricetable t_pricetable%rowtype;<br>begin<br>  open cur_pricetable(1);–打开游标<br>  loop<br>    fetch cur_pricetable into v_pricetable;–提取游标<br>    exit when cur_pricetable%notfound;–退出循环游标<br>    dbms_output.put_line(‘价格：’||v_pricetable.price||<br>    ‘ 吨位：’||v_pricetable.minnum||’-‘||v_pricetable.maxnum);<br>  end loop;<br>  close cur_pricetable;–关闭游标<br>end;         </p><h1 id="11-for循环游标"><a href="#11-for循环游标" class="headerlink" title="11.for循环游标"></a>11.for循环游标</h1><p>要点：for循环可以自动打开关闭游标，自动提取游标，而且还可以自动声明变量。<br>–for循环 带参数的游标<br>declare<br>  cursor cur_pricetable(v_ownertype number) is select * from t_pricetable where ownertypeid=v_ownertype;–声明游标<br>begin<br>  for v_pricetable in cur_pricetable(1)<br>  loop<br>    dbms_output.put_line(‘价格：’||v_pricetable.price||<br>    ‘ 吨位：’||v_pricetable.minnum||’-‘||v_pricetable.maxnum);<br>  end loop;<br>end;</p><h1 id="12-存储函数"><a href="#12-存储函数" class="headerlink" title="12.存储函数"></a>12.存储函数</h1><pre><code>要点：存储函数也叫自定义函数，可以接收一个或者多个参数，返回一个结果。类似于Java中的方法。</code></pre><p>1、语法<br>函数名称后面的参数类型不需要写长度大小<br>return 后面的参数也不需要写长度</p><p>2、案例<br>–需求： 创建存储函数，根据地址 ID 查询地址名称。<br>create or replace function fn_getaddress<br>(v_id number)<br>return varchar2<br>is<br>  v_name varchar2(30);<br>begin<br>  –查询地址表<br>  select name into v_name from t_address where id=v_id;<br>  return v_name;<br>end;<br>–存储函数测试<br>select fn_getaddress(3) from dual;<br>–存储函数的应用<br>–需求：查询业主 ID，业主名称，业主地址，业主地址使用刚才我们创建的函数来实现。<br>select id,name,fn_getaddress(addressid) from t_owners;</p><h1 id="13-存储过程-什么是存储过程"><a href="#13-存储过程-什么是存储过程" class="headerlink" title="13.存储过程-什么是存储过程"></a>13.存储过程-什么是存储过程</h1><p>要点：1、存储过程实际上就是供应用程序调用的一种数据函数对象。<br>2、存储函数与存储过程的区别：存储函数一般用来select查询，且返回的只有一个值，存储过程只能供应用程序调用可以返回多个值。且存储过程没有return返回值，可以通过参数设置一个或者多个返回值。<br>3、语法：<br>CREATE [ OR REPLACE ] PROCEDURE 存储过程名称<br>（参数名 类型, 参数名 类型, 参数名 类型）<br>IS|AS<br>变量声明部分;<br>BEGIN<br>逻辑部分<br>[EXCEPTION<br>异常处理部分]<br>END;<br>参数只指定类型，不指定长度<br>过程参数的三种模式：<br>IN 传入参数（默认）<br>OUT 传出参数 ，主要用于返回程序运行结果<br>IN OUT 传入传出参数</p><h1 id="14-不带传出参数的存储过程创建及调用"><a href="#14-不带传出参数的存储过程创建及调用" class="headerlink" title="14.不带传出参数的存储过程创建及调用"></a>14.不带传出参数的存储过程创建及调用</h1><p>要点：1、根据例子理解如何创建一个不带传出参数的存储过程。<br>2、根据例子理解如果用Oracle调用存储过程。</p><p>–创建业主序列起始值为11<br>create sequence seq_owners start with 11;<br>–不带传出参数的存储过程<br>create or replace procedure pro_owners_add<br>(<br>v_name varchar2,–名称<br>v_addressid number,–地址编号<br>v_housenumber varchar2,–门牌号<br>v_watermeter varchar2,–水表号<br>v_ownertype number–业主类型<br>)<br>is</p><p>begin<br>  insert into t_owners values(seq_owners.nextval,v_name,v_addressid,v_housenumber,v_watermeter,sysdate,v_ownertype);<br>  commit;<br>end;<br>–调用不带传出参数的存储过程<br>call pro_owners_add(‘马大哈’,2,’3232’,’22333’,1);</p><p>begin<br>  pro_owners_add(‘马2哈’,2,’32312’,’223331’,1);<br>end;</p><h1 id="15-JDBC调用不带传出参数的存储过程"><a href="#15-JDBC调用不带传出参数的存储过程" class="headerlink" title="15.JDBC调用不带传出参数的存储过程"></a>15.JDBC调用不带传出参数的存储过程</h1><p>要点：通过jdbc代码调用存储过程注意调用存储过程使用CallableStatement，sql语句中要用“{call 存储过程名称（？，？,…）}”。</p><h1 id="16-带传出参数的存储过程创建与调用"><a href="#16-带传出参数的存储过程创建与调用" class="headerlink" title="16.带传出参数的存储过程创建与调用"></a>16.带传出参数的存储过程创建与调用</h1><p>要点：1、根据例子理解如何创建一个带传出参数的存储过程。<br>2、根据例子理解如果用Oracle调用存储过程。</p><p>–创建带传出参数的存储过程<br>create or replace procedure pro_owners_add1<br>(<br>v_name varchar2,–名称<br>v_addressid number,–地址编号<br>v_housenumber varchar2,–门牌号<br>v_watermeter varchar2,–水表号<br>v_ownertypeid number,–业主类型<br>v_id out number<br>)<br>is</p><p>begin<br>  select seq_owners.nextval into v_id from dual;<br>  insert into t_owners values(v_id,v_name,v_addressid,v_housenumber,v_watermeter,sysdate,v_ownertypeid);<br>  commit;<br>end;<br>–调用传出参数的存储过程<br>declare<br>   v_id number;<br>begin<br>   pro_owners_add1(‘马3哈’,2,’32-32’,’2233312’,1,v_id);<br>   dbms_output.put_line(v_id);<br>end;</p><h1 id="17-JDBC调用带传出参数的存储过程"><a href="#17-JDBC调用带传出参数的存储过程" class="headerlink" title="17.JDBC调用带传出参数的存储过程"></a>17.JDBC调用带传出参数的存储过程</h1><p>要点：1、通过代码例子了解如何调用带传出参数的存储过程。<br>2、注意需要传出的参数要再执行sql语句之前注册类型，并且获得传出参数时要再执行完sql语句之后。</p><h1 id="18-什么是触发器"><a href="#18-什么是触发器" class="headerlink" title="18.什么是触发器"></a>18.什么是触发器</h1><p>要点：1、触发器：当一个指定的语句执行增删改的操作时。Oracle自动执行了触发器中自定义的数据库函数。<br>2、前置触发器：在增删改操作没有commit之前执行的触发器叫前置触发器。<br>3、后置触发器：在增删改操作commit之后执行的触发器叫后置触发器。</p><h1 id="19-触发器语法"><a href="#19-触发器语法" class="headerlink" title="19.触发器语法"></a>19.触发器语法</h1><p>要点：1、行级触发器：针对表中每行数据变化进行操作。<br>2、语句级触发器：针对每张表进行操作的触发器。<br>3、：old 修改前的数据。Update 和 delete。<br>4、：new 修改后的数据。Insert 和 update。</p><p>5、语法：<br>CREATE [or REPLACE] TRIGGER 触发器名<br>BEFORE | AFTER<br>[DELETE ][[or] INSERT] [[or]UPDATE [OF 列名]]<br>ON 表名<br>[FOR EACH ROW ][WHEN(条件) ]<br>declare<br>……<br>begin<br>PLSQL 块<br>End ；</p><h1 id="20-前置触发器"><a href="#20-前置触发器" class="headerlink" title="20.前置触发器"></a>20.前置触发器</h1><p>要点：根据例子理解如何创建前置触发器。<br>–需求：当用户输入本月累计表数后，自动计算出本月使用数 。<br>create or replace trigger tri_account_num1<br>before<br>update of num1<br>on t_account<br>for each row<br>declare</p><p>begin<br>  –通过伪记录变量修改usenum字段的值num1（水表现在的数值），num0（上个月使用的水表数）<br>  :new.usenum := :new.num1-:new.num0;<br>end;</p><h1 id="21-后置触发器"><a href="#21-后置触发器" class="headerlink" title="21.后置触发器"></a>21.后置触发器</h1><p>要点：根据例子理解如何创建后置触发器。<br>–需求：当用户修改了业主信息表的数据时记录修改前与修改后的值<br>–创建后置触发器日志表<br>create table t_owners_log(<br>updatetime date,<br>ownerid number,<br>oldname varchar2(30),<br>newname varchar2(30)<br>);<br>–根据需求创建后置触发器<br>create or replace trigger tri_owners_log<br>after<br>update of name<br>on t_owners<br>for each row<br>declare<br>begin<br>  –向日志表插入记录<br>  insert into t_owners_log values(sysdate,:new.id,:old.name,:new.name);<br>end;<br>–修改t_owners表中的name<br>update t_owners set name=’林玲玲1’ where id=4;</p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;ORACLE&quot;&gt;&lt;a href=&quot;#ORACLE&quot; class=&quot;headerlink&quot; title=&quot;ORACLE&quot;&gt;&lt;/a&gt;ORACLE&lt;/h1&gt;&lt;h2 id=&quot;01-单表查询-简单条件和去重&quot;&gt;&lt;a href=&quot;#01-单表查询-简单条件和去重&quot; class=&quot;headerlink&quot; title=&quot;01.单表查询-简单条件和去重&quot;&gt;&lt;/a&gt;01.单表查询-简单条件和去重&lt;/h2&gt;&lt;h3 id=&quot;Oracle-的简单查询和去重&quot;&gt;&lt;a href=&quot;#Oracle-的简单查询和去重&quot; class=&quot;headerlink&quot; title=&quot;Oracle 的简单查询和去重&quot;&gt;&lt;/a&gt;Oracle 的简单查询和去重&lt;/h3&gt;&lt;p&gt;（1）–精确查询&lt;/p&gt;
&lt;p&gt;–需求：查询水表编号为 30408 的业主记录&lt;br&gt;select * from T_OWNERS where watermeter = ‘30408’;&lt;/p&gt;
&lt;p&gt;（2）–模糊查询&lt;/p&gt;
&lt;p&gt;–需求：查询业主名称包含“刘”的业主记录&lt;br&gt;select * from T_OWNERS where name like ‘%刘%’;&lt;br&gt;
    
    </summary>
    
      <category term="数据库" scheme="http://www.fashionkillyou.xyz/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    
    
      <category term="oracle" scheme="http://www.fashionkillyou.xyz/tags/oracle/"/>
    
  </entry>
  
</feed>
