<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Fashionkillyou</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://www.fashionkillyou.xyz/"/>
  <updated>2018-03-25T07:57:50.974Z</updated>
  <id>http://www.fashionkillyou.xyz/</id>
  
  <author>
    <name>liuxinming</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>最近收集的前端素材,给大家分享一波~</title>
    <link href="http://www.fashionkillyou.xyz/2018/03/25/%E6%9C%80%E8%BF%91%E6%94%B6%E9%9B%86%E7%9A%84%E5%89%8D%E7%AB%AF%E7%B4%A0%E6%9D%90-%E7%BB%99%E5%A4%A7%E5%AE%B6%E5%88%86%E4%BA%AB%E4%B8%80%E6%B3%A2/"/>
    <id>http://www.fashionkillyou.xyz/2018/03/25/最近收集的前端素材-给大家分享一波/</id>
    <published>2018-03-25T07:51:23.000Z</published>
    <updated>2018-03-25T07:57:50.974Z</updated>
    
    <content type="html"><![CDATA[<script src="\assets\js\APlayer.min.js"> </script><p>最近发现一个很好的网站,给大家推广一下:</p><p><a href="http://www.17sucai.com/" title="http://www.17sucai.com/" target="_blank" rel="noopener">http://www.17sucai.com/</a></p><p>这个网站里面有很多分享的前端很好用的素材,只需要每天签到,连续签3天就可以获得一天时间的vip会员,能下载10个素材.</p><p>下面是我积累的一些素材,如果有需要可以到下面我分享的连接下载:</p><p><img src="http://p57l8frp4.bkt.clouddn.com/17%E7%B4%A0%E6%9D%901.jpg" alt=""></p><p><img src="http://p57l8frp4.bkt.clouddn.com/17%E7%B4%A0%E6%9D%902.jpg" alt=""></p><p>下载地址:</p><p>链接：<br><a href="https://pan.baidu.com/s/11lkX4ShzfQOxuo8os-Zo3w" target="_blank" rel="noopener">https://pan.baidu.com/s/11lkX4ShzfQOxuo8os-Zo3w</a></p><p>密码： 61ne</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;script src=&quot;\assets\js\APlayer.min.js&quot;&gt; &lt;/script&gt;&lt;p&gt;最近发现一个很好的网站,给大家推广一下:&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;http://www.17sucai.com/&quot; title=&quot;http://www.17sucai
      
    
    </summary>
    
      <category term="前端" scheme="http://www.fashionkillyou.xyz/categories/%E5%89%8D%E7%AB%AF/"/>
    
    
      <category term="素材" scheme="http://www.fashionkillyou.xyz/tags/%E7%B4%A0%E6%9D%90/"/>
    
  </entry>
  
  <entry>
    <title>FreeMarker模板引擎</title>
    <link href="http://www.fashionkillyou.xyz/2018/03/21/FreeMarker%E6%A8%A1%E6%9D%BF%E5%BC%95%E6%93%8E/"/>
    <id>http://www.fashionkillyou.xyz/2018/03/21/FreeMarker模板引擎/</id>
    <published>2018-03-21T11:53:33.000Z</published>
    <updated>2018-03-21T15:53:38.314Z</updated>
    
    <content type="html"><![CDATA[<script src="\assets\js\APlayer.min.js"> </script><h1 id="什么是-Freemarker"><a href="#什么是-Freemarker" class="headerlink" title="什么是 Freemarker"></a>什么是 Freemarker</h1><p>FreeMarker 是一个用 Java 语言编写的模板引擎，它基于模板来生成文本输出。FreeMarker与 Web 容器无关，即在 Web 运行时，它并不知道 Servlet 或 HTTP。它不仅可以用作表现层的实现技术，而且还可以用于生成 XML，JSP 或 Java 等。<br><a id="more"></a><br><img src="http://p57l8frp4.bkt.clouddn.com/freemarker1.png" alt=""></p><h1 id="Freemarker入门小DEMO"><a href="#Freemarker入门小DEMO" class="headerlink" title="Freemarker入门小DEMO"></a>Freemarker入门小DEMO</h1><h2 id="工程引入依赖"><a href="#工程引入依赖" class="headerlink" title="工程引入依赖"></a>工程引入依赖</h2><pre><code>&lt;dependency&gt;        &lt;groupId&gt;org.freemarker&lt;/groupId&gt;        &lt;artifactId&gt;freemarker&lt;/artifactId&gt;        &lt;version&gt;2.3.23&lt;/version&gt;&lt;/dependency&gt;  </code></pre><h2 id="创建模板文件"><a href="#创建模板文件" class="headerlink" title="创建模板文件"></a>创建模板文件</h2><p>模板文件中四种元素</p><p>  1、文本，直接输出的部分</p><p>  2、注释，即&lt;#–…–&gt;格式不会输出</p><p>  3、插值（Interpolation）：即${..}部分,将使用数据模型中的部分替代输出</p><p>  4、FTL指令：FreeMarker指令，和HTML标记类似，名字前加#予以区分，不会输出。</p><p>我们现在就创建一个简单的创建模板文件test.ftl</p><pre><code>&lt;html&gt;&lt;head&gt;    &lt;meta charset=&quot;utf-8&quot;&gt;    &lt;title&gt;Freemarker入门小DEMO &lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;#--我只是一个注释，我不会有任何输出  --&gt;${name},你好。${message}&lt;/body&gt;&lt;/html&gt;</code></pre><p>这里有文本、插值和注释</p><h2 id="生成文件"><a href="#生成文件" class="headerlink" title="生成文件"></a>生成文件</h2><p>使用步骤：</p><p>第一步：创建一个 Configuration 对象，直接 new 一个对象。构造方法的参数就是 freemarker的版本号。</p><p>第二步：设置模板文件所在的路径。</p><p>第三步：设置模板文件使用的字符集。一般就是 utf-8.</p><p>第四步：加载一个模板，创建一个模板对象。</p><p>第五步：创建一个模板使用的数据集，可以是 pojo 也可以是 map。一般是 Map。</p><p>第六步：创建一个 Writer 对象，一般创建一 FileWriter 对象，指定生成的文件名。</p><p>第七步：调用模板对象的 process 方法输出文件。</p><p>第八步：关闭流</p><p>代码：<br>创建Test类 main方法如下：</p><pre><code> //1.创建配置类Configuration configuration=new Configuration(Configuration.getVersion());//2.设置模板所在的目录 configuration.setDirectoryForTemplateLoading(new File(&quot;D:/pinyougou_work/freemarkerDemo/src/main/resources/&quot;));//3.设置字符集configuration.setDefaultEncoding(&quot;utf-8&quot;);//4.加载模板Template template = configuration.getTemplate(&quot;test.ftl&quot;);//5.创建数据模型Map map=new HashMap();map.put(&quot;name&quot;, &quot;张三 &quot;);map.put(&quot;message&quot;, &quot;欢迎来到神奇的品优购世界！&quot;);//6.创建Writer对象Writer out =new FileWriter(new File(&quot;d:\\test.html&quot;));//7.输出template.process(map, out);//8.关闭Writer对象out.close();</code></pre><p>执行后，在D盘根目录即可看到生成的test.html ，打开看看</p><h1 id="FTL指令"><a href="#FTL指令" class="headerlink" title="FTL指令"></a>FTL指令</h1><h2 id="assign指令"><a href="#assign指令" class="headerlink" title="assign指令"></a>assign指令</h2><p>此指令用于在页面上定义一个变量 </p><p>（1）定义简单类型：</p><pre><code>&lt;#assign linkman=&quot;周先生&quot;&gt;联系人：${linkman}</code></pre><p>（2）定义对象类型：</p><pre><code>&lt;#assign info={&quot;mobile&quot;:&quot;13301231212&quot;,&apos;address&apos;:&apos;北京市昌平区王府街&apos;} &gt;电话：${info.mobile}  地址：${info.address}</code></pre><h2 id="include指令"><a href="#include指令" class="headerlink" title="include指令"></a>include指令</h2><p>此指令用于模板文件的嵌套</p><p>创建模板文件head.ftl</p><pre><code>&lt;h1&gt;信息网&lt;/h1&gt;</code></pre><p>我们修改test.ftl，在模板文件中使用include指令引入刚才我们建立的模板</p><pre><code>&lt;#include &quot;head.ftl&quot;&gt;</code></pre><h2 id="if指令"><a href="#if指令" class="headerlink" title="if指令"></a>if指令</h2><p>在模板文件上添加</p><pre><code>&lt;#if success=true&gt;  你已通过实名认证&lt;#else&gt;    你未通过实名认证&lt;/#if&gt;</code></pre><p>在代码中对str变量赋值</p><pre><code>map.put(&quot;success&quot;, true);</code></pre><p>在freemarker的判断中，可以使用= 也可以使用== </p><h2 id="list指令"><a href="#list指令" class="headerlink" title="list指令"></a>list指令</h2><p>（1）代码中对变量goodsList赋值</p><pre><code>List goodsList=new ArrayList();Map goods1=new HashMap();goods1.put(&quot;name&quot;, &quot;苹果&quot;);goods1.put(&quot;price&quot;, 5.8);Map goods2=new HashMap();goods2.put(&quot;name&quot;, &quot;香蕉&quot;);goods2.put(&quot;price&quot;, 2.5);Map goods3=new HashMap();goods3.put(&quot;name&quot;, &quot;橘子&quot;);goods3.put(&quot;price&quot;, 3.2);goodsList.add(goods1);goodsList.add(goods2);goodsList.add(goods3);map.put(&quot;goodsList&quot;, goodsList);</code></pre><p>（2）在模板文件上添加</p><pre><code>----商品价格表----&lt;br&gt;&lt;#list goodsList as goods&gt;  ${goods_index+1} 商品名称： ${goods.name} 价格：${goods.price}&lt;br&gt;&lt;/#list&gt;</code></pre><p>如果想在循环中得到索引，使用循环变量+_index就可以得到。</p><h2 id="内建函数"><a href="#内建函数" class="headerlink" title="内建函数"></a>内建函数</h2><p>内建函数语法格式： 变量+?+函数名称  </p><h3 id="获取集合大小"><a href="#获取集合大小" class="headerlink" title="获取集合大小"></a>获取集合大小</h3><p>我们使用size函数来实现，代码如下：</p><pre><code>共  ${goodsList?size}  条记录</code></pre><h3 id="转换JSON字符串为对象"><a href="#转换JSON字符串为对象" class="headerlink" title="转换JSON字符串为对象"></a>转换JSON字符串为对象</h3><p>我们通常需要将json字符串转换为对象，那如何处理呢？看代码</p><pre><code>&lt;#assign text=&quot;{&apos;bank&apos;:&apos;工商银行&apos;,&apos;account&apos;:&apos;10101920201920212&apos;}&quot; /&gt;&lt;#assign data=text?eval /&gt;开户行：${data.bank}  账号：${data.account}</code></pre><h3 id="日期格式化"><a href="#日期格式化" class="headerlink" title="日期格式化"></a>日期格式化</h3><p>代码中对变量赋值：</p><pre><code>dataModel.put(&quot;today&quot;, new Date());</code></pre><p>在模板文件中加入</p><pre><code>当前日期：${today?date} &lt;br&gt;当前时间：${today?time} &lt;br&gt;   当前日期+时间：${today?datetime} &lt;br&gt;        日期格式化：  ${today?string(&quot;yyyy年MM月&quot;)}</code></pre><h3 id="数字转换为字符串"><a href="#数字转换为字符串" class="headerlink" title="数字转换为字符串"></a>数字转换为字符串</h3><p>代码中对变量赋值：</p><pre><code>map.put(&quot;point&quot;, 102920122);累计积分：${point}</code></pre><p>我们会发现数字会以每三位一个分隔符显示，有些时候我们不需要这个分隔符，就需要将数字转换为字符串,使用内建函数c</p><p>累计积分：${point?c}</p><h2 id="空值处理运算符"><a href="#空值处理运算符" class="headerlink" title="空值处理运算符"></a>空值处理运算符</h2><p>如果你在模板中使用了变量但是在代码中没有对变量赋值，那么运行生成时会抛出异常。但是有些时候，有的变量确实是null，怎么解决这个问题呢？</p><h3 id="判断某变量是否存在-“-”"><a href="#判断某变量是否存在-“-”" class="headerlink" title="判断某变量是否存在:“??”"></a>判断某变量是否存在:“??”</h3><p>用法为:variable??,如果该变量存在,返回true,否则返回false </p><pre><code>&lt;#if aaa??&gt;  aaa变量存在&lt;#else&gt;  aaa变量不存在&lt;/#if&gt;</code></pre><h3 id="缺失变量默认值-“-”"><a href="#缺失变量默认值-“-”" class="headerlink" title="缺失变量默认值:“!”"></a>缺失变量默认值:“!”</h3><p>我们除了可以判断是否为空值，也可以使用!对null值做转换处理<br>在模板文件中加入</p><pre><code>${aaa!&apos;-&apos;}</code></pre><p>在代码中不对aaa赋值，也不会报错了 ，当aaa为null则返回！后边的内容-</p><h2 id="运算符"><a href="#运算符" class="headerlink" title="运算符"></a>运算符</h2><h3 id="算数运算符"><a href="#算数运算符" class="headerlink" title="算数运算符"></a>算数运算符</h3><p>FreeMarker表达式中完全支持算术运算,FreeMarker支持的算术运算符包括:+, - , * , / , %</p><h3 id="逻辑运算符"><a href="#逻辑运算符" class="headerlink" title="逻辑运算符"></a>逻辑运算符</h3><p>逻辑运算符有如下几个: </p><p>逻辑与:&amp;&amp; </p><p>逻辑或:|| </p><p>逻辑非:! </p><p>逻辑运算符只能作用于布尔值,否则将产生错误 </p><h3 id="比较运算符"><a href="#比较运算符" class="headerlink" title="比较运算符"></a>比较运算符</h3><p>表达式中支持的比较运算符有如下几个:</p><p>1  =或者==:判断两个值是否相等. </p><p>2  !=:判断两个值是否不等. </p><p>3  &gt;或者gt:判断左边值是否大于右边值 </p><p>4  &gt;=或者gte:判断左边值是否大于等于右边值 </p><p>5  &lt;或者lt:判断左边值是否小于右边值</p><p>6  &lt;=或者lte:判断左边值是否小于等于右边值 </p><p>注意:  =和!=可以用于字符串,数值和日期来比较是否相等,但=和!=两边必须是相同类型的值,否则会产生错误,而且FreeMarker是精确比较,”x”,”x “,”X”是不等的.其它的运行符可以作用于数字和日期,但不能作用于字符串,大部分的时候,<strong>使用gt等字母运算符代替&gt;</strong>会有更好的效果,因为 FreeMarker会把&gt;解释成FTL标签的结束字符,当然,<strong>也可以使用括号来避免这种情况,如:&lt;#if (x&gt;y)&gt;</strong></p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;什么是-Freemarker&quot;&gt;&lt;a href=&quot;#什么是-Freemarker&quot; class=&quot;headerlink&quot; title=&quot;什么是 Freemarker&quot;&gt;&lt;/a&gt;什么是 Freemarker&lt;/h1&gt;&lt;p&gt;FreeMarker 是一个用 Java 语言编写的模板引擎，它基于模板来生成文本输出。FreeMarker与 Web 容器无关，即在 Web 运行时，它并不知道 Servlet 或 HTTP。它不仅可以用作表现层的实现技术，而且还可以用于生成 XML，JSP 或 Java 等。&lt;br&gt;
    
    </summary>
    
      <category term="java" scheme="http://www.fashionkillyou.xyz/categories/java/"/>
    
    
      <category term="FreeMarker" scheme="http://www.fashionkillyou.xyz/tags/FreeMarker/"/>
    
  </entry>
  
  <entry>
    <title>Solr搜索平台</title>
    <link href="http://www.fashionkillyou.xyz/2018/03/18/Solr%E6%90%9C%E7%B4%A2%E5%B9%B3%E5%8F%B0/"/>
    <id>http://www.fashionkillyou.xyz/2018/03/18/Solr搜索平台/</id>
    <published>2018-03-17T16:18:23.000Z</published>
    <updated>2018-03-19T06:10:43.789Z</updated>
    
    <content type="html"><![CDATA[<script src="\assets\js\APlayer.min.js"> </script><h1 id="Solr安装与配置"><a href="#Solr安装与配置" class="headerlink" title="Solr安装与配置"></a>Solr安装与配置</h1><h2 id="什么是Solr"><a href="#什么是Solr" class="headerlink" title="什么是Solr"></a>什么是Solr</h2><p>大多数搜索引擎应用都必须具有某种搜索功能，问题是搜索功能往往是巨大的资源消耗并且它们由于沉重的数据库加载而拖垮你的应用的性能。<br>这就是为什么转移负载到一个外部的搜索服务器是一个不错的主意，Apache Solr是一个流行的开源搜索服务器，它通过使用类似REST的HTTP API，这就确保你能从几乎任何编程语言来使用solr。<br><a id="more"></a><br>Solr是一个开源搜索平台，用于构建搜索应用程序。 它建立在Lucene(全文搜索引擎)之上。 Solr是企业级的，快速的和高度可扩展的。 使用Solr构建的应用程序非常复杂，可提供高性能。</p><p>为了在CNET网络的公司网站上添加搜索功能，Yonik Seely于2004年创建了Solr。并在2006年1月，它成为Apache软件基金会下的一个开源项目。并于2016年发布最新版本Solr 6.0，支持并行SQL查询的执行。</p><p>Solr可以和Hadoop一起使用。由于Hadoop处理大量数据，Solr帮助我们从这么大的源中找到所需的信息。不仅限于搜索，Solr也可以用于存储目的。像其他NoSQL数据库一样，它是一种非关系数据存储和处理技术。</p><p>总之，Solr是一个<strong>可扩展的，可部署，搜索/存储引擎，优化搜索大量以文本为中心的数据</strong>。</p><p>solr和Lucene的区别</p><pre><code>solr是基于Lucene的Lucene是一个全文检索工具包都是一些类库,只能java调用solr是个Apache开源顶级项目,一个服务平台,供不同的语言调用Lucene不支持数值范围的查询语法price:[100 To 200]solr支持数值范围的查询语法price:[100 To 200]</code></pre><h2 id="Solr安装"><a href="#Solr安装" class="headerlink" title="Solr安装"></a>Solr安装</h2><p>准备资料(包含solr、分词器、案例代码):</p><p>链接：<a href="https://pan.baidu.com/s/1JdTBbDyX9mWT2rWvatDdQg" target="_blank" rel="noopener">https://pan.baidu.com/s/1JdTBbDyX9mWT2rWvatDdQg</a> </p><p>密码：rcme</p><p>1：安装 Tomcat，解压缩即可。</p><p>2：解压 solr。</p><p>3：把 solr 下的dist目录solr-4.10.3.war部署到 Tomcat\webapps下(为了访问方便,去掉版本号)。</p><p>4：启动 Tomcat解压缩 war 包</p><p>5：把solr下example/lib/ext 目录下的所有的 jar 包，添加到 solr 的工程中(\WEB-INF\lib目录下)。</p><p>6：创建一个 solrhome 。solr 下的/example/solr 目录就是一个 solrhome。复制此目录到D盘改名为solrhome  </p><p>7：关联 solr 及 solrhome。需要修改 solr 工程的 web.xml 文件。(配置文件里面有只需解开注释然后修改成以下内容即可,如果只有war的话启动一下生成即可)</p><pre><code>&lt;env-entry&gt;   &lt;env-entry-name&gt;solr/home&lt;/env-entry-name&gt;   &lt;env-entry-value&gt;d:\solrhome&lt;/env-entry-value&gt;   &lt;env-entry-type&gt;java.lang.String&lt;/env-entry-type&gt;&lt;/env-entry&gt;</code></pre><p>8：启动 Tomcat(如果之前有了tomcat的话,这里必须要将端口号修改.然后访问自己配置的端口号即可)<br><a href="http://IP:8080/solr/" target="_blank" rel="noopener">http://IP:8080/solr/</a></p><h1 id="中文分析器IK-Analyzer"><a href="#中文分析器IK-Analyzer" class="headerlink" title="中文分析器IK Analyzer"></a>中文分析器IK Analyzer</h1><h2 id="IK-Analyzer简介"><a href="#IK-Analyzer简介" class="headerlink" title="IK Analyzer简介"></a>IK Analyzer简介</h2><p>IK Analyzer 是一个开源的，基亍 java 语言开发的轻量级的中文分词工具包。从 2006年 12 月推出 1.0 版开始， IKAnalyzer 已经推出了 4 个大版本。最初，它是以开源项目Luence 为应用主体的，结合词典分词和文法分析算法的中文分词组件。从 3.0 版本开始，IK 发展为面向 Java 的公用分词组件，独立亍 Lucene 项目，同时提供了对 Lucene 的默认优化实现。在 2012 版本中，IK 实现了简单的分词歧义排除算法，标志着 IK 分词器从单纯的词典分词向模拟语义分词衍化。</p><h2 id="IK-Analyzer配置"><a href="#IK-Analyzer配置" class="headerlink" title="IK Analyzer配置"></a>IK Analyzer配置</h2><p>步骤：<br>1、把IKAnalyzer2012FF_u1.jar 添加到 solr 工程的 lib 目录下</p><p>2、创建WEB-INF/classes文件夹  把扩展词典、停用词词典、配置文件放到 solr 工程的 WEB-INF/classes 目录下。</p><pre><code>(扩展词典、停用词词典、配置文件 ext_stopword.dic IKAnalyzer.cfg.xml  mydict.dic)</code></pre><p>3、修改 Solrhome 的collection1\conf\schema.xml 文件，配置一个 FieldType，使用 IKAnalyzer</p><pre><code>&lt;fieldType name=&quot;text_ik&quot; class=&quot;solr.TextField&quot;&gt;     &lt;analyzer class=&quot;org.wltea.analyzer.lucene.IKAnalyzer&quot;/&gt;&lt;/fieldType&gt;</code></pre><h3 id="配置域"><a href="#配置域" class="headerlink" title="配置域"></a>配置域</h3><p>域相当于数据库的表字段，用户存放数据，因此用户根据业务需要去定义相关的Field（域），一般来说，每一种对应着一种数据，用户对同一种数据进行相同的操作。</p><p>域的常用属性：</p><p>•    name：指定域的名称</p><p>•    type：指定域的类型</p><p>•    indexed：是否索引</p><p>•    stored：是否存储</p><p>•    required：是否必须</p><p>•    multiValued：是否多值</p><h4 id="域"><a href="#域" class="headerlink" title="域"></a>域</h4><p>修改solrhome的schema.xml 文件  设置业务系统 Field</p><pre><code>&lt;field name=&quot;item_goodsid&quot; type=&quot;long&quot; indexed=&quot;true&quot; stored=&quot;true&quot;/&gt;&lt;field name=&quot;item_title&quot; type=&quot;text_ik&quot; indexed=&quot;true&quot; stored=&quot;true&quot;/&gt;&lt;field name=&quot;item_price&quot; type=&quot;double&quot; indexed=&quot;true&quot; stored=&quot;true&quot;/&gt;&lt;field name=&quot;item_image&quot; type=&quot;string&quot; indexed=&quot;false&quot; stored=&quot;true&quot; /&gt;&lt;field name=&quot;item_category&quot; type=&quot;string&quot; indexed=&quot;true&quot; stored=&quot;true&quot; /&gt;&lt;field name=&quot;item_seller&quot; type=&quot;text_ik&quot; indexed=&quot;true&quot; stored=&quot;true&quot; /&gt;&lt;field name=&quot;item_brand&quot; type=&quot;string&quot; indexed=&quot;true&quot; stored=&quot;true&quot; /&gt;</code></pre><h4 id="复制域"><a href="#复制域" class="headerlink" title="复制域"></a>复制域</h4><p>复制域的作用在于将某一个Field中的数据复制到另一个域中(<strong>在电商项目的商品搜索中,设置这个复制域可以集成多个条件的查询,将其他域的数据集中到这一个item_keywords域中,方便查询</strong>)</p><pre><code>&lt;field name=&quot;item_keywords&quot; type=&quot;text_ik&quot; indexed=&quot;true&quot; stored=&quot;false&quot; multiValued=&quot;true&quot;/&gt;&lt;copyField source=&quot;item_title&quot; dest=&quot;item_keywords&quot;/&gt;&lt;copyField source=&quot;item_category&quot; dest=&quot;item_keywords&quot;/&gt;&lt;copyField source=&quot;item_seller&quot; dest=&quot;item_keywords&quot;/&gt;&lt;copyField source=&quot;item_brand&quot; dest=&quot;item_keywords&quot;/&gt;</code></pre><h4 id="动态域"><a href="#动态域" class="headerlink" title="动态域"></a>动态域</h4><p>当我们需要动态扩充字段时，我们需要使用动态域。<strong>对于电商项目，规格的值是不确定的，所以我们需要使用动态域来实现。</strong></p><p>配置：</p><pre><code>&lt;dynamicField name=&quot;item_spec_*&quot; type=&quot;string&quot; indexed=&quot;true&quot; stored=&quot;true&quot; /&gt;    </code></pre><h1 id="Spring-Data-Solr入门"><a href="#Spring-Data-Solr入门" class="headerlink" title="Spring Data Solr入门"></a>Spring Data Solr入门</h1><h2 id="Spring-Data-Solr简介"><a href="#Spring-Data-Solr简介" class="headerlink" title="Spring Data Solr简介"></a>Spring Data Solr简介</h2><p>虽然支持任何编程语言的能力具有很大的市场价值，你可能感兴趣的问题是：我如何将Solr的应用集成到Spring中？可以，Spring Data Solr就是为了方便Solr的开发所研制的一个框架，其底层是对SolrJ（官方API）的封装。</p><h2 id="Spring-Data-Solr入门小Demo"><a href="#Spring-Data-Solr入门小Demo" class="headerlink" title="Spring Data Solr入门小Demo"></a>Spring Data Solr入门小Demo</h2><p>(<strong>完整项目程序在上面的准备资料里面</strong>)</p><h3 id="搭建工程"><a href="#搭建工程" class="headerlink" title="搭建工程"></a>搭建工程</h3><p>（1）创建maven工程，pom.xml中引入依赖</p><pre><code> &lt;dependencies&gt;  &lt;dependency&gt;      &lt;groupId&gt;org.springframework.data&lt;/groupId&gt;      &lt;artifactId&gt;spring-data-solr&lt;/artifactId&gt;      &lt;version&gt;1.5.5.RELEASE&lt;/version&gt;  &lt;/dependency&gt;   &lt;dependency&gt;      &lt;groupId&gt;org.springframework&lt;/groupId&gt;      &lt;artifactId&gt;spring-test&lt;/artifactId&gt;      &lt;version&gt;4.2.4.RELEASE&lt;/version&gt;  &lt;/dependency&gt;  &lt;dependency&gt;      &lt;groupId&gt;junit&lt;/groupId&gt;      &lt;artifactId&gt;junit&lt;/artifactId&gt;      &lt;version&gt;4.9&lt;/version&gt;  &lt;/dependency&gt;&lt;/dependencies&gt;</code></pre><p>（2）在src/main/resources下创建  applicationContext-solr.xml</p><pre><code>&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot;    xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xmlns:p=&quot;http://www.springframework.org/schema/p&quot;    xmlns:context=&quot;http://www.springframework.org/schema/context&quot;    xmlns:solr=&quot;http://www.springframework.org/schema/data/solr&quot;    xsi:schemaLocation=&quot;http://www.springframework.org/schema/data/solr           http://www.springframework.org/schema/data/solr/spring-solr-1.0.xsd        http://www.springframework.org/schema/beans         http://www.springframework.org/schema/beans/spring-beans.xsd        http://www.springframework.org/schema/context         http://www.springframework.org/schema/context/spring-context.xsd&quot;&gt;    &lt;!-- solr服务器地址 --&gt;    &lt;solr:solr-server id=&quot;solrServer&quot; url=&quot;http://127.0.0.1:8080/solr&quot; /&gt;    &lt;!-- solr模板，使用solr模板可对索引库进行CRUD的操作 --&gt;    &lt;bean id=&quot;solrTemplate&quot; class=&quot;org.springframework.data.solr.core.SolrTemplate&quot;&gt;        &lt;constructor-arg ref=&quot;solrServer&quot; /&gt;    &lt;/bean&gt;&lt;/beans&gt;</code></pre><h3 id="Field-注解"><a href="#Field-注解" class="headerlink" title="@Field 注解"></a>@Field 注解</h3><p>创建 cn.lxm.pojo 包，创建TbItem实体类,属性使用@Field注解标识 。如果属性与配置文件定义的域名称不一致，需要在注解中指定域名称。</p><pre><code>public class TbItem implements Serializable{    @Field    private Long id;    @Field(&quot;item_title&quot;)    private String title;    @Field(&quot;item_price&quot;)private BigDecimal price;    @Field(&quot;item_image&quot;)    private String image;    @Field(&quot;item_goodsid&quot;)    private Long goodsId;    @Field(&quot;item_category&quot;)    private String category;    @Field(&quot;item_brand&quot;)    private String brand;    @Field(&quot;item_seller&quot;)private String seller;.......}</code></pre><h3 id="增加（修改）"><a href="#增加（修改）" class="headerlink" title="增加（修改）"></a>增加（修改）</h3><p>创建测试类TestTemplate.java</p><pre><code>@RunWith(SpringJUnit4ClassRunner.class)@ContextConfiguration(locations=&quot;classpath:applicationContext-solr.xml&quot;)public class TestTemplate {    @Autowired    private SolrTemplate solrTemplate;    @Test    public void testAdd(){        TbItem item=new TbItem();        item.setId(1L);        item.setBrand(&quot;华为&quot;);        item.setCategory(&quot;手机&quot;);        item.setGoodsId(1L);        item.setSeller(&quot;华为2号专卖店&quot;);        item.setTitle(&quot;华为Mate9&quot;);        item.setPrice(new BigDecimal(2000));                solrTemplate.saveBean(item);        solrTemplate.commit();    }}</code></pre><h3 id="按主键查询"><a href="#按主键查询" class="headerlink" title="按主键查询"></a>按主键查询</h3><pre><code>@Testpublic void testFindOne(){    TbItem item = solrTemplate.getById(1, TbItem.class);    System.out.println(item.getTitle());}</code></pre><h3 id="按主键删除"><a href="#按主键删除" class="headerlink" title="按主键删除"></a>按主键删除</h3><pre><code>@Testpublic void testDelete(){    solrTemplate.deleteById(&quot;1&quot;);    solrTemplate.commit();}</code></pre><h3 id="分页查询"><a href="#分页查询" class="headerlink" title="分页查询"></a>分页查询</h3><p>首先循环插入100条测试数据</p><pre><code>@Testpublic void testAddList(){    List&lt;TbItem&gt; list=new ArrayList();    for(int i=0;i&lt;100;i++){        TbItem item=new TbItem();        item.setId(i+1L);        item.setBrand(&quot;华为&quot;);        item.setCategory(&quot;手机&quot;);        item.setGoodsId(1L);        item.setSeller(&quot;华为2号专卖店&quot;);        item.setTitle(&quot;华为Mate&quot;+i);        item.setPrice(new BigDecimal(2000+i));            list.add(item);    }    solrTemplate.saveBeans(list);    solrTemplate.commit();}</code></pre><p>编写分页查询测试代码：</p><pre><code>@Testpublic void testPageQuery(){    Query query=new SimpleQuery(&quot;*:*&quot;);    query.setOffset(20);//开始索引（默认0）    query.setRows(20);//每页记录数(默认10)    ScoredPage&lt;TbItem&gt; page = solrTemplate.queryForPage(query, TbItem.class);    System.out.println(&quot;总记录数：&quot;+page.getTotalElements());    List&lt;TbItem&gt; list = page.getContent();    showList(list);}</code></pre><p>公共代码遍历循环显示查询结果:</p><pre><code>//显示记录数据private void showList(List&lt;TbItem&gt; list){            for(TbItem item:list){        System.out.println(item.getTitle() +item.getPrice());    }        }</code></pre><h3 id="条件查询"><a href="#条件查询" class="headerlink" title="条件查询"></a>条件查询</h3><p> Criteria 用于对条件的封装：</p><pre><code>@Testpublic void testPageQueryMutil(){        Query query=new SimpleQuery(&quot;*:*&quot;);    Criteria criteria=new Criteria(&quot;item_title&quot;).contains(&quot;2&quot;);    criteria=criteria.and(&quot;item_title&quot;).contains(&quot;5&quot;);            query.addCriteria(criteria);    //query.setOffset(20);//开始索引（默认0）    //query.setRows(20);//每页记录数(默认10)    ScoredPage&lt;TbItem&gt; page = solrTemplate.queryForPage(query, TbItem.class);    System.out.println(&quot;总记录数：&quot;+page.getTotalElements());    List&lt;TbItem&gt; list = page.getContent();    showList(list);}</code></pre><h3 id="删除全部数据"><a href="#删除全部数据" class="headerlink" title="删除全部数据"></a>删除全部数据</h3><pre><code>@Testpublic void testDeleteAll(){    Query query=new SimpleQuery(&quot;*:*&quot;);    solrTemplate.delete(query);    solrTemplate.commit();}</code></pre><h3 id="描述-设置高亮显示"><a href="#描述-设置高亮显示" class="headerlink" title="描述 设置高亮显示"></a>描述 设置高亮显示</h3><pre><code>@Testpublic void testHighLight(){    HighlightQuery query = new SimpleHighlightQuery();    //设置高亮的域    HighlightOptions highlightOptions = new HighlightOptions().addField(&quot;item_title&quot;);    //设置高亮显示的前缀    highlightOptions.setSimplePrefix(&quot;&lt;em style=&apos;color:red&apos;&quot;);    //设置高亮显示的后缀    highlightOptions.setSimplePostfix(&quot;&lt;/em&gt;&quot;);    //设置高亮选项    query.setHighlightOptions(highlightOptions);    //设置查询条件    Criteria criteria = new Criteria(&quot;item_title&quot;).contains(&quot;手机&quot;);    query.addCriteria(criteria);    HighlightPage&lt;TbItem&gt; page = solrTemplate.queryForHighlightPage(query, TbItem.class);    //循环高亮入口集合    for (HighlightEntry&lt;TbItem&gt; h : page.getHighlighted()) {        //获取原实体类        TbItem item = h.getEntity();        if(h.getHighlights().size()&gt;0 &amp;&amp; h.getHighlights().get(0).getSnipplets().size()&gt;0){            //设置高亮的结果            item.setTitle(h.getHighlights().get(0).getSnipplets().get(0));        }    }    System.out.println(&quot;总记录数：&quot;+page.getTotalElements());    List&lt;TbItem&gt; list = page.getContent();    showList(list);}</code></pre><h3 id="描述-分组查询"><a href="#描述-分组查询" class="headerlink" title="描述 分组查询"></a>描述 分组查询</h3><p>注意这里的测试数据的分组查询结果只有手机一项,可以自行添加索引库中item_category这一项的值</p><pre><code>@Testpublic void testFindForGroup(){    List&lt;String&gt; list=new ArrayList();    Query query=new SimpleQuery();    //按照关键字查询    Criteria criteria=new Criteria(&quot;item_keywords&quot;).is(&quot;三星&quot;);    query.addCriteria(criteria);    //设置分组选项    GroupOptions groupOptions=new GroupOptions().addGroupByField(&quot;item_category&quot;);    query.setGroupOptions(groupOptions);    //得到分组页    GroupPage&lt;TbItem&gt; page = solrTemplate.queryForGroupPage(query, TbItem.class);    //根据列得到分组结果集    GroupResult&lt;TbItem&gt; groupResult = page.getGroupResult(&quot;item_category&quot;);    //得到分组结果入口页    Page&lt;GroupEntry&lt;TbItem&gt;&gt; groupEntries = groupResult.getGroupEntries();    //得到分组入口集合    List&lt;GroupEntry&lt;TbItem&gt;&gt; content = groupEntries.getContent();    for(GroupEntry&lt;TbItem&gt; entry:content){        list.add(entry.getGroupValue());//将分组结果的名称封装到返回值中    }    for (String s : list) {        System.out.println(s);    }}</code></pre>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;Solr安装与配置&quot;&gt;&lt;a href=&quot;#Solr安装与配置&quot; class=&quot;headerlink&quot; title=&quot;Solr安装与配置&quot;&gt;&lt;/a&gt;Solr安装与配置&lt;/h1&gt;&lt;h2 id=&quot;什么是Solr&quot;&gt;&lt;a href=&quot;#什么是Solr&quot; class=&quot;headerlink&quot; title=&quot;什么是Solr&quot;&gt;&lt;/a&gt;什么是Solr&lt;/h2&gt;&lt;p&gt;大多数搜索引擎应用都必须具有某种搜索功能，问题是搜索功能往往是巨大的资源消耗并且它们由于沉重的数据库加载而拖垮你的应用的性能。&lt;br&gt;这就是为什么转移负载到一个外部的搜索服务器是一个不错的主意，Apache Solr是一个流行的开源搜索服务器，它通过使用类似REST的HTTP API，这就确保你能从几乎任何编程语言来使用solr。&lt;br&gt;
    
    </summary>
    
      <category term="搜索解决方案" scheme="http://www.fashionkillyou.xyz/categories/%E6%90%9C%E7%B4%A2%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88/"/>
    
    
      <category term="Solr" scheme="http://www.fashionkillyou.xyz/tags/Solr/"/>
    
      <category term="Spring Data Solr" scheme="http://www.fashionkillyou.xyz/tags/Spring-Data-Solr/"/>
    
  </entry>
  
  <entry>
    <title>Spring-Data-Redis总结</title>
    <link href="http://www.fashionkillyou.xyz/2018/03/15/Spring-Data-Redis%E6%80%BB%E7%BB%93/"/>
    <id>http://www.fashionkillyou.xyz/2018/03/15/Spring-Data-Redis总结/</id>
    <published>2018-03-15T09:57:36.000Z</published>
    <updated>2018-03-15T10:41:30.477Z</updated>
    
    <content type="html"><![CDATA[<script src="\assets\js\APlayer.min.js"> </script><h1 id="什么是Redis"><a href="#什么是Redis" class="headerlink" title="什么是Redis"></a>什么是Redis</h1><p>redis是一个非关系型Key-Value数据库,运行在内存中,由ANSI C编写。企业开发通常采用Redis来实现缓存。同类的产品还有memcache 、memcached 、MongoDB等。</p><a id="more"></a><h1 id="什么是Jedis"><a href="#什么是Jedis" class="headerlink" title="什么是Jedis"></a>什么是Jedis</h1><p>Jedis是Redis官方推出的一款面向Java的客户端，提供了很多接口供Java语言调用。可以在Redis官网下载，当然还有一些开源爱好者提供的客户端，如Jredis、SRP等等，推荐使用Jedis。</p><h1 id="Spring-Data-Redis"><a href="#Spring-Data-Redis" class="headerlink" title="Spring Data Redis"></a>Spring Data Redis</h1><p>Spring-data-redis是spring大家族的一部分，提供了在srping应用中通过简单的配置访问redis服务，对reids底层开发包(Jedis,  JRedis, and RJC)进行了高度封装，RedisTemplate提供了redis各种操作、异常处理及序列化，支持发布订阅，并对spring 3.1 cache进行了实现。<br>spring-data-redis针对jedis提供了如下功能：</p><p>1.连接池自动管理，提供了一个高度封装的“RedisTemplate”类</p><p>2.针对jedis客户端中大量api进行了归类封装,将同一类型操作封装为operation接口</p><pre><code>ValueOperations：简单K-V操作SetOperations：set类型数据操作ZSetOperations：zset类型数据操作HashOperations：针对map类型的数据操作ListOperations：针对list类型的数据操作</code></pre><h1 id="使用spring-data-redis"><a href="#使用spring-data-redis" class="headerlink" title="使用spring-data-redis"></a>使用spring-data-redis</h1><h2 id="准备工作"><a href="#准备工作" class="headerlink" title="准备工作:"></a>准备工作:</h2><h3 id="1-构建maven工程-步骤略-如果已有请忽略"><a href="#1-构建maven工程-步骤略-如果已有请忽略" class="headerlink" title="1.构建maven工程(步骤略,如果已有请忽略)"></a>1.构建maven工程(步骤略,如果已有请忽略)</h3><h3 id="2-引入spring相关依赖-引入junit依赖-步骤略-如果已有请忽略"><a href="#2-引入spring相关依赖-引入junit依赖-步骤略-如果已有请忽略" class="headerlink" title="2.引入spring相关依赖,引入junit依赖(步骤略,如果已有请忽略)"></a>2.引入spring相关依赖,引入junit依赖(步骤略,如果已有请忽略)</h3><h3 id="3-引入jedis和SpringDataRedis依赖"><a href="#3-引入jedis和SpringDataRedis依赖" class="headerlink" title="3.引入jedis和SpringDataRedis依赖"></a>3.引入jedis和SpringDataRedis依赖</h3><pre><code>&lt;!-- 缓存 --&gt;&lt;dependency&gt;           &lt;groupId&gt;redis.clients&lt;/groupId&gt;           &lt;artifactId&gt;jedis&lt;/artifactId&gt;           &lt;version&gt;2.8.1&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt;           &lt;groupId&gt;org.springframework.data&lt;/groupId&gt;           &lt;artifactId&gt;spring-data-redis&lt;/artifactId&gt;           &lt;version&gt;1.7.2.RELEASE&lt;/version&gt; &lt;/dependency&gt;</code></pre><h3 id="4-在src-main-resource下创建properties文件夹-建立redis-config-properties"><a href="#4-在src-main-resource下创建properties文件夹-建立redis-config-properties" class="headerlink" title="4.在src/main/resource下创建properties文件夹,建立redis-config.properties"></a>4.在src/main/resource下创建properties文件夹,建立redis-config.properties</h3><p>redis.host用来设置服务器地址</p><p>redis.port用来设置端口号</p><pre><code>redis.host=127.0.0.1 redis.port=6379 redis.pass= redis.database=0 redis.maxIdle=300 redis.maxWait=3000 redis.testOnBorrow=true</code></pre><h3 id="5-在src-main-resources下创建spring文件夹-，创建applicationContext-redis-xml"><a href="#5-在src-main-resources下创建spring文件夹-，创建applicationContext-redis-xml" class="headerlink" title="5.在src/main/resources下创建spring文件夹 ，创建applicationContext-redis.xml"></a>5.在src/main/resources下创建spring文件夹 ，创建applicationContext-redis.xml</h3><pre><code>&lt;context:property-placeholder location=&quot;classpath*:properties/*.properties&quot; /&gt;   &lt;!-- redis 相关配置 --&gt; &lt;bean id=&quot;poolConfig&quot; class=&quot;redis.clients.jedis.JedisPoolConfig&quot;&gt;   &lt;property name=&quot;maxIdle&quot; value=&quot;${redis.maxIdle}&quot; /&gt;    &lt;property name=&quot;maxWaitMillis&quot; value=&quot;${redis.maxWait}&quot; /&gt;   &lt;property name=&quot;testOnBorrow&quot; value=&quot;${redis.testOnBorrow}&quot; /&gt;  &lt;/bean&gt;  &lt;bean id=&quot;JedisConnectionFactory&quot; class=&quot;org.springframework.data.redis.connection.jedis.JedisConnectionFactory&quot;    p:host-name=&quot;${redis.host}&quot; p:port=&quot;${redis.port}&quot; p:password=&quot;${redis.pass}&quot; p:pool-config-ref=&quot;poolConfig&quot;/&gt;  &lt;bean id=&quot;redisTemplate&quot; class=&quot;org.springframework.data.redis.core.RedisTemplate&quot;&gt;   &lt;property name=&quot;connectionFactory&quot; ref=&quot;JedisConnectionFactory&quot; /&gt;  &lt;/bean&gt;</code></pre><p>maxIdle ：最大空闲数</p><p>maxWaitMillis:连接时的最大等待毫秒数</p><p>testOnBorrow：在提取一个jedis实例时，是否提前进行验证操作；如果为true，则得到的jedis实例均是可用的</p><h1 id="测试"><a href="#测试" class="headerlink" title="测试"></a>测试</h1><p>这里只写常用的hash和String两种类型的数据CRUD</p><h2 id="String"><a href="#String" class="headerlink" title="String:"></a>String:</h2><pre><code>@RunWith(SpringJUnit4ClassRunner.class)@ContextConfiguration(locations=&quot;classpath:spring/applicationContext-redis.xml&quot;)public class TestValue {    @Autowired    private RedisTemplate redisTemplate;        @Test    public void setValue(){        redisTemplate.boundValueOps(&quot;name&quot;).set(&quot;itcast&quot;);            }        @Test    public void getValue(){        String str = (String) redisTemplate.boundValueOps(&quot;name&quot;).get();        System.out.println(str);    }        @Test    public void deleteValue(){        redisTemplate.delete(&quot;name&quot;);;    }    }</code></pre><h2 id="Hash类型操作"><a href="#Hash类型操作" class="headerlink" title="Hash类型操作"></a>Hash类型操作</h2><p>创建测试类TestHash</p><p>（1）存入值</p><pre><code>@Testpublic void testSetValue(){    redisTemplate.boundHashOps(&quot;namehash&quot;).put(&quot;a&quot;, &quot;唐僧&quot;);    redisTemplate.boundHashOps(&quot;namehash&quot;).put(&quot;b&quot;, &quot;悟空&quot;);    redisTemplate.boundHashOps(&quot;namehash&quot;).put(&quot;c&quot;, &quot;八戒&quot;);    redisTemplate.boundHashOps(&quot;namehash&quot;).put(&quot;d&quot;, &quot;沙僧&quot;);}</code></pre><p>（2）提取所有的KEY</p><pre><code>@Testpublic void testGetKeys(){    Set s = redisTemplate.boundHashOps(&quot;namehash&quot;).keys();            System.out.println(s);        }</code></pre><p>运行结果：<br>[a, b, c, d]</p><p>（3）提取所有的值</p><pre><code>@Testpublic void testGetValues(){    List values = redisTemplate.boundHashOps(&quot;namehash&quot;).values();    System.out.println(values);        }</code></pre><p>运行结果：<br>[唐僧, 悟空, 八戒, 沙僧]</p><p>（4）根据KEY提取值</p><pre><code>@Testpublic void testGetValueByKey(){    Object object = redisTemplate.boundHashOps(&quot;namehash&quot;).get(&quot;b&quot;);    System.out.println(object);}</code></pre><p>运行结果：<br>悟空</p><p>（5）根据KEY移除值</p><pre><code>@Testpublic void testRemoveValueByKey(){    redisTemplate.boundHashOps(&quot;namehash&quot;).delete(&quot;c&quot;);}</code></pre><p>运行后再次查看集合内容：<br>[唐僧, 悟空, 沙僧]</p><h1 id="小节-缓存同步问题"><a href="#小节-缓存同步问题" class="headerlink" title="小节(缓存同步问题)"></a>小节(缓存同步问题)</h1><p> 在项目中使用redis会涉及到缓存同步的问题,解决这个问题是在进行缓存内容增删改之前要先删除缓存,然后再进行查询数据,这样在更改后的下次查询,在缓存中查不到数据就会去数据库中查询,然后再保存进缓存,这样就实现了缓存的同步.</p><p>在使用时是先要查询缓存,然后判断缓存是否存在所要查询的数据,如果存在的话就直接返回结果,如果没有查询到的话,就去数据库里面查询,然后将查询结果保存进缓存中.</p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;什么是Redis&quot;&gt;&lt;a href=&quot;#什么是Redis&quot; class=&quot;headerlink&quot; title=&quot;什么是Redis&quot;&gt;&lt;/a&gt;什么是Redis&lt;/h1&gt;&lt;p&gt;redis是一个非关系型Key-Value数据库,运行在内存中,由ANSI C编写。企业开发通常采用Redis来实现缓存。同类的产品还有memcache 、memcached 、MongoDB等。&lt;/p&gt;
    
    </summary>
    
      <category term="java" scheme="http://www.fashionkillyou.xyz/categories/java/"/>
    
    
      <category term="redis" scheme="http://www.fashionkillyou.xyz/tags/redis/"/>
    
      <category term="spring-data-redis" scheme="http://www.fashionkillyou.xyz/tags/spring-data-redis/"/>
    
      <category term="jedis" scheme="http://www.fashionkillyou.xyz/tags/jedis/"/>
    
  </entry>
  
  <entry>
    <title>数据库的事务</title>
    <link href="http://www.fashionkillyou.xyz/2018/03/14/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%9A%84%E4%BA%8B%E5%8A%A1/"/>
    <id>http://www.fashionkillyou.xyz/2018/03/14/数据库的事务/</id>
    <published>2018-03-14T08:32:27.000Z</published>
    <updated>2018-03-14T09:18:08.599Z</updated>
    
    <content type="html"><![CDATA[<script src="\assets\js\APlayer.min.js"> </script><h1 id="【事务的概述】"><a href="#【事务的概述】" class="headerlink" title="【事务的概述】"></a>【事务的概述】</h1><h2 id="什么是事务"><a href="#什么是事务" class="headerlink" title="什么是事务:"></a>什么是事务:</h2><p>事务指的是逻辑上的一组操作,组成这组操作的各个逻辑单元要么一起成功,要么一起失败.<br><a id="more"></a><br>MYSQL的事务管理有两种方式:(MYSQL数据库事务默认是自动提交的.Oracle数据库事务默认是不自动提交.)</p><p>1.手动开启事务</p><ul><li>start transaction; – 开启事务</li><li>多条sql;</li><li>commit/rollback;</li></ul><p>2.设置一个自动提交参数</p><ul><li>show variables like ‘%commit%’; – 查看与commit相关参数.</li><li>set autocommit = 0; – 将autocommit参数设置为OFF.</li></ul><h1 id="【JDBC中的事务管理】"><a href="#【JDBC中的事务管理】" class="headerlink" title="【JDBC中的事务管理】"></a>【JDBC中的事务管理】</h1><h2 id="JDBC的事务的管理的API"><a href="#JDBC的事务的管理的API" class="headerlink" title="JDBC的事务的管理的API:"></a>JDBC的事务的管理的API:</h2><p>同一个事务 连接必须得是同一个对象(就是提交和设置的connection必须得是同一个),要加在业务层</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结:"></a>总结:</h2><h3 id="事务特性"><a href="#事务特性" class="headerlink" title="事务特性:"></a>事务特性:</h3><ul><li>原子性：强调事务的不可分割.(要么一起成功,要么一起失败)</li><li>一致性：强调的是事务的执行的前后，数据的完整性要保持一致.(转账前总和2000,转完后总和也得是2000)</li><li>隔离性：一个事务的执行不应该受到其他事务的干扰.</li><li>持久性：事务一旦结束(提交/回滚)数据就持久保持到了数据库.</li><li>如果不考虑事务的隔离性,引发一些安全性问题:</li></ul><p>一类是  读问题:</p><ul><li>不可重复读    :一个事务读到了另一个事务已经提交的update的数据,导致在当前的事务中多次查询结果不一致.</li><li>虚读/幻读    :一个事务读到另一个事务已经提交的insert的数据,导致在</li><li>当前的事务中多次的查询结果不一致.</li></ul><p>一类是  写问题:</p><p>引发两类丢失更新:</p><h3 id="解决引发的读问题"><a href="#解决引发的读问题" class="headerlink" title="解决引发的读问题:"></a>解决引发的读问题:</h3><p>设置事务的隔离级别:</p><ul><li>read uncommitted        :未提交读.脏读，不可重复读，虚读都可能发生.(安全性低,但是效率高)</li><li>read committed        :已提交读.避免脏读.但是不可重复读和虚读有可能发生.</li><li>repeatable read        :可重复读.避免脏读,不可重复读.但是虚读有可能发生.</li><li>serializable            :串行化的.避免脏读，不可重复读，虚读的发生.(安全性高,但是效率低)</li></ul><p><strong>*</strong> MYSQL隔离级别：repeatable read  Oracle隔离级别:read committed</p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;【事务的概述】&quot;&gt;&lt;a href=&quot;#【事务的概述】&quot; class=&quot;headerlink&quot; title=&quot;【事务的概述】&quot;&gt;&lt;/a&gt;【事务的概述】&lt;/h1&gt;&lt;h2 id=&quot;什么是事务&quot;&gt;&lt;a href=&quot;#什么是事务&quot; class=&quot;headerlink&quot; title=&quot;什么是事务:&quot;&gt;&lt;/a&gt;什么是事务:&lt;/h2&gt;&lt;p&gt;事务指的是逻辑上的一组操作,组成这组操作的各个逻辑单元要么一起成功,要么一起失败.&lt;br&gt;
    
    </summary>
    
      <category term="数据库" scheme="http://www.fashionkillyou.xyz/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    
    
      <category term="事务管理" scheme="http://www.fashionkillyou.xyz/tags/%E4%BA%8B%E5%8A%A1%E7%AE%A1%E7%90%86/"/>
    
  </entry>
  
  <entry>
    <title>使用FastDFS+angularJS+HTML5+springMVC进行文件上传</title>
    <link href="http://www.fashionkillyou.xyz/2018/03/12/%E4%BD%BF%E7%94%A8FastDFS-angularJS-HTML5-springMVC%E8%BF%9B%E8%A1%8C%E6%96%87%E4%BB%B6%E4%B8%8A%E4%BC%A0/"/>
    <id>http://www.fashionkillyou.xyz/2018/03/12/使用FastDFS-angularJS-HTML5-springMVC进行文件上传/</id>
    <published>2018-03-11T17:14:11.000Z</published>
    <updated>2018-03-11T18:01:34.932Z</updated>
    
    <content type="html"><![CDATA[<script src="\assets\js\APlayer.min.js"> </script><h1 id="分布式文件服务器FastDFS"><a href="#分布式文件服务器FastDFS" class="headerlink" title="分布式文件服务器FastDFS"></a>分布式文件服务器FastDFS</h1><h2 id="什么是FastDFS"><a href="#什么是FastDFS" class="headerlink" title="什么是FastDFS"></a>什么是FastDFS</h2><p>FastDFS 是用 c 语言编写的一款开源的分布式文件系统。FastDFS 为互联网量身定制，充分考虑了冗余备份、负载均衡、线性扩容等机制，并注重高可用、高性能等指标，使用 FastDFS很容易搭建一套高性能的文件服务器集群提供文件上传、下载等服务。</p><a id="more"></a><p>FastDFS 架构包括 Tracker server 和 Storage server。客户端请求 Tracker server 进行文件上传、下载，通过 Tracker server 调度最终由 Storage server 完成文件上传和下载。</p><p>Tracker server 作用是负载均衡和调度，通过 Tracker server 在文件上传时可以根据一些策略找到 Storage server 提供文件上传服务。可以将 tracker 称为追踪服务器或调度服务器。</p><p>Storage server 作用是文件存储，客户端上传的文件最终存储在 Storage 服务器上，Storageserver 没有实现自己的文件系统而是利用操作系统 的文件系统来管理文件。可以将storage称为存储服务器。</p><p><img src="http://p57l8frp4.bkt.clouddn.com/FastDFS1.png" alt=""></p><p>服务端两个角色：</p><ul><li><p>Tracker：管理集群，tracker 也可以实现集群。每个 tracker 节点地位平等。收集 Storage 集群的状态。</p></li><li><p>Storage：实际保存文件   Storage 分为多个组，每个组之间保存的文件是不同的。每个组内部可以有多个成员，组成员内部保存的内容是一样的，组成员的地位是一致的，没有主从的概念。</p><h2 id="文件上传及下载的流程"><a href="#文件上传及下载的流程" class="headerlink" title="文件上传及下载的流程"></a>文件上传及下载的流程</h2><h3 id="文件上传流程"><a href="#文件上传流程" class="headerlink" title="文件上传流程"></a>文件上传流程</h3></li></ul><p><img src="http://p57l8frp4.bkt.clouddn.com/FastDFS2.png" alt=""></p><p>客户端上传文件后存储服务器将文件 ID 返回给客户端，此文件 ID 用于以后访问该文件的索引信息。文件索引信息包括：组名，虚拟磁盘路径，数据两级目录，文件名。</p><p><img src="http://p57l8frp4.bkt.clouddn.com/FastDFS3.png" alt=""></p><p>组名：文件上传后所在的 storage 组名称，在文件上传成功后有 storage 服务器返回，需要客户端自行保存。</p><ul><li><p>虚拟磁盘路径：storage 配置的虚拟路径，与磁盘选项 store_path*对应。如果配置了<br>store_path0 则是 M00，如果配置了 store_path1 则是 M01，以此类推。</p></li><li><p>数据两级目录：storage 服务器在每个虚拟磁盘路径下创建的两级目录，用于存储数据<br>文件。</p></li><li><p>文件名：与文件上传时不同。是由存储服务器根据特定信息生成，文件名包含：源存储<br>服务器 IP 地址、文件创建时间戳、文件大小、随机数和文件拓展名等信息。</p></li></ul><h3 id="文件下载流程"><a href="#文件下载流程" class="headerlink" title="文件下载流程"></a>文件下载流程</h3><p><img src="http://p57l8frp4.bkt.clouddn.com/FastDFS4.png" alt=""></p><h3 id="最简单的-FastDFS-架构"><a href="#最简单的-FastDFS-架构" class="headerlink" title="最简单的 FastDFS 架构"></a>最简单的 FastDFS 架构</h3><p><img src="http://p57l8frp4.bkt.clouddn.com/FastDFS5.png" alt=""></p><h3 id="FastDFS安装"><a href="#FastDFS安装" class="headerlink" title="FastDFS安装"></a>FastDFS安装</h3><p>请参考一下博客:</p><p><a href="https://www.cnblogs.com/fishbay/archive/2017/09/24/7586772.html" target="_blank" rel="noopener">https://www.cnblogs.com/fishbay/archive/2017/09/24/7586772.html</a></p><p><a href="http://blog.csdn.net/XingJames/article/details/52759876" target="_blank" rel="noopener">http://blog.csdn.net/XingJames/article/details/52759876</a></p><p><a href="https://www.cnblogs.com/jym-sunshine/p/6397470.html" target="_blank" rel="noopener">FastDFS安装全过程记录</a></p><h2 id="代码案例"><a href="#代码案例" class="headerlink" title="代码案例"></a>代码案例</h2><h3 id="依赖的jar包"><a href="#依赖的jar包" class="headerlink" title="依赖的jar包:"></a>依赖的jar包:</h3><pre><code>&lt;!-- 文件上传组件 --&gt;    &lt;dependency&gt;        &lt;groupId&gt;org.csource.fastdfs&lt;/groupId&gt;        &lt;artifactId&gt;fastdfs&lt;/artifactId&gt;    &lt;/dependency&gt;    &lt;dependency&gt;        &lt;groupId&gt;commons-fileupload&lt;/groupId&gt;        &lt;artifactId&gt;commons-fileupload&lt;/artifactId&gt;    &lt;/dependency&gt;</code></pre><h3 id="使用的工具类"><a href="#使用的工具类" class="headerlink" title="使用的工具类:"></a>使用的工具类:</h3><pre><code>package util;import org.csource.common.NameValuePair;import org.csource.fastdfs.ClientGlobal;import org.csource.fastdfs.StorageClient1;import org.csource.fastdfs.StorageServer;import org.csource.fastdfs.TrackerClient;import org.csource.fastdfs.TrackerServer;public class FastDFSClient {    private TrackerClient trackerClient = null;    private TrackerServer trackerServer = null;    private StorageServer storageServer = null;    private StorageClient1 storageClient = null;    public FastDFSClient(String conf) throws Exception {        if (conf.contains(&quot;classpath:&quot;)) {            conf = conf.replace(&quot;classpath:&quot;, this.getClass().getResource(&quot;/&quot;).getPath());        }        ClientGlobal.init(conf);        trackerClient = new TrackerClient();        trackerServer = trackerClient.getConnection();        storageServer = null;        storageClient = new StorageClient1(trackerServer, storageServer);    }    /**     * 上传文件方法     * &lt;p&gt;Title: uploadFile&lt;/p&gt;     * &lt;p&gt;Description: &lt;/p&gt;     * @param fileName 文件全路径     * @param extName 文件扩展名，不包含（.）     * @param metas 文件扩展信息     * @return     * @throws Exception     */    public String uploadFile(String fileName, String extName, NameValuePair[] metas) throws Exception {        String result = storageClient.upload_file1(fileName, extName, metas);        return result;    }    public String uploadFile(String fileName) throws Exception {        return uploadFile(fileName, null, null);    }    public String uploadFile(String fileName, String extName) throws Exception {        return uploadFile(fileName, extName, null);    }    /**     * 上传文件方法     * &lt;p&gt;Title: uploadFile&lt;/p&gt;     * &lt;p&gt;Description: &lt;/p&gt;     * @param fileContent 文件的内容，字节数组     * @param extName 文件扩展名     * @param metas 文件扩展信息     * @return     * @throws Exception     */    public String uploadFile(byte[] fileContent, String extName, NameValuePair[] metas) throws Exception {        String result = storageClient.upload_file1(fileContent, extName, metas);        return result;    }    public String uploadFile(byte[] fileContent) throws Exception {        return uploadFile(fileContent, null, null);    }    public String uploadFile(byte[] fileContent, String extName) throws Exception {        return uploadFile(fileContent, extName, null);    }}</code></pre><h3 id="config下的配置文件-fdfs-client-conf"><a href="#config下的配置文件-fdfs-client-conf" class="headerlink" title="config下的配置文件(fdfs_client.conf):"></a>config下的配置文件(fdfs_client.conf):</h3><p>注意修改</p><p>tracker_server=192.168.25.133:22122为tracker服务器地址</p><pre><code># connect timeout in seconds# default value is 30sconnect_timeout=30# network timeout in seconds# default value is 30snetwork_timeout=60# the base path to store log filesbase_path=/home/fastdfs# tracker_server can ocur more than once, and tracker_server format is#  &quot;host:port&quot;, host can be hostname or ip addresstracker_server=192.168.25.133:22122#standard log level as syslog, case insensitive, value list:### emerg for emergency### alert### crit for critical### error### warn for warning### notice### info### debuglog_level=info# if use connection pool# default value is false# since V4.05use_connection_pool = false# connections whose the idle time exceeds this time will be closed# unit: second# default value is 3600# since V4.05connection_pool_max_idle_time = 3600# if load FastDFS parameters from tracker server# since V4.05# default value is falseload_fdfs_parameters_from_tracker=false# if use storage ID instead of IP address# same as tracker.conf# valid only when load_fdfs_parameters_from_tracker is false# default value is false# since V4.05use_storage_id = false# specify storage ids filename, can use relative or absolute path# same as tracker.conf# valid only when load_fdfs_parameters_from_tracker is false# since V4.05storage_ids_filename = storage_ids.conf#HTTP settingshttp.tracker_server_port=80#use &quot;#include&quot; directive to include HTTP other settiongs##include http.conf</code></pre><h3 id="springmvc-xml中添加配置"><a href="#springmvc-xml中添加配置" class="headerlink" title="springmvc.xml中添加配置"></a>springmvc.xml中添加配置</h3><pre><code>&lt;!-- 配置多媒体解析器 --&gt;&lt;bean id=&quot;multipartResolver&quot; class=&quot;org.springframework.web.multipart.commons.CommonsMultipartResolver&quot;&gt;    &lt;property name=&quot;defaultEncoding&quot; value=&quot;UTF-8&quot;&gt;&lt;/property&gt;    &lt;!-- 设定文件上传的最大值5MB，5*1024*1024 --&gt;    &lt;property name=&quot;maxUploadSize&quot; value=&quot;5242880&quot;&gt;&lt;/property&gt;&lt;/bean&gt;</code></pre><h3 id="controller控制层代码"><a href="#controller控制层代码" class="headerlink" title="controller控制层代码:"></a>controller控制层代码:</h3><pre><code>/** * 文件上传Controller * @author Administrator * */@RestControllerpublic class UploadController {@RequestMapping(&quot;/upload&quot;)public Result upload( MultipartFile file){                    //1、取文件的扩展名    String originalFilename = file.getOriginalFilename();    String extName = originalFilename.substring(originalFilename.lastIndexOf(&quot;.&quot;) + 1);    try {    //2、创建一个 FastDFS 的客户端            FastDFSClient fastDFSClient      = new FastDFSClient(&quot;classpath:config/fdfs_client.conf&quot;);            //3、执行上传处理            String path = fastDFSClient.uploadFile(file.getBytes(), extName);            //4、拼接返回的 url 和 ip 地址，拼装成完整的 url            String url = &quot;文件服务器地址&quot; + path;                        return new Result(true,url);                    } catch (Exception e) {            e.printStackTrace();            return new Result(false, &quot;上传失败&quot;);        }            }    }</code></pre><h3 id="前端Service-js代码"><a href="#前端Service-js代码" class="headerlink" title="前端Service.js代码"></a>前端Service.js代码</h3><pre><code>//文件上传服务层app.service(&quot;uploadService&quot;,function($http){    this.uploadFile=function(){        var formData=new FormData();        formData.append(&quot;file&quot;,file.files[0]);           return $http({            method:&apos;POST&apos;,            url:&quot;../upload.do&quot;,            data: formData,            headers: {&apos;Content-Type&apos;:undefined},            transformRequest: angular.identity        });            }    });</code></pre><p>anjularjs对于post和get请求默认的Content-Type header 是application/json。通过设置‘Content-Type’: undefined，这样浏览器会帮我们把Content-Type 设置为 multipart/form-data.</p><p>通过设置 transformRequest: angular.identity ，anjularjs transformRequest function 将序列化我们的formdata object.</p><h3 id="前端controller-js代码"><a href="#前端controller-js代码" class="headerlink" title="前端controller.js代码"></a>前端controller.js代码</h3><pre><code>app.controller(&apos;myController&apos; ,function($scope,$controller,goodsService,itemCatService,uploadService){/** * 上传图片 */$scope.uploadFile=function(){          uploadService.uploadFile().success(function(response) {                    if(response.success){//如果上传成功，取出url            $scope.image_entity.url=response.message;//设置文件地址        }else{            alert(response.message);        }    }).error(function() {                        alert(&quot;上传发生错误&quot;);    });        }; }</code></pre><h3 id="页面显示"><a href="#页面显示" class="headerlink" title="页面显示"></a>页面显示</h3><pre><code>&lt;div class=&quot;modal-body&quot;&gt;                    &lt;table class=&quot;table table-bordered table-striped&quot;&gt;              &lt;tr&gt;                  &lt;td&gt;图片&lt;/td&gt;                  &lt;td&gt;                    &lt;table&gt;                        &lt;tr&gt;                            &lt;td&gt;                            &lt;input type=&quot;file&quot; id=&quot;file&quot; /&gt;                                                                &lt;button class=&quot;btn btn-primary&quot; type=&quot;button&quot; ng-click=&quot;uploadFile()&quot;&gt;                                       上传                                &lt;/button&gt;                                &lt;/td&gt;                            &lt;td&gt;                                &lt;img  src=&quot;{{image_entity.url}}&quot; width=&quot;200px&quot; height=&quot;200px&quot;&gt;                            &lt;/td&gt;                        &lt;/tr&gt;                                            &lt;/table&gt;                  &lt;/td&gt;              &lt;/tr&gt;                           &lt;/table&gt;                &lt;/div&gt;</code></pre>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;分布式文件服务器FastDFS&quot;&gt;&lt;a href=&quot;#分布式文件服务器FastDFS&quot; class=&quot;headerlink&quot; title=&quot;分布式文件服务器FastDFS&quot;&gt;&lt;/a&gt;分布式文件服务器FastDFS&lt;/h1&gt;&lt;h2 id=&quot;什么是FastDFS&quot;&gt;&lt;a href=&quot;#什么是FastDFS&quot; class=&quot;headerlink&quot; title=&quot;什么是FastDFS&quot;&gt;&lt;/a&gt;什么是FastDFS&lt;/h2&gt;&lt;p&gt;FastDFS 是用 c 语言编写的一款开源的分布式文件系统。FastDFS 为互联网量身定制，充分考虑了冗余备份、负载均衡、线性扩容等机制，并注重高可用、高性能等指标，使用 FastDFS很容易搭建一套高性能的文件服务器集群提供文件上传、下载等服务。&lt;/p&gt;
    
    </summary>
    
      <category term="前端" scheme="http://www.fashionkillyou.xyz/categories/%E5%89%8D%E7%AB%AF/"/>
    
    
      <category term="FastDFS" scheme="http://www.fashionkillyou.xyz/tags/FastDFS/"/>
    
      <category term="angularJS" scheme="http://www.fashionkillyou.xyz/tags/angularJS/"/>
    
      <category term="HTML5" scheme="http://www.fashionkillyou.xyz/tags/HTML5/"/>
    
      <category term="springMVC" scheme="http://www.fashionkillyou.xyz/tags/springMVC/"/>
    
  </entry>
  
  <entry>
    <title>基于angularJS的多选框select2</title>
    <link href="http://www.fashionkillyou.xyz/2018/03/09/%E5%9F%BA%E4%BA%8EangularJS%E7%9A%84%E5%A4%9A%E9%80%89%E6%A1%86select2/"/>
    <id>http://www.fashionkillyou.xyz/2018/03/09/基于angularJS的多选框select2/</id>
    <published>2018-03-09T03:03:38.000Z</published>
    <updated>2018-03-14T00:48:14.410Z</updated>
    
    <content type="html"><![CDATA[<script src="\assets\js\APlayer.min.js"> </script><h1 id="基于angularJS框架下的select2插件的使用"><a href="#基于angularJS框架下的select2插件的使用" class="headerlink" title="基于angularJS框架下的select2插件的使用"></a>基于angularJS框架下的select2插件的使用</h1><a id="more"></a><p><img src="http://p57l8frp4.bkt.clouddn.com/select2.jpg" alt=""></p><h2 id="使用步骤"><a href="#使用步骤" class="headerlink" title="使用步骤:"></a>使用步骤:</h2><h3 id="引入JS文件"><a href="#引入JS文件" class="headerlink" title="引入JS文件"></a>引入JS文件</h3><pre><code>&lt;link rel=&quot;stylesheet&quot; href=&quot;bootstrap/css/bootstrap.min.css&quot;&gt;&lt;script src=&quot;jQuery/jquery-2.2.3.min.js&quot;&gt;&lt;/script&gt;&lt;script src=&quot;bootstrap/js/bootstrap.min.js&quot;&gt;&lt;/script&gt;&lt;!-- 引入angularJS,分页,controller,service --&gt;&lt;script type=&quot;text/javascript&quot; src=&quot;angularjs/angular.min.js&quot;&gt;  &lt;/script&gt;&lt;!-- 引入select2的插件 --&gt;&lt;!-- 这个要在base_pagination.js之后,因为用到了app --&gt;&lt;link rel=&quot;stylesheet&quot; href=&quot;select2/select2.css&quot; /&gt;&lt;link rel=&quot;stylesheet&quot; href=&quot;select2/select2-bootstrap.css&quot; /&gt;&lt;script src=&quot;select2/select2.min.js&quot; type=&quot;text/javascript&quot;&gt;&lt;/script&gt;&lt;script type=&quot;text/javascript&quot; src=&quot;select2/angular-select2.js&quot;&gt;&lt;/script&gt;</code></pre><h3 id="写input的属性"><a href="#写input的属性" class="headerlink" title="写input的属性"></a>写input的属性</h3><pre><code>&lt;input select2 select2-model=&quot;entity.brandIds&quot;  config=&quot;brandList&quot; multiple placeholder=&quot; 选择品牌（可多选） &quot; class=&quot;form-control&quot;&gt;</code></pre><p>multiple 表示可多选</p><p>Config用于配置数据来源</p><p>select2-model用于指定用户选择后提交的变量</p><p>select2 必须加上否则失效</p><h3 id="给定数据源"><a href="#给定数据源" class="headerlink" title="给定数据源"></a>给定数据源</h3><p><strong>注意这个要放置在select插件的前面,因为select2使用到了app</strong></p><pre><code>这里的数据格式默认是{{id:2,text:'华为'}}&lt;script type=&quot;text/javascript&quot;&gt;    var app = angular.module(&apos;app&apos;,[]);    app.controller(&apos;myController&apos;,function($scope){        //列表数据        $scope.brandList={data:[{id:1,text:&apos;联想&apos;},{id:2,text:&apos;华为&apos;},{id:3,text:&apos;小米&apos;}]};    });&lt;/script&gt;</code></pre><p>资源文件:</p><h3 id="简单多选demo"><a href="#简单多选demo" class="headerlink" title="简单多选demo"></a>简单多选demo</h3><p>链接：<a href="https://pan.baidu.com/s/12xz7kcmZGwcTjMH7MJhmDg" target="_blank" rel="noopener">https://pan.baidu.com/s/12xz7kcmZGwcTjMH7MJhmDg</a> </p><p>密码：0aq2</p><h3 id="完整说明文档"><a href="#完整说明文档" class="headerlink" title="完整说明文档"></a>完整说明文档</h3><p>链接：<a href="https://pan.baidu.com/s/1XSHqbbx3ikZRlkIFgXgMGQ" target="_blank" rel="noopener">https://pan.baidu.com/s/1XSHqbbx3ikZRlkIFgXgMGQ</a> </p><p>密码：66gc</p><h3 id="官网"><a href="#官网" class="headerlink" title="官网"></a>官网</h3><p><a href="https://select2.org/" target="_blank" rel="noopener">https://select2.org</a>/</p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;基于angularJS框架下的select2插件的使用&quot;&gt;&lt;a href=&quot;#基于angularJS框架下的select2插件的使用&quot; class=&quot;headerlink&quot; title=&quot;基于angularJS框架下的select2插件的使用&quot;&gt;&lt;/a&gt;基于angularJS框架下的select2插件的使用&lt;/h1&gt;
    
    </summary>
    
      <category term="前端" scheme="http://www.fashionkillyou.xyz/categories/%E5%89%8D%E7%AB%AF/"/>
    
    
      <category term="angularJS" scheme="http://www.fashionkillyou.xyz/tags/angularJS/"/>
    
      <category term="select2" scheme="http://www.fashionkillyou.xyz/tags/select2/"/>
    
  </entry>
  
  <entry>
    <title>使用Mybatis的PageHelper插件进行分页</title>
    <link href="http://www.fashionkillyou.xyz/2018/03/07/%E4%BD%BF%E7%94%A8Mybatis%E7%9A%84PageHelper%E6%8F%92%E4%BB%B6%E8%BF%9B%E8%A1%8C%E5%88%86%E9%A1%B5/"/>
    <id>http://www.fashionkillyou.xyz/2018/03/07/使用Mybatis的PageHelper插件进行分页/</id>
    <published>2018-03-07T12:39:39.000Z</published>
    <updated>2018-03-19T06:00:58.869Z</updated>
    
    <content type="html"><![CDATA[<script src="\assets\js\APlayer.min.js"> </script><h1 id="PageHelper插件进行分页"><a href="#PageHelper插件进行分页" class="headerlink" title="PageHelper插件进行分页"></a>PageHelper插件进行分页</h1><h2 id="实现效果"><a href="#实现效果" class="headerlink" title="实现效果"></a>实现效果</h2><a id="more"></a><p> <img src="http://p57l8frp4.bkt.clouddn.com/PageHelper.png" alt=""></p><p>##准备内容<br>本文是建立在以下框架之上:</p><ul><li>前端使用的是angularJS框架+BootStrap</li><li>后台是SpringMVC+Spring+Mybatis</li></ul><p>前期的搭建请看(<a href="https://github.com/pagehelper/Mybatis-PageHelper/blob/master/wikis/zh/HowToUse.md" title="官方文档" target="_blank" rel="noopener">官方文档</a>)</p><p>推荐博客:</p><p><a href="http://blog.csdn.net/maoyuanming0806/article/details/77720754" target="_blank" rel="noopener">http://blog.csdn.net/maoyuanming0806/article/details/77720754</a></p><p><a href="http://blog.csdn.net/FansUnion/article/details/40304187" target="_blank" rel="noopener">http://blog.csdn.net/FansUnion/article/details/40304187</a></p><h2 id="后端代码"><a href="#后端代码" class="headerlink" title="后端代码"></a>后端代码</h2><h3 id="分页结果封装实体"><a href="#分页结果封装实体" class="headerlink" title="分页结果封装实体"></a>分页结果封装实体</h3><p>创建类PageResult用于在controller中返回分页数据</p><pre><code>package entity;import java.util.List;/** * 分页结果封装对象 * @author Administrator * */public class PageResult implements Serializable{    private long total;//总记录数    private List rows;//当前页结果            public PageResult(long total, List rows) {        super();        this.total = total;        this.rows = rows;    }     //getter  and setter .....}</code></pre><h3 id="服务接口层"><a href="#服务接口层" class="headerlink" title="服务接口层"></a>服务接口层</h3><p>在service的接口BrandService.java 增加方法定义</p><pre><code>/** * 返回分页列表 * @return */public PageResult findPage(int pageNum,int pageSize);</code></pre><h3 id="服务实现层"><a href="#服务实现层" class="headerlink" title="服务实现层"></a>服务实现层</h3><p>service的实现类BrandServiceImpl.java中实现该方法</p><pre><code>@Overridepublic PageResult findPage(int pageNum, int pageSize) {    PageHelper.startPage(pageNum, pageSize);            Page&lt;TbBrand&gt; page=   (Page&lt;TbBrand&gt;) brandMapper.selectByExample(null);    return new PageResult(page.getTotal(), page.getResult());}</code></pre><p>PageHelper为MyBatis分页插件</p><h3 id="控制层"><a href="#控制层" class="headerlink" title="控制层"></a>控制层</h3><p>在控制层BrandController.java新增方法</p><pre><code>/** * 返回全部列表 * @return */@RequestMapping(&quot;/findPage&quot;)public PageResult  findPage(int page,int rows){                return brandService.findPage(page, rows);}</code></pre><h2 id="前端代码"><a href="#前端代码" class="headerlink" title="前端代码"></a>前端代码</h2><h3 id="HTML"><a href="#HTML" class="headerlink" title="HTML"></a>HTML</h3><p>在brand.html引入分页组件</p><pre><code>&lt;!-- 分页组件开始 --&gt;&lt;script src=&quot;../plugins/angularjs/pagination.js&quot;&gt;&lt;/script&gt;&lt;link rel=&quot;stylesheet&quot; href=&quot;../plugins/angularjs/pagination.css&quot;&gt;&lt;!-- 分页组件结束 --&gt;</code></pre><p>构建app模块时引入pagination模块</p><pre><code>var app=angular.module(&apos;pinyougou&apos;,[&apos;pagination&apos;]);</code></pre><p>页面的表格下放置分页组件</p><pre><code> &lt;!-- 分页 --&gt;&lt;tm-pagination conf=&quot;paginationConf&quot;&gt;&lt;/tm-pagination&gt;</code></pre><h3 id="JS代码"><a href="#JS代码" class="headerlink" title="JS代码"></a>JS代码</h3><pre><code>//重新加载列表 数据$scope.reloadList=function(){     //切换页码      $scope.findPage( $scope.paginationConf.currentPage, $scope.paginationConf.itemsPerPage);}//分页控件配置 $scope.paginationConf = {         currentPage: 1,         totalItems: 10,         itemsPerPage: 10,         perPageOptions: [10, 20, 30, 40, 50],         onChange: function(){                     $scope.reloadList();//重新加载         }}; //分页$scope.findPage=function(page,rows){        $http.get(&apos;../brand/findPage.do?page=&apos;+page+&apos;&amp;rows=&apos;+rows).success(            function(response){                $scope.list=response.rows;                    $scope.paginationConf.totalItems=response.total;//更新总记录数            }                );}</code></pre><p>paginationConf 变量各属性的意义：</p><ul><li><p>currentPage：当前页码</p></li><li><p>totalItems:总条数</p></li><li><p>itemsPerPage:</p></li><li><p>perPageOptions：页码选项</p></li><li><p>onChange：更改页面时触发事件</p></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;PageHelper插件进行分页&quot;&gt;&lt;a href=&quot;#PageHelper插件进行分页&quot; class=&quot;headerlink&quot; title=&quot;PageHelper插件进行分页&quot;&gt;&lt;/a&gt;PageHelper插件进行分页&lt;/h1&gt;&lt;h2 id=&quot;实现效果&quot;&gt;&lt;a href=&quot;#实现效果&quot; class=&quot;headerlink&quot; title=&quot;实现效果&quot;&gt;&lt;/a&gt;实现效果&lt;/h2&gt;
    
    </summary>
    
      <category term="SSM" scheme="http://www.fashionkillyou.xyz/categories/SSM/"/>
    
    
      <category term="Mybatis" scheme="http://www.fashionkillyou.xyz/tags/Mybatis/"/>
    
      <category term="PageHelper" scheme="http://www.fashionkillyou.xyz/tags/PageHelper/"/>
    
  </entry>
  
  <entry>
    <title>AngularJS框架</title>
    <link href="http://www.fashionkillyou.xyz/2018/03/07/AngularJS%E6%A1%86%E6%9E%B6/"/>
    <id>http://www.fashionkillyou.xyz/2018/03/07/AngularJS框架/</id>
    <published>2018-03-07T04:45:07.000Z</published>
    <updated>2018-03-18T11:56:47.968Z</updated>
    
    <content type="html"><![CDATA[<script src="\assets\js\APlayer.min.js"> </script><h1 id="AngularJS简介"><a href="#AngularJS简介" class="headerlink" title="AngularJS简介"></a>AngularJS简介</h1><p><img src="http://p57l8frp4.bkt.clouddn.com/angularJS.png" alt=""></p><p>AngularJS  诞生于2009年，由Misko Hevery 等人创建，后为Google所收购。是一款优秀的前端JS框架，已经被用于Google的多款产品当中。AngularJS有着诸多特性，最为核心的是：MVC、模块化、自动化双向数据绑定、依赖注入等等。<br>  <a id="more"></a></p><h2 id="AngularJS四大特征"><a href="#AngularJS四大特征" class="headerlink" title="AngularJS四大特征"></a>AngularJS四大特征</h2><h3 id="MVC-模式"><a href="#MVC-模式" class="headerlink" title="MVC    模式"></a>MVC    模式</h3><p>Angular遵循软件工程的MVC模式,并鼓励展现，数据，和逻辑组件之间的松耦合.通过依赖注入（dependency injection），Angular为客户端的Web应用带来了传统服务端的服务，例如独立于视图的控制。 因此，后端减少了许多负担，产生了更轻的Web应用。<br> <img src="http://p57l8frp4.bkt.clouddn.com/angularJS1.png" alt=""></p><ul><li>Model:数据,其实就是angular变量($scope.XX);</li><li>View: 数据的呈现,Html+Directive(指令);</li><li>Controller:操作数据,就是function,数据的增删改查;</li></ul><h3 id="双向绑定"><a href="#双向绑定" class="headerlink" title="双向绑定"></a>双向绑定</h3><p>AngularJS是建立在这样的信念上的：即声明式编程应该用于构建用户界面以及编写软件构建，而指令式编程非常适合来表示业务逻辑。框架采用并扩展了传统HTML，通过双向的数据绑定来适应动态内容，双向的数据绑定允许模型和视图之间的自动同步。因此，AngularJS使得对DOM的操作不再重要并提升了可测试性。<br> <img src="http://p57l8frp4.bkt.clouddn.com/angularJS2.png" alt=""></p><h3 id="依赖注入"><a href="#依赖注入" class="headerlink" title="依赖注入"></a>依赖注入</h3><p>依赖注入(Dependency Injection,简称DI)是一种设计模式, 指某个对象依赖的其他对象无需手工创建，只需要“吼一嗓子”，则此对象在创建时，其依赖的对象由框架来自动创建并注入进来,其实就是最少知识法则;模块中所有的service和provider两类对象，都可以根据形参名称实现DI.</p><h3 id="模块化设计"><a href="#模块化设计" class="headerlink" title="模块化设计"></a>模块化设计</h3><p>高内聚低耦合法则</p><ul><li><p>官方提供的模块           ng、ngRoute、ngAnimate</p></li><li><p>用户自定义的模块     angular.module(‘模块名’,[ ])</p></li></ul><h2 id="入门小Demo"><a href="#入门小Demo" class="headerlink" title="入门小Demo"></a>入门小Demo</h2><h3 id="表达式"><a href="#表达式" class="headerlink" title="表达式"></a>表达式</h3><pre><code>&lt;html&gt;&lt;head&gt;    &lt;title&gt;入门小Demo-1&lt;/title&gt;    &lt;script src=&quot;angular.min.js&quot;&gt;&lt;/script&gt;&lt;/head&gt;&lt;body ng-app&gt;{{100+100}}&lt;/body&gt;&lt;/html&gt;</code></pre><p>执行结果如下：</p><p>表达式的写法是 表达式可以是变量或是运算式</p><ul><li>ng-app 指令 作用是告诉子元素一下的指令是归angularJs的,angularJs会识别的</li><li>ng-app 指令定义了 AngularJS 应用程序的 根元素。</li><li>ng-app 指令在网页加载完毕时会自动引导（自动初始化）应用程序。</li></ul><h3 id="双向绑定-1"><a href="#双向绑定-1" class="headerlink" title="双向绑定"></a>双向绑定</h3><pre><code>&lt;html&gt;&lt;head&gt;    &lt;title&gt;入门小Demo-1  双向绑定&lt;/title&gt;    &lt;script src=&quot;angular.min.js&quot;&gt;&lt;/script&gt;&lt;/head&gt;&lt;body ng-app&gt;请输入你的姓名：&lt;input ng-model=&quot;myname&quot;&gt;&lt;br&gt;{{myname}},你好&lt;/body&gt;&lt;/html&gt;</code></pre><p>运行效果如下：</p><p>ng-model 指令用于绑定变量,这样用户在文本框输入的内容会绑定到变量上，而表达式可以实时地输出变量。</p><h3 id="初始化指令"><a href="#初始化指令" class="headerlink" title="初始化指令"></a>初始化指令</h3><p>我们如果希望有些变量具有初始值，可以使用ng-init指令来对变量初始化</p><pre><code>&lt;html&gt;&lt;head&gt;    &lt;title&gt;入门小Demo-3  初始化&lt;/title&gt;    &lt;script src=&quot;angular.min.js&quot;&gt;&lt;/script&gt;&lt;/head&gt;&lt;body ng-app   ng-init=&quot;myname=&apos;陈大海&apos;&quot;&gt;请输入你的姓名：&lt;input ng-model=&quot;myname&quot;&gt;&lt;br&gt;{{myname}},你好&lt;/body&gt;&lt;/html&gt;</code></pre><h3 id="控制器"><a href="#控制器" class="headerlink" title="控制器"></a>控制器</h3><pre><code>&lt;html&gt;&lt;head&gt;    &lt;title&gt;入门小Demo-3  初始化&lt;/title&gt;    &lt;script src=&quot;angular.min.js&quot;&gt;&lt;/script&gt;    &lt;script&gt;        var app=angular.module(&apos;myApp&apos;,[]); //定义了一个叫myApp的模块        //定义控制器        app.controller(&apos;myController&apos;,function($scope){            $scope.add=function(){                return parseInt($scope.x)+parseInt($scope.y);            }        });    &lt;/script&gt;&lt;/head&gt;&lt;body ng-app=&quot;myApp&quot; ng-controller=&quot;myController&quot;&gt;x:&lt;input ng-model=&quot;x&quot; &gt;y:&lt;input ng-model=&quot;y&quot; &gt;运算结果：{{add()}}&lt;/body&gt;&lt;/html&gt;</code></pre><p>运行结果如下：</p><p>ng-controller用于指定所使用的控制器。</p><p>理解 $scope：</p><p>$scope 的使用贯穿整个 AngularJS App 应用,它与数据模型相关联,同时也是表达式执行的上下文.有了$scope 就在视图和控制器之间建立了一个通道,基于作用域视图在修改数据时会立刻更新 $scope,同样的$scope 发生改变时也会立刻重新渲染视图.</p><h3 id="事件指令"><a href="#事件指令" class="headerlink" title="事件指令"></a>事件指令</h3><pre><code>&lt;html&gt;&lt;head&gt;    &lt;title&gt;入门小Demo-5  事件指令&lt;/title&gt;    &lt;script src=&quot;angular.min.js&quot;&gt;&lt;/script&gt;        &lt;script&gt;        var app=angular.module(&apos;myApp&apos;,[]); //定义了一个叫myApp的模块        //定义控制器        app.controller(&apos;myController&apos;,function($scope){                        $scope.add=function(){                $scope.z= parseInt($scope.x)+parseInt($scope.y);            }                    });        &lt;/script&gt;&lt;/head&gt;&lt;body ng-app=&quot;myApp&quot; ng-controller=&quot;myController&quot;&gt;x:&lt;input ng-model=&quot;x&quot; &gt;y:&lt;input ng-model=&quot;y&quot; &gt;&lt;button ng-click=&quot;add()&quot;&gt;运算&lt;/button&gt;结果：{{z}}&lt;/body&gt;&lt;/html&gt;</code></pre><p>运行结果：</p><p>ng-click  是最常用的单击事件指令，再点击时触发控制器的某个方法</p><h3 id="循环数组"><a href="#循环数组" class="headerlink" title="循环数组"></a>循环数组</h3><pre><code>&lt;html&gt;&lt;head&gt;    &lt;title&gt;入门小Demo-6  循环数据&lt;/title&gt;    &lt;script src=&quot;angular.min.js&quot;&gt;&lt;/script&gt;    &lt;script&gt;        var app=angular.module(&apos;myApp&apos;,[]); //定义了一个叫myApp的模块        //定义控制器        app.controller(&apos;myController&apos;,function($scope){            $scope.list= [100,192,203,434 ];//定义数组        });    &lt;/script&gt;&lt;/head&gt;&lt;body ng-app=&quot;myApp&quot; ng-controller=&quot;myController&quot;&gt;&lt;table&gt;&lt;tr ng-repeat=&quot;x in list&quot;&gt;    &lt;td&gt;{{x}}&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/body&gt;&lt;/html&gt;</code></pre><p>这里的ng-repeat指令用于循环数组变量。<br>运行结果如下：</p><h3 id="循环对象数组"><a href="#循环对象数组" class="headerlink" title="循环对象数组"></a>循环对象数组</h3><pre><code>&lt;html&gt;&lt;head&gt;    &lt;title&gt;入门小Demo-7  循环对象数组&lt;/title&gt;    &lt;script src=&quot;angular.min.js&quot;&gt;&lt;/script&gt;        &lt;script&gt;        var app=angular.module(&apos;myApp&apos;,[]); //定义了一个叫myApp的模块        //定义控制器        app.controller(&apos;myController&apos;,function($scope){                    $scope.list= [                {name:&apos;张三&apos;,shuxue:100,yuwen:93},                {name:&apos;李四&apos;,shuxue:88,yuwen:87},                {name:&apos;王五&apos;,shuxue:77,yuwen:56}            ];//定义数组                    });        &lt;/script&gt;    &lt;/head&gt;&lt;body ng-app=&quot;myApp&quot; ng-controller=&quot;myController&quot;&gt;&lt;table&gt;&lt;tr&gt;    &lt;td&gt;姓名&lt;/td&gt;    &lt;td&gt;数学&lt;/td&gt;    &lt;td&gt;语文&lt;/td&gt;&lt;/tr&gt;&lt;tr ng-repeat=&quot;entity in list&quot;&gt;    &lt;td&gt;{{entity.name}}&lt;/td&gt;    &lt;td&gt;{{entity.shuxue}}&lt;/td&gt;    &lt;td&gt;{{entity.yuwen}}&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/body&gt;&lt;/html&gt;</code></pre><p>运行结果如下：</p><h3 id="内置服务"><a href="#内置服务" class="headerlink" title="内置服务"></a>内置服务</h3><p>我们的数据一般都是从后端获取的，那么如何获取数据呢？我们一般使用内置服务$http来实现。注意：以下代码需要在tomcat中运行。</p><pre><code>&lt;html&gt;&lt;head&gt;    &lt;title&gt;入门小Demo-8  内置服务&lt;/title&gt;    &lt;meta charset=&quot;utf-8&quot; /&gt;    &lt;script src=&quot;angular.min.js&quot;&gt;&lt;/script&gt;        &lt;script&gt;        var app=angular.module(&apos;myApp&apos;,[]); //定义了一个叫myApp的模块        //定义控制器        app.controller(&apos;myController&apos;,function($scope,$http){                    $scope.findAll=function(){                $http.get(&apos;data.json&apos;).success(                    function(response){                        $scope.list=response;                    }                                    );                            }                    });        &lt;/script&gt;    &lt;/head&gt;&lt;body ng-app=&quot;myApp&quot; ng-controller=&quot;myController&quot; ng-init=&quot;findAll()&quot;&gt;&lt;table&gt;&lt;tr&gt;    &lt;td&gt;姓名&lt;/td&gt;    &lt;td&gt;数学&lt;/td&gt;    &lt;td&gt;语文&lt;/td&gt;&lt;/tr&gt;&lt;tr ng-repeat=&quot;entity in list&quot;&gt;    &lt;td&gt;{{entity.name}}&lt;/td&gt;    &lt;td&gt;{{entity.shuxue}}&lt;/td&gt;    &lt;td&gt;{{entity.yuwen}}&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/body&gt;&lt;/html&gt;建立文件 data.json[    {&quot;name&quot;:&quot;张三&quot;,&quot;shuxue&quot;:100,&quot;yuwen&quot;:93},    {&quot;name&quot;:&quot;李四&quot;,&quot;shuxue&quot;:88,&quot;yuwen&quot;:87},    {&quot;name&quot;:&quot;王五&quot;,&quot;shuxue&quot;:77,&quot;yuwen&quot;:56},    {&quot;name&quot;:&quot;赵六&quot;,&quot;shuxue&quot;:67,&quot;yuwen&quot;:86}]</code></pre><h1 id="常用的指令"><a href="#常用的指令" class="headerlink" title="常用的指令"></a>常用的指令</h1><p>名称       描述</p><p><strong>ngApp    定义应用程序的根元素。</strong></p><p>ngBind    绑定 HTML 元素到应用程序数据</p><p><strong>ngBindhtml    绑定 HTML 元素的 innerHTML 到应用程序数据，并移除 HTML 字符串中危险字<br>符</strong></p><p>ngBindtemplate    规定要使用模板替换的文本内容</p><p>ngBlur    规定 blur 事件的行为</p><p>ngChange    规定在内容改变时要执行的表达式</p><p><strong>ngChecked    规定元素是否被选中</strong></p><p>ngClass    指定 HTML 元素使用的 CSS 类</p><p>ngClasseven    类似 ng-class，但只在偶数行起作用</p><p>ngClassodd    类似 ng-class，但只在奇数行起作用</p><p><strong>ngClick    定义元素被点击时的行为</strong></p><p>ngCloak    在应用正要加载时防止其闪烁</p><p>ngController    定义应用的控制器对象</p><p>ngCopy    规定拷贝事件的行为</p><p>ngCsp    修改内容的安全策略</p><p>ngCut    规定剪切事件的行为</p><p>ngDblclick    规定双击事件的行为</p><p>ngDisabled    规定一个元素是否被禁用</p><p>ngFocus    规定聚焦事件的行为</p><p>ngHide    隐藏或显示 HTML 元素</p><p>ngHref    为 元素指定链接</p><p><strong>ngIf    判断语句，如果值为falsh，所在的div层不显示</strong></p><p>ngInclude    在应用中包含 HTML 文件</p><p>ngInit    定义应用的初始化值</p><p>ngKeydown    规定按下按键事件的行为</p><p>ngKeypress    规定按下按键事件的行为</p><p>ngKeyup    规定松开按键事件的行为</p><p>ngList    将文本转换为列表 (数组)</p><p><strong>ngModel    绑定 HTML 控制器的值到应用数据</strong></p><p>ngModeloptions    规定如何更新模型</p><p>ngMousedown    规定按下鼠标按键时的行为</p><p>ngMouseenter    规定鼠标指针穿过元素时的行为</p><p>ngMouseleave    规定鼠标指针离开元素时的行为</p><p>ngMousemove    规定鼠标指针在指定的元素中移动时的行为</p><p>ngMouseover    规定鼠标指针位于元素上方时的行为</p><p>ngMouseup    规定当在元素上松开鼠标按钮时的行为</p><p>ngNonbindable    规定元素或子元素不能绑定数据</p><p>ngOpen    指定元素的 open 属性</p><p><strong>ngOptions    在 &lt; select&gt; 列表中指定 &lt; options&gt;</strong></p><p>ngPaste    规定粘贴事件的行为</p><p>ngReadonly    指定元素的 readonly 属性</p><p><strong>ngRepeat    定义集合中每项数据的模板</strong></p><p>ngSelected    指定元素的 selected 属性</p><p>ngShow    显示或隐藏 HTML 元素</p><p>ngSrc    指定  元素的 src 属性</p><p>ngSrcset    指定  元素的 srcset 属性</p><p>ngStyle    指定元素的 style 属性</p><p>ngSubmit    规定 onsubmit 事件发生时执行的表达式</p><p>ngSwitch    规定显示或隐藏子元素的条件</p><p><strong>ngValue    规定input元素的值</strong></p><h1 id="服务"><a href="#服务" class="headerlink" title="服务"></a>服务</h1><p>名称    描述</p><p>$http    $http是Angular的一个核心服务，它有利于浏览器通过XMLHttpRequest 对象或者 JSONP和远程HTTP服务器交互。</p><p>$controller    </p><p>$filter    ()</p><pre><code>// 定义过滤器app.filter(&apos;trustHtml&apos;,[&apos;$sce&apos;,function($sce){    return function(data){//传入参数时被过滤的内容        return $sce.trustAsHtml(data);//返回的是过滤后的内容（信任html的转换）    }    } ]);</code></pre><p>页面:<br>    <div class="attr" ng-bind-html="item.title | trustHtml"></div></p><p>$location    $location服务解析浏览器地址中的url（基于window.location）并且使url在应用程序中可用。将地址栏中的网址的变化反映到$location服务和$location的变化反映到浏览器地址栏。</p><p>$sce    $sce 服务是AngularJs提供的一种严格上下文转义服务。</p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;AngularJS简介&quot;&gt;&lt;a href=&quot;#AngularJS简介&quot; class=&quot;headerlink&quot; title=&quot;AngularJS简介&quot;&gt;&lt;/a&gt;AngularJS简介&lt;/h1&gt;&lt;p&gt;&lt;img src=&quot;http://p57l8frp4.bkt.clouddn.com/angularJS.png&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;p&gt;AngularJS  诞生于2009年，由Misko Hevery 等人创建，后为Google所收购。是一款优秀的前端JS框架，已经被用于Google的多款产品当中。AngularJS有着诸多特性，最为核心的是：MVC、模块化、自动化双向数据绑定、依赖注入等等。&lt;br&gt;
    
    </summary>
    
      <category term="前端" scheme="http://www.fashionkillyou.xyz/categories/%E5%89%8D%E7%AB%AF/"/>
    
    
      <category term="AngularJS" scheme="http://www.fashionkillyou.xyz/tags/AngularJS/"/>
    
  </entry>
  
  <entry>
    <title>Dubbox框架入门小demo</title>
    <link href="http://www.fashionkillyou.xyz/2018/03/05/Dubbox%E6%A1%86%E6%9E%B6%E5%85%A5%E9%97%A8%E5%B0%8Fdemo/"/>
    <id>http://www.fashionkillyou.xyz/2018/03/05/Dubbox框架入门小demo/</id>
    <published>2018-03-05T12:02:42.000Z</published>
    <updated>2018-03-05T16:42:05.235Z</updated>
    
    <content type="html"><![CDATA[<script src="\assets\js\APlayer.min.js"> </script><h1 id="Dubbox框架"><a href="#Dubbox框架" class="headerlink" title="Dubbox框架"></a>Dubbox框架</h1><h2 id="Dubbox简介"><a href="#Dubbox简介" class="headerlink" title="Dubbox简介"></a>Dubbox简介</h2><p>Dubbox 是一个<strong>分布式服务框架</strong>，其前身是阿里巴巴开源项目Dubbo ，被国内电商及互联网项目中使用，后期阿里巴巴停止了该项目的维护，当当网便在Dubbo基础上进行优化，并继续维护，为了与原有的Dubbo区分，故将其命名为Dubbox。<br><a id="more"></a><br>Dubbox 致力于提供高性能和透明化的RPC远程服务调用方案，以及SOA服务治理方案。简单的说，dubbox就是个服务框架，如果没有分布式的需求，其实是不需要用的，只有在分布式的时候，才有dubbox这样的分布式服务框架的需求，并且本质上是个服务调用的东东，说白了就是个远程服务调用的分布式框架。</p><p>###节点角色说明：<br>• Provider: 暴露服务的服务提供方。</p><p>• Consumer: 调用远程服务的服务消费方。</p><p>• Registry: 服务注册与发现的注册中心。</p><p>• Monitor: 统计服务的调用次调和调用时间的监控中心。</p><p>• Container: 服务运行容器。</p><h3 id="调用关系说明："><a href="#调用关系说明：" class="headerlink" title="调用关系说明："></a>调用关系说明：</h3><p>• 0. 服务容器负责启动，加载，运行服务提供者。</p><p>• 1. 服务提供者在启动时，向注册中心注册自己提供的服务。</p><p>• 2. 服务消费者在启动时，向注册中心订阅自己所需的服务。</p><p>• 3. 注册中心返回服务提供者地址列表给消费者，如果有变更，注册中心将基于长连接推<br>送变更数据给消费者。</p><p>• 4. 服务消费者，从提供者地址列表中，基于软负载均衡算法，选一台提供者进行调用，<br>如果调用失败，再选另一台调用。</p><p>• 5. 服务消费者和提供者，在内存中累计调用次数和调用时间，定时每分钟发送一次统计<br>数据到监控中心。</p><h2 id="注册中心Zookeeper"><a href="#注册中心Zookeeper" class="headerlink" title="注册中心Zookeeper"></a>注册中心Zookeeper</h2><h3 id="Zookeeper-介绍"><a href="#Zookeeper-介绍" class="headerlink" title="Zookeeper 介绍"></a>Zookeeper 介绍</h3><p>官方推荐使用 zookeeper 注册中心。注册中心负责服务地址的注册与查找，相当于目录服务，服务提供者和消费者只在启动时与注册中心交互，注册中心不转发请求，压力较小。</p><p>Zookeeper 是 Apacahe Hadoop 的子项目，是一个树型的目录服务，支持变更推送，适合作为Dubbox 服务的注册中心，工业强度较高，可用于生产环境。</p><h3 id="Zookeeper-在Linux系统的安装"><a href="#Zookeeper-在Linux系统的安装" class="headerlink" title="Zookeeper 在Linux系统的安装"></a>Zookeeper 在Linux系统的安装</h3><p>安装步骤：</p><p>第一步：安装 jdk(这里请自行百度,如何在Linux中安装jdk)</p><p>第二步：把 zookeeper 的压缩包（…\dubbox\zookeeper-3.4.6.tar.gz）上传到 linux 系统。</p><pre><code>Alt+P 进入SFTP ，输入put d:\zookeeper-3.4.6.tar.gz 上传(这里d:是你放置压缩包的位置)</code></pre><p>第三步：解压缩压缩包</p><pre><code>tar -zxvf zookeeper-3.4.6.tar.gz</code></pre><p>第四步：进入 zookeeper-3.4.6 目录，创建 data 文件夹。</p><pre><code>mkdir data</code></pre><p>第五步：进入conf目录 ，把 zoo_sample.cfg 改名为 zoo.cfg</p><pre><code>cd confmv zoo_sample.cfg zoo.cfg</code></pre><p>第六步：打开zoo.cfg ,  修改 data 属性：</p><pre><code>dataDir=/root/zookeeper-3.4.6/data</code></pre><h3 id="Zookeeper-服务启动"><a href="#Zookeeper-服务启动" class="headerlink" title="Zookeeper 服务启动"></a>Zookeeper 服务启动</h3><p>进入bin目录，启动服务输入命令</p><pre><code>./zkServer.sh start</code></pre><p>关闭服务输入命令</p><pre><code>./zkServer.sh stop</code></pre><p>查看状态：</p><pre><code>./zkServer.sh status</code></pre><h3 id="Dubbox本地-JAR包部署与安装"><a href="#Dubbox本地-JAR包部署与安装" class="headerlink" title="Dubbox本地 JAR包部署与安装"></a>Dubbox本地 JAR包部署与安装</h3><p>Dubbox的jar包并没有部署到Maven的中央仓库中，大家在Maven的中央仓库中可以查找到Dubbo的最终版本是2.5.3 , 阿里巴巴解散了Dubbo团队后由当当网继续维护此项目，并改名为 Dubbox ,坐标不变，版本变更了，但是并没有提交到中央仓库。</p><p>我们现在需要手动将Dubbox的jar包安装到我的本地仓库中。</p><p>先将dubbo-2.8.4.jar包放到d:\setup, 然后输入命令</p><pre><code>mvn install:install-file -Dfile=d:\setup\dubbo-2.8.4.jar -DgroupId=com.alibaba -DartifactId=dubbo -Dversion=2.8.4 -Dpackaging=jar</code></pre><h3 id="配置离线约束"><a href="#配置离线约束" class="headerlink" title="配置离线约束"></a>配置离线约束</h3><p>地址：</p><pre><code>http://code.alibabatech.com/schema/dubbo/dubbo.xsd </code></pre><h2 id="入门小Demo"><a href="#入门小Demo" class="headerlink" title="入门小Demo"></a>入门小Demo</h2><h3 id="服务提供者开发"><a href="#服务提供者开发" class="headerlink" title="服务提供者开发"></a>服务提供者开发</h3><p>开发步骤：</p><p>（1）创建Maven工程（WAR）dubboxdemo-service  ，在pom.xml中引入依赖</p><pre><code>&lt;project xmlns=&quot;http://maven.apache.org/POM/4.0.0&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xsi:schemaLocation=&quot;http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd&quot;&gt;  &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt;  &lt;groupId&gt;cn.lxm.dubboxdemo&lt;/groupId&gt;  &lt;artifactId&gt;dubboxdemo-service&lt;/artifactId&gt;  &lt;version&gt;0.0.1-SNAPSHOT&lt;/version&gt;  &lt;packaging&gt;war&lt;/packaging&gt;     &lt;properties&gt;                &lt;spring.version&gt;4.2.4.RELEASE&lt;/spring.version&gt;   &lt;/properties&gt;        &lt;dependencies&gt;        &lt;!-- Spring --&gt;        &lt;dependency&gt;            &lt;groupId&gt;org.springframework&lt;/groupId&gt;            &lt;artifactId&gt;spring-context&lt;/artifactId&gt;            &lt;version&gt;${spring.version}&lt;/version&gt;        &lt;/dependency&gt;        &lt;dependency&gt;            &lt;groupId&gt;org.springframework&lt;/groupId&gt;            &lt;artifactId&gt;spring-beans&lt;/artifactId&gt;            &lt;version&gt;${spring.version}&lt;/version&gt;        &lt;/dependency&gt;        &lt;dependency&gt;            &lt;groupId&gt;org.springframework&lt;/groupId&gt;            &lt;artifactId&gt;spring-webmvc&lt;/artifactId&gt;            &lt;version&gt;${spring.version}&lt;/version&gt;        &lt;/dependency&gt;        &lt;dependency&gt;            &lt;groupId&gt;org.springframework&lt;/groupId&gt;            &lt;artifactId&gt;spring-jdbc&lt;/artifactId&gt;            &lt;version&gt;${spring.version}&lt;/version&gt;        &lt;/dependency&gt;        &lt;dependency&gt;            &lt;groupId&gt;org.springframework&lt;/groupId&gt;            &lt;artifactId&gt;spring-aspects&lt;/artifactId&gt;            &lt;version&gt;${spring.version}&lt;/version&gt;        &lt;/dependency&gt;        &lt;dependency&gt;            &lt;groupId&gt;org.springframework&lt;/groupId&gt;            &lt;artifactId&gt;spring-jms&lt;/artifactId&gt;            &lt;version&gt;${spring.version}&lt;/version&gt;        &lt;/dependency&gt;        &lt;dependency&gt;            &lt;groupId&gt;org.springframework&lt;/groupId&gt;            &lt;artifactId&gt;spring-context-support&lt;/artifactId&gt;            &lt;version&gt;${spring.version}&lt;/version&gt;        &lt;/dependency&gt;            &lt;!-- dubbo相关 --&gt;        &lt;dependency&gt;            &lt;groupId&gt;com.alibaba&lt;/groupId&gt;            &lt;artifactId&gt;dubbo&lt;/artifactId&gt;            &lt;version&gt;2.8.4&lt;/version&gt;                    &lt;/dependency&gt;        &lt;dependency&gt;            &lt;groupId&gt;org.apache.zookeeper&lt;/groupId&gt;            &lt;artifactId&gt;zookeeper&lt;/artifactId&gt;            &lt;version&gt;3.4.6&lt;/version&gt;        &lt;/dependency&gt;        &lt;dependency&gt;            &lt;groupId&gt;com.github.sgroschupf&lt;/groupId&gt;            &lt;artifactId&gt;zkclient&lt;/artifactId&gt;            &lt;version&gt;0.1&lt;/version&gt;        &lt;/dependency&gt;                &lt;dependency&gt;            &lt;groupId&gt;javassist&lt;/groupId&gt;            &lt;artifactId&gt;javassist&lt;/artifactId&gt;            &lt;version&gt;3.11.0.GA&lt;/version&gt;        &lt;/dependency&gt;            &lt;/dependencies&gt;   &lt;build&gt;        &lt;plugins&gt;          &lt;plugin&gt;                &lt;groupId&gt;org.apache.maven.plugins&lt;/groupId&gt;                &lt;artifactId&gt;maven-compiler-plugin&lt;/artifactId&gt;                &lt;version&gt;2.3.2&lt;/version&gt;                &lt;configuration&gt;                    &lt;source&gt;1.7&lt;/source&gt;                    &lt;target&gt;1.7&lt;/target&gt;                &lt;/configuration&gt;            &lt;/plugin&gt;            &lt;plugin&gt;                &lt;groupId&gt;org.apache.tomcat.maven&lt;/groupId&gt;                &lt;artifactId&gt;tomcat7-maven-plugin&lt;/artifactId&gt;                &lt;configuration&gt;                    &lt;!-- 指定端口 --&gt;                    &lt;port&gt;8081&lt;/port&gt;                    &lt;!-- 请求路径 --&gt;                    &lt;path&gt;/&lt;/path&gt;                &lt;/configuration&gt;            &lt;/plugin&gt;      &lt;/plugins&gt;      &lt;/build&gt;&lt;/project&gt;</code></pre><p>（2）在工程的webapps下创建WEB-INF文件夹，创建web.xml</p><pre><code>&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;web-app xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;    xmlns=&quot;http://java.sun.com/xml/ns/javaee&quot;    xsi:schemaLocation=&quot;http://java.sun.com/xml/ns/javaee http://java.sun.com/xml/ns/javaee/web-app_2_5.xsd&quot;    version=&quot;2.5&quot;&gt;        &lt;!-- 加载spring容器 --&gt;    &lt;context-param&gt;        &lt;param-name&gt;contextConfigLocation&lt;/param-name&gt;        &lt;param-value&gt;classpath:applicationContext*.xml&lt;/param-value&gt;    &lt;/context-param&gt;    &lt;listener&gt;        &lt;listener-class&gt;org.springframework.web.context.ContextLoaderListener&lt;/listener-class&gt;    &lt;/listener&gt;    &lt;/web-app&gt;</code></pre><p>（3）创建业务接口<br>创建包cn.lxm.dubbodemo.service，用于存放业务接口，创建接口</p><pre><code>package cn.lxm.dubbodemo.service;/** * 业务接口 * @author Administrator * */public interface UserService {        public String getName();    }</code></pre><p>（4）创建业务实现类<br>创建包cn.lxm.dubbodemo.service.impl ，用于存放业务实现类。创建业务实现类：</p><pre><code>package cn.lxm.dubbodemo.service.impl;import com.alibaba.dubbo.config.annotation.Service;import cn.lxm.dubbodemo.service.UserService;@Servicepublic class UserServiceImpl implements UserService {    public String getName() {                return &quot;lxm&quot;;    }}</code></pre><p>注意：Service注解与原来不同，需要引入com.alibaba包下的</p><p>（5）编写配置文件<br>在src/main/resources下创建applicationContext-service.xml ,内容如下：</p><pre><code>&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot;    xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xmlns:p=&quot;http://www.springframework.org/schema/p&quot;    xmlns:context=&quot;http://www.springframework.org/schema/context&quot;    xmlns:dubbo=&quot;http://code.alibabatech.com/schema/dubbo&quot; xmlns:mvc=&quot;http://www.springframework.org/schema/mvc&quot;    xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd        http://www.springframework.org/schema/mvc http://www.springframework.org/schema/mvc/spring-mvc.xsd        http://code.alibabatech.com/schema/dubbo http://code.alibabatech.com/schema/dubbo/dubbo.xsd        http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context.xsd&quot;&gt;    &lt;dubbo:application name=&quot;dubboxdemo-service&quot;/&gt;  &lt;dubbo:registry address=&quot;zookeeper://192.168.25.132:2181&quot;/&gt; &lt;dubbo:annotation package=&quot;cn.lxm.dubboxdemo.service&quot; /&gt; &lt;/beans&gt;</code></pre><p>注意：dubbo:annotation用于扫描@Service注解。</p><h3 id="服务消费者开发"><a href="#服务消费者开发" class="headerlink" title="服务消费者开发"></a>服务消费者开发</h3><p>开发步骤：</p><p>（1）创建Maven工程（WAR）dubboxdemo-web ，在pom.xml引入依赖 ，同“dubboxdemo-service”工程。区别就是把tomcat插件的运行端口改为8082 。</p><p>（2）在webapps目录下创建WEB-INF 目录，并创建web.xml </p><pre><code>&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;web-app xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;    xmlns=&quot;http://java.sun.com/xml/ns/javaee&quot;    xsi:schemaLocation=&quot;http://java.sun.com/xml/ns/javaee http://java.sun.com/xml/ns/javaee/web-app_2_5.xsd&quot;    version=&quot;2.5&quot;&gt;       &lt;!-- 解决post乱码 --&gt;    &lt;filter&gt;        &lt;filter-name&gt;CharacterEncodingFilter&lt;/filter-name&gt;        &lt;filter-class&gt;org.springframework.web.filter.CharacterEncodingFilter&lt;/filter-class&gt;        &lt;init-param&gt;            &lt;param-name&gt;encoding&lt;/param-name&gt;            &lt;param-value&gt;utf-8&lt;/param-value&gt;        &lt;/init-param&gt;        &lt;init-param&gt;              &lt;param-name&gt;forceEncoding&lt;/param-name&gt;              &lt;param-value&gt;true&lt;/param-value&gt;          &lt;/init-param&gt;      &lt;/filter&gt;    &lt;filter-mapping&gt;        &lt;filter-name&gt;CharacterEncodingFilter&lt;/filter-name&gt;        &lt;url-pattern&gt;/*&lt;/url-pattern&gt;    &lt;/filter-mapping&gt;          &lt;servlet&gt;      &lt;servlet-name&gt;springmvc&lt;/servlet-name&gt;      &lt;servlet-class&gt;org.springframework.web.servlet.DispatcherServlet&lt;/servlet-class&gt;      &lt;!-- 指定加载的配置文件 ，通过参数contextConfigLocation加载--&gt;      &lt;init-param&gt;          &lt;param-name&gt;contextConfigLocation&lt;/param-name&gt;          &lt;param-value&gt;classpath:applicationContext-web.xml&lt;/param-value&gt;      &lt;/init-param&gt;  &lt;/servlet&gt;    &lt;servlet-mapping&gt;      &lt;servlet-name&gt;springmvc&lt;/servlet-name&gt;      &lt;url-pattern&gt;*.do&lt;/url-pattern&gt;  &lt;/servlet-mapping&gt;&lt;/web-app&gt;</code></pre><p>（3）拷贝业务接口<br>将“dubboxdemo-service”工程的cn.lxm.dubboxdemo.service 包以及下面的接口拷贝至此工程。</p><p>（4）编写Controller </p><pre><code>package cn.lxm.dubboxdemo.controller;import org.springframework.beans.factory.annotation.Autowired;import org.springframework.stereotype.Controller;import org.springframework.web.bind.annotation.RequestMapping;import org.springframework.web.bind.annotation.ResponseBody;import cn.lxm.dubbodemo.service.UserService;@Controller@RequestMapping(&quot;/user&quot;)public class UserController {    @Reference    private UserService userService;        @RequestMapping(&quot;/showName&quot;)    @ResponseBody    public String showName(){        return userService.getName();    }        }</code></pre><p>（5）编写spring配置文件<br>在src/main/resources下创建applicationContext-web.xml  </p><pre><code>&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot;    xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xmlns:p=&quot;http://www.springframework.org/schema/p&quot;    xmlns:context=&quot;http://www.springframework.org/schema/context&quot;    xmlns:dubbo=&quot;http://code.alibabatech.com/schema/dubbo&quot; xmlns:mvc=&quot;http://www.springframework.org/schema/mvc&quot;    xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd        http://www.springframework.org/schema/mvc http://www.springframework.org/schema/mvc/spring-mvc.xsd        http://code.alibabatech.com/schema/dubbo http://code.alibabatech.com/schema/dubbo/dubbo.xsd        http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context.xsd&quot;&gt;    &lt;mvc:annotation-driven &gt;        &lt;mvc:message-converters register-defaults=&quot;false&quot;&gt;            &lt;bean class=&quot;org.springframework.http.converter.StringHttpMessageConverter&quot;&gt;                  &lt;constructor-arg value=&quot;UTF-8&quot; /&gt;            &lt;/bean&gt;          &lt;/mvc:message-converters&gt;        &lt;/mvc:annotation-driven&gt;    &lt;!-- 引用dubbo 服务 --&gt;    &lt;dubbo:application name=&quot;dubboxdemo-web&quot; /&gt;    &lt;dubbo:registry address=&quot;zookeeper://192.168.25.132:2181&quot;/&gt;     &lt;dubbo:annotation package=&quot;cn.lxm.dubboxdemo.controller&quot; /&gt;&lt;/beans&gt;</code></pre><p>（6）测试运行</p><p>tomcat7:run<br>在浏览器输入<a href="http://localhost:8082/user/showName.do，查看浏览器输出结果" target="_blank" rel="noopener">http://localhost:8082/user/showName.do，查看浏览器输出结果</a></p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;Dubbox框架&quot;&gt;&lt;a href=&quot;#Dubbox框架&quot; class=&quot;headerlink&quot; title=&quot;Dubbox框架&quot;&gt;&lt;/a&gt;Dubbox框架&lt;/h1&gt;&lt;h2 id=&quot;Dubbox简介&quot;&gt;&lt;a href=&quot;#Dubbox简介&quot; class=&quot;headerlink&quot; title=&quot;Dubbox简介&quot;&gt;&lt;/a&gt;Dubbox简介&lt;/h2&gt;&lt;p&gt;Dubbox 是一个&lt;strong&gt;分布式服务框架&lt;/strong&gt;，其前身是阿里巴巴开源项目Dubbo ，被国内电商及互联网项目中使用，后期阿里巴巴停止了该项目的维护，当当网便在Dubbo基础上进行优化，并继续维护，为了与原有的Dubbo区分，故将其命名为Dubbox。&lt;br&gt;
    
    </summary>
    
      <category term="java" scheme="http://www.fashionkillyou.xyz/categories/java/"/>
    
    
      <category term="Dubbox" scheme="http://www.fashionkillyou.xyz/tags/Dubbox/"/>
    
      <category term="分布式服务框架" scheme="http://www.fashionkillyou.xyz/tags/%E5%88%86%E5%B8%83%E5%BC%8F%E6%9C%8D%E5%8A%A1%E6%A1%86%E6%9E%B6/"/>
    
      <category term="Dubbo" scheme="http://www.fashionkillyou.xyz/tags/Dubbo/"/>
    
  </entry>
  
  <entry>
    <title>Lucene全文检索入门</title>
    <link href="http://www.fashionkillyou.xyz/2018/03/03/Lucene%E5%85%A8%E6%96%87%E6%A3%80%E7%B4%A2%E5%85%A5%E9%97%A8/"/>
    <id>http://www.fashionkillyou.xyz/2018/03/03/Lucene全文检索入门/</id>
    <published>2018-03-03T13:02:41.000Z</published>
    <updated>2018-03-17T16:21:20.427Z</updated>
    
    <content type="html"><![CDATA[<script src="\assets\js\APlayer.min.js"> </script><p>#Lucene概述</p><h2 id="什么是Lucene"><a href="#什么是Lucene" class="headerlink" title="什么是Lucene"></a>什么是Lucene</h2><ul><li><p>Lucene是一套用于全文检索和搜寻的开源程序库，由Apache软件基金会支持和提供</p></li><li><p>Lucene提供了一个简单却强大的应用程序接口（API），能够做全文索引和搜寻，在Java开发环境里Lucene是一个成熟的免费开放源代码工具</p></li><li><p>Lucene并不是现成的搜索引擎产品，但可以用来制作搜索引擎产品</p></li><li><p>官网：<a href="http://lucene.apache.org/" target="_blank" rel="noopener">http://lucene.apache.org/</a></p></li></ul><p># </p><p>待更新…</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;script src=&quot;\assets\js\APlayer.min.js&quot;&gt; &lt;/script&gt;&lt;p&gt;#Lucene概述&lt;/p&gt;
&lt;h2 id=&quot;什么是Lucene&quot;&gt;&lt;a href=&quot;#什么是Lucene&quot; class=&quot;headerlink&quot; title=&quot;什么是Luce
      
    
    </summary>
    
      <category term="搜索解决方案" scheme="http://www.fashionkillyou.xyz/categories/%E6%90%9C%E7%B4%A2%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88/"/>
    
    
      <category term="Lucene" scheme="http://www.fashionkillyou.xyz/tags/Lucene/"/>
    
      <category term="全文检索" scheme="http://www.fashionkillyou.xyz/tags/%E5%85%A8%E6%96%87%E6%A3%80%E7%B4%A2/"/>
    
  </entry>
  
  <entry>
    <title>使用formfill.js快速填充表单</title>
    <link href="http://www.fashionkillyou.xyz/2018/03/02/%E4%BD%BF%E7%94%A8formfill-js%E5%BF%AB%E9%80%9F%E5%A1%AB%E5%85%85%E8%A1%A8%E5%8D%95/"/>
    <id>http://www.fashionkillyou.xyz/2018/03/02/使用formfill-js快速填充表单/</id>
    <published>2018-03-02T13:26:17.000Z</published>
    <updated>2018-03-02T16:12:15.573Z</updated>
    
    <content type="html"><![CDATA[<script src="\assets\js\APlayer.min.js"> </script><h1 id="form表单的快速回显"><a href="#form表单的快速回显" class="headerlink" title="form表单的快速回显"></a>form表单的快速回显</h1><p>做项目开发的时候在写修改的页面时,如果字段很多的话,数据回显塞值挺麻烦的,所以最近找了一个formfill.js快速填充表单的js</p><p>使用起来很简单,首先引用js文件<br><a id="more"></a><br>百度云盘下载:</p><p>链接：<a href="https://pan.baidu.com/s/1mjSDRtA" target="_blank" rel="noopener">https://pan.baidu.com/s/1mjSDRtA</a></p><p>密码：5ljt</p><pre><code>&lt;script src=&quot;../js/jquery.formautofill.js&quot;&gt;&lt;/script&gt;</code></pre><p>使用:</p><pre><code>var data = {&quot;name&quot;:&quot;haha&quot;,&quot;password&quot;:&quot;123&quot;}$(&quot;#formId&quot;).autofill(data);</code></pre><h1 id="英文解释"><a href="#英文解释" class="headerlink" title="英文解释:"></a>英文解释:</h1><h1 id="jQuery-form-autofill"><a href="#jQuery-form-autofill" class="headerlink" title="jQuery form autofill"></a>jQuery form autofill</h1><p>jQuery plugin to simply autofill an empty form with data.</p><h2 id="Documentation"><a href="#Documentation" class="headerlink" title="Documentation"></a>Documentation</h2><p><a href="http://labs.creative-area.net/jquery.formautofill/doc/" target="_blank" rel="noopener">See complete documentation and demo</a></p><h2 id="Usage"><a href="#Usage" class="headerlink" title="Usage"></a>Usage</h2><p>You have a <strong>form</strong></p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">form</span> <span class="attr">id</span>=<span class="string">"f"</span>&gt;</span></span><br><span class="line">    name <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"text"</span> <span class="attr">name</span>=<span class="string">"name"</span>&gt;</span></span><br><span class="line">    email <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"text"</span> <span class="attr">name</span>=<span class="string">"email"</span>&gt;</span></span><br><span class="line">    love jQuery</span><br><span class="line">    <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"radio"</span> <span class="attr">name</span>=<span class="string">"lovejquery"</span> <span class="attr">value</span>=<span class="string">"yes"</span>&gt;</span> yes</span><br><span class="line">    <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"radio"</span> <span class="attr">name</span>=<span class="string">"lovejquery"</span> <span class="attr">value</span>=<span class="string">"no"</span>&gt;</span> no</span><br><span class="line"><span class="tag">&lt;/<span class="name">form</span>&gt;</span></span><br></pre></td></tr></table></figure><p>And <strong>data</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> data = &#123;</span><br><span class="line">    <span class="string">"name"</span>: <span class="string">"John Doe"</span>,</span><br><span class="line">    <span class="string">"email"</span>: <span class="string">"johndoe@mail.com"</span>,</span><br><span class="line">    <span class="string">"lovejquery"</span>: <span class="string">"yes"</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>Autofill</strong> the form with data ? just do</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$(<span class="string">"#f"</span>).autofill( data );</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;form表单的快速回显&quot;&gt;&lt;a href=&quot;#form表单的快速回显&quot; class=&quot;headerlink&quot; title=&quot;form表单的快速回显&quot;&gt;&lt;/a&gt;form表单的快速回显&lt;/h1&gt;&lt;p&gt;做项目开发的时候在写修改的页面时,如果字段很多的话,数据回显塞值挺麻烦的,所以最近找了一个formfill.js快速填充表单的js&lt;/p&gt;
&lt;p&gt;使用起来很简单,首先引用js文件&lt;br&gt;
    
    </summary>
    
      <category term="前端" scheme="http://www.fashionkillyou.xyz/categories/%E5%89%8D%E7%AB%AF/"/>
    
    
      <category term="jquery" scheme="http://www.fashionkillyou.xyz/tags/jquery/"/>
    
      <category term="formautofill" scheme="http://www.fashionkillyou.xyz/tags/formautofill/"/>
    
  </entry>
  
  <entry>
    <title>SpringMVC架构入门二</title>
    <link href="http://www.fashionkillyou.xyz/2018/03/01/SpringMVC%E6%9E%B6%E6%9E%84%E5%85%A5%E9%97%A8%E4%BA%8C/"/>
    <id>http://www.fashionkillyou.xyz/2018/03/01/SpringMVC架构入门二/</id>
    <published>2018-02-28T16:10:20.000Z</published>
    <updated>2018-03-16T04:01:45.057Z</updated>
    
    <content type="html"><![CDATA[<script src="\assets\js\APlayer.min.js"> </script><h1 id="高级参数绑定"><a href="#高级参数绑定" class="headerlink" title="高级参数绑定"></a>高级参数绑定</h1><h2 id="绑定数组"><a href="#绑定数组" class="headerlink" title="绑定数组"></a>绑定数组</h2><p>Controller方法中可以用String[]接收，或者pojo的String[]属性接收。两种方式任选其一即可。<br><a id="more"></a><br>使用String[]:</p><pre><code>@RequestMapping(&quot;/queryitem&quot;)public String queryItem(Query queryVo, String[] ids) {    System.out.println(queryVo.getItems().getName());    System.out.println(queryVo.getItems().getPrice());    System.out.println(ids.toString());    return null;}</code></pre><p>pojo的String[]:</p><pre><code>public class Query{    private Items items;    private String[] ids;    get/set...}</code></pre><h2 id="将表单的数据绑定到List"><a href="#将表单的数据绑定到List" class="headerlink" title="将表单的数据绑定到List"></a>将表单的数据绑定到List</h2><p>List中存放对象，并将定义的List放在包装类中，使用包装pojo对象接收。</p><pre><code>public class Query{    private Items items;    private String[] ids;    private List&lt;Items&gt; itemList;    get/set...}</code></pre><p>jsp页面:</p><pre><code>&lt;tr&gt;    &lt;td&gt;        &lt;input type=&quot;text&quot; name=&quot; itemsList[0].id&quot; value=&quot;${item.id}&quot;/&gt;    &lt;/td&gt;    &lt;td&gt;        &lt;input type=&quot;text&quot; name=&quot; itemsList[0].name&quot; value=&quot;${item.name }&quot;/&gt;    &lt;/td&gt;    &lt;td&gt;        &lt;input type=&quot;text&quot; name=&quot; itemsList[0].price&quot; value=&quot;${item.price}&quot;/&gt;    &lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;    &lt;td&gt;        &lt;input type=&quot;text&quot; name=&quot; itemsList[1].id&quot; value=&quot;${item.id}&quot;/&gt;    &lt;/td&gt;    &lt;td&gt;        &lt;input type=&quot;text&quot; name=&quot; itemsList[1].name&quot; value=&quot;${item.name }&quot;/&gt;    &lt;/td&gt;    &lt;td&gt;        &lt;input type=&quot;text&quot; name=&quot; itemsList[1].price&quot; value=&quot;${item.price}&quot;/&gt;    &lt;/td&gt;&lt;/tr&gt;</code></pre><p>Name属性必须是包装pojo的list属性+下标+元素属性。</p><p>Jsp做如下改造：</p><pre><code>&lt;c:forEach items=&quot;${itemList }&quot; var=&quot;item&quot;&gt;&lt;tr&gt;    &lt;td&gt;        &lt;input name=&quot;ids&quot; value=&quot;${item.id}&quot; type=&quot;checkbox&quot;&gt;&lt;/td&gt;    &lt;td&gt;        &lt;input name=&quot;id&quot; value=&quot;${item.id}&quot; type=&quot;hidden&quot;&gt;        &lt;input name=&quot;name&quot; value=&quot;${item.name }&quot; type=&quot;text&quot;&gt;    &lt;/td&gt;    &lt;td&gt;        &lt;input name=&quot;name&quot; value=&quot;${item.price }&quot; type=&quot;text&quot;&gt;&lt;/td&gt;    &lt;td&gt;        &lt;input name=&quot;name&quot; value=&quot;&lt;fmt:formatDate value=&quot;${item.createtime}&quot; pattern=&quot;yyyy-MM-dd HH:mm:ss&quot;/&gt;&quot; type=&quot;text&quot;&gt;&lt;/td&gt;    &lt;td&gt;        &lt;input name=&quot;name&quot; value=&quot;${item.detail }&quot; type=&quot;text&quot;&gt;&lt;/td&gt;    &lt;td&gt;        &lt;a href=&quot;${pageContext.request.contextPath }/itemEdit.action?id=${item.id}&quot;&gt;修改&lt;/a&gt;    &lt;/td&gt;&lt;/tr&gt;&lt;/c:forEach&gt;</code></pre><p>varStatus属性常用参数总结下：</p><pre><code>${status.index}      输出行号，从0开始。${status.count}      输出行号，从1开始。${status.current}   当前这次迭代的（集合中的）项${status.first}  判断当前项是否为集合中的第一项，返回值为true或false${status.last}   判断当前项是否为集合中的最后一项，返回值为true或falsebegin、end、step分别表示：起始序号，结束序号，跳跃步伐。</code></pre><p>Contrller</p><pre><code>@RequestMapping(&quot;/queryitem&quot;)public String queryItem(QueryVo queryVo, String[] ids) {    System.out.println(queryVo.getItems().getName());    System.out.println(queryVo.getItems().getPrice());    System.out.println(ids.toString());    return null;}</code></pre><p>注意：接收List类型的数据必须是pojo的属性，方法的形参为List类型无法正确接收到数据。</p><h1 id="RequestMapping"><a href="#RequestMapping" class="headerlink" title="@RequestMapping"></a>@RequestMapping</h1><p>通过RequestMapping注解可以定义不同的处理器映射规则。</p><h2 id="URL路径映射"><a href="#URL路径映射" class="headerlink" title="URL路径映射"></a>URL路径映射</h2><p>@RequestMapping(value=”/item”)或@RequestMapping(“/item）<br>value的值是数组，可以将多个url映射到同一个方法</p><h2 id="窄化请求映射"><a href="#窄化请求映射" class="headerlink" title="窄化请求映射"></a>窄化请求映射</h2><p>在class上添加@RequestMapping(url)指定通用请求前缀， 限制此类下的所有方法请求url必须以请求前缀开头，通过此方法对url进行分类管理。</p><p>如下：</p><pre><code>@RequestMapping放在类名上边，设置请求前缀 @Controller@RequestMapping(&quot;/item&quot;)</code></pre><p>方法名上边设置请求映射url：</p><pre><code>@RequestMapping放在方法名上边，如下：@RequestMapping(&quot;/queryItem &quot;)</code></pre><p>访问地址为：/item/queryItem</p><h2 id="请求方法限定"><a href="#请求方法限定" class="headerlink" title="请求方法限定"></a>请求方法限定</h2><h3 id="限定GET方法"><a href="#限定GET方法" class="headerlink" title="限定GET方法"></a>限定GET方法</h3><pre><code>@RequestMapping(method = RequestMethod.GET)</code></pre><p>如果通过Post访问则报错：<br>HTTP Status 405 - Request method ‘POST’ not supported</p><p>例如：</p><pre><code>@RequestMapping(value=&quot;/editItem&quot;,method=RequestMethod.GET)</code></pre><h3 id="限定POST方法"><a href="#限定POST方法" class="headerlink" title="限定POST方法"></a>限定POST方法</h3><pre><code>@RequestMapping(method = RequestMethod.POST)</code></pre><p>如果通过Post访问则报错：<br>HTTP Status 405 - Request method ‘GET’ not supported</p><h3 id="GET和POST都可以"><a href="#GET和POST都可以" class="headerlink" title="GET和POST都可以"></a>GET和POST都可以</h3><pre><code>@RequestMapping(method={RequestMethod.GET,RequestMethod.POST})</code></pre><h1 id="controller方法返回值"><a href="#controller方法返回值" class="headerlink" title="controller方法返回值"></a>controller方法返回值</h1><h2 id="返回ModelAndView"><a href="#返回ModelAndView" class="headerlink" title="返回ModelAndView"></a>返回ModelAndView</h2><p>controller方法中定义ModelAndView对象并返回，对象中可添加model数据、指定view。</p><h2 id="返回void"><a href="#返回void" class="headerlink" title="返回void"></a>返回void</h2><p>在controller方法形参上可以定义request和response，使用request或response指定响应结果：</p><p>1、使用request转向页面，如下：</p><pre><code>request.getRequestDispatcher(&quot;页面路径&quot;).forward(request, response);</code></pre><p>2、也可以通过response页面重定向：</p><pre><code>response.sendRedirect(&quot;url&quot;)</code></pre><p>3、也可以通过response指定响应结果，例如响应json数据如下：</p><pre><code>response.setCharacterEncoding(&quot;utf-8&quot;);response.setContentType(&quot;application/json;charset=utf-8&quot;);response.getWriter().write(&quot;json串&quot;);</code></pre><h2 id="返回字符串"><a href="#返回字符串" class="headerlink" title="返回字符串"></a>返回字符串</h2><h3 id="逻辑视图名"><a href="#逻辑视图名" class="headerlink" title="逻辑视图名"></a>逻辑视图名</h3><p>controller方法返回字符串可以指定逻辑视图名，通过视图解析器解析为物理视图地址。</p><pre><code>//指定逻辑视图名，经过视图解析器解析为jsp物理路径：/WEB-INF/jsp/item/editItem.jspreturn &quot;item/editItem&quot;;</code></pre><h3 id="Redirect重定向"><a href="#Redirect重定向" class="headerlink" title="Redirect重定向"></a>Redirect重定向</h3><p>Contrller方法返回结果重定向到一个url地址，如下商品修改提交后重定向到商品查询方法，参数无法带到商品查询方法中。</p><pre><code>//重定向到queryItem.action地址,request无法带过去return &quot;redirect:queryItem.action&quot;;</code></pre><p>redirect方式相当于“response.sendRedirect()”，转发后浏览器的地址栏变为转发后的地址，因为转发即执行了一个新的request和response。<br>由于新发起一个request原来的参数在转发时就不能传递到下一个url，如果要传参数可以/item/queryItem.action后边加参数，如下：</p><pre><code>/item/queryItem?...&amp;…..</code></pre><p>如果使用了model的话,他会自动给你拼接数据,就是自动在后面拼接?</p><h3 id="forward转发"><a href="#forward转发" class="headerlink" title="forward转发"></a>forward转发</h3><p>controller方法执行后继续执行另一个controller方法，如下商品修改提交后转向到商品修改页面，修改商品的id参数可以带到商品修改方法中。</p><pre><code>//结果转发到editItem.action，request可以带过去return &quot;forward:editItem.action&quot;;</code></pre><p>forward方式相当于“request.getRequestDispatcher().forward(request,response)”，转发后浏览器地址栏还是原来的地址。转发并没有执行新的request和response，而是和转发前的请求共用一个request和response。所以转发前请求的参数在转发后仍然可以读取到。</p><h1 id="异常处理器"><a href="#异常处理器" class="headerlink" title="异常处理器"></a>异常处理器</h1><p>springmvc在处理请求过程中出现异常信息交由异常处理器进行处理，自定义异常处理器可以实现一个系统的异常处理逻辑。</p><h2 id="异常处理思路"><a href="#异常处理思路" class="headerlink" title="异常处理思路"></a>异常处理思路</h2><p>系统中异常包括两类：预期异常和运行时异常RuntimeException，前者通过捕获异常从而获取异常信息，后者主要通过规范代码开发、测试通过手段减少运行时异常的发生。</p><p>系统的dao、service、controller出现都通过throws Exception向上抛出，最后由springmvc前端控制器交由异常处理器进行异常处理</p><p>步骤:写异常处理器类,然后在springmvc.xml中配置,然后写异常错误页面</p><h2 id="自定义异常处理器"><a href="#自定义异常处理器" class="headerlink" title="自定义异常处理器"></a>自定义异常处理器</h2><pre><code>public class CustomExceptionResolver implements HandlerExceptionResolver {    @Override    public ModelAndView resolveException(HttpServletRequest request,            HttpServletResponse response, Object handler, Exception ex) {        ex.printStackTrace();        CustomException customException = null;        //如果抛出的是系统自定义异常则直接转换        if(ex instanceof CustomException){            customException = (CustomException)ex;        }else{            //如果抛出的不是系统自定义异常则重新构造一个系统错误异常。            customException = new CustomException(&quot;系统错误，请与系统管理 员联系！&quot;);        }        ModelAndView modelAndView = new ModelAndView();        modelAndView.addObject(&quot;message&quot;, customException.getMessage());        modelAndView.setViewName(&quot;error&quot;);        return modelAndView;    }}</code></pre><p>###取异常堆栈：</p><pre><code>//错误信息存储在堆栈中,取异常堆栈将其显示在控制台上,或输出到日志文件中       try {        } catch (Exception e) {            StringWriter s = new StringWriter();            PrintWriter printWriter = new PrintWriter(s);            e.printStackTrace(printWriter);            s.toString();        }</code></pre><h2 id="错误页面"><a href="#错误页面" class="headerlink" title="错误页面"></a>错误页面</h2><pre><code>&lt;%@ page language=&quot;java&quot; contentType=&quot;text/html; charset=UTF-8&quot;    pageEncoding=&quot;UTF-8&quot;%&gt;&lt;%@ taglib uri=&quot;http://java.sun.com/jsp/jstl/core&quot; prefix=&quot;c&quot; %&gt;&lt;%@ taglib uri=&quot;http://java.sun.com/jsp/jstl/fmt&quot;  prefix=&quot;fmt&quot;%&gt; &lt;!DOCTYPE html PUBLIC &quot;-//W3C//DTD HTML 4.01 Transitional//EN&quot; &quot;http://www.w3.org/TR/html4/loose.dtd&quot;&gt;&lt;html&gt;&lt;head&gt;&lt;meta http-equiv=&quot;Content-Type&quot; content=&quot;text/html; charset=UTF-8&quot;&gt;&lt;title&gt;错误页面&lt;/title&gt;&lt;/head&gt;&lt;body&gt;您的操作出现错误如下：&lt;br/&gt;${message }&lt;/body&gt;&lt;/html&gt;</code></pre><h2 id="异常处理器配置"><a href="#异常处理器配置" class="headerlink" title="异常处理器配置"></a>异常处理器配置</h2><p>在springmvc.xml中添加：</p><pre><code>&lt;!-- 全局异常处理器 --&gt;&lt;bean class=&quot;com.lxm.springmvc.exception.GlobalExceptionResolver&quot;/&gt;</code></pre><h2 id="测试异常"><a href="#测试异常" class="headerlink" title="测试异常"></a>测试异常</h2><p>在需要抛出异常的地方加上throw new CustomerException(“出错信息”);然后方法上向上抛出就可以了</p><pre><code>@RequestMapping(&quot;/itemEdit&quot;)public String getEditItem(@RequestParam(value=&quot;id&quot;,required=true)Integer id,Model model) throws CustomerException{    Items items = itemService.getItemById(id);    if(items == null){        throw new CustomerException(&quot;商品信息不存在!&quot;);    }    model.addAttribute(&quot;item&quot;,items);    return &quot;editItem&quot;;}</code></pre><h1 id="上传图片"><a href="#上传图片" class="headerlink" title="上传图片"></a>上传图片</h1><h2 id="配置虚拟目录"><a href="#配置虚拟目录" class="headerlink" title="配置虚拟目录"></a>配置虚拟目录</h2><p>在tomcat上配置图片虚拟目录，在tomcat下conf/server.xml中添加：</p><pre><code>&lt;Context docBase=&quot;F:\develop\upload\temp&quot; path=&quot;/pic&quot; reloadable=&quot;false&quot;/&gt;</code></pre><p>访问<a href="http://localhost:8080/pic即可访问F:\develop\upload\temp下的图片。" target="_blank" rel="noopener">http://localhost:8080/pic即可访问F:\develop\upload\temp下的图片。</a></p><p>也可以通过eclipse配置：</p><p>1:在tomcat服务配置里面有个modules,<br>点击AddExternalWebModule</p><p>2:然后在Documentbase里面填写虚拟路径的绝对路径(例如:F:\develop\upload\temp),</p><p>3:在Path里面填写虚拟路径(例如:/pic)</p><p>4:AutoReload(这个根据需要自行设定,以下是作用,一般设置为disabled就可以)</p><pre><code>在eclipse中集成tomca来开发时,如果使用run as模式启动项目的话,tomcat配置Auto reloading enabled,我们修改java文件,项目会重新加载,修改的内容会生效.如果使用debug as 模式启动项目的话,tomcat不要配置Auto reloading enabled,我们修改的java文件,也会生效.注意:在debug模式下,tomcat配置了Auto reloading enabled,当修改了java文件,项目会报错.</code></pre><h2 id="jar包"><a href="#jar包" class="headerlink" title="jar包"></a>jar包</h2><p>CommonsMultipartResolver解析器依赖:</p><pre><code>commons-fileuploadcommons-io</code></pre><h2 id="配置解析器"><a href="#配置解析器" class="headerlink" title="配置解析器"></a>配置解析器</h2><p>springmvc.xml</p><pre><code>&lt;!-- 文件上传 --&gt;&lt;bean id=&quot;multipartResolver&quot;    class=&quot;org.springframework.web.multipart.commons.CommonsMultipartResolver&quot;&gt;    &lt;!-- 设置上传文件的最大尺寸为5MB --&gt;    &lt;property name=&quot;maxUploadSize&quot;&gt;        &lt;value&gt;5242880&lt;/value&gt;    &lt;/property&gt;&lt;/bean&gt;</code></pre><h2 id="图片上传"><a href="#图片上传" class="headerlink" title="图片上传"></a>图片上传</h2><p>controller：</p><pre><code>@RequestMapping(&quot;/updateitem&quot;)public String updateItem(Items items,MultipartFile pictureFile) throws Exception, IOException{    //把图片保存到图片目录下    //为每个文件生成一个新的文件名    String picName = UUID.randomUUID().toString();    //去文件的扩展名    String oriName = pictureFile.getOriginalFilename();    System.out.println(&quot;oriName&quot;+oriName);    if(oriName!=null &amp;&amp; oriName!=&quot;&quot;){        String extName = oriName.substring(oriName.lastIndexOf(&quot;.&quot;));        System.out.println(&quot;extName&quot;+extName);        //保存文件 d:\picture\temp        pictureFile.transferTo(new File(&quot;d:\\picture\\temp\\&quot;+picName+extName));        //把文件名保存到数据库        items.setPic(picName+extName);    }    itemService.updateItem(items);//        return &quot;forward:/itemList.action?items=&quot;+items;//转发是可以传递对象的    return &quot;forward:/itemList.action&quot;;}</code></pre><h2 id="页面："><a href="#页面：" class="headerlink" title="页面："></a>页面：</h2><pre><code>form添加enctype=&quot;multipart/form-data&quot;：&lt;form id=&quot;itemForm&quot;action=&quot;${pageContext.request.contextPath }/item/editItemSubmit.action&quot;    method=&quot;post&quot; enctype=&quot;multipart/form-data&quot;&gt;    &lt;input type=&quot;hidden&quot; name=&quot;pic&quot; value=&quot;${item.pic }&quot; /&gt;file的name与controller形参一致：&lt;tr&gt;    &lt;td&gt;商品图片&lt;/td&gt;    &lt;td&gt;&lt;c:if test=&quot;${item.pic !=null}&quot;&gt;            &lt;img src=&quot;/pic/${item.pic}&quot; width=100 height=100 /&gt;            &lt;br /&gt;        &lt;/c:if&gt; &lt;input type=&quot;file&quot; name=&quot;pictureFile&quot; /&gt;&lt;/td&gt;&lt;/tr&gt;</code></pre><h1 id="json数据交互"><a href="#json数据交互" class="headerlink" title="json数据交互"></a>json数据交互</h1><h2 id="RequestBody"><a href="#RequestBody" class="headerlink" title="@RequestBody"></a>@RequestBody</h2><p>作用：</p><p>@RequestBody注解用于读取http请求的内容(字符串)，通过springmvc提供的HttpMessageConverter接口将读到的内容转换为json、xml等格式的数据并绑定到controller方法的参数上。</p><p>List.action?id=1&amp;name=zhangsan&amp;age=12</p><p>本例子应用：</p><p>@RequestBody注解实现接收http请求的json数据，将json数据转换为java对象</p><h2 id="ResponseBody"><a href="#ResponseBody" class="headerlink" title="@ResponseBody"></a>@ResponseBody</h2><p>作用：</p><p>该注解用于将Controller的方法返回的对象，通过HttpMessageConverter接口转换为指定格式的数据如：json,xml等，通过Response响应给客户端</p><p>本例子应用：</p><p>@ResponseBody注解实现将controller方法返回对象转换为json响应给客户端</p><h2 id="请求json，响应json实现："><a href="#请求json，响应json实现：" class="headerlink" title="请求json，响应json实现："></a>请求json，响应json实现：</h2><h3 id="环境准备"><a href="#环境准备" class="headerlink" title="环境准备"></a>环境准备</h3><p>Springmvc默认用MappingJacksonHttpMessageConverter对json数据进行转换，需要加入jackson的包，</p><pre><code>jackson-annotations-2.4.0.jarjackson-core-2.4.2.jarjackson-databind-2.4.2.jar</code></pre><h3 id="配置json转换器"><a href="#配置json转换器" class="headerlink" title="配置json转换器"></a>配置json转换器</h3><p>在注解适配器中加入messageConverters</p><pre><code>&lt;!--注解适配器 --&gt;&lt;bean class=&quot;org.springframework.web.servlet.mvc.method.annotation.RequestMappingHandlerAdapter&quot;&gt;    &lt;property name=&quot;messageConverters&quot;&gt;    &lt;list&gt;    &lt;bean class=&quot;org.springframework.http.converter.json.MappingJacksonHttpMessageConverter&quot;&gt;&lt;/bean&gt;    &lt;/list&gt;    &lt;/property&gt;&lt;/bean&gt;</code></pre><p>注意：如果使用<mvc:annotation-driven> 则不用定义上边的内容。</mvc:annotation-driven></p><h3 id="controller编写"><a href="#controller编写" class="headerlink" title="controller编写"></a>controller编写</h3><pre><code>// 商品修改提交json信息，响应json信息@RequestMapping(&quot;/editItemSubmit_RequestJson&quot;)public @ResponseBody Items editItemSubmit_RequestJson(@RequestBody Items items) throws Exception {    System.out.println(items);    //itemService.saveItem(items);    return items;}</code></pre><h3 id="页面js方法编写："><a href="#页面js方法编写：" class="headerlink" title="页面js方法编写："></a>页面js方法编写：</h3><p>引入 js：<br>    <script type="text/javascript" src="${pageContext.request.contextPath }/js/jquery-1.4.4.min.js"></script></p><pre><code>//请求json响应jsonfunction request_json(){    $.ajax({        type:&quot;post&quot;,        url:&quot;${pageContext.request.contextPath }/item/editItemSubmit_RequestJson.action&quot;,        contentType:&quot;application/json;charset=utf-8&quot;,        data:&apos;{&quot;name&quot;:&quot;测试商品&quot;,&quot;price&quot;:99.9}&apos;,        success:function(data){            alert(data);        }    });}</code></pre>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;高级参数绑定&quot;&gt;&lt;a href=&quot;#高级参数绑定&quot; class=&quot;headerlink&quot; title=&quot;高级参数绑定&quot;&gt;&lt;/a&gt;高级参数绑定&lt;/h1&gt;&lt;h2 id=&quot;绑定数组&quot;&gt;&lt;a href=&quot;#绑定数组&quot; class=&quot;headerlink&quot; title=&quot;绑定数组&quot;&gt;&lt;/a&gt;绑定数组&lt;/h2&gt;&lt;p&gt;Controller方法中可以用String[]接收，或者pojo的String[]属性接收。两种方式任选其一即可。&lt;br&gt;
    
    </summary>
    
      <category term="SSM" scheme="http://www.fashionkillyou.xyz/categories/SSM/"/>
    
    
      <category term="SpringMVC" scheme="http://www.fashionkillyou.xyz/tags/SpringMVC/"/>
    
      <category term="SpringWebMVC" scheme="http://www.fashionkillyou.xyz/tags/SpringWebMVC/"/>
    
  </entry>
  
  <entry>
    <title>SpringMVC架构入门一</title>
    <link href="http://www.fashionkillyou.xyz/2018/02/27/SpringMVC%E6%9E%B6%E6%9E%84%E5%85%A5%E9%97%A8%E4%B8%80/"/>
    <id>http://www.fashionkillyou.xyz/2018/02/27/SpringMVC架构入门一/</id>
    <published>2018-02-27T10:58:33.000Z</published>
    <updated>2018-03-16T04:01:31.022Z</updated>
    
    <content type="html"><![CDATA[<script src="\assets\js\APlayer.min.js"> </script><h1 id="SpringMVC架构"><a href="#SpringMVC架构" class="headerlink" title="SpringMVC架构"></a>SpringMVC架构</h1><p>Spring web mvc和Struts2都属于表现层的框架,它是Spring框架的一部分.</p><h2 id="架构流程"><a href="#架构流程" class="headerlink" title="架构流程"></a>架构流程</h2><pre><code>1、    用户发送请求至前端控制器DispatcherServlet2、    DispatcherServlet收到请求调用HandlerMapping处理器映射器。3、    处理器映射器根据请求url找到具体的处理器，生成处理器对象及处理器拦截器(如果有则生成)一并返回给DispatcherServlet。4、    DispatcherServlet通过HandlerAdapter处理器适配器调用处理器5、    执行处理器(Controller，也叫后端控制器)。6、    Controller执行完成返回ModelAndView7、    HandlerAdapter将controller执行结果ModelAndView返回给DispatcherServlet8、    DispatcherServlet将ModelAndView传给ViewReslover视图解析器9、    ViewReslover解析后返回具体View10、    DispatcherServlet对View进行渲染视图（即将模型数据填充至视图中）。11、    DispatcherServlet响应用户</code></pre><a id="more"></a><p><img src="http://p57l8frp4.bkt.clouddn.com/springmvc%E6%89%A7%E8%A1%8C%E6%B5%81%E7%A8%8B%E5%9B%BE2.jpg" alt=""></p><h2 id="组件说明"><a href="#组件说明" class="headerlink" title="组件说明"></a>组件说明</h2><p>以下组件通常使用框架提供实现：</p><ul><li><p>DispatcherServlet：前端控制器</p><p>  用户请求到达前端控制器，它就相当于mvc模式中的c，dispatcherServlet是整个流程控制的中心，由它调用其它组件处理用户的请求，dispatcherServlet的存在降低了组件之间的耦合性。</p></li><li><p>HandlerMapping：处理器映射器</p><p>  HandlerMapping负责根据用户请求找到Handler即处理器，springmvc提供了不同的映射器实现不同的映射方式，例如：配置文件方式，实现接口方式，注解方式等。</p></li><li><p>Handler：处理器</p><p>  Handler 是继DispatcherServlet前端控制器的后端控制器，在DispatcherServlet的控制下Handler对具体的用户请求进行处理。<br>  由于Handler涉及到具体的用户业务请求，所以一般情况需要程序员根据业务需求开发Handler。</p></li><li><p>HandlAdapter：处理器适配器</p><p>  通过HandlerAdapter对处理器进行执行，这是适配器模式的应用，通过扩展适配器可以对更多类型的处理器进行执行。</p></li><li><p>View Resolver：视图解析器</p><p>  View Resolver负责将处理结果生成View视图，View Resolver首先根据逻辑视图名解析成物理视图名即具体的页面地址，再生成View视图对象，最后对View进行渲染将处理结果通过页面展示给用户。 </p></li><li><p>View：视图</p><p>  springmvc框架提供了很多的View视图类型的支持，包括：jstlView、freemarkerView、pdfView等。我们最常用的视图就是jsp。<br>  一般情况下需要通过页面标签或页面模版技术将模型数据通过页面展示给用户，需要由程序员根据业务需求开发具体的页面。</p></li></ul><p>说明：在springmvc的各个组件中，<strong>处理器映射器</strong>、<strong>处理器适配器</strong>、<strong>视图解析器</strong>称为springmvc的三大组件。</p><p>需要用户开放的组件有<strong>handler、view</strong></p><h2 id="注解映射器和适配器"><a href="#注解映射器和适配器" class="headerlink" title="注解映射器和适配器"></a>注解映射器和适配器</h2><h3 id="组件扫描器"><a href="#组件扫描器" class="headerlink" title="组件扫描器"></a>组件扫描器</h3><p>使用组件扫描器省去在spring容器配置每个controller类的繁琐。使用<context:component-scan>自动扫描标记@controller的控制器类，配置如下：</context:component-scan></p><pre><code>&lt;!-- 扫描controller注解,多个包中间使用半角逗号分隔 --&gt;&lt;context:component-scan base-package=&quot;cn.lxm.springmvc.controller.first&quot;/&gt;</code></pre><h3 id="RequestMappingHandlerMapping"><a href="#RequestMappingHandlerMapping" class="headerlink" title="RequestMappingHandlerMapping"></a>RequestMappingHandlerMapping</h3><p>注解式处理器映射器，对类中标记@ResquestMapping的方法进行映射，根据ResquestMapping定义的url匹配ResquestMapping标记的方法，匹配成功返回HandlerMethod对象给前端控制器，HandlerMethod对象中封装url对应的方法Method。 </p><p>从spring3.1版本开始，废除了DefaultAnnotationHandlerMapping的使用，推荐使用RequestMappingHandlerMapping完成注解式处理器映射。</p><p>配置如下：</p><pre><code>&lt;!--注解映射器 --&gt;&lt;bean class=&quot;org.springframework.web.servlet.mvc.method.annotation.RequestMappingHandlerMapping&quot;/&gt;</code></pre><p>注解描述：<br>@RequestMapping：定义请求url到处理器功能方法的映射</p><h3 id="RequestMappingHandlerAdapter"><a href="#RequestMappingHandlerAdapter" class="headerlink" title="RequestMappingHandlerAdapter"></a>RequestMappingHandlerAdapter</h3><p>注解式处理器适配器，对标记@ResquestMapping的方法进行适配。</p><p>从spring3.1版本开始，废除了AnnotationMethodHandlerAdapter的使用，推荐使用RequestMappingHandlerAdapter完成注解式处理器适配。</p><p>配置如下：</p><pre><code>&lt;!--注解适配器 --&gt;&lt;bean class=&quot;org.springframework.web.servlet.mvc.method.annotation.RequestMappingHandlerAdapter&quot;/&gt;</code></pre><h3 id=""><a href="#" class="headerlink" title=""></a><mvc:annotation-driven></mvc:annotation-driven></h3><p>springmvc使用<mvc:annotation-driven>自动加载RequestMappingHandlerMapping和RequestMappingHandlerAdapter，可用在springmvc.xml配置文件中使用<mvc:annotation-driven>替代注解处理器和适配器的配置。</mvc:annotation-driven></mvc:annotation-driven></p><h2 id="视图解析器"><a href="#视图解析器" class="headerlink" title="视图解析器"></a>视图解析器</h2><p>在springmvc.xml文件配置如下：</p><pre><code>&lt;bean class=&quot;org.springframework.web.servlet.view.InternalResourceViewResolver&quot;&gt;    &lt;property name=&quot;viewClass&quot;        value=&quot;org.springframework.web.servlet.view.JstlView&quot; /&gt;    &lt;property name=&quot;prefix&quot; value=&quot;/WEB-INF/jsp/&quot; /&gt;    &lt;property name=&quot;suffix&quot; value=&quot;.jsp&quot; /&gt;&lt;/bean&gt;</code></pre><p>InternalResourceViewResolver：支持JSP视图解析</p><p>viewClass：JstlView表示JSP模板页面需要使用JSTL标签库，所以classpath中必须包含jstl的相关jar 包。此属性可以不设置，默认为JstlView。</p><p>prefix 和suffix：查找视图页面的前缀和后缀，最终视图的地址为：<br>前缀+逻辑视图名+后缀，逻辑视图名需要在controller中返回ModelAndView指定，比如逻辑视图名为hello，则最终返回的jsp视图地址 “WEB-INF/jsp/hello.jsp”</p><h1 id="整合mybatis"><a href="#整合mybatis" class="headerlink" title="整合mybatis"></a>整合mybatis</h1><p>ssm框架:springmvc + spring + mybatis</p><p>控制层采用springmvc、持久层使用mybatis实现。</p><h2 id="准备jar包"><a href="#准备jar包" class="headerlink" title="准备jar包"></a>准备jar包</h2><p>spring（包括springmvc）、mybatis、mybatis-spring整合包、数据库驱动、第三方连接池。</p><h2 id="整合思路"><a href="#整合思路" class="headerlink" title="整合思路"></a>整合思路</h2><h3 id="Dao层："><a href="#Dao层：" class="headerlink" title="Dao层："></a>Dao层：</h3><p>1、SqlMapConfig.xml</p><pre><code>空文件即可。需要文件头。</code></pre><p>2、applicationContext-dao.xml。</p><pre><code>a)    数据库连接池b)    SqlSessionFactory对象，需要spring和mybatis整合包下的。c)    配置mapper文件扫描器。</code></pre><h3 id="Service层："><a href="#Service层：" class="headerlink" title="Service层："></a>Service层：</h3><p>1、applicationContext-service.xml</p><pre><code>包扫描器，扫描@service注解的类。</code></pre><p>2、applicationContext-trans.xml</p><pre><code>配置事务。</code></pre><h3 id="表现层："><a href="#表现层：" class="headerlink" title="表现层："></a>表现层：</h3><p>Springmvc.xml</p><pre><code>1、包扫描器，扫描@Controller注解的类。2、配置注解驱动。3、视图解析器</code></pre><p>Web.xml</p><pre><code>配置前端控制器。</code></pre><h1 id="参数绑定"><a href="#参数绑定" class="headerlink" title="参数绑定"></a>参数绑定</h1><h2 id="Controller参数绑定"><a href="#Controller参数绑定" class="headerlink" title="Controller参数绑定"></a>Controller参数绑定</h2><p>要根据id查询商品数据，需要从请求的参数中把请求的id取出来。Id应该包含在Request对象中。可以从Request对象中取id。</p><pre><code>@RequestMapping(&quot;/itemEdit&quot;)public ModelAndView itemEdit(HttpServletRequest request) {    //从Request中取id    String strId = request.getParameter(&quot;id&quot;);    Integer id = null;    //如果id有值则转换成int类型    if (strId != null &amp;&amp; !&quot;&quot;.equals(strId)) {        id = new Integer(strId);    } else {        //出错        return null;    }    Items items = itemService.getItemById(id);    //创建ModelAndView    ModelAndView modelAndView = new ModelAndView();    //向jsp传递数据    modelAndView.addObject(&quot;item&quot;, items);    //设置跳转的jsp页面    modelAndView.setViewName(&quot;editItem&quot;);    return modelAndView;}</code></pre><p>如果想获得Request对象只需要在Controller方法的形参中添加一个参数即可。Springmvc框架会自动把Request对象传递给方法。</p><h2 id="Service"><a href="#Service" class="headerlink" title="Service"></a>Service</h2><pre><code>@Overridepublic Items getItemById(int id) {    Items items = itemsMapper.selectByPrimaryKey(id);    return items;}</code></pre><h2 id="默认支持的参数类型"><a href="#默认支持的参数类型" class="headerlink" title="默认支持的参数类型"></a>默认支持的参数类型</h2><p>处理器形参中添加如下类型的参数处理适配器会默认识别并进行赋值。</p><h3 id="HttpServletRequest"><a href="#HttpServletRequest" class="headerlink" title="HttpServletRequest"></a>HttpServletRequest</h3><p>通过request对象获取请求信息</p><h3 id="HttpServletResponse"><a href="#HttpServletResponse" class="headerlink" title="HttpServletResponse"></a>HttpServletResponse</h3><p>通过response处理响应信息</p><h3 id="HttpSession"><a href="#HttpSession" class="headerlink" title="HttpSession"></a>HttpSession</h3><p>通过session对象得到session中存放的对象</p><h3 id="Model-ModelMap"><a href="#Model-ModelMap" class="headerlink" title="Model/ModelMap"></a>Model/ModelMap</h3><p>ModelMap是Model接口的实现类，通过Model或ModelMap向页面传递数据，如下：</p><pre><code>//调用service查询商品信息Items item = itemService.findItemById(id);model.addAttribute(&quot;item&quot;, item);</code></pre><p>页面通过${item.XXXX}获取item对象的属性值。</p><p>使用Model和ModelMap的效果一样，如果直接使用Model，springmvc会实例化ModelMap。</p><p>如果使用Model则可以不使用ModelAndView对象，Model对象可以向页面传递数据，View对象则可以使用String返回值替代。不管是Model还是ModelAndView，其本质都是使用Request对象向jsp传递数据。<br>如果使用Model则方法可以改造成：</p><pre><code>@RequestMapping(&quot;/itemEdit&quot;)public String itemEdit(HttpServletRequest request, Model model) {    //从Request中取id    String strId = request.getParameter(&quot;id&quot;);    Integer id = null;    //如果id有值则转换成int类型    if (strId != null &amp;&amp; !&quot;&quot;.equals(strId)) {        id = new Integer(strId);    } else {        //出错        return null;    }    Items items = itemService.getItemById(id);    //创建ModelAndView    //ModelAndView modelAndView = new ModelAndView();    //向jsp传递数据    //modelAndView.addObject(&quot;item&quot;, items);    model.addAttribute(&quot;item&quot;, items);    //设置跳转的jsp页面    //modelAndView.setViewName(&quot;editItem&quot;);    //return modelAndView;    return &quot;editItem&quot;;}</code></pre><h2 id="绑定简单类型"><a href="#绑定简单类型" class="headerlink" title="绑定简单类型"></a>绑定简单类型</h2><p>当请求的参数名称和处理器形参名称一致时会将请求参数与形参进行绑定。从Request取参数的方法可以进一步简化。</p><pre><code>@RequestMapping(&quot;/itemEdit&quot;)public String itemEdit(Integer id, Model model) {    Items items = itemService.getItemById(id);    //向jsp传递数据    model.addAttribute(&quot;item&quot;, items);    //设置跳转的jsp页面    return &quot;editItem&quot;;}</code></pre><h3 id="支持的数据类型"><a href="#支持的数据类型" class="headerlink" title="支持的数据类型"></a>支持的数据类型</h3><p>参数类型推荐使用包装数据类型，因为基础数据类型不可以为null</p><p>整形：Integer、int</p><p>字符串：String</p><p>单精度：Float、float</p><p>双精度：Double、double</p><p>布尔型：Boolean、boolean</p><p>说明：对于布尔类型的参数，请求的参数值为true或false。</p><p>处理器方法：</p><pre><code>public String editItem(Model model,Integer id,Boolean status) throws Exception</code></pre><p>请求url：</p><pre><code>http://localhost:8080/xxx.action?id=2&amp;status=false</code></pre><h3 id="RequestParam"><a href="#RequestParam" class="headerlink" title="@RequestParam"></a>@RequestParam</h3><p>使用@RequestParam常用于处理简单类型的绑定。</p><p>value：参数名字，即入参的请求参数名字，如value=“item_id”表示请求的参数区中的名字为item_id的参数的值将传入；</p><p>required：是否必须，默认是true，表示请求中一定要有相应的参数，否则将报；</p><p>TTP Status 400 - Required Integer parameter ‘XXXX’ is not present</p><p>defaultValue：默认值，表示如果请求中没有同名参数时的默认值</p><p>定义如下：</p><pre><code>public String editItem(@RequestParam(value=&quot;item_id&quot;,required=true) String id) {}</code></pre><p>形参名称为id，但是这里使用value=” item_id”限定请求的参数名为item_id，所以页面传递参数的名必须为item_id。</p><p>注意：如果请求参数中没有item_id将跑出异常：</p><pre><code>HTTP Status 500 - Required Integer parameter &apos;item_id&apos; is not present</code></pre><p>这里通过required=true限定item_id参数为必需传递，如果不传递则报400错误，可以使用defaultvalue设置默认值，即使required=true也可以不传item_id参数值</p><h2 id="绑定pojo类型"><a href="#绑定pojo类型" class="headerlink" title="绑定pojo类型"></a>绑定pojo类型</h2><h3 id="Controller"><a href="#Controller" class="headerlink" title="Controller:"></a>Controller:</h3><pre><code>@RequestMapping(&quot;/updateitem&quot;)public String updateItem(Items items){    itemService.updateItem(items);    return &quot;success&quot;;}</code></pre><h3 id="service"><a href="#service" class="headerlink" title="service"></a>service</h3><pre><code>@Overridepublic void updateItem(Items items) {    //ItemsExample example = new ItemsExample();    //如果example定义了两个字段，数据库共4个字段，则修改数据库的两个字段，其余两个字段改为null    //itemsMapper.updateByExample(items, example);    //成功,但是没有的值置为了null    //itemsMapper.updateByPrimaryKey(items);    //成功,但是没有的值置为了null    //itemsMapper.updateByPrimaryKeyWithBLOBs(items);    //和updateByExample相比此方法可以修改大字段类型，其余性质和updateByExample相同    //itemsMapper.updateByExampleWithBLOBs(items, example);    //如果example定义了两个字段，数据库共4个字段，则修改数据库的两个字段，其余两个字段不动    itemsMapper.updateByPrimaryKeySelective(items);}</code></pre><p>注意：提交的表单中不要有日期类型的数据，否则会报400错误。如果想提交日期类型的数据需要用到后面的自定义参数绑定的内容。</p><h2 id="解决日期参数问题"><a href="#解决日期参数问题" class="headerlink" title="解决日期参数问题:"></a>解决日期参数问题:</h2><h3 id="自定义Converter"><a href="#自定义Converter" class="headerlink" title="自定义Converter"></a>自定义Converter</h3><pre><code>import org.joda.time.DateTime;import org.joda.time.format.DateTimeFormat;import org.joda.time.format.DateTimeFormatter;import org.springframework.core.convert.converter.Converter;import org.springframework.util.StringUtils;import java.util.ArrayList;import java.util.Date;import java.util.List;/** * Created by Rock 2016/12/6. */public class DateConverter implements Converter&lt;String,Date&gt; {private static final List&lt;String&gt; formarts = new ArrayList&lt;&gt;(4);static {    formarts.add(&quot;yyyy-MM&quot;);    formarts.add(&quot;yyyy-MM-dd&quot;);    formarts.add(&quot;yyyy-MM-dd HH:mm&quot;);    formarts.add(&quot;yyyy-MM-dd HH:mm:ss&quot;);}@Overridepublic Date convert(String s) {    if(StringUtils.isEmpty(s)){        return null;    }    try {        String formatter = &quot;&quot;;        if (s.matches(&quot;^\\d{4}-\\d{1,2}$&quot;)) {            formatter = formarts.get(0);        } else if (s.matches(&quot;^\\d{4}-\\d{1,2}-\\d{1,2}$&quot;)) {            formatter = formarts.get(1);        } else if (s.matches(&quot;^\\d{4}-\\d{1,2}-\\d{1,2} {1}\\d{1,2}:\\d{1,2}$&quot;)) {            formatter = formarts.get(2);        } else if (s.matches(&quot;^\\d{4}-\\d{1,2}-\\d{1,2} {1}\\d{1,2}:\\d{1,2}:\\d{1,2}$&quot;)) {            formatter = formarts.get(3);        } else {            throw new IllegalArgumentException(&quot;Invalid boolean value &apos;&quot; + s + &quot;&apos;&quot;);        }        DateFormat dateFormat = new SimpleDateFormat(formatter);        Date date = dateFormat.parse(s);        return date;    } catch (Exception e){        return null;    }}}</code></pre><h3 id="在springmvc-xml里面配置"><a href="#在springmvc-xml里面配置" class="headerlink" title="在springmvc.xml里面配置"></a>在springmvc.xml里面配置</h3><pre><code>&lt;!-- 配置注解驱动，如果配置此标签可以不用配置处理器映射器和适配器  --&gt;&lt;!-- &lt;mvc:annotation-driven /&gt; --&gt;&lt;!-- 加载注解驱动 --&gt;&lt;mvc:annotation-driven conversion-service=&quot;conversionService&quot;/&gt;&lt;!-- 转换器配置 --&gt;&lt;bean id=&quot;conversionService&quot;    class=&quot;org.springframework.format.support.FormattingConversionServiceFactoryBean&quot;&gt;    &lt;property name=&quot;converters&quot;&gt;        &lt;set&gt;            &lt;bean class=&quot;cn.lxm.springmvc.convert.DateConverter&quot;/&gt;        &lt;/set&gt;    &lt;/property&gt;&lt;/bean&gt;</code></pre><h2 id="解决post乱码问题"><a href="#解决post乱码问题" class="headerlink" title="解决post乱码问题"></a>解决post乱码问题</h2><p>在web.xml中加入：</p><pre><code>&lt;filter&gt;    &lt;filter-name&gt;CharacterEncodingFilter&lt;/filter-name&gt;    &lt;filter-class&gt;org.springframework.web.filter.CharacterEncodingFilter&lt;/filter-class&gt;    &lt;init-param&gt;        &lt;param-name&gt;encoding&lt;/param-name&gt;        &lt;param-value&gt;utf-8&lt;/param-value&gt;    &lt;/init-param&gt;&lt;/filter&gt;&lt;filter-mapping&gt;    &lt;filter-name&gt;CharacterEncodingFilter&lt;/filter-name&gt;    &lt;url-pattern&gt;/*&lt;/url-pattern&gt;&lt;/filter-mapping&gt;</code></pre><p>以上可以解决post请求乱码问题。</p><p>对于get请求中文参数出现乱码解决方法有两个：</p><p>修改tomcat配置文件添加编码与工程编码一致，如下：</p><pre><code>&lt;Connector URIEncoding=&quot;utf-8&quot; connectionTimeout=&quot;20000&quot; port=&quot;8080&quot; protocol=&quot;HTTP/1.1&quot; redirectPort=&quot;8443&quot;/&gt;</code></pre><p>另外一种方法对参数进行重新编码：</p><pre><code>String userName new String(request.getParamter(&quot;userName&quot;).getBytes(&quot;ISO8859-1&quot;),&quot;utf-8&quot;)</code></pre><p>ISO8859-1是tomcat默认编码，需要将tomcat编码后的内容按utf-8编码</p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;SpringMVC架构&quot;&gt;&lt;a href=&quot;#SpringMVC架构&quot; class=&quot;headerlink&quot; title=&quot;SpringMVC架构&quot;&gt;&lt;/a&gt;SpringMVC架构&lt;/h1&gt;&lt;p&gt;Spring web mvc和Struts2都属于表现层的框架,它是Spring框架的一部分.&lt;/p&gt;
&lt;h2 id=&quot;架构流程&quot;&gt;&lt;a href=&quot;#架构流程&quot; class=&quot;headerlink&quot; title=&quot;架构流程&quot;&gt;&lt;/a&gt;架构流程&lt;/h2&gt;&lt;pre&gt;&lt;code&gt;1、    用户发送请求至前端控制器DispatcherServlet

2、    DispatcherServlet收到请求调用HandlerMapping处理器映射器。

3、    处理器映射器根据请求url找到具体的处理器，生成处理器对象及处理器拦截器(如果有则生成)一并返回给DispatcherServlet。

4、    DispatcherServlet通过HandlerAdapter处理器适配器调用处理器

5、    执行处理器(Controller，也叫后端控制器)。

6、    Controller执行完成返回ModelAndView

7、    HandlerAdapter将controller执行结果ModelAndView返回给DispatcherServlet

8、    DispatcherServlet将ModelAndView传给ViewReslover视图解析器

9、    ViewReslover解析后返回具体View

10、    DispatcherServlet对View进行渲染视图（即将模型数据填充至视图中）。

11、    DispatcherServlet响应用户
&lt;/code&gt;&lt;/pre&gt;
    
    </summary>
    
      <category term="SSM" scheme="http://www.fashionkillyou.xyz/categories/SSM/"/>
    
    
      <category term="SpringMVC" scheme="http://www.fashionkillyou.xyz/tags/SpringMVC/"/>
    
      <category term="SpringWebMVC" scheme="http://www.fashionkillyou.xyz/tags/SpringWebMVC/"/>
    
  </entry>
  
  <entry>
    <title>mybatis五</title>
    <link href="http://www.fashionkillyou.xyz/2018/02/26/mybatis%E4%BA%94/"/>
    <id>http://www.fashionkillyou.xyz/2018/02/26/mybatis五/</id>
    <published>2018-02-26T08:21:09.000Z</published>
    <updated>2018-03-16T04:02:20.069Z</updated>
    
    <content type="html"><![CDATA[<script src="\assets\js\APlayer.min.js"> </script><h1 id="mybatis整合spring"><a href="#mybatis整合spring" class="headerlink" title="mybatis整合spring"></a>mybatis整合spring</h1><h2 id="整合思路"><a href="#整合思路" class="headerlink" title="整合思路"></a>整合思路</h2><p>1、SqlSessionFactory对象应该放到spring容器中作为单例存在。</p><p>2、传统dao的开发方式中，应该从spring容器中获得sqlsession对象。</p><p>3、Mapper代理形式中，应该从spring容器中直接获得mapper的代理对象。</p><p>4、数据库的连接以及数据库连接池事务管理都交给spring容器来完成。</p><a id="more"></a><h2 id="整合需要的jar包"><a href="#整合需要的jar包" class="headerlink" title="整合需要的jar包"></a>整合需要的jar包</h2><p>1、spring的jar包<br>2、Mybatis的jar包<br>3、Spring+mybatis的整合包。<br>4、Mysql的数据库驱动jar包。<br>5、数据库连接池的jar包。</p><h2 id="整合的步骤"><a href="#整合的步骤" class="headerlink" title="整合的步骤"></a>整合的步骤</h2><p>第一步：创建一个java工程。</p><p>第二步：导入jar包。（上面提到的jar包）</p><p>第三步：mybatis的配置文件SqlMapConfig.xml</p><p>第四步：编写Spring的配置文件</p><pre><code>1、数据库连接及连接池2、事务管理（暂时可以不配置）3、sqlsessionFactory对象，配置到spring容器中4、mapeer代理对象或者是dao实现类配置到spring容器中。</code></pre><p>第五步：编写dao或者mapper文件</p><p>第六步：测试。</p><h3 id="SqlMapConfig-xml"><a href="#SqlMapConfig-xml" class="headerlink" title="SqlMapConfig.xml"></a>SqlMapConfig.xml</h3><pre><code>&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; ?&gt;&lt;!DOCTYPE configurationPUBLIC &quot;-//mybatis.org//DTD Config 3.0//EN&quot;&quot;http://mybatis.org/dtd/mybatis-3-config.dtd&quot;&gt;&lt;configuration&gt;    &lt;typeAliases&gt;        &lt;package name=&quot;cn.lxm.mybatis.pojo&quot;/&gt;    &lt;/typeAliases&gt;    &lt;mappers&gt;        &lt;!-- 使用包扫描扫描mapper.xml            如果在ApplicationContext.xml中配置了扫描包之后,就 不需要此配置         --&gt;        &lt;package name=&quot;cn.lxm.mybatis.mapper&quot;/&gt;    &lt;/mappers&gt;&lt;/configuration&gt;</code></pre><h3 id="applicationContext-xml"><a href="#applicationContext-xml" class="headerlink" title="applicationContext.xml"></a>applicationContext.xml</h3><pre><code>&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot;    xmlns:context=&quot;http://www.springframework.org/schema/context&quot; xmlns:p=&quot;http://www.springframework.org/schema/p&quot;    xmlns:aop=&quot;http://www.springframework.org/schema/aop&quot; xmlns:tx=&quot;http://www.springframework.org/schema/tx&quot;    xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;    xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans-4.0.xsd    http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context-4.0.xsd    http://www.springframework.org/schema/aop http://www.springframework.org/schema/aop/spring-aop-4.0.xsd http://www.springframework.org/schema/tx http://www.springframework.org/schema/tx/spring-tx-4.0.xsd    http://www.springframework.org/schema/util http://www.springframework.org/schema/util/spring-util-4.0.xsd&quot;&gt;    &lt;!-- 加载配置文件 --&gt;    &lt;context:property-placeholder location=&quot;classpath:db.properties&quot; /&gt;    &lt;!-- 数据库连接池 --&gt;    &lt;bean id=&quot;dataSource&quot; class=&quot;org.apache.commons.dbcp.BasicDataSource&quot;        destroy-method=&quot;close&quot;&gt;        &lt;property name=&quot;driverClassName&quot; value=&quot;${jdbc.driver}&quot; /&gt;        &lt;property name=&quot;url&quot; value=&quot;${jdbc.url}&quot; /&gt;        &lt;property name=&quot;username&quot; value=&quot;${jdbc.username}&quot; /&gt;        &lt;property name=&quot;password&quot; value=&quot;${jdbc.password}&quot; /&gt;        &lt;property name=&quot;maxActive&quot; value=&quot;10&quot; /&gt;        &lt;property name=&quot;maxIdle&quot; value=&quot;5&quot; /&gt;    &lt;/bean&gt;    &lt;!-- mapper配置 --&gt;    &lt;!-- 让spring管理sqlsessionfactory 使用mybatis和spring整合包中的 --&gt;    &lt;bean id=&quot;sqlSessionFactory&quot; class=&quot;org.mybatis.spring.SqlSessionFactoryBean&quot;&gt;        &lt;!-- 数据库连接池 --&gt;        &lt;property name=&quot;dataSource&quot; ref=&quot;dataSource&quot; /&gt;        &lt;!-- 加载mybatis的全局配置文件 --&gt;        &lt;property name=&quot;configLocation&quot; value=&quot;classpath:mybatis/SqlMapConfig.xml&quot; /&gt;    &lt;/bean&gt;&lt;/beans&gt;</code></pre><h3 id="db-properties"><a href="#db-properties" class="headerlink" title="db.properties"></a>db.properties</h3><pre><code>jdbc.driver=com.mysql.jdbc.Driverjdbc.url=jdbc:mysql://localhost:3306/mybatis?characterEncoding=utf-8jdbc.username=rootjdbc.password=root</code></pre><h2 id="Dao的开发"><a href="#Dao的开发" class="headerlink" title="Dao的开发"></a>Dao的开发</h2><p>三种dao的实现方式：</p><pre><code>1、传统dao的开发方式2、使用mapper代理形式开发方式3、使用扫描包配置mapper代理。</code></pre><p>这里只介绍第二种和第三种</p><h3 id="Mapper代理形式开发dao"><a href="#Mapper代理形式开发dao" class="headerlink" title="Mapper代理形式开发dao"></a>Mapper代理形式开发dao</h3><h4 id="开发mapper接口"><a href="#开发mapper接口" class="headerlink" title="开发mapper接口"></a>开发mapper接口</h4><p>开发mapper文件</p><p>创建UserMapper.java</p><pre><code>public interface UserMapper {    User findUserById(Integer id) throws Exception;}</code></pre><p>并且在同一目录下创建UserMapper.xml</p><pre><code> &lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; ?&gt;&lt;!DOCTYPE mapperPUBLIC &quot;-//mybatis.org//DTD Mapper 3.0//EN&quot;&quot;http://mybatis.org/dtd/mybatis-3-mapper.dtd&quot;&gt;&lt;mapper namespace=&quot;cn.lxm.mybatis.mapper.UserMapper&quot;&gt;    &lt;!-- 根据id获取用户信息 --&gt;    &lt;select id=&quot;findUserById&quot; parameterType=&quot;int&quot; resultType=&quot;cn.lxm.mybatis.po.User&quot;&gt;        select * from user where id = #{id}    &lt;/select&gt;&lt;/mapper&gt;</code></pre><h4 id="配置mapper代理"><a href="#配置mapper代理" class="headerlink" title="配置mapper代理"></a>配置mapper代理</h4><pre><code>&lt;!-- 配置mapper代理对象 --&gt;&lt;bean class=&quot;org.mybatis.spring.mapper.MapperFactoryBean&quot;&gt;    &lt;property name=&quot;mapperInterface&quot; value=&quot;cn.lxm.mybatis.mapper.UserMapper&quot;/&gt;    &lt;property name=&quot;sqlSessionFactory&quot; ref=&quot;sqlSessionFactory&quot;&gt;&lt;/property&gt;&lt;/bean&gt;</code></pre><h4 id="测试方法"><a href="#测试方法" class="headerlink" title="测试方法"></a>测试方法</h4><pre><code>public class UserMapperTest {    private ApplicationContext applicationContext;    @Before    public void setUp() throws Exception {        applicationContext = new ClassPathXmlApplicationContext(&quot;classpath:spring/applicationContext.xml&quot;);    }    @Test    public void testGetUserById() {        UserMapper userMapper = applicationContext.getBean(UserMapper.class);        User user = userMapper.getUserById(1);        System.out.println(user);    }}</code></pre><h3 id="扫描包形式配置mapper"><a href="#扫描包形式配置mapper" class="headerlink" title="扫描包形式配置mapper"></a>扫描包形式配置mapper</h3><pre><code>&lt;!-- 使用扫描包的形式来创建mapper代理对象 --&gt;&lt;bean class=&quot;org.mybatis.spring.mapper.MapperScannerConfigurer&quot;&gt;    &lt;property name=&quot;basePackage&quot; value=&quot;cn.lxm.mybatis.mapper&quot;&gt;&lt;/property&gt;&lt;/bean&gt;</code></pre><p>如果配置了这个后 ,在SQLMapConfig.xml中的包扫描配置就不需要了</p><h2 id="逆向工程生成代码"><a href="#逆向工程生成代码" class="headerlink" title="逆向工程生成代码"></a>逆向工程生成代码</h2><p>步骤:</p><p>1.导入逆向工程代码,然后修改配置文件generatorConfig.xml</p><pre><code>&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;!DOCTYPE generatorConfiguration  PUBLIC &quot;-//mybatis.org//DTD MyBatis Generator Configuration 1.0//EN&quot;  &quot;http://mybatis.org/dtd/mybatis-generator-config_1_0.dtd&quot;&gt;&lt;generatorConfiguration&gt;    &lt;context id=&quot;testTables&quot; targetRuntime=&quot;MyBatis3&quot;&gt;        &lt;commentGenerator&gt;            &lt;!-- 是否去除自动生成的注释 true：是 ： false:否 --&gt;            &lt;property name=&quot;suppressAllComments&quot; value=&quot;true&quot; /&gt;        &lt;/commentGenerator&gt;        &lt;!--数据库连接的信息：驱动类、连接地址、用户名、密码 --&gt;        &lt;jdbcConnection driverClass=&quot;com.mysql.jdbc.Driver&quot;            connectionURL=&quot;jdbc:mysql://localhost:3306/mybatis&quot; userId=&quot;root&quot;            password=&quot;root&quot;&gt;        &lt;/jdbcConnection&gt;        &lt;!-- &lt;jdbcConnection driverClass=&quot;oracle.jdbc.OracleDriver&quot;            connectionURL=&quot;jdbc:oracle:thin:@127.0.0.1:1521:yycg&quot;             userId=&quot;yycg&quot;            password=&quot;yycg&quot;&gt;        &lt;/jdbcConnection&gt; --&gt;        &lt;!-- 默认false，把JDBC DECIMAL 和 NUMERIC 类型解析为 Integer，为 true时把JDBC DECIMAL 和             NUMERIC 类型解析为java.math.BigDecimal --&gt;        &lt;javaTypeResolver&gt;            &lt;property name=&quot;forceBigDecimals&quot; value=&quot;false&quot; /&gt;        &lt;/javaTypeResolver&gt;        &lt;!-- targetProject:生成PO类的位置 --&gt;        &lt;javaModelGenerator targetPackage=&quot;cn.lxm.mybatis.po&quot;            targetProject=&quot;.\src&quot;&gt;            &lt;!-- enableSubPackages:是否让schema作为包的后缀 --&gt;            &lt;property name=&quot;enableSubPackages&quot; value=&quot;false&quot; /&gt;            &lt;!-- 从数据库返回的值被清理前后的空格 --&gt;            &lt;property name=&quot;trimStrings&quot; value=&quot;true&quot; /&gt;        &lt;/javaModelGenerator&gt;        &lt;!-- targetProject:mapper映射文件生成的位置 --&gt;        &lt;sqlMapGenerator targetPackage=&quot;cn.lxm.mybatis.mapper&quot;             targetProject=&quot;.\src&quot;&gt;            &lt;!-- enableSubPackages:是否让schema作为包的后缀 --&gt;            &lt;property name=&quot;enableSubPackages&quot; value=&quot;false&quot; /&gt;        &lt;/sqlMapGenerator&gt;        &lt;!-- targetPackage：mapper接口生成的位置 --&gt;        &lt;javaClientGenerator type=&quot;XMLMAPPER&quot;            targetPackage=&quot;cn.lxm.mybatis.mapper&quot;             targetProject=&quot;.\src&quot;&gt;            &lt;!-- enableSubPackages:是否让schema作为包的后缀 --&gt;            &lt;property name=&quot;enableSubPackages&quot; value=&quot;false&quot; /&gt;        &lt;/javaClientGenerator&gt;        &lt;!-- 指定数据库表 --&gt;        &lt;table schema=&quot;&quot; tableName=&quot;user&quot;&gt;&lt;/table&gt;        &lt;table schema=&quot;&quot; tableName=&quot;orders&quot;&gt;&lt;/table&gt;        &lt;!-- 有些表的字段需要指定java类型         &lt;table schema=&quot;&quot; tableName=&quot;&quot;&gt;            &lt;columnOverride column=&quot;&quot; javaType=&quot;&quot; /&gt;        &lt;/table&gt; --&gt;    &lt;/context&gt;&lt;/generatorConfiguration&gt;</code></pre>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;mybatis整合spring&quot;&gt;&lt;a href=&quot;#mybatis整合spring&quot; class=&quot;headerlink&quot; title=&quot;mybatis整合spring&quot;&gt;&lt;/a&gt;mybatis整合spring&lt;/h1&gt;&lt;h2 id=&quot;整合思路&quot;&gt;&lt;a href=&quot;#整合思路&quot; class=&quot;headerlink&quot; title=&quot;整合思路&quot;&gt;&lt;/a&gt;整合思路&lt;/h2&gt;&lt;p&gt;1、SqlSessionFactory对象应该放到spring容器中作为单例存在。&lt;/p&gt;
&lt;p&gt;2、传统dao的开发方式中，应该从spring容器中获得sqlsession对象。&lt;/p&gt;
&lt;p&gt;3、Mapper代理形式中，应该从spring容器中直接获得mapper的代理对象。&lt;/p&gt;
&lt;p&gt;4、数据库的连接以及数据库连接池事务管理都交给spring容器来完成。&lt;/p&gt;
    
    </summary>
    
      <category term="SSM" scheme="http://www.fashionkillyou.xyz/categories/SSM/"/>
    
    
      <category term="mybatis" scheme="http://www.fashionkillyou.xyz/tags/mybatis/"/>
    
  </entry>
  
  <entry>
    <title>mybatis四</title>
    <link href="http://www.fashionkillyou.xyz/2018/02/25/mybatis%E5%9B%9B/"/>
    <id>http://www.fashionkillyou.xyz/2018/02/25/mybatis四/</id>
    <published>2018-02-25T08:07:42.000Z</published>
    <updated>2018-03-16T04:02:17.660Z</updated>
    
    <content type="html"><![CDATA[<script src="\assets\js\APlayer.min.js"> </script><h1 id="关联查询"><a href="#关联查询" class="headerlink" title="关联查询"></a>关联查询</h1><h2 id="一对一查询"><a href="#一对一查询" class="headerlink" title="一对一查询"></a>一对一查询</h2><p>这里举例是一个订单对应一个用户</p><h3 id="方法一："><a href="#方法一：" class="headerlink" title="方法一："></a>方法一：</h3><p>使用resultType，定义订单信息po类，此po类中包括了订单信息和用户信息：</p><a id="more"></a><h4 id="Sql语句："><a href="#Sql语句：" class="headerlink" title="Sql语句："></a>Sql语句：</h4><pre><code>SELECT   orders.*,  user.username,  user.addressFROM  orders,  user WHERE orders.user_id = user.id</code></pre><h4 id="定义po类"><a href="#定义po类" class="headerlink" title="定义po类"></a>定义po类</h4><p>Po类中应该包括上边sql查询出来的所有字段，如下：</p><pre><code>public class OrdersCustom extends Orders {private String username;// 用户名称private String address;// 用户地址get/set。。。。</code></pre><p>OrdersCustom类继承Orders类后OrdersCustom类包括了Orders类的所有字段，只需要定义用户的信息字段即可。</p><h4 id="Mapper-xml"><a href="#Mapper-xml" class="headerlink" title="Mapper.xml"></a>Mapper.xml</h4><pre><code>&lt;!-- 查询所有订单信息 --&gt;&lt;select id=&quot;findOrdersList&quot; resultType=&quot;cn.lxm.mybatis.po.OrdersCustom&quot;&gt;SELECTorders.*,user.username,user.addressFROMorders,    userWHERE orders.user_id = user.id &lt;/select&gt;</code></pre><h4 id="Mapper接口："><a href="#Mapper接口：" class="headerlink" title="Mapper接口："></a>Mapper接口：</h4><pre><code>public List&lt;OrdersCustom&gt; findOrdersList() throws Exception;</code></pre><h4 id="测试："><a href="#测试：" class="headerlink" title="测试："></a>测试：</h4><pre><code>Public void testfindOrdersList()throws Exception{    //获取session    SqlSession session = sqlSessionFactory.openSession();    //获限mapper接口实例    UserMapper userMapper = session.getMapper(UserMapper.class);    //查询订单信息    List&lt;OrdersCustom&gt; list = userMapper.findOrdersList();    System.out.println(list);    //关闭session    session.close();}</code></pre><h4 id="小结："><a href="#小结：" class="headerlink" title="小结："></a>小结：</h4><pre><code>定义专门的po类作为输出类型，其中定义了sql查询结果集所有的字段。此方法较为简单，企业中使用普遍。</code></pre><h3 id="方法二："><a href="#方法二：" class="headerlink" title="方法二："></a>方法二：</h3><p>使用resultMap，定义专门的resultMap用于映射一对一查询结果。</p><h4 id="Sql语句：-1"><a href="#Sql语句：-1" class="headerlink" title="Sql语句："></a>Sql语句：</h4><pre><code>SELECT   orders.*,  user.username,  user.addressFROM  orders,  user WHERE orders.user_id = user.id</code></pre><h4 id="定义po类-1"><a href="#定义po类-1" class="headerlink" title="定义po类"></a>定义po类</h4><p>在Orders类中加入User属性，user属性中用于存储关联查询的用户信息，因为订单关联查询用户是一对一关系，所以这里使用单个User对象存储关联查询的用户信息。<br>    public class Orders {<br>    private Integer id;</p><pre><code>private Integer userId;private String number;private Date createtime;private String note;private User user;get/set()...</code></pre><h4 id="Mapper-xml-1"><a href="#Mapper-xml-1" class="headerlink" title="Mapper.xml"></a>Mapper.xml</h4><pre><code>&lt;!-- 查询订单关联用户信息使用resultmap --&gt;&lt;resultMap type=&quot;Orders&quot; id=&quot;orderUserResultMap&quot;&gt;    &lt;id column=&quot;id&quot; property=&quot;id&quot;/&gt;    &lt;result column=&quot;user_id&quot; property=&quot;userId&quot;/&gt;    &lt;result column=&quot;number&quot; property=&quot;number&quot;/&gt;    &lt;result column=&quot;createtime&quot; property=&quot;createtime&quot;/&gt;    &lt;result column=&quot;note&quot; property=&quot;note&quot;/&gt;    &lt;!-- 一对一关联映射 --&gt;    &lt;!--     property:Orders对象的user属性    javaType：user属性对应 的类型     --&gt;    &lt;association property=&quot;user&quot; javaType=&quot;cn.lxm.po.User&quot;&gt;        &lt;!-- column:user表的主键对应的列  property：user对象中id属性--&gt;        &lt;id column=&quot;user_id&quot; property=&quot;id&quot;/&gt;        &lt;result column=&quot;username&quot; property=&quot;username&quot;/&gt;        &lt;result column=&quot;address&quot; property=&quot;address&quot;/&gt;    &lt;/association&gt;&lt;/resultMap&gt;&lt;select id=&quot;findOrdersWithUserResultMap&quot; resultMap=&quot;orderUserResultMap&quot;&gt;    SELECT        o.id,        o.user_id,        o.number,        o.createtime,        o.note,        u.username,        u.address    FROM        orders o    JOIN `user` u ON u.id = o.user_id&lt;/select&gt;</code></pre><p>这里resultMap指定orderUserResultMap。</p><p>association：表示进行关联查询单条记录</p><p>property：表示关联查询的结果存储在cn.lxm.mybatis.po.Orders的user属性中</p><p>javaType：表示关联查询的结果类型</p><p>&lt; id property=”id” column=”user_id”/&gt;：查询结果的user_id列对应关联对象的id属性，这里是&lt; id /&gt;表示user_id是关联查询对象的唯一标识。</p><p>&lt; result property=”username” column=”username”/&gt;：查询结果的username列对应关联对象的username属性。</p><h4 id="Mapper接口：-1"><a href="#Mapper接口：-1" class="headerlink" title="Mapper接口："></a>Mapper接口：</h4><pre><code>public List&lt;Orders&gt; findOrdersListResultMap() throws Exception;</code></pre><h4 id="测试：-1"><a href="#测试：-1" class="headerlink" title="测试："></a>测试：</h4><pre><code>Public void testfindOrdersListResultMap()throws Exception{    //获取session    SqlSession session = sqlSessionFactory.openSession();    //获限mapper接口实例    UserMapper userMapper = session.getMapper(UserMapper.class);    //查询订单信息    List&lt;Orders&gt; list = userMapper.findOrdersList2();    System.out.println(list);    //关闭session    session.close();}</code></pre><h4 id="小结：-1"><a href="#小结：-1" class="headerlink" title="小结："></a>小结：</h4><p>使用association完成关联查询，将关联查询信息映射到pojo对象中。</p><h2 id="一对多查询"><a href="#一对多查询" class="headerlink" title="一对多查询"></a>一对多查询</h2><p>案例：查询所有用户信息及用户关联的订单信息。</p><p>用户信息和订单信息为一对多关系。</p><p>使用resultMap实现如下：</p><h3 id="Sql语句：-2"><a href="#Sql语句：-2" class="headerlink" title="Sql语句："></a>Sql语句：</h3><pre><code>SELECTu.*, o.id oid,o.number,o.createtime,o.noteFROM`user` uLEFT JOIN orders o ON u.id = o.user_id</code></pre><h3 id="定义po类-2"><a href="#定义po类-2" class="headerlink" title="定义po类"></a>定义po类</h3><p>在User类中加入List&lt; Orders&gt; orders属性</p><pre><code>public class User {   private int id;   private String username;// 用户姓名   private String sex;// 性别   private Date birthday;// 生日   private String address;// 地址   private List&lt;Orders&gt; orders;   get/set()...</code></pre><h3 id="Mapper-xml-2"><a href="#Mapper-xml-2" class="headerlink" title="Mapper.xml"></a>Mapper.xml</h3><pre><code>&lt;resultMap type=&quot;user&quot; id=&quot;userOrderResultMap&quot;&gt;    &lt;!-- 用户信息映射 --&gt;    &lt;id property=&quot;id&quot; column=&quot;id&quot;/&gt;    &lt;result property=&quot;username&quot; column=&quot;username&quot;/&gt;    &lt;result property=&quot;birthday&quot; column=&quot;birthday&quot;/&gt;    &lt;result property=&quot;sex&quot; column=&quot;sex&quot;/&gt;    &lt;result property=&quot;address&quot; column=&quot;address&quot;/&gt;    &lt;!-- 一对多关联映射 --&gt;    &lt;collection property=&quot;orders&quot; ofType=&quot;orders&quot;&gt;        &lt;id property=&quot;id&quot; column=&quot;oid&quot;/&gt;              &lt;!--用户id已经在user对象中存在，此处可以不设置--&gt;        &lt;!-- &lt;result property=&quot;userId&quot; column=&quot;id&quot;/&gt; --&gt;        &lt;result property=&quot;number&quot; column=&quot;number&quot;/&gt;        &lt;result property=&quot;createtime&quot; column=&quot;createtime&quot;/&gt;        &lt;result property=&quot;note&quot; column=&quot;note&quot;/&gt;    &lt;/collection&gt;&lt;/resultMap&gt;&lt;select id=&quot;getUserOrderList&quot; resultMap=&quot;userOrderResultMap&quot;&gt;    SELECT    u.*, o.id oid,    o.number,    o.createtime,    o.note    FROM    `user` u    LEFT JOIN orders o ON u.id = o.user_id&lt;/select&gt;</code></pre><p>collection部分定义了用户关联的订单信息。表示关联查询结果集</p><p>property=”orders”：关联查询的结果集存储在User对象的上哪个属性。</p><p>ofType=”orders”：指定关联查询的结果集中的对象类型即List中的对象类型。此处可以使用别名，也可以使用全限定名。</p><p>&lt; id /&gt;及&lt; result/&gt;的意义同一对一查询。</p><h3 id="Mapper接口：-2"><a href="#Mapper接口：-2" class="headerlink" title="Mapper接口："></a>Mapper接口：</h3><pre><code>List&lt;User&gt; getUserOrderList();</code></pre><h3 id="测试"><a href="#测试" class="headerlink" title="测试"></a>测试</h3><pre><code>@Testpublic void getUserOrderList() {    SqlSession session = sqlSessionFactory.openSession();    UserMapper userMapper = session.getMapper(UserMapper.class);    List&lt;User&gt; result = userMapper.getUserOrderList();    for (User user : result) {        System.out.println(user);    }    session.close();}</code></pre>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;关联查询&quot;&gt;&lt;a href=&quot;#关联查询&quot; class=&quot;headerlink&quot; title=&quot;关联查询&quot;&gt;&lt;/a&gt;关联查询&lt;/h1&gt;&lt;h2 id=&quot;一对一查询&quot;&gt;&lt;a href=&quot;#一对一查询&quot; class=&quot;headerlink&quot; title=&quot;一对一查询&quot;&gt;&lt;/a&gt;一对一查询&lt;/h2&gt;&lt;p&gt;这里举例是一个订单对应一个用户&lt;/p&gt;
&lt;h3 id=&quot;方法一：&quot;&gt;&lt;a href=&quot;#方法一：&quot; class=&quot;headerlink&quot; title=&quot;方法一：&quot;&gt;&lt;/a&gt;方法一：&lt;/h3&gt;&lt;p&gt;使用resultType，定义订单信息po类，此po类中包括了订单信息和用户信息：&lt;/p&gt;
    
    </summary>
    
      <category term="SSM" scheme="http://www.fashionkillyou.xyz/categories/SSM/"/>
    
    
      <category term="mybatis" scheme="http://www.fashionkillyou.xyz/tags/mybatis/"/>
    
  </entry>
  
  <entry>
    <title>mybatis三</title>
    <link href="http://www.fashionkillyou.xyz/2018/02/25/mybatis%E4%B8%89/"/>
    <id>http://www.fashionkillyou.xyz/2018/02/25/mybatis三/</id>
    <published>2018-02-25T00:58:28.000Z</published>
    <updated>2018-03-16T04:02:15.451Z</updated>
    
    <content type="html"><![CDATA[<script src="\assets\js\APlayer.min.js"> </script><h1 id="输入映射和输出映射"><a href="#输入映射和输出映射" class="headerlink" title="输入映射和输出映射"></a>输入映射和输出映射</h1><p>Mapper.xml映射文件中定义了操作数据库的sql，每个sql是一个statement，映射文件是mybatis的核心。<br><a id="more"></a></p><h2 id="parameterType-输入类型"><a href="#parameterType-输入类型" class="headerlink" title="parameterType(输入类型)"></a>parameterType(输入类型)</h2><h3 id="传递简单类型"><a href="#传递简单类型" class="headerlink" title="传递简单类型"></a>传递简单类型</h3><p>参考文章 <a href="http://fashionkillyou.xyz/2018/02/24/mybatis入门一/" title="mybatis入门一" target="_blank" rel="noopener">mybatis入门一</a></p><h3 id="传递pojo对象"><a href="#传递pojo对象" class="headerlink" title="传递pojo对象"></a>传递pojo对象</h3><p>Mybatis使用ognl表达式解析对象字段的值，#{}或者${}括号中的值为pojo属性名称。</p><h3 id="传递pojo包装对象"><a href="#传递pojo包装对象" class="headerlink" title="传递pojo包装对象"></a>传递pojo包装对象</h3><p>开发中通过pojo传递查询条件 ，查询条件是综合的查询条件，不仅包括用户查询条件还包括其它的查询条件（比如将用户购买商品信息也作为查询条件），这时可以使用包装对象传递输入参数。<br>Pojo类中包含pojo。</p><p>需求：根据用户名查询用户信息，查询条件放到QueryVo的user属性中。</p><h4 id="QueryVo"><a href="#QueryVo" class="headerlink" title="QueryVo"></a>QueryVo</h4><pre><code>public class QueryVo {    private User user;    public User getUser() {        return user;    }    public void setUser(User user) {        this.user = user;    }}</code></pre><h4 id="Sql语句"><a href="#Sql语句" class="headerlink" title="Sql语句"></a>Sql语句</h4><p>SELECT * FROM user where username like ‘%刘%’</p><h4 id="Mapper文件"><a href="#Mapper文件" class="headerlink" title="Mapper文件"></a>Mapper文件</h4><pre><code>&lt;!-- 使用包装类型查询用户使用ognl从对象中取属性值，如果是包装对象可以使用.操作符来取内容部的属性--&gt;&lt;select id=&quot;findUserByQueryVo&quot; parameterType=&quot;queryvo&quot; resultType=&quot;user&quot;&gt;    SELECT * FROM user where username like &apos;%${user.username}%&apos;&lt;/select&gt;</code></pre><h4 id="接口"><a href="#接口" class="headerlink" title="接口"></a>接口</h4><pre><code> public interface UserMapper{    User findUserById(int id) throws Exception;    void insertUser(User user) throws Exception;    List&lt;User&gt; findUserByQueryVo(QueryVo queryVo) throws Exception;}</code></pre><h4 id="测试方法"><a href="#测试方法" class="headerlink" title="测试方法"></a>测试方法</h4><pre><code>@Testpublic void testFindUserByQueryVo() throws Exception {    SqlSession sqlSession = sessionFactory.openSession();    //获得mapper的代理对象    UserMapper userMapper = sqlSession.getMapper(UserMapper.class);    //创建QueryVo对象    QueryVo queryVo = new QueryVo();    //创建user对象    User user = new User();    user.setUsername(&quot;刘&quot;);    queryVo.setUser(user);    //根据queryvo查询用户    List&lt;User&gt; list = userMapper.findUserByQueryVo(queryVo);    System.out.println(list);    sqlSession.close();}</code></pre><h2 id="resultType-输出类型"><a href="#resultType-输出类型" class="headerlink" title="resultType(输出类型)"></a>resultType(输出类型)</h2><h3 id="输出简单类型"><a href="#输出简单类型" class="headerlink" title="输出简单类型"></a>输出简单类型</h3><p>参考getnow输出日期类型，看下边的例子输出整型：</p><p>Mapper.xml文件</p><pre><code>&lt;!-- 获取用户列表总数 --&gt;&lt;select id=&quot;findUserCount&quot; parameterType=&quot;user&quot; resultType=&quot;int&quot;&gt;   select count(1) from user&lt;/select&gt;</code></pre><p>Mapper接口</p><pre><code>public int findUserCount(User user) throws Exception;</code></pre><p>调用：</p><pre><code>Public void testFindUserCount() throws Exception{    //获取session    SqlSession session = sqlSessionFactory.openSession();    //获取mapper接口实例    UserMapper userMapper = session.getMapper(UserMapper.class);    User user = new User();    user.setUsername(&quot;管理员&quot;);    //传递Hashmap对象查询用户列表    int count = userMapper.findUserCount(user);    //关闭session    session.close();}</code></pre><p>输出简单类型必须查询出来的结果集有一条记录，最终将第一个字段的值转换为输出类型。<br>使用session的selectOne可查询单条记录。</p><h3 id="输出pojo对象"><a href="#输出pojo对象" class="headerlink" title="输出pojo对象"></a>输出pojo对象</h3><p>参考文章 <a href="http://fashionkillyou.xyz/2018/02/24/mybatis入门一/" title="mybatis入门一" target="_blank" rel="noopener">mybatis入门一</a></p><h3 id="输出pojo列表"><a href="#输出pojo列表" class="headerlink" title="输出pojo列表"></a>输出pojo列表</h3><p>参考文章 <a href="http://fashionkillyou.xyz/2018/02/24/mybatis入门一/" title="mybatis入门一" target="_blank" rel="noopener">mybatis入门一</a></p><h2 id="resultMap"><a href="#resultMap" class="headerlink" title="resultMap"></a>resultMap</h2><p>resultType可以指定pojo将查询结果映射为pojo，但需要pojo的属性名和sql查询的列名一致方可映射成功。</p><p>如果sql查询字段名和pojo的属性名不一致，可以通过resultMap将字段名和属性名作一个对应关系 ，resultMap实质上还需要将查询结果映射到pojo对象中。</p><p>resultMap可以实现将查询结果映射为复杂类型的pojo，比如在查询结果映射对象中包括pojo和list实现一对一查询和一对多查询。</p><h3 id="Mapper-xml定义"><a href="#Mapper-xml定义" class="headerlink" title="Mapper.xml定义"></a>Mapper.xml定义</h3><pre><code> &lt;select id=&quot;findUserListResultMap&quot; parameterType=&quot;queryVo&quot; resultMap=&quot;userListResultMap&quot;&gt;    select id id_,username username_,birthday birthday_ from user&lt;/select&gt;</code></pre><p>使用resultMap指定上边定义的personmap。</p><h3 id="定义resultMap"><a href="#定义resultMap" class="headerlink" title="定义resultMap"></a>定义resultMap</h3><p>由于上边的mapper.xml中sql查询列和Users.java类属性不一致，需要定义resultMap：</p><p>userListResultMap将sql查询列和Users.java类属性对应起来</p><pre><code>&lt;!-- type:最终映射的java对象.id:resultMap的唯一标识 --&gt;&lt;resultMap type=&quot;user&quot; id=&quot;userListResultMap&quot;&gt;&lt;!-- id标签:查询结果集的唯一标识列(主键或唯一标识)    column:SQL查询字段名(列名)    property:pojo的属性名    result标签:普通列 --&gt;    &lt;id property=&quot;id&quot; column=&quot;id_&quot;/&gt;    &lt;result property=&quot;username&quot; column=&quot;username_&quot;/&gt;    &lt;result property=&quot;birthday&quot; column=&quot;birthday_&quot;/&gt;&lt;/resultMap&gt;</code></pre><p>&lt; id /&gt;：此属性表示查询结果集的唯一标识，非常重要。如果是多个字段为复合唯一约束则定义多个&lt; id /&gt;。</p><p>Property：表示User类的属性。</p><p>Column：表示sql查询出来的字段名。</p><p>Column和property放在一块儿表示将sql查询出来的字段映射到指定的pojo类属性上。</p><p>&lt; result /&gt;：普通结果，即pojo的属性。</p><h3 id="Mapper接口定义"><a href="#Mapper接口定义" class="headerlink" title="Mapper接口定义"></a>Mapper接口定义</h3><pre><code>public List&lt;User&gt; findUserListResultMap() throws Exception;</code></pre><h1 id="动态sql"><a href="#动态sql" class="headerlink" title="动态sql"></a>动态sql</h1><p>通过mybatis提供的各种标签方法实现动态拼接sql。</p><h2 id="If"><a href="#If" class="headerlink" title="If"></a>If</h2><pre><code>&lt;!-- 传递pojo综合查询用户信息 --&gt;&lt;select id=&quot;findUserList&quot; parameterType=&quot;user&quot; resultType=&quot;user&quot;&gt;    select * from user     where 1=1     &lt;if test=&quot;id!=null and id!=&apos;&apos;&quot;&gt;    and id=#{id}    &lt;/if&gt;    &lt;if test=&quot;username!=null and username!=&apos;&apos;&quot;&gt;    and username like &apos;%${username}%&apos;    &lt;/if&gt;&lt;/select&gt;</code></pre><p>注意要做不等于空字符串校验。</p><h2 id="Where"><a href="#Where" class="headerlink" title="Where"></a>Where</h2><p>上边的sql也可以改为：</p><pre><code>&lt;select id=&quot;findUserList&quot; parameterType=&quot;user&quot; resultType=&quot;user&quot;&gt;    select * from user     &lt;where&gt;    &lt;if test=&quot;id!=null and id!=&apos;&apos;&quot;&gt;    and id=#{id}    &lt;/if&gt;    &lt;if test=&quot;username!=null and username!=&apos;&apos;&quot;&gt;    and username like &apos;%${username}%&apos;    &lt;/if&gt;    &lt;/where&gt;&lt;/select&gt;</code></pre><p>&lt; where /&gt;可以自动处理第一个and。</p><h2 id="foreach"><a href="#foreach" class="headerlink" title="foreach"></a>foreach</h2><p>向sql传递数组或List，mybatis使用foreach解析，如下：</p><p>需求<br>传入多个id查询用户信息，用下边两个sql实现：</p><pre><code>SELECT * FROM USERS WHERE username LIKE &apos;%张%&apos; AND (id =10 OR id =89 OR id=16)SELECT * FROM USERS WHERE username LIKE &apos;%张%&apos;  id IN (10,89,16)</code></pre><p>在pojo中定义list属性ids存储多个用户id，并添加getter/setter方法</p><pre><code> public class QueryVo {    private User user;    private List&lt;Integer&gt; ids;    public List&lt;Integer&gt; getIds() {        return ids;    }    public void setIds(List&lt;Integer&gt; ids) {        this.ids = ids;    }...</code></pre><p>mapper.xml</p><pre><code>&lt;if test=&quot;ids!=null and ids.size&gt;0&quot;&gt;        &lt;foreach collection=&quot;ids&quot; open=&quot; and id in(&quot; close=&quot;)&quot; item=&quot;id&quot; separator=&quot;,&quot; &gt;            #{id}        &lt;/foreach&gt;&lt;/if&gt;</code></pre><p>测试代码：</p><pre><code>List&lt;Integer&gt; ids = new ArrayList&lt;Integer&gt;();    ids.add(1);//查询id为1的用户    ids.add(10); //查询id为10的用户    queryVo.setIds(ids);    List&lt;User&gt; list = userMapper.findUserList(queryVo);</code></pre><h2 id="Sql片段"><a href="#Sql片段" class="headerlink" title="Sql片段"></a>Sql片段</h2><p>Sql中可将重复的sql提取出来，使用时用include引用即可，最终达到sql重用的目的，如下：</p><pre><code>&lt;!-- 传递pojo综合查询用户信息 --&gt;&lt;select id=&quot;findUserList&quot; parameterType=&quot;user&quot; resultType=&quot;user&quot;&gt;    select * from user     &lt;where&gt;    &lt;if test=&quot;id!=null and id!=&apos;&apos;&quot;&gt;    and id=#{id}    &lt;/if&gt;    &lt;if test=&quot;username!=null and username!=&apos;&apos;&quot;&gt;    and username like &apos;%${username}%&apos;    &lt;/if&gt;    &lt;/where&gt;&lt;/select&gt;</code></pre><p>    将where条件抽取出来：</p><pre><code>&lt;sql id=&quot;query_user_where&quot;&gt;    &lt;if test=&quot;id!=null and id!=&apos;&apos;&quot;&gt;        and id=#{id}    &lt;/if&gt;    &lt;if test=&quot;username!=null and username!=&apos;&apos;&quot;&gt;        and username like &apos;%${username}%&apos;    &lt;/if&gt;&lt;/sql&gt;</code></pre><p>    使用include引用：</p><pre><code>&lt;select id=&quot;findUserList&quot; parameterType=&quot;user&quot; resultType=&quot;user&quot;&gt;    select * from user     &lt;where&gt;    &lt;include refid=&quot;query_user_where&quot;/&gt;    &lt;/where&gt;&lt;/select&gt;</code></pre><p>注意：如果引用其它mapper.xml的sql片段，则在引用时需要加上namespace，如下：</p><pre><code>&lt;include refid=&quot;namespace.sql片段”/&gt;</code></pre><p>如果使用 &gt;或者&lt;符号的时候,因为是在xml文件中这些符号都是有特殊含义的,可以使用CDATA区域 &lt;![CDATA[要写的内容]]&gt;       &lt;![CDATA[&gt;]]&gt;大于   &lt;![CDATA[&lt;]]&gt;</p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;输入映射和输出映射&quot;&gt;&lt;a href=&quot;#输入映射和输出映射&quot; class=&quot;headerlink&quot; title=&quot;输入映射和输出映射&quot;&gt;&lt;/a&gt;输入映射和输出映射&lt;/h1&gt;&lt;p&gt;Mapper.xml映射文件中定义了操作数据库的sql，每个sql是一个statement，映射文件是mybatis的核心。&lt;br&gt;
    
    </summary>
    
      <category term="SSM" scheme="http://www.fashionkillyou.xyz/categories/SSM/"/>
    
    
      <category term="mybatis" scheme="http://www.fashionkillyou.xyz/tags/mybatis/"/>
    
  </entry>
  
  <entry>
    <title>mybatis二</title>
    <link href="http://www.fashionkillyou.xyz/2018/02/24/mybatis%E4%BA%8C/"/>
    <id>http://www.fashionkillyou.xyz/2018/02/24/mybatis二/</id>
    <published>2018-02-24T09:18:11.000Z</published>
    <updated>2018-03-16T04:02:12.962Z</updated>
    
    <content type="html"><![CDATA[<script src="\assets\js\APlayer.min.js"> </script><h1 id="Mapper动态代理方式"><a href="#Mapper动态代理方式" class="headerlink" title="Mapper动态代理方式"></a>Mapper动态代理方式</h1><h2 id="开发规范"><a href="#开发规范" class="headerlink" title="开发规范"></a>开发规范</h2><p>Mapper接口开发方法只需要程序员编写Mapper接口（相当于Dao接口），由Mybatis框架根据接口定义创建接口的动态代理对象，代理对象的方法体同上边Dao接口实现类方法。</p><p>Mapper接口开发需要遵循以下规范：<br><a id="more"></a><br>1、    Mapper.xml文件中的namespace与mapper接口的类路径相同。</p><p>2、    Mapper接口方法名和Mapper.xml中定义的每个statement的id相同</p><p>3、    Mapper接口方法的输入参数类型和mapper.xml中定义的每个sql 的parameterType的类型相同</p><p>4、    Mapper接口方法的输出参数类型和mapper.xml中定义的每个sql的resultType的类型相同</p><h2 id="Mapper-xml-映射文件"><a href="#Mapper-xml-映射文件" class="headerlink" title="Mapper.xml(映射文件)"></a>Mapper.xml(映射文件)</h2><p>定义mapper映射文件UserMapper.xml（内容同Users.xml），需要修改namespace的值为 UserMapper接口路径。将UserMapper.xml放在classpath 下mapper目录 下。</p><pre><code>&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; ?&gt;&lt;!DOCTYPE mapperPUBLIC &quot;-//mybatis.org//DTD Mapper 3.0//EN&quot;&quot;http://mybatis.org/dtd/mybatis-3-mapper.dtd&quot;&gt;&lt;mapper namespace=&quot;cn.lxm.mybatis.mapper.UserMapper&quot;&gt;&lt;!-- 根据id获取用户信息 --&gt;&lt;select id=&quot;findUserById&quot; parameterType=&quot;int&quot; resultType=&quot;cn.lxm.mybatis.po.User&quot;&gt;    select * from user where id = #{id}&lt;/select&gt;&lt;!-- 自定义条件查询用户列表 --&gt;&lt;select id=&quot;findUserByUsername&quot; parameterType=&quot;java.lang.String&quot;         resultType=&quot;cn.lxm.mybatis.po.User&quot;&gt;   select * from user where username like &apos;%${value}%&apos; &lt;/select&gt;&lt;!-- 添加用户 --&gt;&lt;insert id=&quot;insertUser&quot; parameterType=&quot;cn.lxm.mybatis.po.User&quot;&gt;&lt;selectKey keyProperty=&quot;id&quot; order=&quot;AFTER&quot; resultType=&quot;java.lang.Integer&quot;&gt;    select LAST_INSERT_ID() &lt;/selectKey&gt;  insert into user(username,birthday,sex,address)   values(#{username},#{birthday},#{sex},#{address})&lt;/insert&gt;&lt;/mapper&gt;</code></pre><h2 id="Mapper-java-接口文件"><a href="#Mapper-java-接口文件" class="headerlink" title="Mapper.java(接口文件)"></a>Mapper.java(接口文件)</h2><pre><code>/** * 用户管理mapper */Public interface UserMapper {//根据用户id查询用户信息public User findUserById(int id) throws Exception;//查询用户列表public List&lt;User&gt; findUserByUsername(String username) throws Exception;//添加用户信息public void insertUser(User user)throws Exception; }</code></pre><p>接口定义有如下特点：</p><p>1、    Mapper接口方法名和Mapper.xml中定义的statement的id相同</p><p>2、    Mapper接口方法的输入参数类型和mapper.xml中定义的statement的parameterType的类型相同</p><p>3、    Mapper接口方法的输出参数类型和mapper.xml中定义的statement的resultType的类型相同</p><h2 id="加载UserMapper-xml文件"><a href="#加载UserMapper-xml文件" class="headerlink" title="加载UserMapper.xml文件"></a>加载UserMapper.xml文件</h2><p>修改SqlMapConfig.xml文件：</p><pre><code>&lt;!-- 加载映射文件 --&gt;&lt;mappers&gt;    &lt;mapper resource=&quot;mapper/UserMapper.xml&quot;/&gt;&lt;/mappers&gt;</code></pre><h2 id="测试"><a href="#测试" class="headerlink" title="测试"></a>测试</h2><pre><code>Public class UserMapperTest extends TestCase {    private SqlSessionFactory sqlSessionFactory;    protected void setUp() throws Exception {        //mybatis配置文件        String resource = &quot;sqlMapConfig.xml&quot;;        InputStream inputStream = Resources.getResourceAsStream(resource);        //使用SqlSessionFactoryBuilder创建sessionFactory        sqlSessionFactory = new SqlSessionFactoryBuilder().build(inputStream);    }    Public void testFindUserById() throws Exception {        //获取session        SqlSession session = sqlSessionFactory.openSession();        //获取mapper接口的代理对象        UserMapper userMapper = session.getMapper(UserMapper.class);        //调用代理对象方法        User user = userMapper.findUserById(1);        System.out.println(user);        //关闭session        session.close();    }    @Test    public void testFindUserByUsername() throws Exception {        SqlSession sqlSession = sqlSessionFactory.openSession();        UserMapper userMapper = sqlSession.getMapper(UserMapper.class);        List&lt;User&gt; list = userMapper.findUserByUsername(&quot;张&quot;);        System.out.println(list.size());    }    Public void testInsertUser() throws Exception {        //获取session        SqlSession session = sqlSessionFactory.openSession();        //获取mapper接口的代理对象        UserMapper userMapper = session.getMapper(UserMapper.class);        //要添加的数据        User user = new User();        user.setUsername(&quot;张三&quot;);        user.setBirthday(new Date());        user.setSex(&quot;1&quot;);        user.setAddress(&quot;北京市&quot;);        //通过mapper接口添加用户        userMapper.insertUser(user);        //提交        session.commit();        //关闭session        session.close();    }}</code></pre><h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><ul><li><p>selectOne和selectList<br>动态代理对象调用sqlSession.selectOne()和sqlSession.selectList()是根据mapper接口方法的返回值决定，如果返回list则调用selectList方法，如果返回单个对象则调用selectOne方法。</p></li><li><p>namespace<br>mybatis官方推荐使用mapper代理方法开发mapper接口，程序员不用编写mapper接口实现类，使用mapper代理方法时，输入参数可以使用pojo包装对象或map对象，保证dao的通用性。</p></li></ul><h2 id="SqlMapConfig-xml配置文件"><a href="#SqlMapConfig-xml配置文件" class="headerlink" title="SqlMapConfig.xml配置文件"></a>SqlMapConfig.xml配置文件</h2><h3 id="配置内容"><a href="#配置内容" class="headerlink" title="配置内容"></a>配置内容</h3><p>SqlMapConfig.xml中配置的内容和顺序如下：</p><pre><code>properties（属性）settings（全局配置参数）typeAliases（类型别名）typeHandlers（类型处理器）objectFactory（对象工厂）plugins（插件）environments（环境集合属性对象）environment（环境子属性对象）transactionManager（事务管理）dataSource（数据源）mappers（映射器）</code></pre><h2 id="properties（属性）"><a href="#properties（属性）" class="headerlink" title="properties（属性）"></a>properties（属性）</h2><p>SqlMapConfig.xml可以引用java属性文件中的配置信息如下：</p><p>在classpath下定义db.properties文件</p><pre><code>jdbc.driver=com.mysql.jdbc.Driverjdbc.url=jdbc:mysql://localhost:3306/mybatis?characterEncoding=utf-8jdbc.username=rootjdbc.password=root</code></pre><p>SqlMapConfig.xml引用如下：</p><pre><code>&lt;properties resource=&quot;db.properties&quot;/&gt;    &lt;environments default=&quot;development&quot;&gt;        &lt;environment id=&quot;development&quot;&gt;            &lt;transactionManager type=&quot;JDBC&quot;/&gt;            &lt;dataSource type=&quot;POOLED&quot;&gt;                &lt;property name=&quot;driver&quot; value=&quot;${jdbc.driver}&quot;/&gt;                &lt;property name=&quot;url&quot; value=&quot;${jdbc.url}&quot;/&gt;                &lt;property name=&quot;username&quot; value=&quot;${jdbc.username}&quot;/&gt;                &lt;property name=&quot;password&quot; value=&quot;${jdbc.password}&quot;/&gt;            &lt;/dataSource&gt;        &lt;/environment&gt;    &lt;/environments&gt;</code></pre><p>注意： MyBatis 将按照下面的顺序来加载属性：</p><ul><li>在 properties 元素体内定义的属性首先被读取。 </li><li>然后会读取properties 元素中resource或 url 加载的属性，它会覆盖已读取的同名属性。 </li></ul><h2 id="typeAliases（类型别名）"><a href="#typeAliases（类型别名）" class="headerlink" title="typeAliases（类型别名）"></a>typeAliases（类型别名）</h2><h3 id="mybatis支持别名："><a href="#mybatis支持别名：" class="headerlink" title="mybatis支持别名："></a>mybatis支持别名：</h3><pre><code>别名    映射的类型_byte     byte _long     long _short     short _int     int _integer     int _double     double _float     float _boolean     boolean string     String byte     Byte long     Long short     Short int     Integer integer     Integer double     Double float     Float boolean     Boolean date     Date decimal     BigDecimal bigdecimal     BigDecimal map    Map</code></pre><h3 id="自定义别名："><a href="#自定义别名：" class="headerlink" title="自定义别名："></a>自定义别名：</h3><p>在SqlMapConfig.xml中配置：<br>    <typealiases><br>        <!-- 单个别名定义 --><br>        <typealias alias="user" type="cn.lxm.mybatis.po.User"><br>        <!-- 批量别名定义，扫描整个包下的类，别名为类名（首字母大写或小写都可以） --><br>        <package name="cn.lxm.mybatis.po"><br>        <package name="其它包"><br>    </package></package></typealias></typealiases><br>这个<typealiases>标签的位置必须放在<environments>标签前面,dtd的约束</environments></typealiases></p><h2 id="mappers（映射器）"><a href="#mappers（映射器）" class="headerlink" title="mappers（映射器）"></a>mappers（映射器）</h2><p>Mapper配置的几种方法：</p><ul><li>&lt; mapper resource=” “ /&gt;</li></ul><p>使用相对于类路径的资源如：</p><pre><code>&lt;mapper resource=&quot;sqlmap/User.xml&quot; /&gt;</code></pre><ul><li>&lt; mapper class=” “ /&gt;</li></ul><p>使用mapper接口类路径如：</p><pre><code>&lt;mapper class=&quot;cn.lxm.mybatis.mapper.UserMapper&quot;/&gt;</code></pre><p>注意：此种方法要求mapper接口名称和mapper映射文件名称相同，且放在同一个目录中。</p><ul><li>&lt; package name=””/&gt;</li></ul><p>注册指定包下的所有mapper接口如：</p><pre><code>&lt;package name=&quot;cn.lxm.mybatis.mapper&quot;/&gt;</code></pre><p>注意：此种方法要求mapper接口名称和mapper映射文件名称相同，且放在同一个目录中。</p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;Mapper动态代理方式&quot;&gt;&lt;a href=&quot;#Mapper动态代理方式&quot; class=&quot;headerlink&quot; title=&quot;Mapper动态代理方式&quot;&gt;&lt;/a&gt;Mapper动态代理方式&lt;/h1&gt;&lt;h2 id=&quot;开发规范&quot;&gt;&lt;a href=&quot;#开发规范&quot; class=&quot;headerlink&quot; title=&quot;开发规范&quot;&gt;&lt;/a&gt;开发规范&lt;/h2&gt;&lt;p&gt;Mapper接口开发方法只需要程序员编写Mapper接口（相当于Dao接口），由Mybatis框架根据接口定义创建接口的动态代理对象，代理对象的方法体同上边Dao接口实现类方法。&lt;/p&gt;
&lt;p&gt;Mapper接口开发需要遵循以下规范：&lt;br&gt;
    
    </summary>
    
      <category term="SSM" scheme="http://www.fashionkillyou.xyz/categories/SSM/"/>
    
    
      <category term="mybatis" scheme="http://www.fashionkillyou.xyz/tags/mybatis/"/>
    
  </entry>
  
  <entry>
    <title>mybatis一</title>
    <link href="http://www.fashionkillyou.xyz/2018/02/24/mybatis%E4%B8%80/"/>
    <id>http://www.fashionkillyou.xyz/2018/02/24/mybatis一/</id>
    <published>2018-02-24T02:09:08.000Z</published>
    <updated>2018-03-16T04:02:22.629Z</updated>
    
    <content type="html"><![CDATA[<script src="\assets\js\APlayer.min.js"> </script><h1 id="Mybatis入门程序"><a href="#Mybatis入门程序" class="headerlink" title="Mybatis入门程序"></a>Mybatis入门程序</h1><h2 id="1-mybatis下载"><a href="#1-mybatis下载" class="headerlink" title="1 mybatis下载"></a>1 mybatis下载</h2><p>mybaits的代码由github.com管理，地址：<a href="https://github.com/mybatis/mybatis-3/releases" target="_blank" rel="noopener">https://github.com/mybatis/mybatis-3/releases</a><br><a id="more"></a> </p><p>mybatis-3.2.7.jar—-mybatis的核心包<br>lib—-mybatis的依赖包<br>mybatis-3.2.7.pdf—-mybatis使用手册</p><h2 id="2-工程搭建"><a href="#2-工程搭建" class="headerlink" title="2 工程搭建"></a>2 工程搭建</h2><h3 id="第一步：创建java工程"><a href="#第一步：创建java工程" class="headerlink" title="第一步：创建java工程"></a>第一步：创建java工程</h3><p>使用eclipse创建java工程，jdk使用1.7.0_72。</p><h3 id="第二步：加入jar包"><a href="#第二步：加入jar包" class="headerlink" title="第二步：加入jar包"></a>第二步：加入jar包</h3><p>加入mybatis核心包、依赖包、数据驱动包。</p><h3 id="第三步：log4j-properties"><a href="#第三步：log4j-properties" class="headerlink" title="第三步：log4j.properties"></a>第三步：log4j.properties</h3><p>在classpath下创建log4j.properties如下：</p><pre><code># Global logging configurationlog4j.rootLogger=DEBUG, stdout# Console output...log4j.appender.stdout=org.apache.log4j.ConsoleAppenderlog4j.appender.stdout.layout=org.apache.log4j.PatternLayoutlog4j.appender.stdout.layout.ConversionPattern=%5p [%t] - %m%n</code></pre><p>mybatis默认使用log4j作为输出日志信息。</p><h3 id="第四步：SqlMapConfig-xml"><a href="#第四步：SqlMapConfig-xml" class="headerlink" title="第四步：SqlMapConfig.xml"></a>第四步：SqlMapConfig.xml</h3><p>在classpath下创建SqlMapConfig.xml，如下：</p><pre><code>&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; ?&gt;&lt;!DOCTYPE configurationPUBLIC &quot;-//mybatis.org//DTD Config 3.0//EN&quot;&quot;http://mybatis.org/dtd/mybatis-3-config.dtd&quot;&gt;&lt;configuration&gt;&lt;!-- 和spring整合后 environments配置将废除--&gt;&lt;environments default=&quot;development&quot;&gt;    &lt;environment id=&quot;development&quot;&gt;    &lt;!-- 使用jdbc事务管理--&gt;        &lt;transactionManager type=&quot;JDBC&quot; /&gt;    &lt;!-- 数据库连接池--&gt;        &lt;dataSource type=&quot;POOLED&quot;&gt;            &lt;property name=&quot;driver&quot; value=&quot;com.mysql.jdbc.Driver&quot; /&gt;            &lt;property name=&quot;url&quot; value=&quot;jdbc:mysql://localhost:3306/mybatis?characterEncoding=utf-8&quot; /&gt;            &lt;property name=&quot;username&quot; value=&quot;root&quot; /&gt;            &lt;property name=&quot;password&quot; value=&quot;root&quot; /&gt;        &lt;/dataSource&gt;    &lt;/environment&gt;&lt;/environments&gt;&lt;/configuration&gt;</code></pre><p>SqlMapConfig.xml是mybatis核心配置文件，上边文件的配置内容为数据源、事务管理。</p><h3 id="第五步：po类"><a href="#第五步：po类" class="headerlink" title="第五步：po类"></a>第五步：po类</h3><p>Po类作为mybatis进行sql映射使用，po类通常与数据库表对应，User.java如下：</p><pre><code>Public class User {    private int id;    private String username;// 用户姓名    private String sex;// 性别    private Date birthday;// 生日    private String address;// 地址get/set……</code></pre><h3 id="第六步：sql映射文件"><a href="#第六步：sql映射文件" class="headerlink" title="第六步：sql映射文件"></a>第六步：sql映射文件</h3><p>在classpath下的sqlmap目录下创建sql映射文件Users.xml：</p><pre><code>&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; ?&gt;&lt;!DOCTYPE mapperPUBLIC &quot;-//mybatis.org//DTD Mapper 3.0//EN&quot;&quot;http://mybatis.org/dtd/mybatis-3-mapper.dtd&quot;&gt;&lt;mapper namespace=&quot;test&quot;&gt;&lt;/mapper&gt;</code></pre><p>namespace ：命名空间，用于隔离sql语句，后面会讲另一层非常重要的作用。</p><h3 id="第七步：加载映射文件"><a href="#第七步：加载映射文件" class="headerlink" title="第七步：加载映射文件"></a>第七步：加载映射文件</h3><p>mybatis框架需要加载映射文件，将User.xml添加在SqlMapConfig.xml，如下：</p><pre><code>&lt;mappers&gt;    &lt;mapper resource=&quot;sqlmap/User.xml&quot;/&gt;&lt;/mappers&gt;</code></pre><h2 id="3-根据id查询用户信息"><a href="#3-根据id查询用户信息" class="headerlink" title="3 根据id查询用户信息"></a>3 根据id查询用户信息</h2><h3 id="映射文件："><a href="#映射文件：" class="headerlink" title="映射文件："></a>映射文件：</h3><p>在user.xml中添加：</p><pre><code>&lt;!-- 根据id获取用户信息 - -&gt;&lt;select id=&quot;findUserById&quot; parameterType=&quot;int&quot; resultType=&quot;cn.lxm.mybatis.po.User&quot;&gt;    select * from user where id = #{id}&lt;/select&gt;</code></pre><p>parameterType：定义输入到sql中的映射类型，#{id}表示使用preparedstatement设置占位符号并将输入变量id传到sql。<br>resultType：定义结果映射类型。</p><h3 id="测试程序："><a href="#测试程序：" class="headerlink" title="测试程序："></a>测试程序：</h3><pre><code>public class Mybatis_first {    //会话工厂    private SqlSessionFactory sqlSessionFactory;    @Before    public void createSqlSessionFactory() throws IOException {        // 配置文件        String resource = &quot;SqlMapConfig.xml&quot;;        InputStream inputStream = Resources.getResourceAsStream(resource);        // 使用SqlSessionFactoryBuilder从xml配置文件中创建SqlSessionFactory        sqlSessionFactory = new SqlSessionFactoryBuilder()                .build(inputStream);    }    // 根据 id查询用户信息    @Test    public void testFindUserById() {        // 数据库会话实例        SqlSession sqlSession = null;        try {            // 创建数据库会话实例sqlSession            sqlSession = sqlSessionFactory.openSession();            // 查询单个记录，根据用户id查询用户信息            User user = sqlSession.selectOne(&quot;test.findUserById&quot;, 10);            // 输出用户信息            System.out.println(user);        } catch (Exception e) {            e.printStackTrace();        } finally {            if (sqlSession != null) {                sqlSession.close();            }        }    }}</code></pre><h2 id="4-根据用户名查询用户信息"><a href="#4-根据用户名查询用户信息" class="headerlink" title="4 根据用户名查询用户信息"></a>4 根据用户名查询用户信息</h2><h3 id="映射文件：-1"><a href="#映射文件：-1" class="headerlink" title="映射文件："></a>映射文件：</h3><p>在user.xml中添加：</p><pre><code>&lt;!-- 自定义条件查询用户列表  - -&gt;&lt;select id=&quot;findUserByUsername&quot; parameterType=&quot;java.lang.String&quot;         resultType=&quot;cn.lxm.mybatis.po.User&quot;&gt;   select * from user where username like &apos;%${value}%&apos; &lt;/select&gt;</code></pre><p>parameterType：定义输入到sql中的映射类型，${value}表示使用参数将${value}替换，做字符串的拼接。<br>注意：如果是取简单数据类型的参数，括号中的值必须为value<br>resultType：定义结果映射类型。</p><h3 id="测试程序：-1"><a href="#测试程序：-1" class="headerlink" title="测试程序："></a>测试程序：</h3><pre><code>// 根据用户名称模糊查询用户信息@Testpublic void testFindUserByUsername() {    // 数据库会话实例    SqlSession sqlSession = null;    try {        // 创建数据库会话实例sqlSession        sqlSession = sqlSessionFactory.openSession();        // 查询单个记录，根据用户id查询用户信息        List&lt;User&gt; list = sqlSession.selectList(&quot;test.findUserByUsername&quot;, &quot;张&quot;);        System.out.println(list.size());    } catch (Exception e) {        e.printStackTrace();    } finally {        if (sqlSession != null) {            sqlSession.close();        }    }}</code></pre><h1 id="5小结"><a href="#5小结" class="headerlink" title="5小结"></a>5小结</h1><h2 id="和"><a href="#和" class="headerlink" title="#{}和${}"></a>#{}和${}</h2><p>-#{}表示一个占位符号，通过#{}可以实现preparedStatement向占位符中设置值，自动进行java类型和jdbc类型转换，#{}可以有效防止sql注入。 #{}可以接收简单类型值或pojo属性值。 如果parameterType传输单个简单类型值，#{}括号中可以是value或其它名称。</p><p>-${}表示拼接sql串，通过${}可以将parameterType 传入的内容拼接在sql中且不进行jdbc类型转换， ${}可以接收简单类型值或pojo属性值，如果parameterType传输单个简单类型值，${}括号中只能是value。</p><h2 id="parameterType和resultType"><a href="#parameterType和resultType" class="headerlink" title="parameterType和resultType"></a>parameterType和resultType</h2><p>parameterType：指定输入参数类型，mybatis通过ognl从输入对象中获取参数值拼接在sql中。<br>resultType：指定输出结果类型，mybatis将sql查询结果的一行记录数据映射为resultType指定类型的对象。</p><h2 id="selectOne和selectList"><a href="#selectOne和selectList" class="headerlink" title="selectOne和selectList"></a>selectOne和selectList</h2><p>selectOne查询一条记录，如果使用selectOne查询多条记录则抛出异常：<br>    org.apache.ibatis.exceptions.TooManyResultsException: Expected one result (or null) to be returned by selectOne(), but found: 3<br>    at org.apache.ibatis.session.defaults.DefaultSqlSession.selectOne(DefaultSqlSession.java:70)</p><p>selectList可以查询一条或多条记录。</p><h1 id="6添加用户"><a href="#6添加用户" class="headerlink" title="6添加用户"></a>6添加用户</h1><h2 id="映射文件：-2"><a href="#映射文件：-2" class="headerlink" title="映射文件："></a>映射文件：</h2><p>在SqlMapConfig.xml中添加：<br><!-- 添加用户 --><br>    <insert id="insertUser" parametertype="cn.lxm.mybatis.po.User"><br>      insert into user(username,birthday,sex,address)<br>      values(#{username},#{birthday},#{sex},#{address})<br>    </insert></p><h2 id="测试程序：-2"><a href="#测试程序：-2" class="headerlink" title="测试程序："></a>测试程序：</h2><pre><code>// 添加用户信息@Testpublic void testInsert() {    // 数据库会话实例    SqlSession sqlSession = null;    try {        // 创建数据库会话实例sqlSession        sqlSession = sqlSessionFactory.openSession();        // 添加用户信息        User user = new User();        user.setUsername(&quot;张小明&quot;);        user.setAddress(&quot;河南郑州&quot;);        user.setSex(&quot;1&quot;);        user.setPrice(1999.9f);        sqlSession.insert(&quot;test.insertUser&quot;, user);        //提交事务        sqlSession.commit();    } catch (Exception e) {        e.printStackTrace();    } finally {        if (sqlSession != null) {            sqlSession.close();        }    }}</code></pre><h2 id="mysql自增主键返回"><a href="#mysql自增主键返回" class="headerlink" title="mysql自增主键返回"></a>mysql自增主键返回</h2><p>通过修改sql映射文件，可以将mysql自增主键返回:</p><pre><code>&lt;insert id=&quot;insertUser&quot; parameterType=&quot;cn.lxm.mybatis.po.User&quot;&gt;    &lt;!-- selectKey将主键返回，需要再返回 使用user.getId()获取返回的id值 --&gt;    &lt;selectKey keyProperty=&quot;id&quot; order=&quot;AFTER&quot; resultType=&quot;java.lang.Integer&quot;&gt;        select LAST_INSERT_ID()    &lt;/selectKey&gt;   insert into user(username,birthday,sex,address)    values(#{username},#{birthday},#{sex},#{address});&lt;/insert&gt;</code></pre><p>添加selectKey实现将主键返回</p><p>keyProperty:返回的主键存储在pojo中的哪个属性</p><p>order：selectKey的执行顺序，是相对与insert语句来说，由于mysql的自增原理执行完insert语句之后才将主键生成，所以这里selectKey的执行顺序为after</p><p>resultType:返回的主键是什么类型</p><p>LAST_INSERT_ID():是mysql的函数，返回auto_increment自增列新记录id值。</p><h2 id="oracle自增主键返回"><a href="#oracle自增主键返回" class="headerlink" title="oracle自增主键返回"></a>oracle自增主键返回</h2><pre><code>&lt;insert id=&quot;insertUser&quot; parameterType=&quot;cn.lxm.mybatis.po.User&quot;&gt;    &lt;!-- selectKey将主键返回，需要再返回 --&gt;    &lt;selectKey keyProperty=&quot;id&quot; order=&quot;BEFORE&quot; resultType=&quot;java.lang.Integer&quot;&gt;        select 序列的.nextval()    &lt;/selectKey&gt;   insert into user(id,username,birthday,sex,address)    values(#{id},#{username},#{birthday},#{sex},#{address});&lt;/insert&gt;</code></pre><p>oracle的不是很常用,这里是需要先取出序列里面的主键,然后再插入数据,插入的时候讲取出来的主键放进去.所以这里的order是BEFORE</p><h2 id="Mysql使用-uuid实现主键"><a href="#Mysql使用-uuid实现主键" class="headerlink" title="Mysql使用 uuid实现主键"></a>Mysql使用 uuid实现主键</h2><p>需要增加通过select uuid()得到uuid值</p><pre><code>&lt;insert  id=&quot;insertUser&quot; parameterType=&quot;cn.lxm.mybatis.po.User&quot;&gt;&lt;selectKey resultType=&quot;java.lang.String&quot; order=&quot;BEFORE&quot; keyProperty=&quot;id&quot;&gt;select uuid()&lt;/selectKey&gt;insert into user(id,username,birthday,sex,address)          values(#{id},#{username},#{birthday},#{sex},#{address})&lt;/insert&gt;</code></pre><p>注意这里使用的order是“BEFORE”</p><h1 id="7删除用户"><a href="#7删除用户" class="headerlink" title="7删除用户"></a>7删除用户</h1><h2 id="映射文件：-3"><a href="#映射文件：-3" class="headerlink" title="映射文件："></a>映射文件：</h2><!-- 删除用户 --><pre><code>&lt;delete id=&quot;deleteUserById&quot; parameterType=&quot;int&quot;&gt;    delete from user where id=#{id}&lt;/delete&gt;</code></pre><h2 id="测试程序：-3"><a href="#测试程序：-3" class="headerlink" title="测试程序："></a>测试程序：</h2><pre><code>// 根据id删除用户@Testpublic void testDelete() {    // 数据库会话实例    SqlSession sqlSession = null;    try {        // 创建数据库会话实例sqlSession        sqlSession = sqlSessionFactory.openSession();        // 删除用户        sqlSession.delete(&quot;test.deleteUserById&quot;,18);        // 提交事务        sqlSession.commit();    } catch (Exception e) {        e.printStackTrace();    } finally {        if (sqlSession != null) {            sqlSession.close();        }    }}</code></pre><h1 id="8修改用户"><a href="#8修改用户" class="headerlink" title="8修改用户"></a>8修改用户</h1><h2 id="映射文件"><a href="#映射文件" class="headerlink" title="映射文件"></a>映射文件</h2><!-- 更新用户 --><pre><code>&lt;update id=&quot;updateUser&quot; parameterType=&quot;cn.lxm.mybatis.po.User&quot;&gt;    update user set username=#{username},birthday=#{birthday},sex=#{sex},address=#{address}    where id=#{id}&lt;/update&gt;</code></pre><h2 id="测试程序"><a href="#测试程序" class="headerlink" title="测试程序"></a>测试程序</h2><pre><code>// 更新用户信息@Testpublic void testUpdate() {    // 数据库会话实例    SqlSession sqlSession = null;    try {        // 创建数据库会话实例sqlSession        sqlSession = sqlSessionFactory.openSession();        // 添加用户信息        User user = new User();        user.setId(16);        user.setUsername(&quot;张小明&quot;);        user.setAddress(&quot;河南郑州&quot;);        user.setSex(&quot;1&quot;);        user.setPrice(1999.9f);        sqlSession.update(&quot;test.updateUser&quot;, user);        // 提交事务        sqlSession.commit();    } catch (Exception e) {        e.printStackTrace();    } finally {        if (sqlSession != null) {            sqlSession.close();        }    }}</code></pre><h1 id="9-Mybatis解决jdbc编程的问题"><a href="#9-Mybatis解决jdbc编程的问题" class="headerlink" title="9 Mybatis解决jdbc编程的问题"></a>9 Mybatis解决jdbc编程的问题</h1><ul><li>1、    数据库链接创建、释放频繁造成系统资源浪费从而影响系统性能，如果使用数据库链接池可解决此问题。<br>解决：在SqlMapConfig.xml中配置数据链接池，使用连接池管理数据库链接。</li><li>2、    Sql语句写在代码中造成代码不易维护，实际应用sql变化的可能较大，sql变动需要改变java代码。<br>解决：将Sql语句配置在XXXXmapper.xml文件中与java代码分离。</li><li>3、    向sql语句传参数麻烦，因为sql语句的where条件不一定，可能多也可能少，占位符需要和参数一一对应。<br>解决：Mybatis自动将java对象映射至sql语句，通过statement中的parameterType定义输入参数的类型。</li><li>4、    对结果集解析麻烦，sql变化导致解析代码变化，且解析前需要遍历，如果能将数据库记录封装成pojo对象解析比较方便。<br>解决：Mybatis自动将sql执行结果映射至java对象，通过statement中的resultType定义输出结果的类型。</li></ul><h1 id="10-mybatis与hibernate不同"><a href="#10-mybatis与hibernate不同" class="headerlink" title="10 mybatis与hibernate不同"></a>10 mybatis与hibernate不同</h1><ul><li><p>Mybatis和hibernate不同，它不完全是一个ORM框架，因为MyBatis需要程序员自己编写Sql语句，不过mybatis可以通过XML或注解方式灵活配置要运行的sql语句，并将java对象和sql语句映射生成最终执行的sql，最后将sql执行的结果再映射生成java对象。</p></li><li><p>Mybatis学习门槛低，简单易学，程序员直接编写原生态sql，可严格控制sql执行性能，灵活度高，非常适合对关系数据模型要求不高的软件开发，例如互联网软件、企业运营类软件等，因为这类软件需求变化频繁，一但需求变化要求成果输出迅速。但是灵活的前提是mybatis无法做到数据库无关性，如果需要实现支持多种数据库的软件则需要自定义多套sql映射文件，工作量大。</p></li><li><p>Hibernate对象/关系映射能力强，数据库无关性好，对于关系模型要求高的软件（例如需求固定的定制化软件）如果用hibernate开发可以节省很多代码，提高效率。但是Hibernate的学习门槛高，要精通门槛更高，而且怎么设计O/R映射，在性能和对象模型之间如何权衡，以及怎样用好Hibernate需要具有很强的经验和能力才行。</p></li><li><p>总之，按照用户的需求在有限的资源环境下只要能做出维护性、扩展性良好的软件架构都是好架构，所以框架只有适合才是最好。</p></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;Mybatis入门程序&quot;&gt;&lt;a href=&quot;#Mybatis入门程序&quot; class=&quot;headerlink&quot; title=&quot;Mybatis入门程序&quot;&gt;&lt;/a&gt;Mybatis入门程序&lt;/h1&gt;&lt;h2 id=&quot;1-mybatis下载&quot;&gt;&lt;a href=&quot;#1-mybatis下载&quot; class=&quot;headerlink&quot; title=&quot;1 mybatis下载&quot;&gt;&lt;/a&gt;1 mybatis下载&lt;/h2&gt;&lt;p&gt;mybaits的代码由github.com管理，地址：&lt;a href=&quot;https://github.com/mybatis/mybatis-3/releases&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://github.com/mybatis/mybatis-3/releases&lt;/a&gt;&lt;br&gt;
    
    </summary>
    
      <category term="SSM" scheme="http://www.fashionkillyou.xyz/categories/SSM/"/>
    
    
      <category term="mybatis" scheme="http://www.fashionkillyou.xyz/tags/mybatis/"/>
    
  </entry>
  
  <entry>
    <title>webService天气预报接口</title>
    <link href="http://www.fashionkillyou.xyz/2018/02/11/webService%E5%A4%A9%E6%B0%94%E9%A2%84%E6%8A%A5%E6%8E%A5%E5%8F%A3/"/>
    <id>http://www.fashionkillyou.xyz/2018/02/11/webService天气预报接口/</id>
    <published>2018-02-11T15:36:17.000Z</published>
    <updated>2018-02-11T15:42:41.163Z</updated>
    
    <content type="html"><![CDATA[<script src="\assets\js\APlayer.min.js"> </script><p>一：环境搭建<br>二：根据wsdl文件生成客户端代码<br>三：测试代码<br><a id="more"></a></p><h1 id="一：环境搭建"><a href="#一：环境搭建" class="headerlink" title="一：环境搭建"></a>一：环境搭建</h1><pre><code>1：新建一个java project工程weatherInf2：引入相应的jar包activation.jaraxis-ant.jaraxis.jarcommons-discovery-0.2.jarcommons-logging-1.0.4.jarjaxrpc.jarlog4j-1.2.8.jarmail.jarsaaj.jarwsdl4j-1.5.1.jar下载axis 1.4 src压缩包，解压后到webapp/web-info/lib下取包，具体路径如下：http://download.csdn.net/detail/yyg64/5351114其中mail.jar 以及 activation.jar 可到如下路径下载：http://download.csdn.net/detail/dbhunter/3982583：将天气预报接口wsdl文件拷贝到src目录下http://www.webxml.com.cn/WebServices/WeatherWebService.asmx?wsdl</code></pre><h1 id="二：根据wsdl文件生成客户端代码"><a href="#二：根据wsdl文件生成客户端代码" class="headerlink" title="二：根据wsdl文件生成客户端代码"></a>二：根据wsdl文件生成客户端代码</h1><p>wsdl文件——右键——web services——Generate Client，然后一路next到finish。</p><h1 id="三：测试代码"><a href="#三：测试代码" class="headerlink" title="三：测试代码"></a>三：测试代码</h1><pre><code> 1 /** 2  *  3  */ 4 package com.paic.services; 5  6 import java.rmi.RemoteException; 7  8 import javax.xml.rpc.ServiceException; 9 10 import cn.com.WebXml.WeatherWebServiceLocator;11 import cn.com.WebXml.WeatherWebServiceSoapStub;12 13 /**14  * @author Administrator15  * 16  */17 public class TestWeather {18     public static void main(String[] args) throws ServiceException,19             RemoteException {20         WeatherWebServiceLocator locator = new WeatherWebServiceLocator();21         WeatherWebServiceSoapStub service = (WeatherWebServiceSoapStub) locator22                 .getPort(WeatherWebServiceSoapStub.class);23         invokeGetSupportProvince(service);24         System.out.println(&quot;...................&quot;);25         invokeGetSupportCity(service);26         invokeGetWeatherByOneCity(service);27     }28 29     // 调用获取支持的省份、州接口30     public static void invokeGetSupportProvince(31             WeatherWebServiceSoapStub service) throws RemoteException {32         String[] provices = service.getSupportProvince();33         System.out.println(&quot;总共&quot; + provices.length + &quot;个&quot;);34         int count = 0;35         for (String str : provices) {36             if (0 != count &amp;&amp; count % 5 == 0) {37                 System.out.println();38             }39             System.out.print(str + &quot;\t&quot;);40             count++;41         }42     }43 44     // 调用获取支持查询某个省份内的城市接口45     public static void invokeGetSupportCity(WeatherWebServiceSoapStub service)46             throws RemoteException {47         String provinceName = &quot;江苏&quot;;48         String[] cities = service.getSupportCity(provinceName);49         System.out.println(&quot;总共&quot; + cities.length + &quot;个市&quot;);50         for (int i = 0; i &lt; cities.length; i++) {51             if (0 != i &amp;&amp; i % 5 == 0) {52                 System.out.println();53             }54             System.out.print(cities[i] + &quot;\t&quot;);55         }56     }57 58     // 调用查询某个城市天气的接口59     public static void invokeGetWeatherByOneCity(60             WeatherWebServiceSoapStub service) throws RemoteException {61         String cityName = &quot;南京&quot;;62         String[] weatherInfo = service.getWeatherbyCityName(cityName);63         for (String str : weatherInfo) {64             System.out.println(str);65         }66     }67 }</code></pre>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;一：环境搭建&lt;br&gt;二：根据wsdl文件生成客户端代码&lt;br&gt;三：测试代码&lt;br&gt;
    
    </summary>
    
      <category term="前端" scheme="http://www.fashionkillyou.xyz/categories/%E5%89%8D%E7%AB%AF/"/>
    
    
      <category term="webservice" scheme="http://www.fashionkillyou.xyz/tags/webservice/"/>
    
  </entry>
  
</feed>
