<?xml version="1.0" encoding="utf-8"?>
<search> 
  
    
    <entry>
      <title>mybatis逆向工程</title>
      <link href="/2018/04/12/mybatis%E9%80%86%E5%90%91%E5%B7%A5%E7%A8%8B/"/>
      <content type="html"><![CDATA[<script src="\assets\js\APlayer.min.js"> </script><h1 id="使用逆向工程时候遇到的一些问题"><a href="#使用逆向工程时候遇到的一些问题" class="headerlink" title="使用逆向工程时候遇到的一些问题"></a>使用逆向工程时候遇到的一些问题</h1><p>在使用Mybatis generatot 自动生成实体类时,遇到一个问题: 实体类中字段名和数据库中的字段名不一致。<br><a id="more"></a><br>具体问题描述如下:</p><p>如: 数据中：client_id , clientName 使用Mybatis generator 反转过来后变成了: clientId(下划线没了), clientname(统一小写)。</p><p>解决办法:</p><p>在 generatorConfig.xml 配置文件中,<table> 元素下增加 子元素 </table></p><pre><code>&lt;property name=&quot;useActualColumnNames&quot; value=&quot;true&quot;/&gt;</code></pre><p>如:</p><pre><code>&lt;table tableName=&quot;crm_client&quot; domainObjectName=&quot;crm_client&quot; enableCountByExample=&quot;false&quot; enableUpdateByExample=&quot;false&quot; enableDeleteByExample=&quot;false&quot; enableSelectByExample=&quot;false&quot; selectByExampleQueryId=&quot;false&quot;&gt;&lt;property name=&quot;useActualColumnNames&quot; value=&quot;true&quot;/&gt;&lt;/table&gt;</code></pre><p>至此即可解决Mybaits Generator 自动生成实体类和数据库中字段名不一致的问题。</p><p>MyBatis Generator中文文档</p><p>MyBatis Generator中文文档地址：</p><p><a href="http://mbg.cndocs.ml/" target="_blank" rel="noopener">http://mbg.cndocs.ml/</a></p><p>该中文文档由于尽可能和原文内容一致，所以有些地方如果不熟悉，看中文版的文档的也会有一定的障碍，所以本章根据该中文文档以及实际应用，使用通俗的语言来讲解详细的配置。</p><p>本文中所有节点的链接都是对应的中文文档地址，可以点击查看详细信息。</p><p>注:本文后面提到的MBG全部指代MyBatis Generator。</p><p>MyBatis Generator 1.3.4 扩展，可以设置 Mapper（Dao）后缀</p><p>运行MyBatis Generator</p><p>有4种运行MBG的方法，具体请看文档 运行 MyBatis Generator</p><p>MBG下载地址:<a href="http://repo1.maven.org/maven2/org/mybatis/generator/mybatis-generator-core/" target="_blank" rel="noopener">http://repo1.maven.org/maven2/org/mybatis/generator/mybatis-generator-core/</a></p><h1 id="XML配置详解"><a href="#XML配置详解" class="headerlink" title="XML配置详解"></a>XML配置详解</h1><p>在MBG中，最主要也最重要的就是XML配置文件，因此本篇文章主要的内容就是XML配置。</p><p>这里按照配置的顺序对配置逐个讲解，更细的内容可以配合中文文档参照。</p><h2 id="1-配置文件头"><a href="#1-配置文件头" class="headerlink" title="1. 配置文件头"></a>1. 配置文件头</h2><pre><code>&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;!DOCTYPE generatorConfiguration    PUBLIC &quot;-//mybatis.org//DTD MyBatis Generator Configuration 1.0//EN&quot;    &quot;http://mybatis.org/dtd/mybatis-generator-config_1_0.dtd&quot;&gt;</code></pre><p>使用最新版的MBG需要使用上面的xml头，配置文件必须包含上面的DOCTYPE。</p><h2 id="2-根节点"><a href="#2-根节点" class="headerlink" title="2. 根节点"></a>2. 根节点<generatorconfiguration></generatorconfiguration></h2><p>generatorConfiguration节点没有任何属性，直接写节点即可，如下：</p><pre><code>&lt;generatorConfiguration&gt;    &lt;!-- 具体配置内容 --&gt;&lt;/generatorConfiguration&gt;  </code></pre><h2 id="3-子元素"><a href="#3-子元素" class="headerlink" title="3. 子元素"></a>3. <generatorconfiguration>子元素</generatorconfiguration></h2><p>从这段开始，就是配置的主要内容，这些配置都是generatorConfiguration元素的子元素。</p><p>包含以下子元素（有严格的顺序）：</p><pre><code>&lt;properties&gt; (0个或1个)&lt;classPathEntry&gt; (0个或多个)&lt;context&gt; (1个或多个)</code></pre><h3 id="3-1-元素"><a href="#3-1-元素" class="headerlink" title="3.1  元素"></a>3.1 <properties> 元素</properties></h3><p>这个元素用来指定外部的属性元素，不是必须的元素。</p><p>元素用于指定一个需要在配置中解析使用的外部属性文件，引入属性文件后，可以在配置中使用 ${property}这种形式的引用，通过这种方式引用属性文件中的属性值。 对于后面需要配置的<strong>jdbc信息</strong>和targetProject属性会很有用。</p><p>这个属性可以通过resource或者url来指定属性文件的位置，这两个属性只能使用其中一个来指定，同时出现会报错。</p><p>resource：指定classpath下的属性文件，使用类似com/myproject/generatorConfig.properties这样的属性值。</p><p>url：可以指定文件系统上的特定位置，例如file:///C:/myfolder/generatorConfig.properties</p><h3 id="3-2-元素"><a href="#3-2-元素" class="headerlink" title="3.2  元素"></a>3.2 <classpathentry> 元素</classpathentry></h3><p>这个元素可以0或多个，不受限制。</p><p>最常见的用法是通过这个属性指定驱动的路径，例如：</p><p><classpathentry location="E:\mysql\mysql-connector-java-5.1.29.jar"><br>重点提醒：本文之前在这里有误导，特别强调。</classpathentry></p><p>注意，classPathEntry只在下面这两种情况下才有效：</p><pre><code>当加载 JDBC 驱动内省数据库时当加载根类中的 JavaModelGenerator 检查重写的方法时</code></pre><p>因此，如果你需要加载其他用途的jar包，classPathEntry起不到作用，不能这么写，解决的办法就是将你用的jar包添加到类路径中，在Eclipse等IDE中运行的时候，添加jar包比较容易。当从命令行执行的时候，需要用</p><pre><code>java -cp xx.jar,xx2.jar xxxMainClass</code></pre><p>这种方式在-cp后面指定来使用(注意-jar会导致-cp无效)。</p><h3 id="3-3-元素"><a href="#3-3-元素" class="headerlink" title="3.3  元素"></a>3.3 <context> 元素</context></h3><p>在MBG的配置中，至少需要有一个<context>元素。</context></p><p><context>元素用于指定生成一组对象的环境。例如指定要连接的数据库，要生成对象的类型和要处理的数据库中的表。运行MBG的时候还可以指定要运行的<context>。</context></context></p><p>该元素只有一个<strong>必选属性</strong>id，用来唯一确定一个<context>元素，该id属性可以在运行MBG的使用。</context></p><p>此外还有几个<strong>可选属性</strong>：</p><p>defaultModelType:<strong>这个属性很重要</strong>，这个属性定义了MBG如何生成<strong>实体类</strong>。<br>这个属性有以下可选值：</p><p>conditional:<em>这是默认值</em>,这个模型和下面的hierarchical类似，除了如果那个单独的类将只包含一个字段，将不会生成一个单独的类。 因此,如果一个表的主键只有一个字段,那么不会为该字段生成单独的实体类,会将该字段合并到基本实体类中。</p><p>flat:该模型为每一张表只生成一个实体类。这个实体类包含表中的所有字段。<strong>这种模型最简单，推荐使用。</strong></p><p>hierarchical:如果表有主键,那么该模型会产生一个单独的主键实体类,如果表还有BLOB字段， 则会为表生成一个包含所有BLOB字段的单独的实体类,然后为所有其他的字段生成一个单独的实体类。 MBG会在所有生成的实体类之间维护一个继承关系。</p><p>targetRuntime:此属性用于指定生成的代码的运行时环境。该属性支持以下可选值：</p><pre><code>MyBatis3:*这是默认值*MyBatis3SimpleIbatis2Java2Ibatis2Java5 一般情况下使用默认值即可，有关这些值的具体作用以及区别请查看中文文档的详细内容。introspectedColumnImpl:该参数可以指定扩展org.mybatis.generator.api.IntrospectedColumn该类的实现类。该属性的作用可以查看扩展MyBatis Generator。</code></pre><p>一般情况下，我们使用如下的配置即可：</p><pre><code>&lt;context id=&quot;Mysql&quot; defaultModelType=&quot;flat&quot;&gt;</code></pre><p>如果你希望不生成和Example查询有关的内容，那么可以按照如下进行配置:</p><pre><code>&lt;context id=&quot;Mysql&quot; targetRuntime=&quot;MyBatis3Simple&quot; defaultModelType=&quot;flat&quot;&gt;</code></pre><p>使用MyBatis3Simple可以避免在后面的<table>中逐个进行配置（后面会提到）。</table></p><p>MBG配置中的其他几个元素，基本上都是<context>的子元素，这些子元素（有严格的配置顺序）包括：</context></p><pre><code>&lt;property&gt; (0个或多个)&lt;plugin&gt; (0个或多个)&lt;commentGenerator&gt; (0个或1个)&lt;jdbcConnection&gt; (1个)&lt;javaTypeResolver&gt; (0个或1个)&lt;javaModelGenerator&gt; (1个)&lt;sqlMapGenerator&gt; (0个或1个)&lt;javaClientGenerator&gt; (0个或1个)&lt;table&gt; (1个或多个)</code></pre><p>其中<property>属性比较特殊，后面讲解的时候都会和父元素一起进行讲解。在讲解<property>属性前，我们先看看<strong>什么是分隔符？</strong>。</property></property></p><p>这里通过一个例子说明。假设在Mysql数据库中有一个表名为user info，你没有看错，中间是一个空格，这种情况下如果写出select * from user info这样的语句，肯定是要报错的，在Mysql中的时候我们一般会写成如下的样子:</p><pre><code>select * from `user info`</code></pre><p>这里的使用的<strong>反单引号(`)</strong>就是<strong>分隔符</strong>，<strong>分隔符</strong>可以用于<strong>表名</strong>或者<strong>列名</strong>。</p><p>下面继续看<property>支持的属性：</property></p><pre><code>autoDelimitKeywordsbeginningDelimiterendingDelimiterjavaFileEncodingjavaFormatterxmlFormatter</code></pre><p>由于这些属性比较重要，这里一一讲解。</p><p>首先是autoDelimitKeywords，当表名或者字段名为SQL关键字的时候，可以设置该属性为true，MBG会自动给表名或字段名添加<strong>分隔符</strong>。</p><p>然后这里继续上面的例子来讲beginningDelimiter和endingDelimiter属性。<br>由于beginningDelimiter和endingDelimiter的默认值为双引号(“)，在Mysql中不能这么写，所以还要将这两个默认值改为<strong>反单引号(`)</strong>，配置如下：</p><pre><code>&lt;property name=&quot;beginningDelimiter&quot; value=&quot;`&quot;/&gt;&lt;property name=&quot;endingDelimiter&quot; value=&quot;`&quot;/&gt;  </code></pre><p>属性javaFileEncoding设置要使用的Java文件的编码，默认使用当前平台的编码，只有当生产的编码需要特殊指定时才需要使用，一般用不到。</p><p>最后两个javaFormatter和xmlFormatter属性<strong>可能会</strong>很有用，如果你想使用模板来定制生成的java文件和xml文件的样式，你可以通过指定这两个属性的值来实现。</p><p>接下来分节对其他的子元素逐个进行介绍。</p><h4 id="3-3-1-元素"><a href="#3-3-1-元素" class="headerlink" title="3.3.1  元素"></a>3.3.1 <plugin> 元素</plugin></h4><p>该元素可以配置0个或者多个，不受限制。</p><p><plugin>元素用来定义一个插件。插件用于扩展或修改通过MyBatis Generator (MBG)代码生成器生成的代码。</plugin></p><p>插件将按在配置中配置的顺序执行。</p><p>有关插件的详细信息可以参考开发插件和提供的插件了解更多。</p><h4 id="3-3-2-元素"><a href="#3-3-2-元素" class="headerlink" title="3.3.2  元素"></a>3.3.2 <commentgenerator> 元素</commentgenerator></h4><p>该元素最多可以配置1个。</p><p>这个元素非常有用，相信很多人都有过这样的需求，就是希望MBG生成的代码中可以包含<strong>注释信息</strong>，具体就是生成表或字段的备注信息。</p><p>使用这个元素就能很简单的实现我们想要的功能。这里先介绍该元素，介绍完后会举例如何扩展实现该功能。</p><p>该元素有一个可选属性type,可以指定用户的实现类，该类需要实现org.mybatis.generator.api.CommentGenerator接口。而且必有一个默认的构造方法。这个属性接收默认的特殊值DEFAULT，会使用默认的实现类org.mybatis.generator.internal.DefaultCommentGenerator。</p><p>默认的实现类中提供了两个可选属性，需要通过<property>属性进行配置。</property></p><pre><code>suppressAllComments:**阻止**生成注释，默认为falsesuppressDate:**阻止**生成的注释包含时间戳，默认为false</code></pre><p>一般情况下由于MBG生成的注释信息没有任何价值，而且有时间戳的情况下每次生成的注释都不一样，使用<strong>版本控制</strong>的时候每次都会提交，因而一般情况下我们都会屏蔽注释信息，可以如下配置：</p><commentgenerator><br>    <property name="suppressAllComments" value="true"><br>    <property name="suppressDate" value="true"><br></property></property></commentgenerator><br>接下来我们简单举例实现生成包含表字段注释信息的注释<br><br>因为系统提供了一个默认的实现类，所以对我们来说，自己实现一个会很容易，最简单的方法就是复制默认实现类代码到一个新的文件中，修改类名如MyCommentGenerator，在你自己的实现类中，你可以选择是否继续支持上面的两个属性，你还可以增加对其他属性的支持。<br><br>我们通过下面一个方法的修改来了解，其他几个方法请自行修改(写本章的时候我也没有完全实现该类，所以不提供完整源码了):<br><br>    @Override<br>    public void addFieldComment(Field field, IntrospectedTable introspectedTable, IntrospectedColumn introspectedColumn) {<br>        if (introspectedColumn.getRemarks() != null &amp;&amp; !introspectedColumn.getRemarks().equals(“”)) {<br>            field.addJavaDocLine(“/<strong>“);<br>            field.addJavaDocLine(“ <em> “ + introspectedColumn.getRemarks());<br>            addJavadocTag(field, false);<br>            field.addJavaDocLine(“ </em>/“);<br>        }<br>    }<br>这个方法是给字段添加注释信息的，其中IntrospectedColumn包含了字段的完整信息，通过getRemarks方法可以获取字段的注释信息。上面这个方法修改起来还是很容易的。除了字段的注释外还有Getter和Setter，以及类的注释。此外还有生成XML的注释，大家可以根据默认的实现进行修改。<br><br>完成我们自己的实现类后，我们还需要做如下配置：<br><br>    <commentgenerator type="com.github.abel533.mybatis.generator.MyCommentGenerator"><br>#### 3.3.3 <jdbcconnection> 元素<br><br><jdbcconnection>用于指定数据库连接信息，该元素必选，并且只能有一个。<br><br>配置该元素只需要注意如果JDBC驱动不在</jdbcconnection></jdbcconnection></commentgenerator></strong>classpath<strong>下，就需要通过<classpathentry>元素引入jar包，这里</classpathentry></strong>推荐<strong>将jar包放到</strong>classpath<strong>下。<br><br>该元素有两个必选属性:<br><br>    driverClass:访问数据库的JDBC驱动程序的完全限定类名<br>    connectionURL:访问数据库的JDBC连接URL<br>该元素还有两个可选属性:<br><br>    userId:访问数据库的用户ID<br>    password:访问数据库的密码<br>此外该元素还可以接受多个<property>子元素，这里配置的<property>属性都会添加到JDBC驱动的属性中。<br><br>这个元素配置起来最容易，这里举个简单例子：<br><br>    <jdbcconnection driverclass="com.mysql.jdbc.Driver" connectionurl="jdbc:mysql://localhost:3306/test" userid="root" password=""><br>    </jdbcconnection><br>#### 3.3.4 <javatyperesolver> 元素<br><br>该元素最多可以配置一个。<br><br>这个元素的配置用来指定JDBC类型和Java类型如何转换。<br><br>该元素提供了一个可选的属性type，和<commentgenerator>比较类型，提供了默认的实现DEFAULT，一般情况下使用默认即可，需要特殊处理的情况可以通过其他元素配置来解决，不建议修改该属性。<br><br>该属性还有一个可以配置的<property>元素。<br><br>可以配置的属性为forceBigDecimals，该属性可以控制是否强制DECIMAL和NUMERIC类型的字段转换为Java类型的java.math.BigDecimal,默认值为false，一般不需要配置。<br><br>默认情况下的转换规则为：<br><br>    如果精度&gt;0或者长度&gt;18，就会使用java.math.BigDecimal<br>    如果精度=0并且10&lt;=长度&lt;=18，就会使用java.lang.Long<br>    如果精度=0并且5&lt;=长度&lt;=9，就会使用java.lang.Integer<br>    如果精度=0并且长度&lt;5，就会使用java.lang.Short<br>    如果设置为true，那么一定会使用java.math.BigDecimal，配置示例如下：<br><br>    <javatyperesolver><br>        <property name="forceBigDecimals" value="true"><br>    </property></javatyperesolver><br>#### 3.3.5 <javamodelgenerator> 元素<br><br>该元素必须配置一个，并且最多一个。<br><br>该元素用来控制生成的实体类，根据<context>中配置的defaultModelType，一个表可能会对应生成多个不同的实体类。一个表对应多个类实际上并不方便，所以前面也推荐使用flat，这种情况下一个表对应一个实体类。<br><br>该元素只有两个属性，都是必选的。<br><br>    targetPackage:生成实体类存放的包名，一般就是放在该包下。实际还会受到其他配置的影响(<table>中会提到)。<br><br>    targetProject:指定目标项目路径，可以是绝对路径或相对路径（如 targetProject=”src/main/java”）。<br>该元素支持以下几个<property>子元素属性：<br><br>    constructorBased:该属性只对MyBatis3有效，如果true就会使用构造方法入参，如果false就会使用setter方式。默认为false。<br><br>    enableSubPackages:如果true，MBG会根据catalog和schema来生成子包。如果false就会直接用targetPackage属性。默认为false。<br><br>    immutable:该属性用来配置实体类属性是否可变，如果设置为true，那么constructorBased不管设置成什么，都会使用构造方法入参，并且不会生成setter方法。如果为false，实体类属性就可以改变。默认为false。<br><br>    rootClass:设置所有实体类的基类。如果设置，需要使用类的全限定名称。并且如果MBG能够加载rootClass，那么MBG不会覆盖和父类中完全匹配的属性。匹配规则：<br><br>        属性名完全相同<br>        属性类型相同<br>        属性有getter方法<br>        属性有setter方法<br>        trimStrings:是否对数据库查询结果进行trim操作，如果设置为true就会生成类似这样public void setUsername(String username) {this.username = username == null ? null : username.trim();}的setter方法。默认值为false。<br>配置示例如下：<br><br>    <javamodelgenerator targetpackage="test.model" targetproject="src\main\java"><br>        <property name="enableSubPackages" value="true"><br>        <property name="trimStrings" value="true"><br>    </property></property></javamodelgenerator><br>#### 3.3.6 <sqlmapgenerator> 元素<br><br>该元素可选，最多配置一个。但是有如下两种必选的特殊情况：<br><br>如果targetRuntime目标是</sqlmapgenerator></property></table></context></javamodelgenerator></property></commentgenerator></javatyperesolver></property></property></strong>iBATIS2<strong>，该元素必须配置一个。<br><br>如果targetRuntime目标是</strong>MyBatis3<strong>，只有当<javaclientgenerator>需要XML时，该元素必须配置一个。 如果没有配置<javaclientgenerator>，则使用以下的规则：<br><br>    如果指定了一个<sqlmapgenerator>，那么MBG将只生成XML的SQL映射文件和实体类。<br><br>    如果没有指定<sqlmapgenerator>，那么MBG将只生成实体类。<br><br>该元素只有两个属性（和前面提过的<javamodelgenerator>的属性含义一样），都是必选的。<br><br>    targetPackage:生成实体类存放的包名，一般就是放在该包下。实际还会受到其他配置的影响(<table>中会提到)。<br>    targetProject:指定目标项目路径，可以是绝对路径或相对路径（如 targetProject=”src/main/resources”）。<br><br>该元素支持<property>子元素，只有一个可以配置的属性：<br><br>    enableSubPackages:如果true，MBG会根据catalog和schema来生成子包。如果false就会直接用targetPackage属性。默认为false。<br>配置示例：<br><br>    <sqlmapgenerator targetpackage="test.xml" targetproject="src\main\resources"><br>        <property name="enableSubPackages" value="true"><br>    </property></sqlmapgenerator><br>#### 3.3.7 <javaclientgenerator> 元素<br><br>该元素可选，最多配置一个。<br><br>如果不配置该元素，就不会生成Mapper接口。<br><br>该元素有3个必选属性：<br><br>type:该属性用于选择一个预定义的客户端代码（可以理解为Mapper接口）生成器，用户可以自定义实现，需要继承org.mybatis.generator.codegen.AbstractJavaClientGenerator类，必选有一个默认的构造方法。 该属性提供了以下预定的代码生成器，首先根据<context>的targetRuntime分成三类：<br><br>        MyBatis3:<br>            ANNOTATEDMAPPER:基于注解的Mapper接口，不会有对应的XML映射文件<br>            MIXEDMAPPER:XML和注解的混合形式，(上面这种情况中的)SqlProvider注解方法会被XML替代。<br>            XMLMAPPER:所有的方法都在XML中，接口调用依赖XML文件。<br>        MyBatis3Simple:<br>            ANNOTATEDMAPPER:基于注解的Mapper接口，不会有对应的XML映射文件<br>            XMLMAPPER:所有的方法都在XML中，接口调用依赖XML文件。<br>        Ibatis2Java2或</context></javaclientgenerator></property></table></javamodelgenerator></sqlmapgenerator></sqlmapgenerator></javaclientgenerator></javaclientgenerator></strong>Ibatis2Java5<strong>:<br>            IBATIS:生成的对象符合iBATIS的DAO框架（不建议使用）。<br>            GENERIC-CI:生成的对象将只依赖于SqlMapClient，通过构造方法注入。<br>            GENERIC-SI:生成的对象将只依赖于SqlMapClient，通过setter方法注入。<br>            SPRING:生成的对象符合Spring的DAO接口<br>            targetPackage:生成实体类存放的包名，一般就是放在该包下。实际还会受到其他配置的影响(<table>中会提到)。<br>targetProject:指定目标项目路径，可以是绝对路径或相对路径（如 targetProject=”src/main/java”）。<br>该元素还有一个可选属性：<br><br>    implementationPackage:如果指定了该属性，实现类就会生成在这个包中。<br>该元素支持<property>子元素设置的属性：<br><br>    enableSubPackages<br>    exampleMethodVisibility<br>    methodNameCalculator<br>    rootInterface<br>    useLegacyBuilder<br>这几个属性不太常用，具体作用请看完整的文档，这里对rootInterface做个简单介绍。<br><br>rootInterface用于指定一个所有生成的接口都继承的父接口。 这个值可以通过<table>配置的rootInterface属性覆盖。<br><br>这个属性对于通用Mapper来说，可以让生成的所有接口都继承该接口。<br><br>配置示例：<br><br>    <javaclientgenerator type="XMLMAPPER" targetpackage="test.dao" targetproject="src\main\java"><br>#### 3.3.8 <table> 元素<br><br>该元素至少要配置一个，可以配置多个。<br><br>该元素用来配置要通过内省的表。只有配置的才会生成实体类和其他文件。<br><br>该元素有一个必选属性：<br><br>tableName：指定要生成的表名，可以使用SQL通配符匹配多个表。<br>例如要生成全部的表，可以按如下配置：<br><br><table tablename="%"><br>该元素包含多个可选属性：<br><br>schema:数据库的schema,可以使用SQL通配符匹配。如果设置了该值，生成SQL的表名会变成如schema.tableName的形式。<br><br>catalog:数据库的catalog，如果设置了该值，生成SQL的表名会变成如catalog.tableName的形式。<br><br>alias:如果指定，这个值会用在生成的select查询SQL的表的别名和列名上。 列名会被别名为 alias<em>actualColumnName(别名</em>实际列名) 这种模式。<br><br>domainObjectName:生成对象的基本名称。如果没有指定，MBG会自动根据表名来生成名称。<br><br>enableXXX:XXX代表多种SQL方法，该属性用来指定是否生成对应的XXX语句。<br><br>selectByPrimaryKeyQueryId:DBA跟踪工具会用到，具体请看详细文档。<br><br>selectByExampleQueryId:DBA跟踪工具会用到，具体请看详细文档。<br><br>modelType:和<context>的defaultModelType含义一样，这里可以针对表进行配置，这里的配置会覆盖<context>的defaultModelType配置。<br><br>escapeWildcards:这个属性表示当查询列，是否对schema和表名中的SQL通配符 (‘_’ and ‘%’) 进行转义。 对于某些驱动当schema或表名中包含SQL通配符时（例如，一个表名是MY_TABLE，有一些驱动需要将下划线进行转义）是必须的。默认值是false。<br><br>delimitIdentifiers:是否给标识符增加</context></context></table></table></javaclientgenerator></table></property></table></strong>分隔符<strong>。默认false。当catalog,schema或tableName中包含空白时，默认为true。<br><br>delimitAllColumns:是否对所有列添加</strong>分隔符<strong>。默认false。<br>该元素包含多个可用的<property>子元素，可选属性为：<br><br>constructorBased:和<javamodelgenerator>中的属性含义一样。<br><br>ignoreQualifiersAtRuntime:生成的SQL中的表名将不会包含schema和catalog前缀。<br><br>immutable:和<javamodelgenerator>中的属性含义一样。<br><br>modelOnly:此属性用于配置是否为表只生成实体类。如果设置为true就不会有Mapper接口。如果配置了<sqlmapgenerator>，并且modelOnly为true，那么XML映射文件中只有实体对象的映射元素(<resultmap>)。如果为true还会覆盖属性中的enableXXX方法，将不会生成任何CRUD方法。<br><br>rootClass:和<javamodelgenerator>中的属性含义一样。<br><br>rootInterface:和<javaclientgenerator>中的属性含义一样。<br><br>runtimeCatalog:运行时的catalog，当生成表和运行环境的表的catalog不一样的时候可以使用该属性进行配置。<br><br>runtimeSchema:运行时的schema，当生成表和运行环境的表的schema不一样的时候可以使用该属性进行配置。<br><br>runtimeTableName:运行时的tableName，当生成表和运行环境的表的tableName不一样的时候可以使用该属性进行配置。<br><br>selectAllOrderByClause:该属性值会追加到selectAll方法后的SQL中，会直接跟order by拼接后添加到SQL末尾。<br><br>useActualColumnNames:如果设置为true,那么MBG会使用从数据库元数据获取的列名作为生成的实体对象的属性。 如果为false(默认值)，MGB将会尝试将返回的名称转换为驼峰形式。 在这两种情况下，可以通过 元素显示指定，在这种情况下将会忽略这个（useActualColumnNames）属性。<br><br>useColumnIndexes:如果是true,MBG生成resultMaps的时候会使用列的索引,而不是结果中列名的顺序。<br><br>useCompoundPropertyNames:如果是true,那么MBG生成属性名的时候会将列名和列备注接起来. 这对于那些通过第四代语言自动生成列(例如:FLD22237),但是备注包含有用信息(例如:”customer id”)的数据库来说很有用. 在这种情况下,MBG会生成属性名FLD2237_CustomerId。<br><br>除了<property>子元素外，<table>还包含以下子元素：<br><br>    <generatedkey> (0个或1个)<br>    <columnrenamingrule> (0个或1个)<br>    <columnoverride> (0个或多个)<br>    <ignorecolumn> (0个或多个)<br>下面对这4个元素进行详细讲解。<br><br>- 1. <generatedkey> 元素<br><br>这个元素最多可以配置一个。<br><br>这个元素用来指定自动生成主键的属性（identity字段或者sequences序列）。如果指定这个元素，MBG在生成insert的SQL映射文件中插入一个<selectkey>元素。 这个元素</selectkey></generatedkey></ignorecolumn></columnoverride></columnrenamingrule></generatedkey></table></property></javaclientgenerator></javamodelgenerator></resultmap></sqlmapgenerator></javamodelgenerator></javamodelgenerator></property></strong>非常重要<strong>，这个元素包含下面两个必选属性：<br><br>column:生成列的列名。<br><br>    sqlStatement:将返回新值的 SQL 语句。如果这是一个identity列，您可以使用其中一个预定义的的特殊值。预定义值如下：<br>    Cloudscape<br>    DB2<br>    DB2_MF<br>    Derby<br>    HSQLDB<br>    Informix<br>    MySql<br>    SqlServer<br>    SYBASE<br><br>JDBC:这会配置MBG使用MyBatis3支持的JDBC标准的生成key来生成代码。 这是一个独立于数据库获取标识列中的值的方法。 重要: 只有当目标运行为MyBatis3时才会产生正确的代码。 如果与iBATIS2一起使用目标运行时会产生运行时错误的代码。<br><br>这个元素还包含两个可选属性：<br><br>identity:当设置为true时,该列会被标记为identity列， 并且<selectkey>元素会被插入在insert后面。 当设置为false时，<selectkey>会插入到insert之前（通常是序列）。</selectkey></selectkey></strong>重要<strong>: 即使您type属性指定为post，您仍然需要为identity列将该参数设置为true。 这将标志MBG从插入列表中删除该列。默认值是false。<br><br>type:type=post and identity=true的时候生成的<selectkey>中的order=AFTER,当type=pre的时候，identity只能为false，生成的<selectkey>中的order=BEFORE。可以这么理解，自动增长的列只有插入到数据库后才能得到ID，所以是AFTER,使用序列时，只有先获取序列之后，才能插入数据库，所以是BEFORE。<br>配置示例一：<br><br>    <table tablename="user login info" domainobjectname="UserLoginInfo"><br>        <generatedkey column="id" sqlstatement="Mysql"><br>    </generatedkey></table><br>对应的生成的结果：<br><br>    <insert id="insert" parametertype="test.model.UserLoginInfo"><br>        <selectkey keyproperty="id" order="AFTER" resulttype="java.lang.Integer"><br>            SELECT LAST_INSERT_ID()<br>        </selectkey><br>        insert into <code>user login info</code> (Id, username, logindate, loginip)<br>        values (#{id,jdbcType=INTEGER}, #{username,jdbcType=VARCHAR}, #{logindate,jdbcType=TIMESTAMP}, #{loginip,jdbcType=VARCHAR})<br>    </insert><br>配置示例二：<br><br>    <table tablename="user login info" domainobjectname="UserLoginInfo"><br>        <generatedkey column="id" sqlstatement="select SEQ_ID.nextval from dual"><br>    </generatedkey></table><br>对应的生成结果：<br><br>    <insert id="insert" parametertype="test.model.UserLoginInfo"><br>        <selectkey keyproperty="id" order="BEFORE" resulttype="java.lang.Integer"><br>            select SEQ_ID.nextval from dual<br>        </selectkey><br>        insert into <code>user login info</code> (Id, username, logindate, loginip)<br>        values (#{id,jdbcType=INTEGER}, #{username,jdbcType=VARCHAR}, #{logindate,jdbcType=TIMESTAMP},#{loginip,jdbcType=VARCHAR})<br>    </insert><br>- 2. <columnrenamingrule> 元素<br><br>该元素最多可以配置一个，使用该元素可以在生成列之前，对列进行重命名。这对那些存在同一前缀的字段想在生成属性名时去除前缀的表非常有用。 例如假设一个表包含以下的列：<br><br>    CUST_BUSINESS_NAME<br>    CUST_STREET_ADDRESS<br>    CUST_CITY<br>    CUST<em>STATE<br>生成的所有属性名中如果都包含CUST的前缀可能会让人不爽。这些前缀可以通过如下方式定义重命名规则:<br><br>    &lt;columnRenamingRule searchString=”^CUST</em>“ replaceString=”” /&gt;<br>注意，在内部，MBG使用java.util.regex.Matcher.replaceAll方法实现这个功能。 请参阅有关该方法的文档和在Java中使用正则表达式的例子。<br><br>当<columnoverride>匹配一列时，这个元素（<columnrenamingrule>）会被忽略。<columnoverride>优先于重命名的规则。<br><br>该元素有一个必选属性：<br><br>searchString:定义将被替换的字符串的正则表达式。<br><br>该元素有一个可选属性：<br><br>replaceString:这是一个用来替换搜索字符串列每一个匹配项的字符串。如果没有指定，就会使用空字符串。<br>关于<table>的<property>属性useActualColumnNames对此的影响可以查看完整文档。<br><br>- 3. <columnoverride> 元素<br><br>该元素可选，可以配置多个。<br><br>该元素从将某些属性默认计算的值更改为指定的值。<br><br>该元素有一个必选属性:<br><br>column:要重写的列名。<br><br>该元素有多个可选属性：<br><br>property:要使用的Java属性的名称。如果没有指定，MBG会根据列名生成。 例如，如果一个表的一列名为STRT_DTE，MBG会根据<table>的useActualColumnNames属性生成STRT_DTE或strtDte。<br><br>javaType:该列属性值为完全限定的Java类型。如果需要，这可以覆盖由JavaTypeResolver计算出的类型。 对某些数据库来说，这是必要的用来处理</table></columnoverride></property></table></columnoverride></columnrenamingrule></columnoverride></columnrenamingrule></selectkey></selectkey></strong>“奇怪的”<strong>数据库类型（例如MySql的unsigned bigint类型需要映射为java.lang.Object)。<br><br>jdbcType:该列的JDBC类型(INTEGER, DECIMAL, NUMERIC, VARCHAR等等)。 如果需要，这可以覆盖由JavaTypeResolver计算出的类型。 对某些数据库来说，这是必要的用来处理怪异的JDBC驱动 (例如DB2的LONGVARCHAR类型需要为iBATIS 映射为VARCHAR)。<br><br>typeHandler:用户定义的需要用来处理这列的类型处理器。它必须是一个继承iBATIS的TypeHandler类或TypeHandlerCallback接口（该接口很容易继承）的全限定的类名。如果没有指定或者是空白，iBATIS会用默认的类型处理器来处理类型。</strong>重要<strong>:MBG不会校验这个类型处理器是否存在或者可用。 MGB只是简单的将这个值插入到生成的SQL映射的配置文件中。<br><br>delimitedColumnName:指定是否应在生成的SQL的列名称上增加</strong>分隔符<strong>。 如果列的名称中包含空格，MGB会自动添加</strong>分隔符<strong>， 所以这个重写只有当列名需要强制为一个合适的名字或者列名是数据库中的保留字时是必要的。<br><br>配置示例：<br><br>    <table schema="DB2ADMIN" tablename="ALLTYPES"><br>        <columnoverride column="LONG_VARCHAR_FIELD" javatype="java.lang.String" jdbctype="VARCHAR"><br>    </columnoverride></table><br>- 4. <ignorecolumn> 元素<br><br>该元素可选，可以配置多个。<br><br>该元素可以用来屏蔽不需要生成的列。<br><br>该元素有一个必选属性：<br><br>column:要忽略的列名。<br><br>该元素还有一个可选属性：<br><br>delimitedColumnName:匹配列名的时候是否区分大小写。如果为true则区分。默认值为false，不区分大小写。<br>MyBatis Generator最佳实践<br><br><br>### 本节内容针对MyBatis3，使用iBATIS的不一定适用。<br><br>以下根据个人经验（对此有意见的可以留言）对一些配置看法列出如下几点：<br><br>关于实体类的modelType，建议使用defaultModelType=”flat”，只有一个对象的情况下管理毕竟方便，使用也简单。<br><br>关于注释<commentgenerator>，不管你是否要重写自己的注释生成器，有一点不能忘记，那就是注释中一定要保留@mbggenerated,MBG通过该字符串来判断代码是否为代码生成器生成的代码，有该标记的的代码在重新生成的时候会被删除，不会重复。不会在XML中出现重复元素。<br><br>使用MBG生成的代码时，建议尽可能不要去修改自动生成的代码，而且要生成带有@mbggenerated，这样才不会在每次重新生成代码的时候需要手动修改好多内容。<br><br>仍然是注释相关，在<commentgenerator>中，建议一定要保留suppressAllComments属性(使用默认值false)，一定要取消(设为true)时间戳suppressDate，避免重复提交SVN。<br><br><jdbcconnection>建议将JDBC驱动放到项目的</jdbcconnection></commentgenerator></commentgenerator></ignorecolumn></strong>classpath**下，而不是使用<classpathentry>来引入jar包，主要考虑到所有开发人员的统一性。<br><br>当数据库字段使用CHAR时，建议在<javamodelgenerator>中设置<property name="trimStrings" value="true">，可以自动去掉不必要的空格。<br><br>在<javaclientgenerator>中，建议设置type=”XMLMAPPER”,不建议使用注解或混合模式，比较代码和SQL完全分离易于维护。<br><br>建议尽可能在<table>中配置<generatedkey>，避免手工操作，以便于MBG重复执行代码生成。<br>如果有其他有价值的经验，会继续补充。<br><br>综合以上信息，这里给出一个Mysql的简单配置：<br><br>    &lt;?xml version=”1.0” encoding=”UTF-8”?&gt;<br>    &lt;!DOCTYPE generatorConfiguration<br>            PUBLIC “-//mybatis.org//DTD MyBatis Generator Configuration 1.0//EN”<br>            “<a href="http://mybatis.org/dtd/mybatis-generator-config_1_0.dtd&quot;&gt;" target="_blank" rel="noopener">http://mybatis.org/dtd/mybatis-generator-config_1_0.dtd&quot;&gt;</a><br><br>    <generatorconfiguration><br>        <context id="MysqlContext" targetruntime="MyBatis3" defaultmodeltype="flat"><br>            <property name="beginningDelimiter" value="`"><br>            <property name="endingDelimiter" value="`"><br><br>            <commentgenerator><br>                <property name="suppressDate" value="true"><br>            </property></commentgenerator><pre><code>        &lt;jdbcConnection driverClass=&quot;com.mysql.jdbc.Driver&quot;                        connectionURL=&quot;jdbc:mysql://localhost:3306/test&quot;                        userId=&quot;root&quot;                        password=&quot;&quot;&gt;        &lt;/jdbcConnection&gt;        &lt;javaModelGenerator targetPackage=&quot;test.model&quot; targetProject=&quot;src\main\java&quot;&gt;            &lt;property name=&quot;trimStrings&quot; value=&quot;true&quot; /&gt;        &lt;/javaModelGenerator&gt;        &lt;sqlMapGenerator targetPackage=&quot;test.xml&quot;  targetProject=&quot;src\main\resources&quot;/&gt;        &lt;javaClientGenerator type=&quot;XMLMAPPER&quot; targetPackage=&quot;test.dao&quot;  targetProject=&quot;src\main\java&quot;/&gt;        &lt;table tableName=&quot;%&quot;&gt;            &lt;generatedKey column=&quot;id&quot; sqlStatement=&quot;Mysql&quot;/&gt;        &lt;/table&gt;    &lt;/context&gt;&lt;/generatorConfiguration&gt;</code></pre><p><table>这里用的通配符匹配全部的表，另外所有表都有自动增长的id字段。如果不是所有表的配置都一样，可以做针对性的配置。<br>改动：去掉来不建议使用Example查询的建议，Example在单表操作上优势明显，可以看个人情况使用。</table></p></property></property></context></generatorconfiguration></generatedkey></table></javaclientgenerator></property></javamodelgenerator></classpathentry>]]></content>
      
      <categories>
          
          <category> java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 逆向工程 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>eclipse常用的快捷键</title>
      <link href="/2018/04/12/eclipse%E5%B8%B8%E7%94%A8%E7%9A%84%E5%BF%AB%E6%8D%B7%E9%94%AE/"/>
      <content type="html"><![CDATA[<script src="\assets\js\APlayer.min.js"> </script><h1 id="以下是eclipse常用的快捷键"><a href="#以下是eclipse常用的快捷键" class="headerlink" title="以下是eclipse常用的快捷键"></a>以下是eclipse常用的快捷键</h1><p>为了方便记忆,先保存起来,这些都是常用的快捷键<br><a id="more"></a></p><p>ctrl+shift+o      导入包<br>alt+/             提示输入代码<br>ctrl+shift+/      全选要注释部分,用/*注释<br>ctrl+/            全选要注释部分，用//多段注释<br>Alt+Shift+R或者右键菜单里面的 refractor 功能          相同变量名全部改成想转换变量名<br>ctrl+shift+f      代码格式整理<br>ctrl+shift+t      查找某各类<br>ctrl+鼠标左键单击  直接查看这个类源代码<br>ctrl+shift+r    打开资源<br>ctrl+o        快速outline,查找当前类中的所有方法及属性<br>ctrl+e  快速切换打开文档<br>shift+enter        在当前行之下创建一个空白行，与光标是否在行末无关<br>ctrl+shift+enter   则在当前行之前插入空白行<br>ctrl+m          编辑器窗口最大化的快捷键<br>Alt+方向键      当前行的内容往上或下移动<br>ctrl+.及ctrl+1   下一个错误及快速修改<br>ctrl+d    删除当前行<br>shift+home 选中鼠标前面内容<br>shift+end  选中鼠标后面内容  </p>]]></content>
      
      
    </entry>
    
    <entry>
      <title>fastDFS与nginx安装部署</title>
      <link href="/2018/04/03/fastDFS%E4%B8%8Enginx%E5%AE%89%E8%A3%85%E9%83%A8%E7%BD%B2/"/>
      <content type="html"><![CDATA[<script src="\assets\js\APlayer.min.js"> </script><h1 id="关于fastDFS的安装"><a href="#关于fastDFS的安装" class="headerlink" title="关于fastDFS的安装"></a>关于fastDFS的安装</h1><h2 id="第一步：搭建虚拟环境"><a href="#第一步：搭建虚拟环境" class="headerlink" title="第一步：搭建虚拟环境"></a>第一步：搭建虚拟环境</h2><p>FastDFS需要在Linux系统上安装，我们一般使用的都是Windows系统，这样就需要有虚拟环境，我这里使用Vmware12创建虚拟机，关于虚拟机最小化的安装大家可以参考：<a href="http://blog.csdn.net/u012453843/article/details/68947589" target="_blank" rel="noopener">http://blog.csdn.net/u012453843/article/details/68947589</a>这篇博客进行学习<br><a id="more"></a></p><h2 id="第二步：配置静态IP而且要保证能上网"><a href="#第二步：配置静态IP而且要保证能上网" class="headerlink" title="第二步：配置静态IP而且要保证能上网"></a>第二步：配置静态IP而且要保证能上网</h2><p>大家可以参考：<a href="http://blog.csdn.net/u012453843/article/details/52839105" target="_blank" rel="noopener">http://blog.csdn.net/u012453843/article/details/52839105</a>这篇博客进行学习，需要提醒的是，由于最小化安装默认是没有vim命令的，因此在配置静态IP时使用vi命令即可。</p><h2 id="第三步：安装vim命令"><a href="#第三步：安装vim命令" class="headerlink" title="第三步：安装vim命令"></a>第三步：安装vim命令</h2><p>之所以安装vim命令是因为在安装它的同时会自动帮我们安装perl，而perl在进行编译安装时是必须要有的。安装vim的命令是：yum install vim-enhanced</p><h2 id="第四步：安装gcc"><a href="#第四步：安装gcc" class="headerlink" title="第四步：安装gcc"></a>第四步：安装gcc</h2><p>使用命令：yum install make cmake gcc gcc-c++进行安装即可</p><h2 id="第五步：上传安装文件到Linux服务器"><a href="#第五步：上传安装文件到Linux服务器" class="headerlink" title="第五步：上传安装文件到Linux服务器"></a>第五步：上传安装文件到Linux服务器</h2><p>  为了便于管理，我们在Linux服务器上新建一个/usr/local/software目录，专门用于存放安装包，如下所示</p><pre><code>[html] view plain copy[root@fastdfs ~]# mkdir /usr/local/software  [root@fastdfs ~]#  </code></pre><p>下面我们把需要用到的安装包都上传到/usr/local/software目录下，我们可以使用XShell和Xftp5相结合来方便的进行上传下载操作，大家可以参考<a href="http://blog.csdn.net/u012453843/article/details/68951776" target="_blank" rel="noopener">http://blog.csdn.net/u012453843/article/details/68951776</a>这篇博客进行学习。也可以通过安装rzsz命令来进行上传下载操作，安装rzsz的命令是yum install lrzsz，安装完之后，rz表示上传，sz 文件表示下载。</p><p>大家可以到<a href="http://download.csdn.net/detail/u012453843/9802538" target="_blank" rel="noopener">http://download.csdn.net/detail/u012453843/9802538</a>这个地址下载需要的安装包，上传完之后，如下所示</p><pre><code>[html] view plain copy[root@fastdfs software]# ll  总用量 1248 -rw-r--r--. 1 root root  17510 11月 28 00:19 fastdfs-nginx-module_v1.16.tar.gz  -rw-r--r--. 1 root root 345400 11月 28 00:20 FastDFS_v5.05.tar.gz  -rw-r--r--. 1 root root 102378 11月 28 00:19 libfastcommon-master.zip  -rw-r--r--. 1 root root 804164 11月 28 01:11 nginx-1.6.2.tar.gz  [root@fastdfs software]# </code></pre><h2 id="第六步：安装zip和unzip命令"><a href="#第六步：安装zip和unzip命令" class="headerlink" title="第六步：安装zip和unzip命令"></a>第六步：安装zip和unzip命令</h2><pre><code>由于解压.zip结尾的文件需要用到unzip命令，因此我们需要安装，安装命令是yum install zip unzip</code></pre><h2 id="第七步：安装libfastcommon"><a href="#第七步：安装libfastcommon" class="headerlink" title="第七步：安装libfastcommon"></a>第七步：安装libfastcommon</h2><pre><code>1、解压[html] view plain copy[root@fastdfs software]# unzip libfastcommon-master.zip -d /usr/local/fast/  2、进入目录[html] view plain copy[root@fastdfs software]# cd /usr/local/fast/libfastcommon-master/  [root@fastdfs libfastcommon-master]# ll  总用量 28  -rw-r--r--. 1 root root 2913 2月  27 2015 HISTORY  -rw-r--r--. 1 root root  582 2月  27 2015 INSTALL  -rw-r--r--. 1 root root 1342 2月  27 2015 libfastcommon.spec  -rwxr-xr-x. 1 root root 2151 2月  27 2015 make.sh  drwxr-xr-x. 2 root root 4096 2月  27 2015 php-fastcommon  -rw-r--r--. 1 root root  617 2月  27 2015 README  drwxr-xr-x. 2 root root 4096 2月  27 2015 src  [root@fastdfs libfastcommon-master]#    3、编译[html] view plain copy[root@fastdfs libfastcommon-master]# ./make.sh    4、安装[html] view plain copy[root@fastdfs libfastcommon-master]# ./make.sh install</code></pre><h2 id="第八步：创建软链接"><a href="#第八步：创建软链接" class="headerlink" title="第八步：创建软链接"></a>第八步：创建软链接</h2><p> FastDFS主程序设置的目录为/usr/local/lib/，所以我们需要创建/ usr/lib64/下的一些核心执行程序的软连接文件。如下所示。</p><pre><code>[html] view plain copy[root@fastdfs libfastcommon-master]# ln -s /usr/lib64/libfastcommon.so /usr/local/lib/libfastcommon.so  [root@fastdfs libfastcommon-master]# ln -s /usr/lib64/libfastcommon.so /usr/lib/libfastcommon.so  [root@fastdfs libfastcommon-master]# ln -s /usr/lib64/libfdfsclient.so /usr/local/lib/libfdfsclient.so  [root@fastdfs libfastcommon-master]# ln -s /usr/lib64/libfdfsclient.so /usr/lib/libfdfsclient.so</code></pre><h2 id="第九步：安装FastDFS"><a href="#第九步：安装FastDFS" class="headerlink" title="第九步：安装FastDFS"></a>第九步：安装FastDFS</h2><p>1、进入到cd /usr/local/software下，解压FastDFS_v5.05.tar.gz文件 </p><pre><code>[html] view plain copy[root@fastdfs fast]# cd /usr/local/software/  [root@fastdfs software]# ll  总用量 1248  -rw-r--r--. 1 root root  17510 4月  11 03:28 fastdfs-nginx-module_v1.16.tar.gz  -rw-r--r--. 1 root root 345400 4月  11 03:28 FastDFS_v5.05.tar.gz  -rw-r--r--. 1 root root 102378 4月  11 03:28 libfastcommon-master.zip  -rw-r--r--. 1 root root 804164 4月  11 03:29 nginx-1.6.2.tar.gz  [root@fastdfs software]# tar -zxvf FastDFS_v5.05.tar.gz -C /usr/local/fast/  </code></pre><p>2、编译安装</p><pre><code>[html] view plain copy[root@fastdfs software]# cd /usr/local/fast/FastDFS/  [root@fastdfs FastDFS]# ./make.sh  [root@fastdfs FastDFS]# ./make.sh install    安装完后，服务脚本位置如下[html] view plain copy[root@fastdfs FastDFS]# cd /etc/init.d/ &amp;&amp; ls | grep fdfs  fdfs_storaged  fdfs_trackerd  [root@fastdfs init.d]#     配置文件位置如下：[html] view plain copy[root@fastdfs init.d]# cd /etc/fdfs/  [root@fastdfs fdfs]# ll  总用量 20  -rw-r--r--. 1 root root 1461 4月  11 04:10 client.conf.sample  -rw-r--r--. 1 root root 7829 4月  11 04:10 storage.conf.sample  -rw-r--r--. 1 root root 7102 4月  11 04:10 tracker.conf.sample  [root@fastdfs fdfs]#      FastDFS一系列执行脚本如下，可以看到有上传文件脚本、下载文件脚本等等。[html] view plain copy[root@fastdfs fdfs]# cd /usr/bin/ &amp;&amp; ls | grep fdfs  fdfs_appender_test  fdfs_appender_test1  fdfs_append_file  fdfs_crc32  fdfs_delete_file  fdfs_download_file  fdfs_file_info  fdfs_monitor  fdfs_storaged  fdfs_test  fdfs_test1  fdfs_trackerd  fdfs_upload_appender  fdfs_upload_file  [root@fastdfs bin]#  </code></pre><p>3、因为FastDFS服务脚本设置的bin目录为/usr/local/bin/下,但是实际我们安装在了/u sr/bin/下面。所以我们需要修改FastDFS配置文件中的路径，也就是需要修改两个配置文件</p><p>使用命令vim /etc/init.d/fdfs_storaged进入编辑模式，然后直接输入”:”，光标会定位到最后一行，在”:”后输入”%s+/usr/local/bin+/usr/bin”，如下图所示。输入完之后回车，会提示修改了7处。为了确保所有的/usr/local/bin都被替换了，我们可以再打开文件确认一下。</p><p><img src="http://p6lpbrjv6.bkt.clouddn.com/1.jpg" alt=""></p><p>接着修改第二个配置文件，我们使用命令vim /etc/init.d/fdfs_trackerd进入编辑模式，接着按照上面那样输入”:%s+/usr/local/bin+/usr/bin “并按回车，同样会提醒我们修改了7处。</p><p><img src="http://p6lpbrjv6.bkt.clouddn.com/2.png" alt=""></p><h2 id="第十步：配置跟踪器"><a href="#第十步：配置跟踪器" class="headerlink" title="第十步：配置跟踪器"></a>第十步：配置跟踪器</h2><pre><code> 1、进入到/etc/fdfs目录并且复制一份tracker.conf.sample并命名为tracker.conf，如下所示。[html] view plain copy[root@fastdfs bin]# cd /etc/fdfs/  [root@fastdfs fdfs]# ll  总用量 20  -rw-r--r--. 1 root root 1461 4月  11 04:10 client.conf.sample  -rw-r--r--. 1 root root 7829 4月  11 04:10 storage.conf.sample  -rw-r--r--. 1 root root 7102 4月  11 04:10 tracker.conf.sample  [root@fastdfs fdfs]# cp tracker.conf.sample tracker.conf  [root@fastdfs fdfs]#   </code></pre><p>2、使用命令vim /etc/fdfs/tracker.conf进入编辑模式，然后修改base_path的值为/fastdfs/tracker，如下图所示。</p><p><img src="http://p6lpbrjv6.bkt.clouddn.com/3.png" alt=""></p><p>3、我们在上图配置文件中配置的/fastdfs/tracker目前是不存在的，因此我们需要创建一下该目录</p><pre><code>[html] view plain copy[root@fastdfs fdfs]# mkdir -p /fastdfs/tracker  [root@fastdfs fdfs]#   </code></pre><p>4、配置防火墙，放开tracker使用的端口22122，使用命令vim /etc/sysconfig/iptables进入编辑模式，添加一行内容-A INPUT -m state –state NEW -m tcp -p tcp –dport 22122 -j ACCEPT，如下图所示。</p><p><img src="http://p6lpbrjv6.bkt.clouddn.com/4.png" alt=""></p><p>5、重启防火墙</p><pre><code>[html] view plain copy[root@fastdfs fdfs]# service iptables restart  iptables：将链设置为政策 ACCEPT：filter                    [确定]  iptables：清除防火墙规则：                                 [确定]  iptables：正在卸载模块：                                   [确定]  iptables：应用防火墙规则：                                 [确定]  [root@fastdfs fdfs]#   </code></pre><p>6、在启动tracker之前，/fastdfs/tracker目录下是没有任何文件的，如下所示</p><pre><code>[html] view plain copy[root@fastdfs tracker]# cd /fastdfs/tracker/ &amp;&amp; ll  总用量 0  [root@fastdfs tracker]#  </code></pre><p>启动tracker，启动完之后，可以看到这个目录下多了两个目录data和logs。如下所示。</p><pre><code>[html] view plain copy[root@fastdfs tracker]# /etc/init.d/fdfs_trackerd start   Starting FastDFS tracker server:   [root@fastdfs tracker]# cd /fastdfs/tracker/ &amp;&amp; ll  总用量 8  drwxr-xr-x. 2 root root 4096 4月  11 05:01 data  drwxr-xr-x. 2 root root 4096 4月  11 05:01 logs  [root@fastdfs tracker]#   </code></pre><p>7、设置开机自启动，在rc.local文件中添加/etc/init.d/fdfs_trackerd start，如下所示。</p><pre><code>[html] view plain copy[root@fastdfs tracker]# vim /etc/rc.d/rc.local  #!/bin/sh  #  # This script will be executed *after* all the other init scripts.  # You can put your own initialization stuff in here if you don&apos;t  # want to do the full Sys V style init stuff.  touch /var/lock/subsys/local  /etc/init.d/fdfs_trackerd start</code></pre><h2 id="第十一步：配置FastDFS存储"><a href="#第十一步：配置FastDFS存储" class="headerlink" title="第十一步：配置FastDFS存储"></a>第十一步：配置FastDFS存储</h2><p>1、进入/etc/fdfs目录，复制一份storage.conf.sample文件并命名为storage.conf，如下所示。</p><pre><code>[html] view plain copy[root@fastdfs tracker]# cd /etc/fdfs/  [root@fastdfs fdfs]# ll  总用量 28  -rw-r--r--. 1 root root 1461 4月  11 04:10 client.conf.sample  -rw-r--r--. 1 root root 7829 4月  11 04:10 storage.conf.sample  -rw-r--r--. 1 root root 7098 4月  11 04:45 tracker.conf  -rw-r--r--. 1 root root 7102 4月  11 04:10 tracker.conf.sample  [root@fastdfs fdfs]# cp storage.conf.sample storage.conf  [root@fastdfs fdfs]# ll  总用量 36  -rw-r--r--. 1 root root 1461 4月  11 04:10 client.conf.sample  -rw-r--r--. 1 root root 7829 4月  11 05:07 storage.conf  -rw-r--r--. 1 root root 7829 4月  11 04:10 storage.conf.sample  -rw-r--r--. 1 root root 7098 4月  11 04:45 tracker.conf  -rw-r--r--. 1 root root 7102 4月  11 04:10 tracker.conf.sample  [root@fastdfs fdfs]#  </code></pre><p>2、修改storage.conf文件 ，我们使用命令vim /etc/fdfs/storage.conf进入编辑模式，对以下四项进行修改，192.168.156.13是我的虚拟机的IP，大家根据自己虚拟机的IP自行设置。(注意网上的那片文章没有加group_name和buff_size)</p><pre><code>[html] view plain copygroup_name=group1base_path=/fastdfs/storagestore_path0=/fastdfs/storagetracker_server=10.1.84.52:22122http.server_port=8888buff_size = 256KB </code></pre><p>3、创建存储目录，如下所示。</p><pre><code>[html] view plain copy[root@fastdfs fdfs]# mkdir -p /fastdfs/storage  [root@fastdfs fdfs]#   </code></pre><p>4、配置防火墙，允许外界访问storage的默认端口23000，如下所示。</p><pre><code>[html] view plain copy[root@fastdfs fdfs]# vim /etc/sysconfig/iptables  # Firewall configuration written by system-config-firewall  # Manual customization of this file is not recommended.  *filter  :INPUT ACCEPT [0:0]  :FORWARD ACCEPT [0:0]  :OUTPUT ACCEPT [0:0]  -A INPUT -m state --state ESTABLISHED,RELATED -j ACCEPT  -A INPUT -p icmp -j ACCEPT  -A INPUT -i lo -j ACCEPT  -A INPUT -m state --state NEW -m tcp -p tcp --dport 22 -j ACCEPT  -A INPUT -m state --state NEW -m tcp -p tcp --dport 22122 -j ACCEPT  -A INPUT -m state --state NEW -m tcp -p tcp --dport 23000 -j ACCEPT  -A INPUT -j REJECT --reject-with icmp-host-prohibited  -A FORWARD -j REJECT --reject-with icmp-host-prohibited  COMMIT  </code></pre><p>添加完之后，重启防火墙，如下所示。<br>    [html] view plain copy<br>    [root@fastdfs fdfs]# service iptables restart<br>    iptables：将链设置为政策 ACCEPT：filter                    [确定]<br>    iptables：清除防火墙规则：                                 [确定]<br>    iptables：正在卸载模块：                                   [确定]<br>    iptables：应用防火墙规则：                                 [确定]<br>    [root@fastdfs fdfs]#<br>5、在启动storage之前，/fastdbf/storage目录下是没有任何文件的</p><pre><code>[html] view plain copy[root@fastdfs fdfs]# cd /fastdfs/storage/ &amp;&amp; ll  总用量 0  [root@fastdfs storage]#   </code></pre><p>启动storage，启动后再看/fastdfs/storage目录，可以看到多了data和logs。</p><pre><code>[html] view plain copy[root@fastdfs storage]# /etc/init.d/fdfs_storaged start  Starting FastDFS storage server:   [root@fastdfs storage]# cd /fastdfs/storage/ &amp;&amp; ll  总用量 8  drwxr-xr-x. 68 root root 4096 4月  11 05:21 data  drwxr-xr-x.  2 root root 4096 4月  11 05:20 logs  [root@fastdfs storage]#  </code></pre><p>6、查看FastDFS tracker和storage 是否启动成功，当看到如下所示信息时说明都启动成功了。</p><pre><code>[html] view plain copy[root@fastdfs storage]# ps -ef | grep fdfs  root       2124      1  0 05:01 ?        00:00:00 /usr/bin/fdfs_trackerd /etc/fdfs/tracker.conf  root       2228      1  0 05:21 ?        00:00:00 /usr/bin/fdfs_storaged /etc/fdfs/storage.conf  root       2238   1360  0 05:22 pts/0    00:00:00 grep fdfs  [root@fastdfs storage]#  </code></pre><p>7、我们进入到 /fastdfs/storage/data/目录下，可以看到两级共256*256个目录，每级都是从00到FF，如下只是列出了第一级的目录，点进去每个目录都还有00到FF共256个目录。</p><pre><code>[html] view plain copy[root@fastdfs storage]# cd /fastdfs/storage/data/ &amp;&amp; ls  00  09  12  1B  24  2D  36  3F  48  51  5A  63  6C  75  7E  87  90  99  A2  AB  B4  BD  C6  CF  D8  E1  EA  F3  FC  01  0A  13  1C  25  2E  37  40  49  52  5B  64  6D  76  7F  88  91  9A  A3  AC  B5  BE  C7  D0  D9  E2  EB  F4  FD  02  0B  14  1D  26  2F  38  41  4A  53  5C  65  6E  77  80  89  92  9B  A4  AD  B6  BF  C8  D1  DA  E3  EC  F5  fdfs_storaged.pid  03  0C  15  1E  27  30  39  42  4B  54  5D  66  6F  78  81  8A  93  9C  A5  AE  B7  C0  C9  D2  DB  E4  ED  F6  FE  04  0D  16  1F  28  31  3A  43  4C  55  5E  67  70  79  82  8B  94  9D  A6  AF  B8  C1  CA  D3  DC  E5  EE  F7  FF  05  0E  17  20  29  32  3B  44  4D  56  5F  68  71  7A  83  8C  95  9E  A7  B0  B9  C2  CB  D4  DD  E6  EF  F8  storage_stat.dat  06  0F  18  21  2A  33  3C  45  4E  57  60  69  72  7B  84  8D  96  9F  A8  B1  BA  C3  CC  D5  DE  E7  F0  F9  sync  07  10  19  22  2B  34  3D  46  4F  58  61  6A  73  7C  85  8E  97  A0  A9  B2  BB  C4  CD  D6  DF  E8  F1  FA  08  11  1A  23  2C  35  3E  47  50  59  62  6B  74  7D  86  8F  98  A1  AA  B3  BC  C5  CE  D7  E0  E9  F2  FB  [root@fastdfs data]#   </code></pre><p>8、设置storage开机自启动，添加一行/etc/init.d/fdfs_storaged start，如下所示。</p><pre><code>[html] view plain copy[root@fastdfs data]# vim /etc/rc.local   #!/bin/sh  #  # This script will be executed *after* all the other init scripts.  # You can put your own initialization stuff in here if you don&apos;t  # want to do the full Sys V style init stuff.  touch /var/lock/subsys/local  /etc/init.d/fdfs_trackerd start  /etc/init.d/fdfs_storaged start  </code></pre><h2 id="第十二步：测试图片上传"><a href="#第十二步：测试图片上传" class="headerlink" title="第十二步：测试图片上传"></a>第十二步：测试图片上传</h2><p>1、进入到/etc/fdfs目录下并复制一份client.conf.sample并更名为client.conf，如下所示。</p><pre><code>[html] view plain copy[root@fastdfs data]# cd /etc/fdfs  [root@fastdfs fdfs]# ll  总用量 36  -rw-r--r--. 1 root root 1461 4月  11 04:10 client.conf.sample  -rw-r--r--. 1 root root 7820 4月  11 05:12 storage.conf  -rw-r--r--. 1 root root 7829 4月  11 04:10 storage.conf.sample  -rw-r--r--. 1 root root 7098 4月  11 04:45 tracker.conf  -rw-r--r--. 1 root root 7102 4月  11 04:10 tracker.conf.sample  [root@fastdfs fdfs]# cp client.conf.sample client.conf  [root@fastdfs fdfs]# ll  总用量 40  -rw-r--r--. 1 root root 1461 4月  11 05:40 client.conf  -rw-r--r--. 1 root root 1461 4月  11 04:10 client.conf.sample  -rw-r--r--. 1 root root 7820 4月  11 05:12 storage.conf  -rw-r--r--. 1 root root 7829 4月  11 04:10 storage.conf.sample  -rw-r--r--. 1 root root 7098 4月  11 04:45 tracker.conf  -rw-r--r--. 1 root root 7102 4月  11 04:10 tracker.conf.sample  [root@fastdfs fdfs]#   </code></pre><p>2、使用命令vim /etc/fdfs/client.conf进入编辑模式并修改如下两项内容，如下所示。</p><pre><code>[html] view plain copybase_path=/fastdfs/tracker  tracker_server=192.168.156.13:22122  </code></pre><p>3、我们找到命令的脚本位置，并且使用命令，进行文件的上传。</p><pre><code>[html] view plain copy[root@fastdfs bin]# cd /usr/bin/ &amp;&amp; ls | grep fdfs  fdfs_appender_test  fdfs_appender_test1  fdfs_append_file  fdfs_crc32  fdfs_delete_file  fdfs_download_file  fdfs_file_info  fdfs_monitor  fdfs_storaged  fdfs_test  fdfs_test1  fdfs_trackerd  fdfs_upload_appender  fdfs_upload_file  [root@fastdfs bin]#   </code></pre><p>下面使用fdfs_upload_file脚本进行文件上传操作，如下所示。可以看到已经上传成功了，返回的是图片的保存位置：group1/M00/00/00/wKicDVjr_ayAE4VVAAHk-VzqZ6w020.jpg</p><pre><code>[html] view plain copy[root@fastdfs bin]# /usr/bin/fdfs_upload_file /etc/fdfs/client.conf /usr/local/software/3.jpg  group1/M00/00/00/wKicDVjr_ayAE4VVAAHk-VzqZ6w020.jpg  [root@fastdfs bin]#  </code></pre><h2 id="第十三步：FastDFS与nginx相结合"><a href="#第十三步：FastDFS与nginx相结合" class="headerlink" title="第十三步：FastDFS与nginx相结合"></a>第十三步：FastDFS与nginx相结合</h2><p>1、先安装nginx，大家可以参考<a href="http://blog.csdn.net/u012453843/article/details/69396434" target="_blank" rel="noopener">http://blog.csdn.net/u012453843/article/details/69396434</a>这篇博客的第四步Nginx安装（我们已经安装过的vim、gcc等就不需要重复安装了）。</p><p>2、安装fastdfs-nginxmodule_v1.16.tar.gz（fast与nginx相结合的模块安装包）， 进入 /usr/local/software目录并解压，如下所示。</p><pre><code>[html] view plain copy[root@fastdfs nginx-1.6.2]# cd /usr/local/software/  [root@fastdfs software]# tar -zxvf fastdfs-nginx-module_v1.16.tar.gz -C /usr/local/fast/  fastdfs-nginx-module/  fastdfs-nginx-module/src/  fastdfs-nginx-module/src/ngx_http_fastdfs_module.c  fastdfs-nginx-module/src/mod_fastdfs.conf  fastdfs-nginx-module/src/config  fastdfs-nginx-module/src/common.h  fastdfs-nginx-module/src/common.c  fastdfs-nginx-module/INSTALL  fastdfs-nginx-module/HISTORY  [root@fastdfs software]#  </code></pre><p>3、进入到/usr/local/fast目录下可以看到解压的fastdfs-nginx-module目录，然后进入到fastdfs-nginx-module/src/目录下，可以看到config文件。</p><pre><code>[html] view plain copy[root@fastdfs software]# cd /usr/local/fast/  [root@fastdfs fast]# ll  总用量 12  drwxr-xr-x. 10 8980 users 4096 4月  11 04:10 FastDFS  drwxrwxr-x.  3  500   500 4096 5月   4 2014 fastdfs-nginx-module  drwxr-xr-x.  4 root root  4096 4月  11 03:30 libfastcommon-master  [root@fastdfs fast]# cd fastdfs-nginx-module/src/  [root@fastdfs src]# ll  总用量 76  -rw-rw-r--. 1 500 500 33207 8月  30 2013 common.c  -rw-rw-r--. 1 500 500  3479 1月   3 2012 common.h  -rw-rw-r--. 1 500 500   447 11月  4 2010 config  -rw-rw-r--. 1 500 500  3679 3月  30 2013 mod_fastdfs.conf  -rw-rw-r--. 1 500 500 28542 5月   4 2014 ngx_http_fastdfs_module.c  [root@fastdfs src]#   </code></pre><p>修改该conf文件，我们把文件的第四行配置中的/usr/local/include都改为/usr/include，共两处。</p><p><img src="http://p6lpbrjv6.bkt.clouddn.com/5.png" alt=""></p><p>4、fastdfs与nginx进行结合，由于我们刚才安装过nginx了，因此在/usr/local目录下已经生成了一个nginx目录了，如下图所示。</p><p><img src="http://p6lpbrjv6.bkt.clouddn.com/6.png" alt=""></p><p>为了将nginx与fastdfs相结合，我们先把这个nginx目录删除掉，如下图所示，可以看到已经没有nginx目录了。</p><p><img src="http://p6lpbrjv6.bkt.clouddn.com/7.png" alt=""></p><p> 进入到nginx-1.6.2/目录下并执行配置和编译安装，如下所示。</p><pre><code>[html] view plain copy[root@fastdfs local]# cd nginx-1.6.2/  [root@fastdfs nginx-1.6.2]# ./configure --add-module=/usr/local/fast/fastdfs-nginx-module/src/  [root@fastdfs nginx-1.6.2]# make &amp;&amp; make install  </code></pre><p>复制fastdfs-nginx-module中的配置文件，到/etc/fdfs目录中，如下所示。</p><pre><code>[html] view plain copy[root@fastdfs fdfs]# cd /usr/local/fast/fastdfs-nginx-module/src/  [root@fastdfs src]# ll  总用量 76  -rw-rw-r--. 1 500 500 33207 8月  30 2013 common.c  -rw-rw-r--. 1 500 500  3479 1月   3 2012 common.h  -rw-rw-r--. 1 500 500   435 4月  11 06:09 config  -rw-rw-r--. 1 500 500  3679 3月  30 2013 mod_fastdfs.conf  -rw-rw-r--. 1 500 500 28542 5月   4 2014 ngx_http_fastdfs_module.c  [root@fastdfs src]# cp /usr/local/fast/fastdfs-nginx-module/src/mod_fastdfs.conf /etc/fdfs/  [root@fastdfs src]#   </code></pre><p>我们到 /etc/fdfs/ 目录下，修改我们刚copy过来的mod_fastdfs.conf 文件，需要修改的项如下，其中第一项是超时时长，第三项是允许外界通过http方式访问资源。</p><pre><code>[html] view plain copyconnect_timeout=10  tracker_server=192.168.156.13:22122  url_have_group_name = true  store_path0=/fastdfs/storage  </code></pre><p>复制FastDFS里的2个文件，到/etc/fdfs目录中，如下所示。</p><pre><code>[html] view plain copy[root@fastdfs fdfs]# cd /usr/local/fast/FastDFS/conf/  [root@fastdfs conf]# ll  总用量 84  -rw-r--r--. 1 8980 users 23981 12月  2 2014 anti-steal.jpg  -rw-r--r--. 1 8980 users  1461 12月  2 2014 client.conf  -rw-r--r--. 1 8980 users   858 12月  2 2014 http.conf  -rw-r--r--. 1 8980 users 31172 12月  2 2014 mime.types  -rw-r--r--. 1 8980 users  7829 12月  2 2014 storage.conf  -rw-r--r--. 1 8980 users   105 12月  2 2014 storage_ids.conf  -rw-r--r--. 1 8980 users  7102 12月  2 2014 tracker.conf  [root@fastdfs conf]# cp http.conf mime.types /etc/fdfs/  [root@fastdfs conf]#   </code></pre><p>创建一个软连接，在/fastdfs/storage文件存储目录下创建软连接，将其链接到实际存放数据 的目录，如下所示。</p><pre><code>[html] view plain copy[root@fastdfs conf]# ln -s /fastdfs/storage/data/ /fastdfs/storage/data/M00  [root@fastdfs conf]#   </code></pre><p>进入到/usr/local/nginx/conf/目录下，修改nginx.conf文件，如下图所示。</p><p><img src="http://p6lpbrjv6.bkt.clouddn.com/8.png" alt=""></p><p>修改的内容如下图示</p><p><img src="http://p6lpbrjv6.bkt.clouddn.com/9.png" alt=""></p><p>可以直接复制下面的内容。</p><pre><code>[html] view plain copylisten       8888;  location ~/group([0-9])/M00 {       ngx_fastdfs_module;  }  </code></pre><p>设置nginx开机自启动，这样下次重启设备之后，tracker、storage、nginx都自动启动了，直接就可以使用服务，如下所示。</p><pre><code>[html] view plain copy[root@fastdfs ~]# vim /etc/rc.d/rc.local   #!/bin/sh  #  # This script will be executed *after* all the other init scripts.  # You can put your own initialization stuff in here if you don&apos;t  # want to do the full Sys V style init stuff.  touch /var/lock/subsys/local  /etc/init.d/fdfs_trackerd start  /etc/init.d/fdfs_storaged start  /usr/local/nginx/sbin/nginx  </code></pre><p>启动nginx，如下所示。</p><pre><code>[html] view plain copy[root@fastdfs conf]# /usr/local/nginx/sbin/nginx   ngx_http_fastdfs_set pid=6809  [root@fastdfs conf]#   </code></pre><p>5、在通过8888端口访问图片之前先配置下防火墙，允许外界访问8888端口，添加的一行是-A INPUT -m state –state NEW -m tcp -p tcp –dport 8888 -j ACCEPT，如下图所示。<br><img src="http://p6lpbrjv6.bkt.clouddn.com/10.png" alt=""></p><p>配置完防火墙后重启防火墙</p><pre><code>[html] view plain copy[root@fastdfs conf]# service iptables restart  iptables：将链设置为政策 ACCEPT：filter                    [确定]  iptables：清除防火墙规则：                                 [确定]  iptables：正在卸载模块：                                   [确定]  iptables：应用防火墙规则：                                 [确定]  [root@fastdfs conf]#   </code></pre><p>6、现在我们便可以通过http的方式访问我们刚才上传的图片了（我们刚才上传图片返回的地址是group1/M00/00/00/wKicDVjr_ayAE4VVAAHk-VzqZ6w020.jpg）</p>]]></content>
      
      <categories>
          
          <category> java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> FastDFS </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>最近收集的前端素材,给大家分享一波~</title>
      <link href="/2018/03/25/%E6%9C%80%E8%BF%91%E6%94%B6%E9%9B%86%E7%9A%84%E5%89%8D%E7%AB%AF%E7%B4%A0%E6%9D%90-%E7%BB%99%E5%A4%A7%E5%AE%B6%E5%88%86%E4%BA%AB%E4%B8%80%E6%B3%A2/"/>
      <content type="html"><![CDATA[<script src="\assets\js\APlayer.min.js"> </script><p>最近发现一个很好的网站,给大家推广一下:</p><p><a href="http://www.17sucai.com/" title="http://www.17sucai.com/" target="_blank" rel="noopener">http://www.17sucai.com/</a></p><p>这个网站里面有很多分享的前端很好用的素材,只需要每天签到,连续签3天就可以获得一天时间的vip会员,能下载10个素材.<br><a id="more"></a><br>下面是我积累的一些素材,如果有需要可以到下面我分享的连接下载:</p><p><img src="http://p57l8frp4.bkt.clouddn.com/17%E7%B4%A0%E6%9D%901.jpg" alt=""></p><p><img src="http://p57l8frp4.bkt.clouddn.com/17%E7%B4%A0%E6%9D%902.jpg" alt=""></p><p>下载地址:</p><p>链接：<br><a href="https://pan.baidu.com/s/11lkX4ShzfQOxuo8os-Zo3w" target="_blank" rel="noopener">https://pan.baidu.com/s/11lkX4ShzfQOxuo8os-Zo3w</a></p><p>密码： 61ne</p>]]></content>
      
      <categories>
          
          <category> 前端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 素材 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>FreeMarker模板引擎</title>
      <link href="/2018/03/21/FreeMarker%E6%A8%A1%E6%9D%BF%E5%BC%95%E6%93%8E/"/>
      <content type="html"><![CDATA[<script src="\assets\js\APlayer.min.js"> </script><h1 id="什么是-Freemarker"><a href="#什么是-Freemarker" class="headerlink" title="什么是 Freemarker"></a>什么是 Freemarker</h1><p>FreeMarker 是一个用 Java 语言编写的模板引擎，它基于模板来生成文本输出。FreeMarker与 Web 容器无关，即在 Web 运行时，它并不知道 Servlet 或 HTTP。它不仅可以用作表现层的实现技术，而且还可以用于生成 XML，JSP 或 Java 等。<br><a id="more"></a><br><img src="http://p57l8frp4.bkt.clouddn.com/freemarker1.png" alt=""></p><h1 id="Freemarker入门小DEMO"><a href="#Freemarker入门小DEMO" class="headerlink" title="Freemarker入门小DEMO"></a>Freemarker入门小DEMO</h1><h2 id="工程引入依赖"><a href="#工程引入依赖" class="headerlink" title="工程引入依赖"></a>工程引入依赖</h2><pre><code>&lt;dependency&gt;        &lt;groupId&gt;org.freemarker&lt;/groupId&gt;        &lt;artifactId&gt;freemarker&lt;/artifactId&gt;        &lt;version&gt;2.3.23&lt;/version&gt;&lt;/dependency&gt;  </code></pre><h2 id="创建模板文件"><a href="#创建模板文件" class="headerlink" title="创建模板文件"></a>创建模板文件</h2><p>模板文件中四种元素</p><p>  1、文本，直接输出的部分</p><p>  2、注释，即&lt;#–…–&gt;格式不会输出</p><p>  3、插值（Interpolation）：即${..}部分,将使用数据模型中的部分替代输出</p><p>  4、FTL指令：FreeMarker指令，和HTML标记类似，名字前加#予以区分，不会输出。</p><p>我们现在就创建一个简单的创建模板文件test.ftl</p><pre><code>&lt;html&gt;&lt;head&gt;    &lt;meta charset=&quot;utf-8&quot;&gt;    &lt;title&gt;Freemarker入门小DEMO &lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;#--我只是一个注释，我不会有任何输出  --&gt;${name},你好。${message}&lt;/body&gt;&lt;/html&gt;</code></pre><p>这里有文本、插值和注释</p><h2 id="生成文件"><a href="#生成文件" class="headerlink" title="生成文件"></a>生成文件</h2><p>使用步骤：</p><p>第一步：创建一个 Configuration 对象，直接 new 一个对象。构造方法的参数就是 freemarker的版本号。</p><p>第二步：设置模板文件所在的路径。</p><p>第三步：设置模板文件使用的字符集。一般就是 utf-8.</p><p>第四步：加载一个模板，创建一个模板对象。</p><p>第五步：创建一个模板使用的数据集，可以是 pojo 也可以是 map。一般是 Map。</p><p>第六步：创建一个 Writer 对象，一般创建一 FileWriter 对象，指定生成的文件名。</p><p>第七步：调用模板对象的 process 方法输出文件。</p><p>第八步：关闭流</p><p>代码：<br>创建Test类 main方法如下：</p><pre><code> //1.创建配置类Configuration configuration=new Configuration(Configuration.getVersion());//2.设置模板所在的目录 configuration.setDirectoryForTemplateLoading(new File(&quot;D:/pinyougou_work/freemarkerDemo/src/main/resources/&quot;));//3.设置字符集configuration.setDefaultEncoding(&quot;utf-8&quot;);//4.加载模板Template template = configuration.getTemplate(&quot;test.ftl&quot;);//5.创建数据模型Map map=new HashMap();map.put(&quot;name&quot;, &quot;张三 &quot;);map.put(&quot;message&quot;, &quot;欢迎来到神奇的品优购世界！&quot;);//6.创建Writer对象Writer out =new FileWriter(new File(&quot;d:\\test.html&quot;));//7.输出template.process(map, out);//8.关闭Writer对象out.close();</code></pre><p>执行后，在D盘根目录即可看到生成的test.html ，打开看看</p><h1 id="FTL指令"><a href="#FTL指令" class="headerlink" title="FTL指令"></a>FTL指令</h1><h2 id="assign指令"><a href="#assign指令" class="headerlink" title="assign指令"></a>assign指令</h2><p>此指令用于在页面上定义一个变量 </p><p>（1）定义简单类型：</p><pre><code>&lt;#assign linkman=&quot;周先生&quot;&gt;联系人：${linkman}</code></pre><p>（2）定义对象类型：</p><pre><code>&lt;#assign info={&quot;mobile&quot;:&quot;13301231212&quot;,&apos;address&apos;:&apos;北京市昌平区王府街&apos;} &gt;电话：${info.mobile}  地址：${info.address}</code></pre><h2 id="include指令"><a href="#include指令" class="headerlink" title="include指令"></a>include指令</h2><p>此指令用于模板文件的嵌套</p><p>创建模板文件head.ftl</p><pre><code>&lt;h1&gt;信息网&lt;/h1&gt;</code></pre><p>我们修改test.ftl，在模板文件中使用include指令引入刚才我们建立的模板</p><pre><code>&lt;#include &quot;head.ftl&quot;&gt;</code></pre><h2 id="if指令"><a href="#if指令" class="headerlink" title="if指令"></a>if指令</h2><p>在模板文件上添加</p><pre><code>&lt;#if success=true&gt;  你已通过实名认证&lt;#else&gt;    你未通过实名认证&lt;/#if&gt;</code></pre><p>在代码中对str变量赋值</p><pre><code>map.put(&quot;success&quot;, true);</code></pre><p>在freemarker的判断中，可以使用= 也可以使用== </p><h2 id="list指令"><a href="#list指令" class="headerlink" title="list指令"></a>list指令</h2><p>（1）代码中对变量goodsList赋值</p><pre><code>List goodsList=new ArrayList();Map goods1=new HashMap();goods1.put(&quot;name&quot;, &quot;苹果&quot;);goods1.put(&quot;price&quot;, 5.8);Map goods2=new HashMap();goods2.put(&quot;name&quot;, &quot;香蕉&quot;);goods2.put(&quot;price&quot;, 2.5);Map goods3=new HashMap();goods3.put(&quot;name&quot;, &quot;橘子&quot;);goods3.put(&quot;price&quot;, 3.2);goodsList.add(goods1);goodsList.add(goods2);goodsList.add(goods3);map.put(&quot;goodsList&quot;, goodsList);</code></pre><p>（2）在模板文件上添加</p><pre><code>----商品价格表----&lt;br&gt;&lt;#list goodsList as goods&gt;  ${goods_index+1} 商品名称： ${goods.name} 价格：${goods.price}&lt;br&gt;&lt;/#list&gt;</code></pre><p>如果想在循环中得到索引，使用循环变量+_index就可以得到。</p><h2 id="内建函数"><a href="#内建函数" class="headerlink" title="内建函数"></a>内建函数</h2><p>内建函数语法格式： 变量+?+函数名称  </p><h3 id="获取集合大小"><a href="#获取集合大小" class="headerlink" title="获取集合大小"></a>获取集合大小</h3><p>我们使用size函数来实现，代码如下：</p><pre><code>共  ${goodsList?size}  条记录</code></pre><h3 id="转换JSON字符串为对象"><a href="#转换JSON字符串为对象" class="headerlink" title="转换JSON字符串为对象"></a>转换JSON字符串为对象</h3><p>我们通常需要将json字符串转换为对象，那如何处理呢？看代码</p><pre><code>&lt;#assign text=&quot;{&apos;bank&apos;:&apos;工商银行&apos;,&apos;account&apos;:&apos;10101920201920212&apos;}&quot; /&gt;&lt;#assign data=text?eval /&gt;开户行：${data.bank}  账号：${data.account}</code></pre><h3 id="日期格式化"><a href="#日期格式化" class="headerlink" title="日期格式化"></a>日期格式化</h3><p>代码中对变量赋值：</p><pre><code>dataModel.put(&quot;today&quot;, new Date());</code></pre><p>在模板文件中加入</p><pre><code>当前日期：${today?date} &lt;br&gt;当前时间：${today?time} &lt;br&gt;   当前日期+时间：${today?datetime} &lt;br&gt;        日期格式化：  ${today?string(&quot;yyyy年MM月&quot;)}</code></pre><h3 id="数字转换为字符串"><a href="#数字转换为字符串" class="headerlink" title="数字转换为字符串"></a>数字转换为字符串</h3><p>代码中对变量赋值：</p><pre><code>map.put(&quot;point&quot;, 102920122);累计积分：${point}</code></pre><p>我们会发现数字会以每三位一个分隔符显示，有些时候我们不需要这个分隔符，就需要将数字转换为字符串,使用内建函数c</p><p>累计积分：${point?c}</p><h2 id="空值处理运算符"><a href="#空值处理运算符" class="headerlink" title="空值处理运算符"></a>空值处理运算符</h2><p>如果你在模板中使用了变量但是在代码中没有对变量赋值，那么运行生成时会抛出异常。但是有些时候，有的变量确实是null，怎么解决这个问题呢？</p><h3 id="判断某变量是否存在-“-”"><a href="#判断某变量是否存在-“-”" class="headerlink" title="判断某变量是否存在:“??”"></a>判断某变量是否存在:“??”</h3><p>用法为:variable??,如果该变量存在,返回true,否则返回false </p><pre><code>&lt;#if aaa??&gt;  aaa变量存在&lt;#else&gt;  aaa变量不存在&lt;/#if&gt;</code></pre><h3 id="缺失变量默认值-“-”"><a href="#缺失变量默认值-“-”" class="headerlink" title="缺失变量默认值:“!”"></a>缺失变量默认值:“!”</h3><p>我们除了可以判断是否为空值，也可以使用!对null值做转换处理<br>在模板文件中加入</p><pre><code>${aaa!&apos;-&apos;}</code></pre><p>在代码中不对aaa赋值，也不会报错了 ，当aaa为null则返回！后边的内容-</p><h2 id="运算符"><a href="#运算符" class="headerlink" title="运算符"></a>运算符</h2><h3 id="算数运算符"><a href="#算数运算符" class="headerlink" title="算数运算符"></a>算数运算符</h3><p>FreeMarker表达式中完全支持算术运算,FreeMarker支持的算术运算符包括:+, - , * , / , %</p><h3 id="逻辑运算符"><a href="#逻辑运算符" class="headerlink" title="逻辑运算符"></a>逻辑运算符</h3><p>逻辑运算符有如下几个: </p><p>逻辑与:&amp;&amp; </p><p>逻辑或:|| </p><p>逻辑非:! </p><p>逻辑运算符只能作用于布尔值,否则将产生错误 </p><h3 id="比较运算符"><a href="#比较运算符" class="headerlink" title="比较运算符"></a>比较运算符</h3><p>表达式中支持的比较运算符有如下几个:</p><p>1  =或者==:判断两个值是否相等. </p><p>2  !=:判断两个值是否不等. </p><p>3  &gt;或者gt:判断左边值是否大于右边值 </p><p>4  &gt;=或者gte:判断左边值是否大于等于右边值 </p><p>5  &lt;或者lt:判断左边值是否小于右边值</p><p>6  &lt;=或者lte:判断左边值是否小于等于右边值 </p><p>注意:  =和!=可以用于字符串,数值和日期来比较是否相等,但=和!=两边必须是相同类型的值,否则会产生错误,而且FreeMarker是精确比较,”x”,”x “,”X”是不等的.其它的运行符可以作用于数字和日期,但不能作用于字符串,大部分的时候,<strong>使用gt等字母运算符代替&gt;</strong>会有更好的效果,因为 FreeMarker会把&gt;解释成FTL标签的结束字符,当然,<strong>也可以使用括号来避免这种情况,如:&lt;#if (x&gt;y)&gt;</strong></p>]]></content>
      
      <categories>
          
          <category> java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> FreeMarker </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Solr搜索平台</title>
      <link href="/2018/03/18/Solr%E6%90%9C%E7%B4%A2%E5%B9%B3%E5%8F%B0/"/>
      <content type="html"><![CDATA[<script src="\assets\js\APlayer.min.js"> </script><h1 id="Solr安装与配置"><a href="#Solr安装与配置" class="headerlink" title="Solr安装与配置"></a>Solr安装与配置</h1><h2 id="什么是Solr"><a href="#什么是Solr" class="headerlink" title="什么是Solr"></a>什么是Solr</h2><p>大多数搜索引擎应用都必须具有某种搜索功能，问题是搜索功能往往是巨大的资源消耗并且它们由于沉重的数据库加载而拖垮你的应用的性能。<br>这就是为什么转移负载到一个外部的搜索服务器是一个不错的主意，Apache Solr是一个流行的开源搜索服务器，它通过使用类似REST的HTTP API，这就确保你能从几乎任何编程语言来使用solr。<br><a id="more"></a><br>Solr是一个开源搜索平台，用于构建搜索应用程序。 它建立在Lucene(全文搜索引擎)之上。 Solr是企业级的，快速的和高度可扩展的。 使用Solr构建的应用程序非常复杂，可提供高性能。</p><p>为了在CNET网络的公司网站上添加搜索功能，Yonik Seely于2004年创建了Solr。并在2006年1月，它成为Apache软件基金会下的一个开源项目。并于2016年发布最新版本Solr 6.0，支持并行SQL查询的执行。</p><p>Solr可以和Hadoop一起使用。由于Hadoop处理大量数据，Solr帮助我们从这么大的源中找到所需的信息。不仅限于搜索，Solr也可以用于存储目的。像其他NoSQL数据库一样，它是一种非关系数据存储和处理技术。</p><p>总之，Solr是一个<strong>可扩展的，可部署，搜索/存储引擎，优化搜索大量以文本为中心的数据</strong>。</p><p>solr和Lucene的区别</p><pre><code>solr是基于Lucene的Lucene是一个全文检索工具包都是一些类库,只能java调用solr是个Apache开源顶级项目,一个服务平台,供不同的语言调用Lucene不支持数值范围的查询语法price:[100 To 200]solr支持数值范围的查询语法price:[100 To 200]</code></pre><h2 id="Solr安装"><a href="#Solr安装" class="headerlink" title="Solr安装"></a>Solr安装</h2><p>准备资料(包含solr、分词器、案例代码):</p><p>链接：<a href="https://pan.baidu.com/s/1JdTBbDyX9mWT2rWvatDdQg" target="_blank" rel="noopener">https://pan.baidu.com/s/1JdTBbDyX9mWT2rWvatDdQg</a> </p><p>密码：rcme</p><p>1：安装 Tomcat，解压缩即可。</p><p>2：解压 solr。</p><p>3：把 solr 下的dist目录solr-4.10.3.war部署到 Tomcat\webapps下(为了访问方便,去掉版本号)。</p><p>4：启动 Tomcat解压缩 war 包</p><p>5：把solr下example/lib/ext 目录下的所有的 jar 包，添加到 solr 的工程中(\WEB-INF\lib目录下)。</p><p>6：创建一个 solrhome 。solr 下的/example/solr 目录就是一个 solrhome。复制此目录到D盘改名为solrhome  </p><p>7：关联 solr 及 solrhome。需要修改 solr 工程的 web.xml 文件。(配置文件里面有只需解开注释然后修改成以下内容即可,如果只有war的话启动一下生成即可)</p><pre><code>&lt;env-entry&gt;   &lt;env-entry-name&gt;solr/home&lt;/env-entry-name&gt;   &lt;env-entry-value&gt;d:\solrhome&lt;/env-entry-value&gt;   &lt;env-entry-type&gt;java.lang.String&lt;/env-entry-type&gt;&lt;/env-entry&gt;</code></pre><p>8：启动 Tomcat(如果之前有了tomcat的话,这里必须要将端口号修改.然后访问自己配置的端口号即可)<br><a href="http://IP:8080/solr/" target="_blank" rel="noopener">http://IP:8080/solr/</a></p><h1 id="中文分析器IK-Analyzer"><a href="#中文分析器IK-Analyzer" class="headerlink" title="中文分析器IK Analyzer"></a>中文分析器IK Analyzer</h1><h2 id="IK-Analyzer简介"><a href="#IK-Analyzer简介" class="headerlink" title="IK Analyzer简介"></a>IK Analyzer简介</h2><p>IK Analyzer 是一个开源的，基亍 java 语言开发的轻量级的中文分词工具包。从 2006年 12 月推出 1.0 版开始， IKAnalyzer 已经推出了 4 个大版本。最初，它是以开源项目Luence 为应用主体的，结合词典分词和文法分析算法的中文分词组件。从 3.0 版本开始，IK 发展为面向 Java 的公用分词组件，独立亍 Lucene 项目，同时提供了对 Lucene 的默认优化实现。在 2012 版本中，IK 实现了简单的分词歧义排除算法，标志着 IK 分词器从单纯的词典分词向模拟语义分词衍化。</p><h2 id="IK-Analyzer配置"><a href="#IK-Analyzer配置" class="headerlink" title="IK Analyzer配置"></a>IK Analyzer配置</h2><p>步骤：<br>1、把IKAnalyzer2012FF_u1.jar 添加到 solr 工程的 lib 目录下</p><p>2、创建WEB-INF/classes文件夹  把扩展词典、停用词词典、配置文件放到 solr 工程的 WEB-INF/classes 目录下。</p><pre><code>(扩展词典、停用词词典、配置文件 ext_stopword.dic IKAnalyzer.cfg.xml  mydict.dic)</code></pre><p>3、修改 Solrhome 的collection1\conf\schema.xml 文件，配置一个 FieldType，使用 IKAnalyzer</p><pre><code>&lt;fieldType name=&quot;text_ik&quot; class=&quot;solr.TextField&quot;&gt;     &lt;analyzer class=&quot;org.wltea.analyzer.lucene.IKAnalyzer&quot;/&gt;&lt;/fieldType&gt;</code></pre><h3 id="配置域"><a href="#配置域" class="headerlink" title="配置域"></a>配置域</h3><p>域相当于数据库的表字段，用户存放数据，因此用户根据业务需要去定义相关的Field（域），一般来说，每一种对应着一种数据，用户对同一种数据进行相同的操作。</p><p>域的常用属性：</p><p>•    name：指定域的名称</p><p>•    type：指定域的类型</p><p>•    indexed：是否索引</p><p>•    stored：是否存储</p><p>•    required：是否必须</p><p>•    multiValued：是否多值</p><h4 id="域"><a href="#域" class="headerlink" title="域"></a>域</h4><p>修改solrhome的schema.xml 文件  设置业务系统 Field</p><pre><code>&lt;field name=&quot;item_goodsid&quot; type=&quot;long&quot; indexed=&quot;true&quot; stored=&quot;true&quot;/&gt;&lt;field name=&quot;item_title&quot; type=&quot;text_ik&quot; indexed=&quot;true&quot; stored=&quot;true&quot;/&gt;&lt;field name=&quot;item_price&quot; type=&quot;double&quot; indexed=&quot;true&quot; stored=&quot;true&quot;/&gt;&lt;field name=&quot;item_image&quot; type=&quot;string&quot; indexed=&quot;false&quot; stored=&quot;true&quot; /&gt;&lt;field name=&quot;item_category&quot; type=&quot;string&quot; indexed=&quot;true&quot; stored=&quot;true&quot; /&gt;&lt;field name=&quot;item_seller&quot; type=&quot;text_ik&quot; indexed=&quot;true&quot; stored=&quot;true&quot; /&gt;&lt;field name=&quot;item_brand&quot; type=&quot;string&quot; indexed=&quot;true&quot; stored=&quot;true&quot; /&gt;</code></pre><h4 id="复制域"><a href="#复制域" class="headerlink" title="复制域"></a>复制域</h4><p>复制域的作用在于将某一个Field中的数据复制到另一个域中(<strong>在电商项目的商品搜索中,设置这个复制域可以集成多个条件的查询,将其他域的数据集中到这一个item_keywords域中,方便查询</strong>)</p><pre><code>&lt;field name=&quot;item_keywords&quot; type=&quot;text_ik&quot; indexed=&quot;true&quot; stored=&quot;false&quot; multiValued=&quot;true&quot;/&gt;&lt;copyField source=&quot;item_title&quot; dest=&quot;item_keywords&quot;/&gt;&lt;copyField source=&quot;item_category&quot; dest=&quot;item_keywords&quot;/&gt;&lt;copyField source=&quot;item_seller&quot; dest=&quot;item_keywords&quot;/&gt;&lt;copyField source=&quot;item_brand&quot; dest=&quot;item_keywords&quot;/&gt;</code></pre><h4 id="动态域"><a href="#动态域" class="headerlink" title="动态域"></a>动态域</h4><p>当我们需要动态扩充字段时，我们需要使用动态域。<strong>对于电商项目，规格的值是不确定的，所以我们需要使用动态域来实现。</strong></p><p>配置：</p><pre><code>&lt;dynamicField name=&quot;item_spec_*&quot; type=&quot;string&quot; indexed=&quot;true&quot; stored=&quot;true&quot; /&gt;    </code></pre><h1 id="Spring-Data-Solr入门"><a href="#Spring-Data-Solr入门" class="headerlink" title="Spring Data Solr入门"></a>Spring Data Solr入门</h1><h2 id="Spring-Data-Solr简介"><a href="#Spring-Data-Solr简介" class="headerlink" title="Spring Data Solr简介"></a>Spring Data Solr简介</h2><p>虽然支持任何编程语言的能力具有很大的市场价值，你可能感兴趣的问题是：我如何将Solr的应用集成到Spring中？可以，Spring Data Solr就是为了方便Solr的开发所研制的一个框架，其底层是对SolrJ（官方API）的封装。</p><h2 id="Spring-Data-Solr入门小Demo"><a href="#Spring-Data-Solr入门小Demo" class="headerlink" title="Spring Data Solr入门小Demo"></a>Spring Data Solr入门小Demo</h2><p>(<strong>完整项目程序在上面的准备资料里面</strong>)</p><h3 id="搭建工程"><a href="#搭建工程" class="headerlink" title="搭建工程"></a>搭建工程</h3><p>（1）创建maven工程，pom.xml中引入依赖</p><pre><code> &lt;dependencies&gt;  &lt;dependency&gt;      &lt;groupId&gt;org.springframework.data&lt;/groupId&gt;      &lt;artifactId&gt;spring-data-solr&lt;/artifactId&gt;      &lt;version&gt;1.5.5.RELEASE&lt;/version&gt;  &lt;/dependency&gt;   &lt;dependency&gt;      &lt;groupId&gt;org.springframework&lt;/groupId&gt;      &lt;artifactId&gt;spring-test&lt;/artifactId&gt;      &lt;version&gt;4.2.4.RELEASE&lt;/version&gt;  &lt;/dependency&gt;  &lt;dependency&gt;      &lt;groupId&gt;junit&lt;/groupId&gt;      &lt;artifactId&gt;junit&lt;/artifactId&gt;      &lt;version&gt;4.9&lt;/version&gt;  &lt;/dependency&gt;&lt;/dependencies&gt;</code></pre><p>（2）在src/main/resources下创建  applicationContext-solr.xml</p><pre><code>&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot;    xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xmlns:p=&quot;http://www.springframework.org/schema/p&quot;    xmlns:context=&quot;http://www.springframework.org/schema/context&quot;    xmlns:solr=&quot;http://www.springframework.org/schema/data/solr&quot;    xsi:schemaLocation=&quot;http://www.springframework.org/schema/data/solr           http://www.springframework.org/schema/data/solr/spring-solr-1.0.xsd        http://www.springframework.org/schema/beans         http://www.springframework.org/schema/beans/spring-beans.xsd        http://www.springframework.org/schema/context         http://www.springframework.org/schema/context/spring-context.xsd&quot;&gt;    &lt;!-- solr服务器地址 --&gt;    &lt;solr:solr-server id=&quot;solrServer&quot; url=&quot;http://127.0.0.1:8080/solr&quot; /&gt;    &lt;!-- solr模板，使用solr模板可对索引库进行CRUD的操作 --&gt;    &lt;bean id=&quot;solrTemplate&quot; class=&quot;org.springframework.data.solr.core.SolrTemplate&quot;&gt;        &lt;constructor-arg ref=&quot;solrServer&quot; /&gt;    &lt;/bean&gt;&lt;/beans&gt;</code></pre><h3 id="Field-注解"><a href="#Field-注解" class="headerlink" title="@Field 注解"></a>@Field 注解</h3><p>创建 cn.lxm.pojo 包，创建TbItem实体类,属性使用@Field注解标识 。如果属性与配置文件定义的域名称不一致，需要在注解中指定域名称。</p><pre><code>public class TbItem implements Serializable{    @Field    private Long id;    @Field(&quot;item_title&quot;)    private String title;    @Field(&quot;item_price&quot;)private BigDecimal price;    @Field(&quot;item_image&quot;)    private String image;    @Field(&quot;item_goodsid&quot;)    private Long goodsId;    @Field(&quot;item_category&quot;)    private String category;    @Field(&quot;item_brand&quot;)    private String brand;    @Field(&quot;item_seller&quot;)private String seller;.......}</code></pre><h3 id="增加（修改）"><a href="#增加（修改）" class="headerlink" title="增加（修改）"></a>增加（修改）</h3><p>创建测试类TestTemplate.java</p><pre><code>@RunWith(SpringJUnit4ClassRunner.class)@ContextConfiguration(locations=&quot;classpath:applicationContext-solr.xml&quot;)public class TestTemplate {    @Autowired    private SolrTemplate solrTemplate;    @Test    public void testAdd(){        TbItem item=new TbItem();        item.setId(1L);        item.setBrand(&quot;华为&quot;);        item.setCategory(&quot;手机&quot;);        item.setGoodsId(1L);        item.setSeller(&quot;华为2号专卖店&quot;);        item.setTitle(&quot;华为Mate9&quot;);        item.setPrice(new BigDecimal(2000));                solrTemplate.saveBean(item);        solrTemplate.commit();    }}</code></pre><h3 id="按主键查询"><a href="#按主键查询" class="headerlink" title="按主键查询"></a>按主键查询</h3><pre><code>@Testpublic void testFindOne(){    TbItem item = solrTemplate.getById(1, TbItem.class);    System.out.println(item.getTitle());}</code></pre><h3 id="按主键删除"><a href="#按主键删除" class="headerlink" title="按主键删除"></a>按主键删除</h3><pre><code>@Testpublic void testDelete(){    solrTemplate.deleteById(&quot;1&quot;);    solrTemplate.commit();}</code></pre><h3 id="分页查询"><a href="#分页查询" class="headerlink" title="分页查询"></a>分页查询</h3><p>首先循环插入100条测试数据</p><pre><code>@Testpublic void testAddList(){    List&lt;TbItem&gt; list=new ArrayList();    for(int i=0;i&lt;100;i++){        TbItem item=new TbItem();        item.setId(i+1L);        item.setBrand(&quot;华为&quot;);        item.setCategory(&quot;手机&quot;);        item.setGoodsId(1L);        item.setSeller(&quot;华为2号专卖店&quot;);        item.setTitle(&quot;华为Mate&quot;+i);        item.setPrice(new BigDecimal(2000+i));            list.add(item);    }    solrTemplate.saveBeans(list);    solrTemplate.commit();}</code></pre><p>编写分页查询测试代码：</p><pre><code>@Testpublic void testPageQuery(){    Query query=new SimpleQuery(&quot;*:*&quot;);    query.setOffset(20);//开始索引（默认0）    query.setRows(20);//每页记录数(默认10)    ScoredPage&lt;TbItem&gt; page = solrTemplate.queryForPage(query, TbItem.class);    System.out.println(&quot;总记录数：&quot;+page.getTotalElements());    List&lt;TbItem&gt; list = page.getContent();    showList(list);}</code></pre><p>公共代码遍历循环显示查询结果:</p><pre><code>//显示记录数据private void showList(List&lt;TbItem&gt; list){            for(TbItem item:list){        System.out.println(item.getTitle() +item.getPrice());    }        }</code></pre><h3 id="条件查询"><a href="#条件查询" class="headerlink" title="条件查询"></a>条件查询</h3><p> Criteria 用于对条件的封装：</p><pre><code>@Testpublic void testPageQueryMutil(){        Query query=new SimpleQuery(&quot;*:*&quot;);    Criteria criteria=new Criteria(&quot;item_title&quot;).contains(&quot;2&quot;);    criteria=criteria.and(&quot;item_title&quot;).contains(&quot;5&quot;);            query.addCriteria(criteria);    //query.setOffset(20);//开始索引（默认0）    //query.setRows(20);//每页记录数(默认10)    ScoredPage&lt;TbItem&gt; page = solrTemplate.queryForPage(query, TbItem.class);    System.out.println(&quot;总记录数：&quot;+page.getTotalElements());    List&lt;TbItem&gt; list = page.getContent();    showList(list);}</code></pre><h3 id="删除全部数据"><a href="#删除全部数据" class="headerlink" title="删除全部数据"></a>删除全部数据</h3><pre><code>@Testpublic void testDeleteAll(){    Query query=new SimpleQuery(&quot;*:*&quot;);    solrTemplate.delete(query);    solrTemplate.commit();}</code></pre><h3 id="描述-设置高亮显示"><a href="#描述-设置高亮显示" class="headerlink" title="描述 设置高亮显示"></a>描述 设置高亮显示</h3><pre><code>@Testpublic void testHighLight(){    HighlightQuery query = new SimpleHighlightQuery();    //设置高亮的域    HighlightOptions highlightOptions = new HighlightOptions().addField(&quot;item_title&quot;);    //设置高亮显示的前缀    highlightOptions.setSimplePrefix(&quot;&lt;em style=&apos;color:red&apos;&quot;);    //设置高亮显示的后缀    highlightOptions.setSimplePostfix(&quot;&lt;/em&gt;&quot;);    //设置高亮选项    query.setHighlightOptions(highlightOptions);    //设置查询条件    Criteria criteria = new Criteria(&quot;item_title&quot;).contains(&quot;手机&quot;);    query.addCriteria(criteria);    HighlightPage&lt;TbItem&gt; page = solrTemplate.queryForHighlightPage(query, TbItem.class);    //循环高亮入口集合    for (HighlightEntry&lt;TbItem&gt; h : page.getHighlighted()) {        //获取原实体类        TbItem item = h.getEntity();        if(h.getHighlights().size()&gt;0 &amp;&amp; h.getHighlights().get(0).getSnipplets().size()&gt;0){            //设置高亮的结果            item.setTitle(h.getHighlights().get(0).getSnipplets().get(0));        }    }    System.out.println(&quot;总记录数：&quot;+page.getTotalElements());    List&lt;TbItem&gt; list = page.getContent();    showList(list);}</code></pre><h3 id="描述-分组查询"><a href="#描述-分组查询" class="headerlink" title="描述 分组查询"></a>描述 分组查询</h3><p>注意这里的测试数据的分组查询结果只有手机一项,可以自行添加索引库中item_category这一项的值</p><pre><code>@Testpublic void testFindForGroup(){    List&lt;String&gt; list=new ArrayList();    Query query=new SimpleQuery();    //按照关键字查询    Criteria criteria=new Criteria(&quot;item_keywords&quot;).is(&quot;三星&quot;);    query.addCriteria(criteria);    //设置分组选项    GroupOptions groupOptions=new GroupOptions().addGroupByField(&quot;item_category&quot;);    query.setGroupOptions(groupOptions);    //得到分组页    GroupPage&lt;TbItem&gt; page = solrTemplate.queryForGroupPage(query, TbItem.class);    //根据列得到分组结果集    GroupResult&lt;TbItem&gt; groupResult = page.getGroupResult(&quot;item_category&quot;);    //得到分组结果入口页    Page&lt;GroupEntry&lt;TbItem&gt;&gt; groupEntries = groupResult.getGroupEntries();    //得到分组入口集合    List&lt;GroupEntry&lt;TbItem&gt;&gt; content = groupEntries.getContent();    for(GroupEntry&lt;TbItem&gt; entry:content){        list.add(entry.getGroupValue());//将分组结果的名称封装到返回值中    }    for (String s : list) {        System.out.println(s);    }}</code></pre>]]></content>
      
      <categories>
          
          <category> 搜索解决方案 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Solr </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Spring-Data-Redis总结</title>
      <link href="/2018/03/15/Spring-Data-Redis%E6%80%BB%E7%BB%93/"/>
      <content type="html"><![CDATA[<script src="\assets\js\APlayer.min.js"> </script><h1 id="什么是Redis"><a href="#什么是Redis" class="headerlink" title="什么是Redis"></a>什么是Redis</h1><p>redis是一个非关系型Key-Value数据库,运行在内存中,由ANSI C编写。企业开发通常采用Redis来实现缓存。同类的产品还有memcache 、memcached 、MongoDB等。</p><a id="more"></a><h1 id="什么是Jedis"><a href="#什么是Jedis" class="headerlink" title="什么是Jedis"></a>什么是Jedis</h1><p>Jedis是Redis官方推出的一款面向Java的客户端，提供了很多接口供Java语言调用。可以在Redis官网下载，当然还有一些开源爱好者提供的客户端，如Jredis、SRP等等，推荐使用Jedis。</p><h1 id="Spring-Data-Redis"><a href="#Spring-Data-Redis" class="headerlink" title="Spring Data Redis"></a>Spring Data Redis</h1><p>Spring-data-redis是spring大家族的一部分，提供了在srping应用中通过简单的配置访问redis服务，对reids底层开发包(Jedis,  JRedis, and RJC)进行了高度封装，RedisTemplate提供了redis各种操作、异常处理及序列化，支持发布订阅，并对spring 3.1 cache进行了实现。<br>spring-data-redis针对jedis提供了如下功能：</p><p>1.连接池自动管理，提供了一个高度封装的“RedisTemplate”类</p><p>2.针对jedis客户端中大量api进行了归类封装,将同一类型操作封装为operation接口</p><pre><code>ValueOperations：简单K-V操作SetOperations：set类型数据操作ZSetOperations：zset类型数据操作HashOperations：针对map类型的数据操作ListOperations：针对list类型的数据操作</code></pre><h1 id="使用spring-data-redis"><a href="#使用spring-data-redis" class="headerlink" title="使用spring-data-redis"></a>使用spring-data-redis</h1><h2 id="准备工作"><a href="#准备工作" class="headerlink" title="准备工作:"></a>准备工作:</h2><h3 id="1-构建maven工程-步骤略-如果已有请忽略"><a href="#1-构建maven工程-步骤略-如果已有请忽略" class="headerlink" title="1.构建maven工程(步骤略,如果已有请忽略)"></a>1.构建maven工程(步骤略,如果已有请忽略)</h3><h3 id="2-引入spring相关依赖-引入junit依赖-步骤略-如果已有请忽略"><a href="#2-引入spring相关依赖-引入junit依赖-步骤略-如果已有请忽略" class="headerlink" title="2.引入spring相关依赖,引入junit依赖(步骤略,如果已有请忽略)"></a>2.引入spring相关依赖,引入junit依赖(步骤略,如果已有请忽略)</h3><h3 id="3-引入jedis和SpringDataRedis依赖"><a href="#3-引入jedis和SpringDataRedis依赖" class="headerlink" title="3.引入jedis和SpringDataRedis依赖"></a>3.引入jedis和SpringDataRedis依赖</h3><pre><code>&lt;!-- 缓存 --&gt;&lt;dependency&gt;           &lt;groupId&gt;redis.clients&lt;/groupId&gt;           &lt;artifactId&gt;jedis&lt;/artifactId&gt;           &lt;version&gt;2.8.1&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt;           &lt;groupId&gt;org.springframework.data&lt;/groupId&gt;           &lt;artifactId&gt;spring-data-redis&lt;/artifactId&gt;           &lt;version&gt;1.7.2.RELEASE&lt;/version&gt; &lt;/dependency&gt;</code></pre><h3 id="4-在src-main-resource下创建properties文件夹-建立redis-config-properties"><a href="#4-在src-main-resource下创建properties文件夹-建立redis-config-properties" class="headerlink" title="4.在src/main/resource下创建properties文件夹,建立redis-config.properties"></a>4.在src/main/resource下创建properties文件夹,建立redis-config.properties</h3><p>redis.host用来设置服务器地址</p><p>redis.port用来设置端口号</p><pre><code>redis.host=127.0.0.1 redis.port=6379 redis.pass= redis.database=0 redis.maxIdle=300 redis.maxWait=3000 redis.testOnBorrow=true</code></pre><h3 id="5-在src-main-resources下创建spring文件夹-，创建applicationContext-redis-xml"><a href="#5-在src-main-resources下创建spring文件夹-，创建applicationContext-redis-xml" class="headerlink" title="5.在src/main/resources下创建spring文件夹 ，创建applicationContext-redis.xml"></a>5.在src/main/resources下创建spring文件夹 ，创建applicationContext-redis.xml</h3><pre><code>&lt;context:property-placeholder location=&quot;classpath*:properties/*.properties&quot; /&gt;   &lt;!-- redis 相关配置 --&gt; &lt;bean id=&quot;poolConfig&quot; class=&quot;redis.clients.jedis.JedisPoolConfig&quot;&gt;   &lt;property name=&quot;maxIdle&quot; value=&quot;${redis.maxIdle}&quot; /&gt;    &lt;property name=&quot;maxWaitMillis&quot; value=&quot;${redis.maxWait}&quot; /&gt;   &lt;property name=&quot;testOnBorrow&quot; value=&quot;${redis.testOnBorrow}&quot; /&gt;  &lt;/bean&gt;  &lt;bean id=&quot;JedisConnectionFactory&quot; class=&quot;org.springframework.data.redis.connection.jedis.JedisConnectionFactory&quot;    p:host-name=&quot;${redis.host}&quot; p:port=&quot;${redis.port}&quot; p:password=&quot;${redis.pass}&quot; p:pool-config-ref=&quot;poolConfig&quot;/&gt;  &lt;bean id=&quot;redisTemplate&quot; class=&quot;org.springframework.data.redis.core.RedisTemplate&quot;&gt;   &lt;property name=&quot;connectionFactory&quot; ref=&quot;JedisConnectionFactory&quot; /&gt;  &lt;/bean&gt;</code></pre><p>maxIdle ：最大空闲数</p><p>maxWaitMillis:连接时的最大等待毫秒数</p><p>testOnBorrow：在提取一个jedis实例时，是否提前进行验证操作；如果为true，则得到的jedis实例均是可用的</p><h1 id="测试"><a href="#测试" class="headerlink" title="测试"></a>测试</h1><p>这里只写常用的hash和String两种类型的数据CRUD</p><h2 id="String"><a href="#String" class="headerlink" title="String:"></a>String:</h2><pre><code>@RunWith(SpringJUnit4ClassRunner.class)@ContextConfiguration(locations=&quot;classpath:spring/applicationContext-redis.xml&quot;)public class TestValue {    @Autowired    private RedisTemplate redisTemplate;        @Test    public void setValue(){        redisTemplate.boundValueOps(&quot;name&quot;).set(&quot;itcast&quot;);            }        @Test    public void getValue(){        String str = (String) redisTemplate.boundValueOps(&quot;name&quot;).get();        System.out.println(str);    }        @Test    public void deleteValue(){        redisTemplate.delete(&quot;name&quot;);;    }    }</code></pre><h2 id="Hash类型操作"><a href="#Hash类型操作" class="headerlink" title="Hash类型操作"></a>Hash类型操作</h2><p>创建测试类TestHash</p><p>（1）存入值</p><pre><code>@Testpublic void testSetValue(){    redisTemplate.boundHashOps(&quot;namehash&quot;).put(&quot;a&quot;, &quot;唐僧&quot;);    redisTemplate.boundHashOps(&quot;namehash&quot;).put(&quot;b&quot;, &quot;悟空&quot;);    redisTemplate.boundHashOps(&quot;namehash&quot;).put(&quot;c&quot;, &quot;八戒&quot;);    redisTemplate.boundHashOps(&quot;namehash&quot;).put(&quot;d&quot;, &quot;沙僧&quot;);}</code></pre><p>（2）提取所有的KEY</p><pre><code>@Testpublic void testGetKeys(){    Set s = redisTemplate.boundHashOps(&quot;namehash&quot;).keys();            System.out.println(s);        }</code></pre><p>运行结果：<br>[a, b, c, d]</p><p>（3）提取所有的值</p><pre><code>@Testpublic void testGetValues(){    List values = redisTemplate.boundHashOps(&quot;namehash&quot;).values();    System.out.println(values);        }</code></pre><p>运行结果：<br>[唐僧, 悟空, 八戒, 沙僧]</p><p>（4）根据KEY提取值</p><pre><code>@Testpublic void testGetValueByKey(){    Object object = redisTemplate.boundHashOps(&quot;namehash&quot;).get(&quot;b&quot;);    System.out.println(object);}</code></pre><p>运行结果：<br>悟空</p><p>（5）根据KEY移除值</p><pre><code>@Testpublic void testRemoveValueByKey(){    redisTemplate.boundHashOps(&quot;namehash&quot;).delete(&quot;c&quot;);}</code></pre><p>运行后再次查看集合内容：<br>[唐僧, 悟空, 沙僧]</p><h1 id="小节-缓存同步问题"><a href="#小节-缓存同步问题" class="headerlink" title="小节(缓存同步问题)"></a>小节(缓存同步问题)</h1><p> 在项目中使用redis会涉及到缓存同步的问题,解决这个问题是在进行缓存内容增删改之前要先删除缓存,然后再进行查询数据,这样在更改后的下次查询,在缓存中查不到数据就会去数据库中查询,然后再保存进缓存,这样就实现了缓存的同步.</p><p>在使用时是先要查询缓存,然后判断缓存是否存在所要查询的数据,如果存在的话就直接返回结果,如果没有查询到的话,就去数据库里面查询,然后将查询结果保存进缓存中.</p>]]></content>
      
      <categories>
          
          <category> java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> redis </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>数据库的事务</title>
      <link href="/2018/03/14/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%9A%84%E4%BA%8B%E5%8A%A1/"/>
      <content type="html"><![CDATA[<script src="\assets\js\APlayer.min.js"> </script><h1 id="【事务的概述】"><a href="#【事务的概述】" class="headerlink" title="【事务的概述】"></a>【事务的概述】</h1><h2 id="什么是事务"><a href="#什么是事务" class="headerlink" title="什么是事务:"></a>什么是事务:</h2><p>事务指的是逻辑上的一组操作,组成这组操作的各个逻辑单元要么一起成功,要么一起失败.<br><a id="more"></a><br>MYSQL的事务管理有两种方式:(MYSQL数据库事务默认是自动提交的.Oracle数据库事务默认是不自动提交.)</p><p>1.手动开启事务</p><ul><li>start transaction; – 开启事务</li><li>多条sql;</li><li>commit/rollback;</li></ul><p>2.设置一个自动提交参数</p><ul><li>show variables like ‘%commit%’; – 查看与commit相关参数.</li><li>set autocommit = 0; – 将autocommit参数设置为OFF.</li></ul><h1 id="【JDBC中的事务管理】"><a href="#【JDBC中的事务管理】" class="headerlink" title="【JDBC中的事务管理】"></a>【JDBC中的事务管理】</h1><h2 id="JDBC的事务的管理的API"><a href="#JDBC的事务的管理的API" class="headerlink" title="JDBC的事务的管理的API:"></a>JDBC的事务的管理的API:</h2><p>同一个事务 连接必须得是同一个对象(就是提交和设置的connection必须得是同一个),要加在业务层</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结:"></a>总结:</h2><h3 id="事务特性"><a href="#事务特性" class="headerlink" title="事务特性:"></a>事务特性:</h3><ul><li>原子性：强调事务的不可分割.(要么一起成功,要么一起失败)</li><li>一致性：强调的是事务的执行的前后，数据的完整性要保持一致.(转账前总和2000,转完后总和也得是2000)</li><li>隔离性：一个事务的执行不应该受到其他事务的干扰.</li><li>持久性：事务一旦结束(提交/回滚)数据就持久保持到了数据库.</li><li>如果不考虑事务的隔离性,引发一些安全性问题:</li></ul><p>一类是  读问题:</p><ul><li>不可重复读    :一个事务读到了另一个事务已经提交的update的数据,导致在当前的事务中多次查询结果不一致.</li><li>虚读/幻读    :一个事务读到另一个事务已经提交的insert的数据,导致在</li><li>当前的事务中多次的查询结果不一致.</li></ul><p>一类是  写问题:</p><p>引发两类丢失更新:</p><h3 id="解决引发的读问题"><a href="#解决引发的读问题" class="headerlink" title="解决引发的读问题:"></a>解决引发的读问题:</h3><p>设置事务的隔离级别:</p><ul><li>read uncommitted        :未提交读.脏读，不可重复读，虚读都可能发生.(安全性低,但是效率高)</li><li>read committed        :已提交读.避免脏读.但是不可重复读和虚读有可能发生.</li><li>repeatable read        :可重复读.避免脏读,不可重复读.但是虚读有可能发生.</li><li>serializable            :串行化的.避免脏读，不可重复读，虚读的发生.(安全性高,但是效率低)</li></ul><p><strong>*</strong> MYSQL隔离级别：repeatable read  Oracle隔离级别:read committed</p>]]></content>
      
      <categories>
          
          <category> 数据库 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 事务管理 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>使用FastDFS+angularJS+HTML5+springMVC进行文件上传</title>
      <link href="/2018/03/12/%E4%BD%BF%E7%94%A8FastDFS-angularJS-HTML5-springMVC%E8%BF%9B%E8%A1%8C%E6%96%87%E4%BB%B6%E4%B8%8A%E4%BC%A0/"/>
      <content type="html"><![CDATA[<script src="\assets\js\APlayer.min.js"> </script><h1 id="分布式文件服务器FastDFS"><a href="#分布式文件服务器FastDFS" class="headerlink" title="分布式文件服务器FastDFS"></a>分布式文件服务器FastDFS</h1><h2 id="什么是FastDFS"><a href="#什么是FastDFS" class="headerlink" title="什么是FastDFS"></a>什么是FastDFS</h2><p>FastDFS 是用 c 语言编写的一款开源的分布式文件系统。FastDFS 为互联网量身定制，充分考虑了冗余备份、负载均衡、线性扩容等机制，并注重高可用、高性能等指标，使用 FastDFS很容易搭建一套高性能的文件服务器集群提供文件上传、下载等服务。</p><a id="more"></a><p>FastDFS 架构包括 Tracker server 和 Storage server。客户端请求 Tracker server 进行文件上传、下载，通过 Tracker server 调度最终由 Storage server 完成文件上传和下载。</p><p>Tracker server 作用是负载均衡和调度，通过 Tracker server 在文件上传时可以根据一些策略找到 Storage server 提供文件上传服务。可以将 tracker 称为追踪服务器或调度服务器。</p><p>Storage server 作用是文件存储，客户端上传的文件最终存储在 Storage 服务器上，Storageserver 没有实现自己的文件系统而是利用操作系统 的文件系统来管理文件。可以将storage称为存储服务器。</p><p><img src="http://p57l8frp4.bkt.clouddn.com/FastDFS1.png" alt=""></p><p>服务端两个角色：</p><ul><li><p>Tracker：管理集群，tracker 也可以实现集群。每个 tracker 节点地位平等。收集 Storage 集群的状态。</p></li><li><p>Storage：实际保存文件   Storage 分为多个组，每个组之间保存的文件是不同的。每个组内部可以有多个成员，组成员内部保存的内容是一样的，组成员的地位是一致的，没有主从的概念。</p><h2 id="文件上传及下载的流程"><a href="#文件上传及下载的流程" class="headerlink" title="文件上传及下载的流程"></a>文件上传及下载的流程</h2><h3 id="文件上传流程"><a href="#文件上传流程" class="headerlink" title="文件上传流程"></a>文件上传流程</h3></li></ul><p><img src="http://p57l8frp4.bkt.clouddn.com/FastDFS2.png" alt=""></p><p>客户端上传文件后存储服务器将文件 ID 返回给客户端，此文件 ID 用于以后访问该文件的索引信息。文件索引信息包括：组名，虚拟磁盘路径，数据两级目录，文件名。</p><p><img src="http://p57l8frp4.bkt.clouddn.com/FastDFS3.png" alt=""></p><p>组名：文件上传后所在的 storage 组名称，在文件上传成功后有 storage 服务器返回，需要客户端自行保存。</p><ul><li><p>虚拟磁盘路径：storage 配置的虚拟路径，与磁盘选项 store_path*对应。如果配置了<br>store_path0 则是 M00，如果配置了 store_path1 则是 M01，以此类推。</p></li><li><p>数据两级目录：storage 服务器在每个虚拟磁盘路径下创建的两级目录，用于存储数据<br>文件。</p></li><li><p>文件名：与文件上传时不同。是由存储服务器根据特定信息生成，文件名包含：源存储<br>服务器 IP 地址、文件创建时间戳、文件大小、随机数和文件拓展名等信息。</p></li></ul><h3 id="文件下载流程"><a href="#文件下载流程" class="headerlink" title="文件下载流程"></a>文件下载流程</h3><p><img src="http://p57l8frp4.bkt.clouddn.com/FastDFS4.png" alt=""></p><h3 id="最简单的-FastDFS-架构"><a href="#最简单的-FastDFS-架构" class="headerlink" title="最简单的 FastDFS 架构"></a>最简单的 FastDFS 架构</h3><p><img src="http://p57l8frp4.bkt.clouddn.com/FastDFS5.png" alt=""></p><h3 id="FastDFS安装"><a href="#FastDFS安装" class="headerlink" title="FastDFS安装"></a>FastDFS安装</h3><p>请参考一下博客:</p><p><a href="https://www.cnblogs.com/fishbay/archive/2017/09/24/7586772.html" target="_blank" rel="noopener">https://www.cnblogs.com/fishbay/archive/2017/09/24/7586772.html</a></p><p><a href="http://blog.csdn.net/XingJames/article/details/52759876" target="_blank" rel="noopener">http://blog.csdn.net/XingJames/article/details/52759876</a></p><p><a href="https://www.cnblogs.com/jym-sunshine/p/6397470.html" target="_blank" rel="noopener">FastDFS安装全过程记录</a></p><h2 id="代码案例"><a href="#代码案例" class="headerlink" title="代码案例"></a>代码案例</h2><h3 id="依赖的jar包"><a href="#依赖的jar包" class="headerlink" title="依赖的jar包:"></a>依赖的jar包:</h3><pre><code>&lt;!-- 文件上传组件 --&gt;    &lt;dependency&gt;        &lt;groupId&gt;org.csource.fastdfs&lt;/groupId&gt;        &lt;artifactId&gt;fastdfs&lt;/artifactId&gt;    &lt;/dependency&gt;    &lt;dependency&gt;        &lt;groupId&gt;commons-fileupload&lt;/groupId&gt;        &lt;artifactId&gt;commons-fileupload&lt;/artifactId&gt;    &lt;/dependency&gt;</code></pre><h3 id="使用的工具类"><a href="#使用的工具类" class="headerlink" title="使用的工具类:"></a>使用的工具类:</h3><pre><code>package util;import org.csource.common.NameValuePair;import org.csource.fastdfs.ClientGlobal;import org.csource.fastdfs.StorageClient1;import org.csource.fastdfs.StorageServer;import org.csource.fastdfs.TrackerClient;import org.csource.fastdfs.TrackerServer;public class FastDFSClient {    private TrackerClient trackerClient = null;    private TrackerServer trackerServer = null;    private StorageServer storageServer = null;    private StorageClient1 storageClient = null;    public FastDFSClient(String conf) throws Exception {        if (conf.contains(&quot;classpath:&quot;)) {            conf = conf.replace(&quot;classpath:&quot;, this.getClass().getResource(&quot;/&quot;).getPath());        }        ClientGlobal.init(conf);        trackerClient = new TrackerClient();        trackerServer = trackerClient.getConnection();        storageServer = null;        storageClient = new StorageClient1(trackerServer, storageServer);    }    /**     * 上传文件方法     * &lt;p&gt;Title: uploadFile&lt;/p&gt;     * &lt;p&gt;Description: &lt;/p&gt;     * @param fileName 文件全路径     * @param extName 文件扩展名，不包含（.）     * @param metas 文件扩展信息     * @return     * @throws Exception     */    public String uploadFile(String fileName, String extName, NameValuePair[] metas) throws Exception {        String result = storageClient.upload_file1(fileName, extName, metas);        return result;    }    public String uploadFile(String fileName) throws Exception {        return uploadFile(fileName, null, null);    }    public String uploadFile(String fileName, String extName) throws Exception {        return uploadFile(fileName, extName, null);    }    /**     * 上传文件方法     * &lt;p&gt;Title: uploadFile&lt;/p&gt;     * &lt;p&gt;Description: &lt;/p&gt;     * @param fileContent 文件的内容，字节数组     * @param extName 文件扩展名     * @param metas 文件扩展信息     * @return     * @throws Exception     */    public String uploadFile(byte[] fileContent, String extName, NameValuePair[] metas) throws Exception {        String result = storageClient.upload_file1(fileContent, extName, metas);        return result;    }    public String uploadFile(byte[] fileContent) throws Exception {        return uploadFile(fileContent, null, null);    }    public String uploadFile(byte[] fileContent, String extName) throws Exception {        return uploadFile(fileContent, extName, null);    }}</code></pre><h3 id="config下的配置文件-fdfs-client-conf"><a href="#config下的配置文件-fdfs-client-conf" class="headerlink" title="config下的配置文件(fdfs_client.conf):"></a>config下的配置文件(fdfs_client.conf):</h3><p>注意修改</p><p>tracker_server=192.168.25.133:22122为tracker服务器地址</p><pre><code># connect timeout in seconds# default value is 30sconnect_timeout=30# network timeout in seconds# default value is 30snetwork_timeout=60# the base path to store log filesbase_path=/home/fastdfs# tracker_server can ocur more than once, and tracker_server format is#  &quot;host:port&quot;, host can be hostname or ip addresstracker_server=192.168.25.133:22122#standard log level as syslog, case insensitive, value list:### emerg for emergency### alert### crit for critical### error### warn for warning### notice### info### debuglog_level=info# if use connection pool# default value is false# since V4.05use_connection_pool = false# connections whose the idle time exceeds this time will be closed# unit: second# default value is 3600# since V4.05connection_pool_max_idle_time = 3600# if load FastDFS parameters from tracker server# since V4.05# default value is falseload_fdfs_parameters_from_tracker=false# if use storage ID instead of IP address# same as tracker.conf# valid only when load_fdfs_parameters_from_tracker is false# default value is false# since V4.05use_storage_id = false# specify storage ids filename, can use relative or absolute path# same as tracker.conf# valid only when load_fdfs_parameters_from_tracker is false# since V4.05storage_ids_filename = storage_ids.conf#HTTP settingshttp.tracker_server_port=80#use &quot;#include&quot; directive to include HTTP other settiongs##include http.conf</code></pre><h3 id="springmvc-xml中添加配置"><a href="#springmvc-xml中添加配置" class="headerlink" title="springmvc.xml中添加配置"></a>springmvc.xml中添加配置</h3><pre><code>&lt;!-- 配置多媒体解析器 --&gt;&lt;bean id=&quot;multipartResolver&quot; class=&quot;org.springframework.web.multipart.commons.CommonsMultipartResolver&quot;&gt;    &lt;property name=&quot;defaultEncoding&quot; value=&quot;UTF-8&quot;&gt;&lt;/property&gt;    &lt;!-- 设定文件上传的最大值5MB，5*1024*1024 --&gt;    &lt;property name=&quot;maxUploadSize&quot; value=&quot;5242880&quot;&gt;&lt;/property&gt;&lt;/bean&gt;</code></pre><h3 id="controller控制层代码"><a href="#controller控制层代码" class="headerlink" title="controller控制层代码:"></a>controller控制层代码:</h3><pre><code>/** * 文件上传Controller * @author Administrator * */@RestControllerpublic class UploadController {@RequestMapping(&quot;/upload&quot;)public Result upload( MultipartFile file){                    //1、取文件的扩展名    String originalFilename = file.getOriginalFilename();    String extName = originalFilename.substring(originalFilename.lastIndexOf(&quot;.&quot;) + 1);    try {    //2、创建一个 FastDFS 的客户端            FastDFSClient fastDFSClient      = new FastDFSClient(&quot;classpath:config/fdfs_client.conf&quot;);            //3、执行上传处理            String path = fastDFSClient.uploadFile(file.getBytes(), extName);            //4、拼接返回的 url 和 ip 地址，拼装成完整的 url            String url = &quot;文件服务器地址&quot; + path;                        return new Result(true,url);                    } catch (Exception e) {            e.printStackTrace();            return new Result(false, &quot;上传失败&quot;);        }            }    }</code></pre><h3 id="前端Service-js代码"><a href="#前端Service-js代码" class="headerlink" title="前端Service.js代码"></a>前端Service.js代码</h3><pre><code>//文件上传服务层app.service(&quot;uploadService&quot;,function($http){    this.uploadFile=function(){        var formData=new FormData();        formData.append(&quot;file&quot;,file.files[0]);           return $http({            method:&apos;POST&apos;,            url:&quot;../upload.do&quot;,            data: formData,            headers: {&apos;Content-Type&apos;:undefined},            transformRequest: angular.identity        });            }    });</code></pre><p>anjularjs对于post和get请求默认的Content-Type header 是application/json。通过设置‘Content-Type’: undefined，这样浏览器会帮我们把Content-Type 设置为 multipart/form-data.</p><p>通过设置 transformRequest: angular.identity ，anjularjs transformRequest function 将序列化我们的formdata object.</p><h3 id="前端controller-js代码"><a href="#前端controller-js代码" class="headerlink" title="前端controller.js代码"></a>前端controller.js代码</h3><pre><code>app.controller(&apos;myController&apos; ,function($scope,$controller,goodsService,itemCatService,uploadService){/** * 上传图片 */$scope.uploadFile=function(){          uploadService.uploadFile().success(function(response) {                    if(response.success){//如果上传成功，取出url            $scope.image_entity.url=response.message;//设置文件地址        }else{            alert(response.message);        }    }).error(function() {                        alert(&quot;上传发生错误&quot;);    });        }; }</code></pre><h3 id="页面显示"><a href="#页面显示" class="headerlink" title="页面显示"></a>页面显示</h3><pre><code>&lt;div class=&quot;modal-body&quot;&gt;                    &lt;table class=&quot;table table-bordered table-striped&quot;&gt;              &lt;tr&gt;                  &lt;td&gt;图片&lt;/td&gt;                  &lt;td&gt;                    &lt;table&gt;                        &lt;tr&gt;                            &lt;td&gt;                            &lt;input type=&quot;file&quot; id=&quot;file&quot; /&gt;                                                                &lt;button class=&quot;btn btn-primary&quot; type=&quot;button&quot; ng-click=&quot;uploadFile()&quot;&gt;                                       上传                                &lt;/button&gt;                                &lt;/td&gt;                            &lt;td&gt;                                &lt;img  src=&quot;{{image_entity.url}}&quot; width=&quot;200px&quot; height=&quot;200px&quot;&gt;                            &lt;/td&gt;                        &lt;/tr&gt;                                            &lt;/table&gt;                  &lt;/td&gt;              &lt;/tr&gt;                           &lt;/table&gt;                &lt;/div&gt;</code></pre>]]></content>
      
      <categories>
          
          <category> 前端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> FastDFS </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>基于angularJS的多选框select2</title>
      <link href="/2018/03/09/%E5%9F%BA%E4%BA%8EangularJS%E7%9A%84%E5%A4%9A%E9%80%89%E6%A1%86select2/"/>
      <content type="html"><![CDATA[<script src="\assets\js\APlayer.min.js"> </script><h1 id="基于angularJS框架下的select2插件的使用"><a href="#基于angularJS框架下的select2插件的使用" class="headerlink" title="基于angularJS框架下的select2插件的使用"></a>基于angularJS框架下的select2插件的使用</h1><a id="more"></a><p><img src="http://p57l8frp4.bkt.clouddn.com/select2.jpg" alt=""></p><h2 id="使用步骤"><a href="#使用步骤" class="headerlink" title="使用步骤:"></a>使用步骤:</h2><h3 id="引入JS文件"><a href="#引入JS文件" class="headerlink" title="引入JS文件"></a>引入JS文件</h3><pre><code>&lt;link rel=&quot;stylesheet&quot; href=&quot;bootstrap/css/bootstrap.min.css&quot;&gt;&lt;script src=&quot;jQuery/jquery-2.2.3.min.js&quot;&gt;&lt;/script&gt;&lt;script src=&quot;bootstrap/js/bootstrap.min.js&quot;&gt;&lt;/script&gt;&lt;!-- 引入angularJS,分页,controller,service --&gt;&lt;script type=&quot;text/javascript&quot; src=&quot;angularjs/angular.min.js&quot;&gt;  &lt;/script&gt;&lt;!-- 引入select2的插件 --&gt;&lt;!-- 这个要在base_pagination.js之后,因为用到了app --&gt;&lt;link rel=&quot;stylesheet&quot; href=&quot;select2/select2.css&quot; /&gt;&lt;link rel=&quot;stylesheet&quot; href=&quot;select2/select2-bootstrap.css&quot; /&gt;&lt;script src=&quot;select2/select2.min.js&quot; type=&quot;text/javascript&quot;&gt;&lt;/script&gt;&lt;script type=&quot;text/javascript&quot; src=&quot;select2/angular-select2.js&quot;&gt;&lt;/script&gt;</code></pre><h3 id="写input的属性"><a href="#写input的属性" class="headerlink" title="写input的属性"></a>写input的属性</h3><pre><code>&lt;input select2 select2-model=&quot;entity.brandIds&quot;  config=&quot;brandList&quot; multiple placeholder=&quot; 选择品牌（可多选） &quot; class=&quot;form-control&quot;&gt;</code></pre><p>multiple 表示可多选</p><p>Config用于配置数据来源</p><p>select2-model用于指定用户选择后提交的变量</p><p>select2 必须加上否则失效</p><h3 id="给定数据源"><a href="#给定数据源" class="headerlink" title="给定数据源"></a>给定数据源</h3><p><strong>注意这个要放置在select插件的前面,因为select2使用到了app</strong></p><pre><code>这里的数据格式默认是{{id:2,text:'华为'}}&lt;script type=&quot;text/javascript&quot;&gt;    var app = angular.module(&apos;app&apos;,[]);    app.controller(&apos;myController&apos;,function($scope){        //列表数据        $scope.brandList={data:[{id:1,text:&apos;联想&apos;},{id:2,text:&apos;华为&apos;},{id:3,text:&apos;小米&apos;}]};    });&lt;/script&gt;</code></pre><p>资源文件:</p><h3 id="简单多选demo"><a href="#简单多选demo" class="headerlink" title="简单多选demo"></a>简单多选demo</h3><p>链接：<a href="https://pan.baidu.com/s/12xz7kcmZGwcTjMH7MJhmDg" target="_blank" rel="noopener">https://pan.baidu.com/s/12xz7kcmZGwcTjMH7MJhmDg</a> </p><p>密码：0aq2</p><h3 id="完整说明文档"><a href="#完整说明文档" class="headerlink" title="完整说明文档"></a>完整说明文档</h3><p>链接：<a href="https://pan.baidu.com/s/1XSHqbbx3ikZRlkIFgXgMGQ" target="_blank" rel="noopener">https://pan.baidu.com/s/1XSHqbbx3ikZRlkIFgXgMGQ</a> </p><p>密码：66gc</p><h3 id="官网"><a href="#官网" class="headerlink" title="官网"></a>官网</h3><p><a href="https://select2.org/" target="_blank" rel="noopener">https://select2.org</a>/</p>]]></content>
      
      <categories>
          
          <category> 前端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> select2 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>使用Mybatis的PageHelper插件进行分页</title>
      <link href="/2018/03/07/%E4%BD%BF%E7%94%A8Mybatis%E7%9A%84PageHelper%E6%8F%92%E4%BB%B6%E8%BF%9B%E8%A1%8C%E5%88%86%E9%A1%B5/"/>
      <content type="html"><![CDATA[<script src="\assets\js\APlayer.min.js"> </script><h1 id="PageHelper插件进行分页"><a href="#PageHelper插件进行分页" class="headerlink" title="PageHelper插件进行分页"></a>PageHelper插件进行分页</h1><h2 id="实现效果"><a href="#实现效果" class="headerlink" title="实现效果"></a>实现效果</h2><a id="more"></a><p> <img src="http://p57l8frp4.bkt.clouddn.com/PageHelper.png" alt=""></p><p>##准备内容<br>本文是建立在以下框架之上:</p><ul><li>前端使用的是angularJS框架+BootStrap</li><li>后台是SpringMVC+Spring+Mybatis</li></ul><p>前期的搭建请看(<a href="https://github.com/pagehelper/Mybatis-PageHelper/blob/master/wikis/zh/HowToUse.md" title="官方文档" target="_blank" rel="noopener">官方文档</a>)</p><p>推荐博客:</p><p><a href="http://blog.csdn.net/maoyuanming0806/article/details/77720754" target="_blank" rel="noopener">http://blog.csdn.net/maoyuanming0806/article/details/77720754</a></p><p><a href="http://blog.csdn.net/FansUnion/article/details/40304187" target="_blank" rel="noopener">http://blog.csdn.net/FansUnion/article/details/40304187</a></p><h2 id="后端代码"><a href="#后端代码" class="headerlink" title="后端代码"></a>后端代码</h2><h3 id="分页结果封装实体"><a href="#分页结果封装实体" class="headerlink" title="分页结果封装实体"></a>分页结果封装实体</h3><p>创建类PageResult用于在controller中返回分页数据</p><pre><code>package entity;import java.util.List;/** * 分页结果封装对象 * @author Administrator * */public class PageResult implements Serializable{    private long total;//总记录数    private List rows;//当前页结果            public PageResult(long total, List rows) {        super();        this.total = total;        this.rows = rows;    }     //getter  and setter .....}</code></pre><h3 id="服务接口层"><a href="#服务接口层" class="headerlink" title="服务接口层"></a>服务接口层</h3><p>在service的接口BrandService.java 增加方法定义</p><pre><code>/** * 返回分页列表 * @return */public PageResult findPage(int pageNum,int pageSize);</code></pre><h3 id="服务实现层"><a href="#服务实现层" class="headerlink" title="服务实现层"></a>服务实现层</h3><p>service的实现类BrandServiceImpl.java中实现该方法</p><pre><code>@Overridepublic PageResult findPage(int pageNum, int pageSize) {    PageHelper.startPage(pageNum, pageSize);            Page&lt;TbBrand&gt; page=   (Page&lt;TbBrand&gt;) brandMapper.selectByExample(null);    return new PageResult(page.getTotal(), page.getResult());}</code></pre><p>PageHelper为MyBatis分页插件</p><h3 id="控制层"><a href="#控制层" class="headerlink" title="控制层"></a>控制层</h3><p>在控制层BrandController.java新增方法</p><pre><code>/** * 返回全部列表 * @return */@RequestMapping(&quot;/findPage&quot;)public PageResult  findPage(int page,int rows){                return brandService.findPage(page, rows);}</code></pre><h2 id="前端代码"><a href="#前端代码" class="headerlink" title="前端代码"></a>前端代码</h2><h3 id="HTML"><a href="#HTML" class="headerlink" title="HTML"></a>HTML</h3><p>在brand.html引入分页组件</p><pre><code>&lt;!-- 分页组件开始 --&gt;&lt;script src=&quot;../plugins/angularjs/pagination.js&quot;&gt;&lt;/script&gt;&lt;link rel=&quot;stylesheet&quot; href=&quot;../plugins/angularjs/pagination.css&quot;&gt;&lt;!-- 分页组件结束 --&gt;</code></pre><p>构建app模块时引入pagination模块</p><pre><code>var app=angular.module(&apos;pinyougou&apos;,[&apos;pagination&apos;]);</code></pre><p>页面的表格下放置分页组件</p><pre><code> &lt;!-- 分页 --&gt;&lt;tm-pagination conf=&quot;paginationConf&quot;&gt;&lt;/tm-pagination&gt;</code></pre><h3 id="JS代码"><a href="#JS代码" class="headerlink" title="JS代码"></a>JS代码</h3><pre><code>//重新加载列表 数据$scope.reloadList=function(){     //切换页码      $scope.findPage( $scope.paginationConf.currentPage, $scope.paginationConf.itemsPerPage);}//分页控件配置 $scope.paginationConf = {         currentPage: 1,         totalItems: 10,         itemsPerPage: 10,         perPageOptions: [10, 20, 30, 40, 50],         onChange: function(){                     $scope.reloadList();//重新加载         }}; //分页$scope.findPage=function(page,rows){        $http.get(&apos;../brand/findPage.do?page=&apos;+page+&apos;&amp;rows=&apos;+rows).success(            function(response){                $scope.list=response.rows;                    $scope.paginationConf.totalItems=response.total;//更新总记录数            }                );}</code></pre><p>paginationConf 变量各属性的意义：</p><ul><li><p>currentPage：当前页码</p></li><li><p>totalItems:总条数</p></li><li><p>itemsPerPage:</p></li><li><p>perPageOptions：页码选项</p></li><li><p>onChange：更改页面时触发事件</p></li></ul>]]></content>
      
      <categories>
          
          <category> SSM </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Mybatis </tag>
            
            <tag> PageHelper </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>AngularJS框架</title>
      <link href="/2018/03/07/AngularJS%E6%A1%86%E6%9E%B6/"/>
      <content type="html"><![CDATA[<script src="\assets\js\APlayer.min.js"> </script><h1 id="AngularJS简介"><a href="#AngularJS简介" class="headerlink" title="AngularJS简介"></a>AngularJS简介</h1><p><img src="http://p57l8frp4.bkt.clouddn.com/angularJS.png" alt=""></p><p>AngularJS  诞生于2009年，由Misko Hevery 等人创建，后为Google所收购。是一款优秀的前端JS框架，已经被用于Google的多款产品当中。AngularJS有着诸多特性，最为核心的是：MVC、模块化、自动化双向数据绑定、依赖注入等等。<br>  <a id="more"></a></p><h2 id="AngularJS四大特征"><a href="#AngularJS四大特征" class="headerlink" title="AngularJS四大特征"></a>AngularJS四大特征</h2><h3 id="MVC-模式"><a href="#MVC-模式" class="headerlink" title="MVC    模式"></a>MVC    模式</h3><p>Angular遵循软件工程的MVC模式,并鼓励展现，数据，和逻辑组件之间的松耦合.通过依赖注入（dependency injection），Angular为客户端的Web应用带来了传统服务端的服务，例如独立于视图的控制。 因此，后端减少了许多负担，产生了更轻的Web应用。<br> <img src="http://p57l8frp4.bkt.clouddn.com/angularJS1.png" alt=""></p><ul><li>Model:数据,其实就是angular变量($scope.XX);</li><li>View: 数据的呈现,Html+Directive(指令);</li><li>Controller:操作数据,就是function,数据的增删改查;</li></ul><h3 id="双向绑定"><a href="#双向绑定" class="headerlink" title="双向绑定"></a>双向绑定</h3><p>AngularJS是建立在这样的信念上的：即声明式编程应该用于构建用户界面以及编写软件构建，而指令式编程非常适合来表示业务逻辑。框架采用并扩展了传统HTML，通过双向的数据绑定来适应动态内容，双向的数据绑定允许模型和视图之间的自动同步。因此，AngularJS使得对DOM的操作不再重要并提升了可测试性。<br> <img src="http://p57l8frp4.bkt.clouddn.com/angularJS2.png" alt=""></p><h3 id="依赖注入"><a href="#依赖注入" class="headerlink" title="依赖注入"></a>依赖注入</h3><p>依赖注入(Dependency Injection,简称DI)是一种设计模式, 指某个对象依赖的其他对象无需手工创建，只需要“吼一嗓子”，则此对象在创建时，其依赖的对象由框架来自动创建并注入进来,其实就是最少知识法则;模块中所有的service和provider两类对象，都可以根据形参名称实现DI.</p><h3 id="模块化设计"><a href="#模块化设计" class="headerlink" title="模块化设计"></a>模块化设计</h3><p>高内聚低耦合法则</p><ul><li><p>官方提供的模块           ng、ngRoute、ngAnimate</p></li><li><p>用户自定义的模块     angular.module(‘模块名’,[ ])</p></li></ul><h2 id="入门小Demo"><a href="#入门小Demo" class="headerlink" title="入门小Demo"></a>入门小Demo</h2><h3 id="表达式"><a href="#表达式" class="headerlink" title="表达式"></a>表达式</h3><pre><code>&lt;html&gt;&lt;head&gt;    &lt;title&gt;入门小Demo-1&lt;/title&gt;    &lt;script src=&quot;angular.min.js&quot;&gt;&lt;/script&gt;&lt;/head&gt;&lt;body ng-app&gt;{{100+100}}&lt;/body&gt;&lt;/html&gt;</code></pre><p>执行结果如下：</p><p>表达式的写法是 表达式可以是变量或是运算式</p><ul><li>ng-app 指令 作用是告诉子元素一下的指令是归angularJs的,angularJs会识别的</li><li>ng-app 指令定义了 AngularJS 应用程序的 根元素。</li><li>ng-app 指令在网页加载完毕时会自动引导（自动初始化）应用程序。</li></ul><h3 id="双向绑定-1"><a href="#双向绑定-1" class="headerlink" title="双向绑定"></a>双向绑定</h3><pre><code>&lt;html&gt;&lt;head&gt;    &lt;title&gt;入门小Demo-1  双向绑定&lt;/title&gt;    &lt;script src=&quot;angular.min.js&quot;&gt;&lt;/script&gt;&lt;/head&gt;&lt;body ng-app&gt;请输入你的姓名：&lt;input ng-model=&quot;myname&quot;&gt;&lt;br&gt;{{myname}},你好&lt;/body&gt;&lt;/html&gt;</code></pre><p>运行效果如下：</p><p>ng-model 指令用于绑定变量,这样用户在文本框输入的内容会绑定到变量上，而表达式可以实时地输出变量。</p><h3 id="初始化指令"><a href="#初始化指令" class="headerlink" title="初始化指令"></a>初始化指令</h3><p>我们如果希望有些变量具有初始值，可以使用ng-init指令来对变量初始化</p><pre><code>&lt;html&gt;&lt;head&gt;    &lt;title&gt;入门小Demo-3  初始化&lt;/title&gt;    &lt;script src=&quot;angular.min.js&quot;&gt;&lt;/script&gt;&lt;/head&gt;&lt;body ng-app   ng-init=&quot;myname=&apos;陈大海&apos;&quot;&gt;请输入你的姓名：&lt;input ng-model=&quot;myname&quot;&gt;&lt;br&gt;{{myname}},你好&lt;/body&gt;&lt;/html&gt;</code></pre><h3 id="控制器"><a href="#控制器" class="headerlink" title="控制器"></a>控制器</h3><pre><code>&lt;html&gt;&lt;head&gt;    &lt;title&gt;入门小Demo-3  初始化&lt;/title&gt;    &lt;script src=&quot;angular.min.js&quot;&gt;&lt;/script&gt;    &lt;script&gt;        var app=angular.module(&apos;myApp&apos;,[]); //定义了一个叫myApp的模块        //定义控制器        app.controller(&apos;myController&apos;,function($scope){            $scope.add=function(){                return parseInt($scope.x)+parseInt($scope.y);            }        });    &lt;/script&gt;&lt;/head&gt;&lt;body ng-app=&quot;myApp&quot; ng-controller=&quot;myController&quot;&gt;x:&lt;input ng-model=&quot;x&quot; &gt;y:&lt;input ng-model=&quot;y&quot; &gt;运算结果：{{add()}}&lt;/body&gt;&lt;/html&gt;</code></pre><p>运行结果如下：</p><p>ng-controller用于指定所使用的控制器。</p><p>理解 $scope：</p><p>$scope 的使用贯穿整个 AngularJS App 应用,它与数据模型相关联,同时也是表达式执行的上下文.有了$scope 就在视图和控制器之间建立了一个通道,基于作用域视图在修改数据时会立刻更新 $scope,同样的$scope 发生改变时也会立刻重新渲染视图.</p><h3 id="事件指令"><a href="#事件指令" class="headerlink" title="事件指令"></a>事件指令</h3><pre><code>&lt;html&gt;&lt;head&gt;    &lt;title&gt;入门小Demo-5  事件指令&lt;/title&gt;    &lt;script src=&quot;angular.min.js&quot;&gt;&lt;/script&gt;        &lt;script&gt;        var app=angular.module(&apos;myApp&apos;,[]); //定义了一个叫myApp的模块        //定义控制器        app.controller(&apos;myController&apos;,function($scope){                        $scope.add=function(){                $scope.z= parseInt($scope.x)+parseInt($scope.y);            }                    });        &lt;/script&gt;&lt;/head&gt;&lt;body ng-app=&quot;myApp&quot; ng-controller=&quot;myController&quot;&gt;x:&lt;input ng-model=&quot;x&quot; &gt;y:&lt;input ng-model=&quot;y&quot; &gt;&lt;button ng-click=&quot;add()&quot;&gt;运算&lt;/button&gt;结果：{{z}}&lt;/body&gt;&lt;/html&gt;</code></pre><p>运行结果：</p><p>ng-click  是最常用的单击事件指令，再点击时触发控制器的某个方法</p><h3 id="循环数组"><a href="#循环数组" class="headerlink" title="循环数组"></a>循环数组</h3><pre><code>&lt;html&gt;&lt;head&gt;    &lt;title&gt;入门小Demo-6  循环数据&lt;/title&gt;    &lt;script src=&quot;angular.min.js&quot;&gt;&lt;/script&gt;    &lt;script&gt;        var app=angular.module(&apos;myApp&apos;,[]); //定义了一个叫myApp的模块        //定义控制器        app.controller(&apos;myController&apos;,function($scope){            $scope.list= [100,192,203,434 ];//定义数组        });    &lt;/script&gt;&lt;/head&gt;&lt;body ng-app=&quot;myApp&quot; ng-controller=&quot;myController&quot;&gt;&lt;table&gt;&lt;tr ng-repeat=&quot;x in list&quot;&gt;    &lt;td&gt;{{x}}&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/body&gt;&lt;/html&gt;</code></pre><p>这里的ng-repeat指令用于循环数组变量。<br>运行结果如下：</p><h3 id="循环对象数组"><a href="#循环对象数组" class="headerlink" title="循环对象数组"></a>循环对象数组</h3><pre><code>&lt;html&gt;&lt;head&gt;    &lt;title&gt;入门小Demo-7  循环对象数组&lt;/title&gt;    &lt;script src=&quot;angular.min.js&quot;&gt;&lt;/script&gt;        &lt;script&gt;        var app=angular.module(&apos;myApp&apos;,[]); //定义了一个叫myApp的模块        //定义控制器        app.controller(&apos;myController&apos;,function($scope){                    $scope.list= [                {name:&apos;张三&apos;,shuxue:100,yuwen:93},                {name:&apos;李四&apos;,shuxue:88,yuwen:87},                {name:&apos;王五&apos;,shuxue:77,yuwen:56}            ];//定义数组                    });        &lt;/script&gt;    &lt;/head&gt;&lt;body ng-app=&quot;myApp&quot; ng-controller=&quot;myController&quot;&gt;&lt;table&gt;&lt;tr&gt;    &lt;td&gt;姓名&lt;/td&gt;    &lt;td&gt;数学&lt;/td&gt;    &lt;td&gt;语文&lt;/td&gt;&lt;/tr&gt;&lt;tr ng-repeat=&quot;entity in list&quot;&gt;    &lt;td&gt;{{entity.name}}&lt;/td&gt;    &lt;td&gt;{{entity.shuxue}}&lt;/td&gt;    &lt;td&gt;{{entity.yuwen}}&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/body&gt;&lt;/html&gt;</code></pre><p>运行结果如下：</p><h3 id="内置服务"><a href="#内置服务" class="headerlink" title="内置服务"></a>内置服务</h3><p>我们的数据一般都是从后端获取的，那么如何获取数据呢？我们一般使用内置服务$http来实现。注意：以下代码需要在tomcat中运行。</p><pre><code>&lt;html&gt;&lt;head&gt;    &lt;title&gt;入门小Demo-8  内置服务&lt;/title&gt;    &lt;meta charset=&quot;utf-8&quot; /&gt;    &lt;script src=&quot;angular.min.js&quot;&gt;&lt;/script&gt;        &lt;script&gt;        var app=angular.module(&apos;myApp&apos;,[]); //定义了一个叫myApp的模块        //定义控制器        app.controller(&apos;myController&apos;,function($scope,$http){                    $scope.findAll=function(){                $http.get(&apos;data.json&apos;).success(                    function(response){                        $scope.list=response;                    }                                    );                            }                    });        &lt;/script&gt;    &lt;/head&gt;&lt;body ng-app=&quot;myApp&quot; ng-controller=&quot;myController&quot; ng-init=&quot;findAll()&quot;&gt;&lt;table&gt;&lt;tr&gt;    &lt;td&gt;姓名&lt;/td&gt;    &lt;td&gt;数学&lt;/td&gt;    &lt;td&gt;语文&lt;/td&gt;&lt;/tr&gt;&lt;tr ng-repeat=&quot;entity in list&quot;&gt;    &lt;td&gt;{{entity.name}}&lt;/td&gt;    &lt;td&gt;{{entity.shuxue}}&lt;/td&gt;    &lt;td&gt;{{entity.yuwen}}&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/body&gt;&lt;/html&gt;建立文件 data.json[    {&quot;name&quot;:&quot;张三&quot;,&quot;shuxue&quot;:100,&quot;yuwen&quot;:93},    {&quot;name&quot;:&quot;李四&quot;,&quot;shuxue&quot;:88,&quot;yuwen&quot;:87},    {&quot;name&quot;:&quot;王五&quot;,&quot;shuxue&quot;:77,&quot;yuwen&quot;:56},    {&quot;name&quot;:&quot;赵六&quot;,&quot;shuxue&quot;:67,&quot;yuwen&quot;:86}]</code></pre><h1 id="常用的指令"><a href="#常用的指令" class="headerlink" title="常用的指令"></a>常用的指令</h1><p>名称       描述</p><p><strong>ngApp    定义应用程序的根元素。</strong></p><p>ngBind    绑定 HTML 元素到应用程序数据</p><p><strong>ngBindhtml    绑定 HTML 元素的 innerHTML 到应用程序数据，并移除 HTML 字符串中危险字<br>符</strong></p><p>ngBindtemplate    规定要使用模板替换的文本内容</p><p>ngBlur    规定 blur 事件的行为</p><p>ngChange    规定在内容改变时要执行的表达式</p><p><strong>ngChecked    规定元素是否被选中</strong></p><p>ngClass    指定 HTML 元素使用的 CSS 类</p><p>ngClasseven    类似 ng-class，但只在偶数行起作用</p><p>ngClassodd    类似 ng-class，但只在奇数行起作用</p><p><strong>ngClick    定义元素被点击时的行为</strong></p><p>ngCloak    在应用正要加载时防止其闪烁</p><p>ngController    定义应用的控制器对象</p><p>ngCopy    规定拷贝事件的行为</p><p>ngCsp    修改内容的安全策略</p><p>ngCut    规定剪切事件的行为</p><p>ngDblclick    规定双击事件的行为</p><p>ngDisabled    规定一个元素是否被禁用</p><p>ngFocus    规定聚焦事件的行为</p><p>ngHide    隐藏或显示 HTML 元素</p><p>ngHref    为 元素指定链接</p><p><strong>ngIf    判断语句，如果值为falsh，所在的div层不显示</strong></p><p>ngInclude    在应用中包含 HTML 文件</p><p>ngInit    定义应用的初始化值</p><p>ngKeydown    规定按下按键事件的行为</p><p>ngKeypress    规定按下按键事件的行为</p><p>ngKeyup    规定松开按键事件的行为</p><p>ngList    将文本转换为列表 (数组)</p><p><strong>ngModel    绑定 HTML 控制器的值到应用数据</strong></p><p>ngModeloptions    规定如何更新模型</p><p>ngMousedown    规定按下鼠标按键时的行为</p><p>ngMouseenter    规定鼠标指针穿过元素时的行为</p><p>ngMouseleave    规定鼠标指针离开元素时的行为</p><p>ngMousemove    规定鼠标指针在指定的元素中移动时的行为</p><p>ngMouseover    规定鼠标指针位于元素上方时的行为</p><p>ngMouseup    规定当在元素上松开鼠标按钮时的行为</p><p>ngNonbindable    规定元素或子元素不能绑定数据</p><p>ngOpen    指定元素的 open 属性</p><p><strong>ngOptions    在 &lt; select&gt; 列表中指定 &lt; options&gt;</strong></p><p>ngPaste    规定粘贴事件的行为</p><p>ngReadonly    指定元素的 readonly 属性</p><p><strong>ngRepeat    定义集合中每项数据的模板</strong></p><p>ngSelected    指定元素的 selected 属性</p><p>ngShow    显示或隐藏 HTML 元素</p><p>ngSrc    指定  元素的 src 属性</p><p>ngSrcset    指定  元素的 srcset 属性</p><p>ngStyle    指定元素的 style 属性</p><p>ngSubmit    规定 onsubmit 事件发生时执行的表达式</p><p>ngSwitch    规定显示或隐藏子元素的条件</p><p><strong>ngValue    规定input元素的值</strong></p><h1 id="服务"><a href="#服务" class="headerlink" title="服务"></a>服务</h1><p>名称    描述</p><p>$http    $http是Angular的一个核心服务，它有利于浏览器通过XMLHttpRequest 对象或者 JSONP和远程HTTP服务器交互。</p><p>$controller    </p><p>$filter    ()</p><pre><code>// 定义过滤器app.filter(&apos;trustHtml&apos;,[&apos;$sce&apos;,function($sce){    return function(data){//传入参数时被过滤的内容        return $sce.trustAsHtml(data);//返回的是过滤后的内容（信任html的转换）    }    } ]);</code></pre><p>页面:<br>    <div class="attr" ng-bind-html="item.title | trustHtml"></div></p><p>$location    $location服务解析浏览器地址中的url（基于window.location）并且使url在应用程序中可用。将地址栏中的网址的变化反映到$location服务和$location的变化反映到浏览器地址栏。</p><p>$sce    $sce 服务是AngularJs提供的一种严格上下文转义服务。</p>]]></content>
      
      <categories>
          
          <category> 前端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> AngularJS </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Dubbox框架入门小demo</title>
      <link href="/2018/03/05/Dubbox%E6%A1%86%E6%9E%B6%E5%85%A5%E9%97%A8%E5%B0%8Fdemo/"/>
      <content type="html"><![CDATA[<script src="\assets\js\APlayer.min.js"> </script><h1 id="Dubbox框架"><a href="#Dubbox框架" class="headerlink" title="Dubbox框架"></a>Dubbox框架</h1><h2 id="Dubbox简介"><a href="#Dubbox简介" class="headerlink" title="Dubbox简介"></a>Dubbox简介</h2><p>Dubbox 是一个<strong>分布式服务框架</strong>，其前身是阿里巴巴开源项目Dubbo ，被国内电商及互联网项目中使用，后期阿里巴巴停止了该项目的维护，当当网便在Dubbo基础上进行优化，并继续维护，为了与原有的Dubbo区分，故将其命名为Dubbox。<br><a id="more"></a><br>Dubbox 致力于提供高性能和透明化的RPC远程服务调用方案，以及SOA服务治理方案。简单的说，dubbox就是个服务框架，如果没有分布式的需求，其实是不需要用的，只有在分布式的时候，才有dubbox这样的分布式服务框架的需求，并且本质上是个服务调用的东东，说白了就是个远程服务调用的分布式框架。</p><p>###节点角色说明：<br>• Provider: 暴露服务的服务提供方。</p><p>• Consumer: 调用远程服务的服务消费方。</p><p>• Registry: 服务注册与发现的注册中心。</p><p>• Monitor: 统计服务的调用次调和调用时间的监控中心。</p><p>• Container: 服务运行容器。</p><h3 id="调用关系说明："><a href="#调用关系说明：" class="headerlink" title="调用关系说明："></a>调用关系说明：</h3><p>• 0. 服务容器负责启动，加载，运行服务提供者。</p><p>• 1. 服务提供者在启动时，向注册中心注册自己提供的服务。</p><p>• 2. 服务消费者在启动时，向注册中心订阅自己所需的服务。</p><p>• 3. 注册中心返回服务提供者地址列表给消费者，如果有变更，注册中心将基于长连接推<br>送变更数据给消费者。</p><p>• 4. 服务消费者，从提供者地址列表中，基于软负载均衡算法，选一台提供者进行调用，<br>如果调用失败，再选另一台调用。</p><p>• 5. 服务消费者和提供者，在内存中累计调用次数和调用时间，定时每分钟发送一次统计<br>数据到监控中心。</p><h2 id="注册中心Zookeeper"><a href="#注册中心Zookeeper" class="headerlink" title="注册中心Zookeeper"></a>注册中心Zookeeper</h2><h3 id="Zookeeper-介绍"><a href="#Zookeeper-介绍" class="headerlink" title="Zookeeper 介绍"></a>Zookeeper 介绍</h3><p>官方推荐使用 zookeeper 注册中心。注册中心负责服务地址的注册与查找，相当于目录服务，服务提供者和消费者只在启动时与注册中心交互，注册中心不转发请求，压力较小。</p><p>Zookeeper 是 Apacahe Hadoop 的子项目，是一个树型的目录服务，支持变更推送，适合作为Dubbox 服务的注册中心，工业强度较高，可用于生产环境。</p><h3 id="Zookeeper-在Linux系统的安装"><a href="#Zookeeper-在Linux系统的安装" class="headerlink" title="Zookeeper 在Linux系统的安装"></a>Zookeeper 在Linux系统的安装</h3><p>安装步骤：</p><p>第一步：安装 jdk(这里请自行百度,如何在Linux中安装jdk)</p><p>第二步：把 zookeeper 的压缩包（…\dubbox\zookeeper-3.4.6.tar.gz）上传到 linux 系统。</p><pre><code>Alt+P 进入SFTP ，输入put d:\zookeeper-3.4.6.tar.gz 上传(这里d:是你放置压缩包的位置)</code></pre><p>第三步：解压缩压缩包</p><pre><code>tar -zxvf zookeeper-3.4.6.tar.gz</code></pre><p>第四步：进入 zookeeper-3.4.6 目录，创建 data 文件夹。</p><pre><code>mkdir data</code></pre><p>第五步：进入conf目录 ，把 zoo_sample.cfg 改名为 zoo.cfg</p><pre><code>cd confmv zoo_sample.cfg zoo.cfg</code></pre><p>第六步：打开zoo.cfg ,  修改 data 属性：</p><pre><code>dataDir=/root/zookeeper-3.4.6/data</code></pre><h3 id="Zookeeper-服务启动"><a href="#Zookeeper-服务启动" class="headerlink" title="Zookeeper 服务启动"></a>Zookeeper 服务启动</h3><p>进入bin目录，启动服务输入命令</p><pre><code>./zkServer.sh start</code></pre><p>关闭服务输入命令</p><pre><code>./zkServer.sh stop</code></pre><p>查看状态：</p><pre><code>./zkServer.sh status</code></pre><h3 id="Dubbox本地-JAR包部署与安装"><a href="#Dubbox本地-JAR包部署与安装" class="headerlink" title="Dubbox本地 JAR包部署与安装"></a>Dubbox本地 JAR包部署与安装</h3><p>Dubbox的jar包并没有部署到Maven的中央仓库中，大家在Maven的中央仓库中可以查找到Dubbo的最终版本是2.5.3 , 阿里巴巴解散了Dubbo团队后由当当网继续维护此项目，并改名为 Dubbox ,坐标不变，版本变更了，但是并没有提交到中央仓库。</p><p>我们现在需要手动将Dubbox的jar包安装到我的本地仓库中。</p><p>先将dubbo-2.8.4.jar包放到d:\setup, 然后输入命令</p><pre><code>mvn install:install-file -Dfile=d:\setup\dubbo-2.8.4.jar -DgroupId=com.alibaba -DartifactId=dubbo -Dversion=2.8.4 -Dpackaging=jar</code></pre><h3 id="配置离线约束"><a href="#配置离线约束" class="headerlink" title="配置离线约束"></a>配置离线约束</h3><p>地址：</p><pre><code>http://code.alibabatech.com/schema/dubbo/dubbo.xsd </code></pre><h2 id="入门小Demo"><a href="#入门小Demo" class="headerlink" title="入门小Demo"></a>入门小Demo</h2><h3 id="服务提供者开发"><a href="#服务提供者开发" class="headerlink" title="服务提供者开发"></a>服务提供者开发</h3><p>开发步骤：</p><p>（1）创建Maven工程（WAR）dubboxdemo-service  ，在pom.xml中引入依赖</p><pre><code>&lt;project xmlns=&quot;http://maven.apache.org/POM/4.0.0&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xsi:schemaLocation=&quot;http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd&quot;&gt;  &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt;  &lt;groupId&gt;cn.lxm.dubboxdemo&lt;/groupId&gt;  &lt;artifactId&gt;dubboxdemo-service&lt;/artifactId&gt;  &lt;version&gt;0.0.1-SNAPSHOT&lt;/version&gt;  &lt;packaging&gt;war&lt;/packaging&gt;     &lt;properties&gt;                &lt;spring.version&gt;4.2.4.RELEASE&lt;/spring.version&gt;   &lt;/properties&gt;        &lt;dependencies&gt;        &lt;!-- Spring --&gt;        &lt;dependency&gt;            &lt;groupId&gt;org.springframework&lt;/groupId&gt;            &lt;artifactId&gt;spring-context&lt;/artifactId&gt;            &lt;version&gt;${spring.version}&lt;/version&gt;        &lt;/dependency&gt;        &lt;dependency&gt;            &lt;groupId&gt;org.springframework&lt;/groupId&gt;            &lt;artifactId&gt;spring-beans&lt;/artifactId&gt;            &lt;version&gt;${spring.version}&lt;/version&gt;        &lt;/dependency&gt;        &lt;dependency&gt;            &lt;groupId&gt;org.springframework&lt;/groupId&gt;            &lt;artifactId&gt;spring-webmvc&lt;/artifactId&gt;            &lt;version&gt;${spring.version}&lt;/version&gt;        &lt;/dependency&gt;        &lt;dependency&gt;            &lt;groupId&gt;org.springframework&lt;/groupId&gt;            &lt;artifactId&gt;spring-jdbc&lt;/artifactId&gt;            &lt;version&gt;${spring.version}&lt;/version&gt;        &lt;/dependency&gt;        &lt;dependency&gt;            &lt;groupId&gt;org.springframework&lt;/groupId&gt;            &lt;artifactId&gt;spring-aspects&lt;/artifactId&gt;            &lt;version&gt;${spring.version}&lt;/version&gt;        &lt;/dependency&gt;        &lt;dependency&gt;            &lt;groupId&gt;org.springframework&lt;/groupId&gt;            &lt;artifactId&gt;spring-jms&lt;/artifactId&gt;            &lt;version&gt;${spring.version}&lt;/version&gt;        &lt;/dependency&gt;        &lt;dependency&gt;            &lt;groupId&gt;org.springframework&lt;/groupId&gt;            &lt;artifactId&gt;spring-context-support&lt;/artifactId&gt;            &lt;version&gt;${spring.version}&lt;/version&gt;        &lt;/dependency&gt;            &lt;!-- dubbo相关 --&gt;        &lt;dependency&gt;            &lt;groupId&gt;com.alibaba&lt;/groupId&gt;            &lt;artifactId&gt;dubbo&lt;/artifactId&gt;            &lt;version&gt;2.8.4&lt;/version&gt;                    &lt;/dependency&gt;        &lt;dependency&gt;            &lt;groupId&gt;org.apache.zookeeper&lt;/groupId&gt;            &lt;artifactId&gt;zookeeper&lt;/artifactId&gt;            &lt;version&gt;3.4.6&lt;/version&gt;        &lt;/dependency&gt;        &lt;dependency&gt;            &lt;groupId&gt;com.github.sgroschupf&lt;/groupId&gt;            &lt;artifactId&gt;zkclient&lt;/artifactId&gt;            &lt;version&gt;0.1&lt;/version&gt;        &lt;/dependency&gt;                &lt;dependency&gt;            &lt;groupId&gt;javassist&lt;/groupId&gt;            &lt;artifactId&gt;javassist&lt;/artifactId&gt;            &lt;version&gt;3.11.0.GA&lt;/version&gt;        &lt;/dependency&gt;            &lt;/dependencies&gt;   &lt;build&gt;        &lt;plugins&gt;          &lt;plugin&gt;                &lt;groupId&gt;org.apache.maven.plugins&lt;/groupId&gt;                &lt;artifactId&gt;maven-compiler-plugin&lt;/artifactId&gt;                &lt;version&gt;2.3.2&lt;/version&gt;                &lt;configuration&gt;                    &lt;source&gt;1.7&lt;/source&gt;                    &lt;target&gt;1.7&lt;/target&gt;                &lt;/configuration&gt;            &lt;/plugin&gt;            &lt;plugin&gt;                &lt;groupId&gt;org.apache.tomcat.maven&lt;/groupId&gt;                &lt;artifactId&gt;tomcat7-maven-plugin&lt;/artifactId&gt;                &lt;configuration&gt;                    &lt;!-- 指定端口 --&gt;                    &lt;port&gt;8081&lt;/port&gt;                    &lt;!-- 请求路径 --&gt;                    &lt;path&gt;/&lt;/path&gt;                &lt;/configuration&gt;            &lt;/plugin&gt;      &lt;/plugins&gt;      &lt;/build&gt;&lt;/project&gt;</code></pre><p>（2）在工程的webapps下创建WEB-INF文件夹，创建web.xml</p><pre><code>&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;web-app xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;    xmlns=&quot;http://java.sun.com/xml/ns/javaee&quot;    xsi:schemaLocation=&quot;http://java.sun.com/xml/ns/javaee http://java.sun.com/xml/ns/javaee/web-app_2_5.xsd&quot;    version=&quot;2.5&quot;&gt;        &lt;!-- 加载spring容器 --&gt;    &lt;context-param&gt;        &lt;param-name&gt;contextConfigLocation&lt;/param-name&gt;        &lt;param-value&gt;classpath:applicationContext*.xml&lt;/param-value&gt;    &lt;/context-param&gt;    &lt;listener&gt;        &lt;listener-class&gt;org.springframework.web.context.ContextLoaderListener&lt;/listener-class&gt;    &lt;/listener&gt;    &lt;/web-app&gt;</code></pre><p>（3）创建业务接口<br>创建包cn.lxm.dubbodemo.service，用于存放业务接口，创建接口</p><pre><code>package cn.lxm.dubbodemo.service;/** * 业务接口 * @author Administrator * */public interface UserService {        public String getName();    }</code></pre><p>（4）创建业务实现类<br>创建包cn.lxm.dubbodemo.service.impl ，用于存放业务实现类。创建业务实现类：</p><pre><code>package cn.lxm.dubbodemo.service.impl;import com.alibaba.dubbo.config.annotation.Service;import cn.lxm.dubbodemo.service.UserService;@Servicepublic class UserServiceImpl implements UserService {    public String getName() {                return &quot;lxm&quot;;    }}</code></pre><p>注意：Service注解与原来不同，需要引入com.alibaba包下的</p><p>（5）编写配置文件<br>在src/main/resources下创建applicationContext-service.xml ,内容如下：</p><pre><code>&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot;    xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xmlns:p=&quot;http://www.springframework.org/schema/p&quot;    xmlns:context=&quot;http://www.springframework.org/schema/context&quot;    xmlns:dubbo=&quot;http://code.alibabatech.com/schema/dubbo&quot; xmlns:mvc=&quot;http://www.springframework.org/schema/mvc&quot;    xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd        http://www.springframework.org/schema/mvc http://www.springframework.org/schema/mvc/spring-mvc.xsd        http://code.alibabatech.com/schema/dubbo http://code.alibabatech.com/schema/dubbo/dubbo.xsd        http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context.xsd&quot;&gt;    &lt;dubbo:application name=&quot;dubboxdemo-service&quot;/&gt;  &lt;dubbo:registry address=&quot;zookeeper://192.168.25.132:2181&quot;/&gt; &lt;dubbo:annotation package=&quot;cn.lxm.dubboxdemo.service&quot; /&gt; &lt;/beans&gt;</code></pre><p>注意：dubbo:annotation用于扫描@Service注解。</p><h3 id="服务消费者开发"><a href="#服务消费者开发" class="headerlink" title="服务消费者开发"></a>服务消费者开发</h3><p>开发步骤：</p><p>（1）创建Maven工程（WAR）dubboxdemo-web ，在pom.xml引入依赖 ，同“dubboxdemo-service”工程。区别就是把tomcat插件的运行端口改为8082 。</p><p>（2）在webapps目录下创建WEB-INF 目录，并创建web.xml </p><pre><code>&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;web-app xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;    xmlns=&quot;http://java.sun.com/xml/ns/javaee&quot;    xsi:schemaLocation=&quot;http://java.sun.com/xml/ns/javaee http://java.sun.com/xml/ns/javaee/web-app_2_5.xsd&quot;    version=&quot;2.5&quot;&gt;       &lt;!-- 解决post乱码 --&gt;    &lt;filter&gt;        &lt;filter-name&gt;CharacterEncodingFilter&lt;/filter-name&gt;        &lt;filter-class&gt;org.springframework.web.filter.CharacterEncodingFilter&lt;/filter-class&gt;        &lt;init-param&gt;            &lt;param-name&gt;encoding&lt;/param-name&gt;            &lt;param-value&gt;utf-8&lt;/param-value&gt;        &lt;/init-param&gt;        &lt;init-param&gt;              &lt;param-name&gt;forceEncoding&lt;/param-name&gt;              &lt;param-value&gt;true&lt;/param-value&gt;          &lt;/init-param&gt;      &lt;/filter&gt;    &lt;filter-mapping&gt;        &lt;filter-name&gt;CharacterEncodingFilter&lt;/filter-name&gt;        &lt;url-pattern&gt;/*&lt;/url-pattern&gt;    &lt;/filter-mapping&gt;          &lt;servlet&gt;      &lt;servlet-name&gt;springmvc&lt;/servlet-name&gt;      &lt;servlet-class&gt;org.springframework.web.servlet.DispatcherServlet&lt;/servlet-class&gt;      &lt;!-- 指定加载的配置文件 ，通过参数contextConfigLocation加载--&gt;      &lt;init-param&gt;          &lt;param-name&gt;contextConfigLocation&lt;/param-name&gt;          &lt;param-value&gt;classpath:applicationContext-web.xml&lt;/param-value&gt;      &lt;/init-param&gt;  &lt;/servlet&gt;    &lt;servlet-mapping&gt;      &lt;servlet-name&gt;springmvc&lt;/servlet-name&gt;      &lt;url-pattern&gt;*.do&lt;/url-pattern&gt;  &lt;/servlet-mapping&gt;&lt;/web-app&gt;</code></pre><p>（3）拷贝业务接口<br>将“dubboxdemo-service”工程的cn.lxm.dubboxdemo.service 包以及下面的接口拷贝至此工程。</p><p>（4）编写Controller </p><pre><code>package cn.lxm.dubboxdemo.controller;import org.springframework.beans.factory.annotation.Autowired;import org.springframework.stereotype.Controller;import org.springframework.web.bind.annotation.RequestMapping;import org.springframework.web.bind.annotation.ResponseBody;import cn.lxm.dubbodemo.service.UserService;@Controller@RequestMapping(&quot;/user&quot;)public class UserController {    @Reference    private UserService userService;        @RequestMapping(&quot;/showName&quot;)    @ResponseBody    public String showName(){        return userService.getName();    }        }</code></pre><p>（5）编写spring配置文件<br>在src/main/resources下创建applicationContext-web.xml  </p><pre><code>&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot;    xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xmlns:p=&quot;http://www.springframework.org/schema/p&quot;    xmlns:context=&quot;http://www.springframework.org/schema/context&quot;    xmlns:dubbo=&quot;http://code.alibabatech.com/schema/dubbo&quot; xmlns:mvc=&quot;http://www.springframework.org/schema/mvc&quot;    xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd        http://www.springframework.org/schema/mvc http://www.springframework.org/schema/mvc/spring-mvc.xsd        http://code.alibabatech.com/schema/dubbo http://code.alibabatech.com/schema/dubbo/dubbo.xsd        http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context.xsd&quot;&gt;    &lt;mvc:annotation-driven &gt;        &lt;mvc:message-converters register-defaults=&quot;false&quot;&gt;            &lt;bean class=&quot;org.springframework.http.converter.StringHttpMessageConverter&quot;&gt;                  &lt;constructor-arg value=&quot;UTF-8&quot; /&gt;            &lt;/bean&gt;          &lt;/mvc:message-converters&gt;        &lt;/mvc:annotation-driven&gt;    &lt;!-- 引用dubbo 服务 --&gt;    &lt;dubbo:application name=&quot;dubboxdemo-web&quot; /&gt;    &lt;dubbo:registry address=&quot;zookeeper://192.168.25.132:2181&quot;/&gt;     &lt;dubbo:annotation package=&quot;cn.lxm.dubboxdemo.controller&quot; /&gt;&lt;/beans&gt;</code></pre><p>（6）测试运行</p><p>tomcat7:run<br>在浏览器输入<a href="http://localhost:8082/user/showName.do，查看浏览器输出结果" target="_blank" rel="noopener">http://localhost:8082/user/showName.do，查看浏览器输出结果</a></p>]]></content>
      
      <categories>
          
          <category> java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Dubbox </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Lucene全文检索入门</title>
      <link href="/2018/03/03/Lucene%E5%85%A8%E6%96%87%E6%A3%80%E7%B4%A2%E5%85%A5%E9%97%A8/"/>
      <content type="html"><![CDATA[<script src="\assets\js\APlayer.min.js"> </script><p>#Lucene概述</p><h2 id="什么是Lucene"><a href="#什么是Lucene" class="headerlink" title="什么是Lucene"></a>什么是Lucene</h2><ul><li><p>Lucene是一套用于全文检索和搜寻的开源程序库，由Apache软件基金会支持和提供</p></li><li><p>Lucene提供了一个简单却强大的应用程序接口（API），能够做全文索引和搜寻，在Java开发环境里Lucene是一个成熟的免费开放源代码工具</p></li><li><p>Lucene并不是现成的搜索引擎产品，但可以用来制作搜索引擎产品</p></li><li><p>官网：<a href="http://lucene.apache.org/" target="_blank" rel="noopener">http://lucene.apache.org/</a></p></li></ul><p># </p><p>待更新…</p>]]></content>
      
      <categories>
          
          <category> 搜索解决方案 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Lucene </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>使用formfill.js快速填充表单</title>
      <link href="/2018/03/02/%E4%BD%BF%E7%94%A8formfill-js%E5%BF%AB%E9%80%9F%E5%A1%AB%E5%85%85%E8%A1%A8%E5%8D%95/"/>
      <content type="html"><![CDATA[<script src="\assets\js\APlayer.min.js"> </script><h1 id="form表单的快速回显"><a href="#form表单的快速回显" class="headerlink" title="form表单的快速回显"></a>form表单的快速回显</h1><p>做项目开发的时候在写修改的页面时,如果字段很多的话,数据回显塞值挺麻烦的,所以最近找了一个formfill.js快速填充表单的js</p><p>使用起来很简单,首先引用js文件<br><a id="more"></a><br>百度云盘下载:</p><p>链接：<a href="https://pan.baidu.com/s/1mjSDRtA" target="_blank" rel="noopener">https://pan.baidu.com/s/1mjSDRtA</a></p><p>密码：5ljt</p><pre><code>&lt;script src=&quot;../js/jquery.formautofill.js&quot;&gt;&lt;/script&gt;</code></pre><p>使用:</p><pre><code>var data = {&quot;name&quot;:&quot;haha&quot;,&quot;password&quot;:&quot;123&quot;}$(&quot;#formId&quot;).autofill(data);</code></pre><h1 id="英文解释"><a href="#英文解释" class="headerlink" title="英文解释:"></a>英文解释:</h1><h1 id="jQuery-form-autofill"><a href="#jQuery-form-autofill" class="headerlink" title="jQuery form autofill"></a>jQuery form autofill</h1><p>jQuery plugin to simply autofill an empty form with data.</p><h2 id="Documentation"><a href="#Documentation" class="headerlink" title="Documentation"></a>Documentation</h2><p><a href="http://labs.creative-area.net/jquery.formautofill/doc/" target="_blank" rel="noopener">See complete documentation and demo</a></p><h2 id="Usage"><a href="#Usage" class="headerlink" title="Usage"></a>Usage</h2><p>You have a <strong>form</strong></p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">form</span> <span class="attr">id</span>=<span class="string">"f"</span>&gt;</span></span><br><span class="line">    name <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"text"</span> <span class="attr">name</span>=<span class="string">"name"</span>&gt;</span></span><br><span class="line">    email <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"text"</span> <span class="attr">name</span>=<span class="string">"email"</span>&gt;</span></span><br><span class="line">    love jQuery</span><br><span class="line">    <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"radio"</span> <span class="attr">name</span>=<span class="string">"lovejquery"</span> <span class="attr">value</span>=<span class="string">"yes"</span>&gt;</span> yes</span><br><span class="line">    <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"radio"</span> <span class="attr">name</span>=<span class="string">"lovejquery"</span> <span class="attr">value</span>=<span class="string">"no"</span>&gt;</span> no</span><br><span class="line"><span class="tag">&lt;/<span class="name">form</span>&gt;</span></span><br></pre></td></tr></table></figure><p>And <strong>data</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> data = &#123;</span><br><span class="line">    <span class="string">"name"</span>: <span class="string">"John Doe"</span>,</span><br><span class="line">    <span class="string">"email"</span>: <span class="string">"johndoe@mail.com"</span>,</span><br><span class="line">    <span class="string">"lovejquery"</span>: <span class="string">"yes"</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>Autofill</strong> the form with data ? just do</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$(<span class="string">"#f"</span>).autofill( data );</span><br></pre></td></tr></table></figure>]]></content>
      
      <categories>
          
          <category> 前端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> jquery </tag>
            
            <tag> formautofill </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>SpringMVC架构入门二</title>
      <link href="/2018/03/01/SpringMVC%E6%9E%B6%E6%9E%84%E5%85%A5%E9%97%A8%E4%BA%8C/"/>
      <content type="html"><![CDATA[<script src="\assets\js\APlayer.min.js"> </script><h1 id="高级参数绑定"><a href="#高级参数绑定" class="headerlink" title="高级参数绑定"></a>高级参数绑定</h1><h2 id="绑定数组"><a href="#绑定数组" class="headerlink" title="绑定数组"></a>绑定数组</h2><p>Controller方法中可以用String[]接收，或者pojo的String[]属性接收。两种方式任选其一即可。<br><a id="more"></a><br>使用String[]:</p><pre><code>@RequestMapping(&quot;/queryitem&quot;)public String queryItem(Query queryVo, String[] ids) {    System.out.println(queryVo.getItems().getName());    System.out.println(queryVo.getItems().getPrice());    System.out.println(ids.toString());    return null;}</code></pre><p>pojo的String[]:</p><pre><code>public class Query{    private Items items;    private String[] ids;    get/set...}</code></pre><h2 id="将表单的数据绑定到List"><a href="#将表单的数据绑定到List" class="headerlink" title="将表单的数据绑定到List"></a>将表单的数据绑定到List</h2><p>List中存放对象，并将定义的List放在包装类中，使用包装pojo对象接收。</p><pre><code>public class Query{    private Items items;    private String[] ids;    private List&lt;Items&gt; itemList;    get/set...}</code></pre><p>jsp页面:</p><pre><code>&lt;tr&gt;    &lt;td&gt;        &lt;input type=&quot;text&quot; name=&quot; itemsList[0].id&quot; value=&quot;${item.id}&quot;/&gt;    &lt;/td&gt;    &lt;td&gt;        &lt;input type=&quot;text&quot; name=&quot; itemsList[0].name&quot; value=&quot;${item.name }&quot;/&gt;    &lt;/td&gt;    &lt;td&gt;        &lt;input type=&quot;text&quot; name=&quot; itemsList[0].price&quot; value=&quot;${item.price}&quot;/&gt;    &lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;    &lt;td&gt;        &lt;input type=&quot;text&quot; name=&quot; itemsList[1].id&quot; value=&quot;${item.id}&quot;/&gt;    &lt;/td&gt;    &lt;td&gt;        &lt;input type=&quot;text&quot; name=&quot; itemsList[1].name&quot; value=&quot;${item.name }&quot;/&gt;    &lt;/td&gt;    &lt;td&gt;        &lt;input type=&quot;text&quot; name=&quot; itemsList[1].price&quot; value=&quot;${item.price}&quot;/&gt;    &lt;/td&gt;&lt;/tr&gt;</code></pre><p>Name属性必须是包装pojo的list属性+下标+元素属性。</p><p>Jsp做如下改造：</p><pre><code>&lt;c:forEach items=&quot;${itemList }&quot; var=&quot;item&quot;&gt;&lt;tr&gt;    &lt;td&gt;        &lt;input name=&quot;ids&quot; value=&quot;${item.id}&quot; type=&quot;checkbox&quot;&gt;&lt;/td&gt;    &lt;td&gt;        &lt;input name=&quot;id&quot; value=&quot;${item.id}&quot; type=&quot;hidden&quot;&gt;        &lt;input name=&quot;name&quot; value=&quot;${item.name }&quot; type=&quot;text&quot;&gt;    &lt;/td&gt;    &lt;td&gt;        &lt;input name=&quot;name&quot; value=&quot;${item.price }&quot; type=&quot;text&quot;&gt;&lt;/td&gt;    &lt;td&gt;        &lt;input name=&quot;name&quot; value=&quot;&lt;fmt:formatDate value=&quot;${item.createtime}&quot; pattern=&quot;yyyy-MM-dd HH:mm:ss&quot;/&gt;&quot; type=&quot;text&quot;&gt;&lt;/td&gt;    &lt;td&gt;        &lt;input name=&quot;name&quot; value=&quot;${item.detail }&quot; type=&quot;text&quot;&gt;&lt;/td&gt;    &lt;td&gt;        &lt;a href=&quot;${pageContext.request.contextPath }/itemEdit.action?id=${item.id}&quot;&gt;修改&lt;/a&gt;    &lt;/td&gt;&lt;/tr&gt;&lt;/c:forEach&gt;</code></pre><p>varStatus属性常用参数总结下：</p><pre><code>${status.index}      输出行号，从0开始。${status.count}      输出行号，从1开始。${status.current}   当前这次迭代的（集合中的）项${status.first}  判断当前项是否为集合中的第一项，返回值为true或false${status.last}   判断当前项是否为集合中的最后一项，返回值为true或falsebegin、end、step分别表示：起始序号，结束序号，跳跃步伐。</code></pre><p>Contrller</p><pre><code>@RequestMapping(&quot;/queryitem&quot;)public String queryItem(QueryVo queryVo, String[] ids) {    System.out.println(queryVo.getItems().getName());    System.out.println(queryVo.getItems().getPrice());    System.out.println(ids.toString());    return null;}</code></pre><p>注意：接收List类型的数据必须是pojo的属性，方法的形参为List类型无法正确接收到数据。</p><h1 id="RequestMapping"><a href="#RequestMapping" class="headerlink" title="@RequestMapping"></a>@RequestMapping</h1><p>通过RequestMapping注解可以定义不同的处理器映射规则。</p><h2 id="URL路径映射"><a href="#URL路径映射" class="headerlink" title="URL路径映射"></a>URL路径映射</h2><p>@RequestMapping(value=”/item”)或@RequestMapping(“/item）<br>value的值是数组，可以将多个url映射到同一个方法</p><h2 id="窄化请求映射"><a href="#窄化请求映射" class="headerlink" title="窄化请求映射"></a>窄化请求映射</h2><p>在class上添加@RequestMapping(url)指定通用请求前缀， 限制此类下的所有方法请求url必须以请求前缀开头，通过此方法对url进行分类管理。</p><p>如下：</p><pre><code>@RequestMapping放在类名上边，设置请求前缀 @Controller@RequestMapping(&quot;/item&quot;)</code></pre><p>方法名上边设置请求映射url：</p><pre><code>@RequestMapping放在方法名上边，如下：@RequestMapping(&quot;/queryItem &quot;)</code></pre><p>访问地址为：/item/queryItem</p><h2 id="请求方法限定"><a href="#请求方法限定" class="headerlink" title="请求方法限定"></a>请求方法限定</h2><h3 id="限定GET方法"><a href="#限定GET方法" class="headerlink" title="限定GET方法"></a>限定GET方法</h3><pre><code>@RequestMapping(method = RequestMethod.GET)</code></pre><p>如果通过Post访问则报错：<br>HTTP Status 405 - Request method ‘POST’ not supported</p><p>例如：</p><pre><code>@RequestMapping(value=&quot;/editItem&quot;,method=RequestMethod.GET)</code></pre><h3 id="限定POST方法"><a href="#限定POST方法" class="headerlink" title="限定POST方法"></a>限定POST方法</h3><pre><code>@RequestMapping(method = RequestMethod.POST)</code></pre><p>如果通过Post访问则报错：<br>HTTP Status 405 - Request method ‘GET’ not supported</p><h3 id="GET和POST都可以"><a href="#GET和POST都可以" class="headerlink" title="GET和POST都可以"></a>GET和POST都可以</h3><pre><code>@RequestMapping(method={RequestMethod.GET,RequestMethod.POST})</code></pre><h1 id="controller方法返回值"><a href="#controller方法返回值" class="headerlink" title="controller方法返回值"></a>controller方法返回值</h1><h2 id="返回ModelAndView"><a href="#返回ModelAndView" class="headerlink" title="返回ModelAndView"></a>返回ModelAndView</h2><p>controller方法中定义ModelAndView对象并返回，对象中可添加model数据、指定view。</p><h2 id="返回void"><a href="#返回void" class="headerlink" title="返回void"></a>返回void</h2><p>在controller方法形参上可以定义request和response，使用request或response指定响应结果：</p><p>1、使用request转向页面，如下：</p><pre><code>request.getRequestDispatcher(&quot;页面路径&quot;).forward(request, response);</code></pre><p>2、也可以通过response页面重定向：</p><pre><code>response.sendRedirect(&quot;url&quot;)</code></pre><p>3、也可以通过response指定响应结果，例如响应json数据如下：</p><pre><code>response.setCharacterEncoding(&quot;utf-8&quot;);response.setContentType(&quot;application/json;charset=utf-8&quot;);response.getWriter().write(&quot;json串&quot;);</code></pre><h2 id="返回字符串"><a href="#返回字符串" class="headerlink" title="返回字符串"></a>返回字符串</h2><h3 id="逻辑视图名"><a href="#逻辑视图名" class="headerlink" title="逻辑视图名"></a>逻辑视图名</h3><p>controller方法返回字符串可以指定逻辑视图名，通过视图解析器解析为物理视图地址。</p><pre><code>//指定逻辑视图名，经过视图解析器解析为jsp物理路径：/WEB-INF/jsp/item/editItem.jspreturn &quot;item/editItem&quot;;</code></pre><h3 id="Redirect重定向"><a href="#Redirect重定向" class="headerlink" title="Redirect重定向"></a>Redirect重定向</h3><p>Contrller方法返回结果重定向到一个url地址，如下商品修改提交后重定向到商品查询方法，参数无法带到商品查询方法中。</p><pre><code>//重定向到queryItem.action地址,request无法带过去return &quot;redirect:queryItem.action&quot;;</code></pre><p>redirect方式相当于“response.sendRedirect()”，转发后浏览器的地址栏变为转发后的地址，因为转发即执行了一个新的request和response。<br>由于新发起一个request原来的参数在转发时就不能传递到下一个url，如果要传参数可以/item/queryItem.action后边加参数，如下：</p><pre><code>/item/queryItem?...&amp;…..</code></pre><p>如果使用了model的话,他会自动给你拼接数据,就是自动在后面拼接?</p><h3 id="forward转发"><a href="#forward转发" class="headerlink" title="forward转发"></a>forward转发</h3><p>controller方法执行后继续执行另一个controller方法，如下商品修改提交后转向到商品修改页面，修改商品的id参数可以带到商品修改方法中。</p><pre><code>//结果转发到editItem.action，request可以带过去return &quot;forward:editItem.action&quot;;</code></pre><p>forward方式相当于“request.getRequestDispatcher().forward(request,response)”，转发后浏览器地址栏还是原来的地址。转发并没有执行新的request和response，而是和转发前的请求共用一个request和response。所以转发前请求的参数在转发后仍然可以读取到。</p><h1 id="异常处理器"><a href="#异常处理器" class="headerlink" title="异常处理器"></a>异常处理器</h1><p>springmvc在处理请求过程中出现异常信息交由异常处理器进行处理，自定义异常处理器可以实现一个系统的异常处理逻辑。</p><h2 id="异常处理思路"><a href="#异常处理思路" class="headerlink" title="异常处理思路"></a>异常处理思路</h2><p>系统中异常包括两类：预期异常和运行时异常RuntimeException，前者通过捕获异常从而获取异常信息，后者主要通过规范代码开发、测试通过手段减少运行时异常的发生。</p><p>系统的dao、service、controller出现都通过throws Exception向上抛出，最后由springmvc前端控制器交由异常处理器进行异常处理</p><p>步骤:写异常处理器类,然后在springmvc.xml中配置,然后写异常错误页面</p><h2 id="自定义异常处理器"><a href="#自定义异常处理器" class="headerlink" title="自定义异常处理器"></a>自定义异常处理器</h2><pre><code>public class CustomExceptionResolver implements HandlerExceptionResolver {    @Override    public ModelAndView resolveException(HttpServletRequest request,            HttpServletResponse response, Object handler, Exception ex) {        ex.printStackTrace();        CustomException customException = null;        //如果抛出的是系统自定义异常则直接转换        if(ex instanceof CustomException){            customException = (CustomException)ex;        }else{            //如果抛出的不是系统自定义异常则重新构造一个系统错误异常。            customException = new CustomException(&quot;系统错误，请与系统管理 员联系！&quot;);        }        ModelAndView modelAndView = new ModelAndView();        modelAndView.addObject(&quot;message&quot;, customException.getMessage());        modelAndView.setViewName(&quot;error&quot;);        return modelAndView;    }}</code></pre><p>###取异常堆栈：</p><pre><code>//错误信息存储在堆栈中,取异常堆栈将其显示在控制台上,或输出到日志文件中       try {        } catch (Exception e) {            StringWriter s = new StringWriter();            PrintWriter printWriter = new PrintWriter(s);            e.printStackTrace(printWriter);            s.toString();        }</code></pre><h2 id="错误页面"><a href="#错误页面" class="headerlink" title="错误页面"></a>错误页面</h2><pre><code>&lt;%@ page language=&quot;java&quot; contentType=&quot;text/html; charset=UTF-8&quot;    pageEncoding=&quot;UTF-8&quot;%&gt;&lt;%@ taglib uri=&quot;http://java.sun.com/jsp/jstl/core&quot; prefix=&quot;c&quot; %&gt;&lt;%@ taglib uri=&quot;http://java.sun.com/jsp/jstl/fmt&quot;  prefix=&quot;fmt&quot;%&gt; &lt;!DOCTYPE html PUBLIC &quot;-//W3C//DTD HTML 4.01 Transitional//EN&quot; &quot;http://www.w3.org/TR/html4/loose.dtd&quot;&gt;&lt;html&gt;&lt;head&gt;&lt;meta http-equiv=&quot;Content-Type&quot; content=&quot;text/html; charset=UTF-8&quot;&gt;&lt;title&gt;错误页面&lt;/title&gt;&lt;/head&gt;&lt;body&gt;您的操作出现错误如下：&lt;br/&gt;${message }&lt;/body&gt;&lt;/html&gt;</code></pre><h2 id="异常处理器配置"><a href="#异常处理器配置" class="headerlink" title="异常处理器配置"></a>异常处理器配置</h2><p>在springmvc.xml中添加：</p><pre><code>&lt;!-- 全局异常处理器 --&gt;&lt;bean class=&quot;com.lxm.springmvc.exception.GlobalExceptionResolver&quot;/&gt;</code></pre><h2 id="测试异常"><a href="#测试异常" class="headerlink" title="测试异常"></a>测试异常</h2><p>在需要抛出异常的地方加上throw new CustomerException(“出错信息”);然后方法上向上抛出就可以了</p><pre><code>@RequestMapping(&quot;/itemEdit&quot;)public String getEditItem(@RequestParam(value=&quot;id&quot;,required=true)Integer id,Model model) throws CustomerException{    Items items = itemService.getItemById(id);    if(items == null){        throw new CustomerException(&quot;商品信息不存在!&quot;);    }    model.addAttribute(&quot;item&quot;,items);    return &quot;editItem&quot;;}</code></pre><h1 id="上传图片"><a href="#上传图片" class="headerlink" title="上传图片"></a>上传图片</h1><h2 id="配置虚拟目录"><a href="#配置虚拟目录" class="headerlink" title="配置虚拟目录"></a>配置虚拟目录</h2><p>在tomcat上配置图片虚拟目录，在tomcat下conf/server.xml中添加：</p><pre><code>&lt;Context docBase=&quot;F:\develop\upload\temp&quot; path=&quot;/pic&quot; reloadable=&quot;false&quot;/&gt;</code></pre><p>访问<a href="http://localhost:8080/pic即可访问F:\develop\upload\temp下的图片。" target="_blank" rel="noopener">http://localhost:8080/pic即可访问F:\develop\upload\temp下的图片。</a></p><p>也可以通过eclipse配置：</p><p>1:在tomcat服务配置里面有个modules,<br>点击AddExternalWebModule</p><p>2:然后在Documentbase里面填写虚拟路径的绝对路径(例如:F:\develop\upload\temp),</p><p>3:在Path里面填写虚拟路径(例如:/pic)</p><p>4:AutoReload(这个根据需要自行设定,以下是作用,一般设置为disabled就可以)</p><pre><code>在eclipse中集成tomca来开发时,如果使用run as模式启动项目的话,tomcat配置Auto reloading enabled,我们修改java文件,项目会重新加载,修改的内容会生效.如果使用debug as 模式启动项目的话,tomcat不要配置Auto reloading enabled,我们修改的java文件,也会生效.注意:在debug模式下,tomcat配置了Auto reloading enabled,当修改了java文件,项目会报错.</code></pre><h2 id="jar包"><a href="#jar包" class="headerlink" title="jar包"></a>jar包</h2><p>CommonsMultipartResolver解析器依赖:</p><pre><code>commons-fileuploadcommons-io</code></pre><h2 id="配置解析器"><a href="#配置解析器" class="headerlink" title="配置解析器"></a>配置解析器</h2><p>springmvc.xml</p><pre><code>&lt;!-- 文件上传 --&gt;&lt;bean id=&quot;multipartResolver&quot;    class=&quot;org.springframework.web.multipart.commons.CommonsMultipartResolver&quot;&gt;    &lt;!-- 设置上传文件的最大尺寸为5MB --&gt;    &lt;property name=&quot;maxUploadSize&quot;&gt;        &lt;value&gt;5242880&lt;/value&gt;    &lt;/property&gt;&lt;/bean&gt;</code></pre><h2 id="图片上传"><a href="#图片上传" class="headerlink" title="图片上传"></a>图片上传</h2><p>controller：</p><pre><code>@RequestMapping(&quot;/updateitem&quot;)public String updateItem(Items items,MultipartFile pictureFile) throws Exception, IOException{    //把图片保存到图片目录下    //为每个文件生成一个新的文件名    String picName = UUID.randomUUID().toString();    //去文件的扩展名    String oriName = pictureFile.getOriginalFilename();    System.out.println(&quot;oriName&quot;+oriName);    if(oriName!=null &amp;&amp; oriName!=&quot;&quot;){        String extName = oriName.substring(oriName.lastIndexOf(&quot;.&quot;));        System.out.println(&quot;extName&quot;+extName);        //保存文件 d:\picture\temp        pictureFile.transferTo(new File(&quot;d:\\picture\\temp\\&quot;+picName+extName));        //把文件名保存到数据库        items.setPic(picName+extName);    }    itemService.updateItem(items);//        return &quot;forward:/itemList.action?items=&quot;+items;//转发是可以传递对象的    return &quot;forward:/itemList.action&quot;;}</code></pre><h2 id="页面："><a href="#页面：" class="headerlink" title="页面："></a>页面：</h2><pre><code>form添加enctype=&quot;multipart/form-data&quot;：&lt;form id=&quot;itemForm&quot;action=&quot;${pageContext.request.contextPath }/item/editItemSubmit.action&quot;    method=&quot;post&quot; enctype=&quot;multipart/form-data&quot;&gt;    &lt;input type=&quot;hidden&quot; name=&quot;pic&quot; value=&quot;${item.pic }&quot; /&gt;file的name与controller形参一致：&lt;tr&gt;    &lt;td&gt;商品图片&lt;/td&gt;    &lt;td&gt;&lt;c:if test=&quot;${item.pic !=null}&quot;&gt;            &lt;img src=&quot;/pic/${item.pic}&quot; width=100 height=100 /&gt;            &lt;br /&gt;        &lt;/c:if&gt; &lt;input type=&quot;file&quot; name=&quot;pictureFile&quot; /&gt;&lt;/td&gt;&lt;/tr&gt;</code></pre><h1 id="json数据交互"><a href="#json数据交互" class="headerlink" title="json数据交互"></a>json数据交互</h1><h2 id="RequestBody"><a href="#RequestBody" class="headerlink" title="@RequestBody"></a>@RequestBody</h2><p>作用：</p><p>@RequestBody注解用于读取http请求的内容(字符串)，通过springmvc提供的HttpMessageConverter接口将读到的内容转换为json、xml等格式的数据并绑定到controller方法的参数上。</p><p>List.action?id=1&amp;name=zhangsan&amp;age=12</p><p>本例子应用：</p><p>@RequestBody注解实现接收http请求的json数据，将json数据转换为java对象</p><h2 id="ResponseBody"><a href="#ResponseBody" class="headerlink" title="@ResponseBody"></a>@ResponseBody</h2><p>作用：</p><p>该注解用于将Controller的方法返回的对象，通过HttpMessageConverter接口转换为指定格式的数据如：json,xml等，通过Response响应给客户端</p><p>本例子应用：</p><p>@ResponseBody注解实现将controller方法返回对象转换为json响应给客户端</p><h2 id="请求json，响应json实现："><a href="#请求json，响应json实现：" class="headerlink" title="请求json，响应json实现："></a>请求json，响应json实现：</h2><h3 id="环境准备"><a href="#环境准备" class="headerlink" title="环境准备"></a>环境准备</h3><p>Springmvc默认用MappingJacksonHttpMessageConverter对json数据进行转换，需要加入jackson的包，</p><pre><code>jackson-annotations-2.4.0.jarjackson-core-2.4.2.jarjackson-databind-2.4.2.jar</code></pre><h3 id="配置json转换器"><a href="#配置json转换器" class="headerlink" title="配置json转换器"></a>配置json转换器</h3><p>在注解适配器中加入messageConverters</p><pre><code>&lt;!--注解适配器 --&gt;&lt;bean class=&quot;org.springframework.web.servlet.mvc.method.annotation.RequestMappingHandlerAdapter&quot;&gt;    &lt;property name=&quot;messageConverters&quot;&gt;    &lt;list&gt;    &lt;bean class=&quot;org.springframework.http.converter.json.MappingJacksonHttpMessageConverter&quot;&gt;&lt;/bean&gt;    &lt;/list&gt;    &lt;/property&gt;&lt;/bean&gt;</code></pre><p>注意：如果使用<mvc:annotation-driven> 则不用定义上边的内容。</mvc:annotation-driven></p><h3 id="controller编写"><a href="#controller编写" class="headerlink" title="controller编写"></a>controller编写</h3><pre><code>// 商品修改提交json信息，响应json信息@RequestMapping(&quot;/editItemSubmit_RequestJson&quot;)public @ResponseBody Items editItemSubmit_RequestJson(@RequestBody Items items) throws Exception {    System.out.println(items);    //itemService.saveItem(items);    return items;}</code></pre><h3 id="页面js方法编写："><a href="#页面js方法编写：" class="headerlink" title="页面js方法编写："></a>页面js方法编写：</h3><p>引入 js：<br>    <script type="text/javascript" src="${pageContext.request.contextPath }/js/jquery-1.4.4.min.js"></script></p><pre><code>//请求json响应jsonfunction request_json(){    $.ajax({        type:&quot;post&quot;,        url:&quot;${pageContext.request.contextPath }/item/editItemSubmit_RequestJson.action&quot;,        contentType:&quot;application/json;charset=utf-8&quot;,        data:&apos;{&quot;name&quot;:&quot;测试商品&quot;,&quot;price&quot;:99.9}&apos;,        success:function(data){            alert(data);        }    });}</code></pre>]]></content>
      
      <categories>
          
          <category> SSM </category>
          
      </categories>
      
      
        <tags>
            
            <tag> SpringMVC </tag>
            
            <tag> SpringWebMVC </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>SpringMVC架构入门一</title>
      <link href="/2018/02/27/SpringMVC%E6%9E%B6%E6%9E%84%E5%85%A5%E9%97%A8%E4%B8%80/"/>
      <content type="html"><![CDATA[<script src="\assets\js\APlayer.min.js"> </script><h1 id="SpringMVC架构"><a href="#SpringMVC架构" class="headerlink" title="SpringMVC架构"></a>SpringMVC架构</h1><p>Spring web mvc和Struts2都属于表现层的框架,它是Spring框架的一部分.</p><h2 id="架构流程"><a href="#架构流程" class="headerlink" title="架构流程"></a>架构流程</h2><pre><code>1、    用户发送请求至前端控制器DispatcherServlet2、    DispatcherServlet收到请求调用HandlerMapping处理器映射器。3、    处理器映射器根据请求url找到具体的处理器，生成处理器对象及处理器拦截器(如果有则生成)一并返回给DispatcherServlet。4、    DispatcherServlet通过HandlerAdapter处理器适配器调用处理器5、    执行处理器(Controller，也叫后端控制器)。6、    Controller执行完成返回ModelAndView7、    HandlerAdapter将controller执行结果ModelAndView返回给DispatcherServlet8、    DispatcherServlet将ModelAndView传给ViewReslover视图解析器9、    ViewReslover解析后返回具体View10、    DispatcherServlet对View进行渲染视图（即将模型数据填充至视图中）。11、    DispatcherServlet响应用户</code></pre><a id="more"></a><p><img src="http://p57l8frp4.bkt.clouddn.com/springmvc%E6%89%A7%E8%A1%8C%E6%B5%81%E7%A8%8B%E5%9B%BE2.jpg" alt=""></p><h2 id="组件说明"><a href="#组件说明" class="headerlink" title="组件说明"></a>组件说明</h2><p>以下组件通常使用框架提供实现：</p><ul><li><p>DispatcherServlet：前端控制器</p><p>  用户请求到达前端控制器，它就相当于mvc模式中的c，dispatcherServlet是整个流程控制的中心，由它调用其它组件处理用户的请求，dispatcherServlet的存在降低了组件之间的耦合性。</p></li><li><p>HandlerMapping：处理器映射器</p><p>  HandlerMapping负责根据用户请求找到Handler即处理器，springmvc提供了不同的映射器实现不同的映射方式，例如：配置文件方式，实现接口方式，注解方式等。</p></li><li><p>Handler：处理器</p><p>  Handler 是继DispatcherServlet前端控制器的后端控制器，在DispatcherServlet的控制下Handler对具体的用户请求进行处理。<br>  由于Handler涉及到具体的用户业务请求，所以一般情况需要程序员根据业务需求开发Handler。</p></li><li><p>HandlAdapter：处理器适配器</p><p>  通过HandlerAdapter对处理器进行执行，这是适配器模式的应用，通过扩展适配器可以对更多类型的处理器进行执行。</p></li><li><p>View Resolver：视图解析器</p><p>  View Resolver负责将处理结果生成View视图，View Resolver首先根据逻辑视图名解析成物理视图名即具体的页面地址，再生成View视图对象，最后对View进行渲染将处理结果通过页面展示给用户。 </p></li><li><p>View：视图</p><p>  springmvc框架提供了很多的View视图类型的支持，包括：jstlView、freemarkerView、pdfView等。我们最常用的视图就是jsp。<br>  一般情况下需要通过页面标签或页面模版技术将模型数据通过页面展示给用户，需要由程序员根据业务需求开发具体的页面。</p></li></ul><p>说明：在springmvc的各个组件中，<strong>处理器映射器</strong>、<strong>处理器适配器</strong>、<strong>视图解析器</strong>称为springmvc的三大组件。</p><p>需要用户开放的组件有<strong>handler、view</strong></p><h2 id="注解映射器和适配器"><a href="#注解映射器和适配器" class="headerlink" title="注解映射器和适配器"></a>注解映射器和适配器</h2><h3 id="组件扫描器"><a href="#组件扫描器" class="headerlink" title="组件扫描器"></a>组件扫描器</h3><p>使用组件扫描器省去在spring容器配置每个controller类的繁琐。使用<context:component-scan>自动扫描标记@controller的控制器类，配置如下：</context:component-scan></p><pre><code>&lt;!-- 扫描controller注解,多个包中间使用半角逗号分隔 --&gt;&lt;context:component-scan base-package=&quot;cn.lxm.springmvc.controller.first&quot;/&gt;</code></pre><h3 id="RequestMappingHandlerMapping"><a href="#RequestMappingHandlerMapping" class="headerlink" title="RequestMappingHandlerMapping"></a>RequestMappingHandlerMapping</h3><p>注解式处理器映射器，对类中标记@ResquestMapping的方法进行映射，根据ResquestMapping定义的url匹配ResquestMapping标记的方法，匹配成功返回HandlerMethod对象给前端控制器，HandlerMethod对象中封装url对应的方法Method。 </p><p>从spring3.1版本开始，废除了DefaultAnnotationHandlerMapping的使用，推荐使用RequestMappingHandlerMapping完成注解式处理器映射。</p><p>配置如下：</p><pre><code>&lt;!--注解映射器 --&gt;&lt;bean class=&quot;org.springframework.web.servlet.mvc.method.annotation.RequestMappingHandlerMapping&quot;/&gt;</code></pre><p>注解描述：<br>@RequestMapping：定义请求url到处理器功能方法的映射</p><h3 id="RequestMappingHandlerAdapter"><a href="#RequestMappingHandlerAdapter" class="headerlink" title="RequestMappingHandlerAdapter"></a>RequestMappingHandlerAdapter</h3><p>注解式处理器适配器，对标记@ResquestMapping的方法进行适配。</p><p>从spring3.1版本开始，废除了AnnotationMethodHandlerAdapter的使用，推荐使用RequestMappingHandlerAdapter完成注解式处理器适配。</p><p>配置如下：</p><pre><code>&lt;!--注解适配器 --&gt;&lt;bean class=&quot;org.springframework.web.servlet.mvc.method.annotation.RequestMappingHandlerAdapter&quot;/&gt;</code></pre><h3 id=""><a href="#" class="headerlink" title=""></a><mvc:annotation-driven></mvc:annotation-driven></h3><p>springmvc使用<mvc:annotation-driven>自动加载RequestMappingHandlerMapping和RequestMappingHandlerAdapter，可用在springmvc.xml配置文件中使用<mvc:annotation-driven>替代注解处理器和适配器的配置。</mvc:annotation-driven></mvc:annotation-driven></p><h2 id="视图解析器"><a href="#视图解析器" class="headerlink" title="视图解析器"></a>视图解析器</h2><p>在springmvc.xml文件配置如下：</p><pre><code>&lt;bean class=&quot;org.springframework.web.servlet.view.InternalResourceViewResolver&quot;&gt;    &lt;property name=&quot;viewClass&quot;        value=&quot;org.springframework.web.servlet.view.JstlView&quot; /&gt;    &lt;property name=&quot;prefix&quot; value=&quot;/WEB-INF/jsp/&quot; /&gt;    &lt;property name=&quot;suffix&quot; value=&quot;.jsp&quot; /&gt;&lt;/bean&gt;</code></pre><p>InternalResourceViewResolver：支持JSP视图解析</p><p>viewClass：JstlView表示JSP模板页面需要使用JSTL标签库，所以classpath中必须包含jstl的相关jar 包。此属性可以不设置，默认为JstlView。</p><p>prefix 和suffix：查找视图页面的前缀和后缀，最终视图的地址为：<br>前缀+逻辑视图名+后缀，逻辑视图名需要在controller中返回ModelAndView指定，比如逻辑视图名为hello，则最终返回的jsp视图地址 “WEB-INF/jsp/hello.jsp”</p><h1 id="整合mybatis"><a href="#整合mybatis" class="headerlink" title="整合mybatis"></a>整合mybatis</h1><p>ssm框架:springmvc + spring + mybatis</p><p>控制层采用springmvc、持久层使用mybatis实现。</p><h2 id="准备jar包"><a href="#准备jar包" class="headerlink" title="准备jar包"></a>准备jar包</h2><p>spring（包括springmvc）、mybatis、mybatis-spring整合包、数据库驱动、第三方连接池。</p><h2 id="整合思路"><a href="#整合思路" class="headerlink" title="整合思路"></a>整合思路</h2><h3 id="Dao层："><a href="#Dao层：" class="headerlink" title="Dao层："></a>Dao层：</h3><p>1、SqlMapConfig.xml</p><pre><code>空文件即可。需要文件头。</code></pre><p>2、applicationContext-dao.xml。</p><pre><code>a)    数据库连接池b)    SqlSessionFactory对象，需要spring和mybatis整合包下的。c)    配置mapper文件扫描器。</code></pre><h3 id="Service层："><a href="#Service层：" class="headerlink" title="Service层："></a>Service层：</h3><p>1、applicationContext-service.xml</p><pre><code>包扫描器，扫描@service注解的类。</code></pre><p>2、applicationContext-trans.xml</p><pre><code>配置事务。</code></pre><h3 id="表现层："><a href="#表现层：" class="headerlink" title="表现层："></a>表现层：</h3><p>Springmvc.xml</p><pre><code>1、包扫描器，扫描@Controller注解的类。2、配置注解驱动。3、视图解析器</code></pre><p>Web.xml</p><pre><code>配置前端控制器。</code></pre><h1 id="参数绑定"><a href="#参数绑定" class="headerlink" title="参数绑定"></a>参数绑定</h1><h2 id="Controller参数绑定"><a href="#Controller参数绑定" class="headerlink" title="Controller参数绑定"></a>Controller参数绑定</h2><p>要根据id查询商品数据，需要从请求的参数中把请求的id取出来。Id应该包含在Request对象中。可以从Request对象中取id。</p><pre><code>@RequestMapping(&quot;/itemEdit&quot;)public ModelAndView itemEdit(HttpServletRequest request) {    //从Request中取id    String strId = request.getParameter(&quot;id&quot;);    Integer id = null;    //如果id有值则转换成int类型    if (strId != null &amp;&amp; !&quot;&quot;.equals(strId)) {        id = new Integer(strId);    } else {        //出错        return null;    }    Items items = itemService.getItemById(id);    //创建ModelAndView    ModelAndView modelAndView = new ModelAndView();    //向jsp传递数据    modelAndView.addObject(&quot;item&quot;, items);    //设置跳转的jsp页面    modelAndView.setViewName(&quot;editItem&quot;);    return modelAndView;}</code></pre><p>如果想获得Request对象只需要在Controller方法的形参中添加一个参数即可。Springmvc框架会自动把Request对象传递给方法。</p><h2 id="Service"><a href="#Service" class="headerlink" title="Service"></a>Service</h2><pre><code>@Overridepublic Items getItemById(int id) {    Items items = itemsMapper.selectByPrimaryKey(id);    return items;}</code></pre><h2 id="默认支持的参数类型"><a href="#默认支持的参数类型" class="headerlink" title="默认支持的参数类型"></a>默认支持的参数类型</h2><p>处理器形参中添加如下类型的参数处理适配器会默认识别并进行赋值。</p><h3 id="HttpServletRequest"><a href="#HttpServletRequest" class="headerlink" title="HttpServletRequest"></a>HttpServletRequest</h3><p>通过request对象获取请求信息</p><h3 id="HttpServletResponse"><a href="#HttpServletResponse" class="headerlink" title="HttpServletResponse"></a>HttpServletResponse</h3><p>通过response处理响应信息</p><h3 id="HttpSession"><a href="#HttpSession" class="headerlink" title="HttpSession"></a>HttpSession</h3><p>通过session对象得到session中存放的对象</p><h3 id="Model-ModelMap"><a href="#Model-ModelMap" class="headerlink" title="Model/ModelMap"></a>Model/ModelMap</h3><p>ModelMap是Model接口的实现类，通过Model或ModelMap向页面传递数据，如下：</p><pre><code>//调用service查询商品信息Items item = itemService.findItemById(id);model.addAttribute(&quot;item&quot;, item);</code></pre><p>页面通过${item.XXXX}获取item对象的属性值。</p><p>使用Model和ModelMap的效果一样，如果直接使用Model，springmvc会实例化ModelMap。</p><p>如果使用Model则可以不使用ModelAndView对象，Model对象可以向页面传递数据，View对象则可以使用String返回值替代。不管是Model还是ModelAndView，其本质都是使用Request对象向jsp传递数据。<br>如果使用Model则方法可以改造成：</p><pre><code>@RequestMapping(&quot;/itemEdit&quot;)public String itemEdit(HttpServletRequest request, Model model) {    //从Request中取id    String strId = request.getParameter(&quot;id&quot;);    Integer id = null;    //如果id有值则转换成int类型    if (strId != null &amp;&amp; !&quot;&quot;.equals(strId)) {        id = new Integer(strId);    } else {        //出错        return null;    }    Items items = itemService.getItemById(id);    //创建ModelAndView    //ModelAndView modelAndView = new ModelAndView();    //向jsp传递数据    //modelAndView.addObject(&quot;item&quot;, items);    model.addAttribute(&quot;item&quot;, items);    //设置跳转的jsp页面    //modelAndView.setViewName(&quot;editItem&quot;);    //return modelAndView;    return &quot;editItem&quot;;}</code></pre><h2 id="绑定简单类型"><a href="#绑定简单类型" class="headerlink" title="绑定简单类型"></a>绑定简单类型</h2><p>当请求的参数名称和处理器形参名称一致时会将请求参数与形参进行绑定。从Request取参数的方法可以进一步简化。</p><pre><code>@RequestMapping(&quot;/itemEdit&quot;)public String itemEdit(Integer id, Model model) {    Items items = itemService.getItemById(id);    //向jsp传递数据    model.addAttribute(&quot;item&quot;, items);    //设置跳转的jsp页面    return &quot;editItem&quot;;}</code></pre><h3 id="支持的数据类型"><a href="#支持的数据类型" class="headerlink" title="支持的数据类型"></a>支持的数据类型</h3><p>参数类型推荐使用包装数据类型，因为基础数据类型不可以为null</p><p>整形：Integer、int</p><p>字符串：String</p><p>单精度：Float、float</p><p>双精度：Double、double</p><p>布尔型：Boolean、boolean</p><p>说明：对于布尔类型的参数，请求的参数值为true或false。</p><p>处理器方法：</p><pre><code>public String editItem(Model model,Integer id,Boolean status) throws Exception</code></pre><p>请求url：</p><pre><code>http://localhost:8080/xxx.action?id=2&amp;status=false</code></pre><h3 id="RequestParam"><a href="#RequestParam" class="headerlink" title="@RequestParam"></a>@RequestParam</h3><p>使用@RequestParam常用于处理简单类型的绑定。</p><p>value：参数名字，即入参的请求参数名字，如value=“item_id”表示请求的参数区中的名字为item_id的参数的值将传入；</p><p>required：是否必须，默认是true，表示请求中一定要有相应的参数，否则将报；</p><p>TTP Status 400 - Required Integer parameter ‘XXXX’ is not present</p><p>defaultValue：默认值，表示如果请求中没有同名参数时的默认值</p><p>定义如下：</p><pre><code>public String editItem(@RequestParam(value=&quot;item_id&quot;,required=true) String id) {}</code></pre><p>形参名称为id，但是这里使用value=” item_id”限定请求的参数名为item_id，所以页面传递参数的名必须为item_id。</p><p>注意：如果请求参数中没有item_id将跑出异常：</p><pre><code>HTTP Status 500 - Required Integer parameter &apos;item_id&apos; is not present</code></pre><p>这里通过required=true限定item_id参数为必需传递，如果不传递则报400错误，可以使用defaultvalue设置默认值，即使required=true也可以不传item_id参数值</p><h2 id="绑定pojo类型"><a href="#绑定pojo类型" class="headerlink" title="绑定pojo类型"></a>绑定pojo类型</h2><h3 id="Controller"><a href="#Controller" class="headerlink" title="Controller:"></a>Controller:</h3><pre><code>@RequestMapping(&quot;/updateitem&quot;)public String updateItem(Items items){    itemService.updateItem(items);    return &quot;success&quot;;}</code></pre><h3 id="service"><a href="#service" class="headerlink" title="service"></a>service</h3><pre><code>@Overridepublic void updateItem(Items items) {    //ItemsExample example = new ItemsExample();    //如果example定义了两个字段，数据库共4个字段，则修改数据库的两个字段，其余两个字段改为null    //itemsMapper.updateByExample(items, example);    //成功,但是没有的值置为了null    //itemsMapper.updateByPrimaryKey(items);    //成功,但是没有的值置为了null    //itemsMapper.updateByPrimaryKeyWithBLOBs(items);    //和updateByExample相比此方法可以修改大字段类型，其余性质和updateByExample相同    //itemsMapper.updateByExampleWithBLOBs(items, example);    //如果example定义了两个字段，数据库共4个字段，则修改数据库的两个字段，其余两个字段不动    itemsMapper.updateByPrimaryKeySelective(items);}</code></pre><p>注意：提交的表单中不要有日期类型的数据，否则会报400错误。如果想提交日期类型的数据需要用到后面的自定义参数绑定的内容。</p><h2 id="解决日期参数问题"><a href="#解决日期参数问题" class="headerlink" title="解决日期参数问题:"></a>解决日期参数问题:</h2><h3 id="自定义Converter"><a href="#自定义Converter" class="headerlink" title="自定义Converter"></a>自定义Converter</h3><pre><code>import org.joda.time.DateTime;import org.joda.time.format.DateTimeFormat;import org.joda.time.format.DateTimeFormatter;import org.springframework.core.convert.converter.Converter;import org.springframework.util.StringUtils;import java.util.ArrayList;import java.util.Date;import java.util.List;/** * Created by Rock 2016/12/6. */public class DateConverter implements Converter&lt;String,Date&gt; {private static final List&lt;String&gt; formarts = new ArrayList&lt;&gt;(4);static {    formarts.add(&quot;yyyy-MM&quot;);    formarts.add(&quot;yyyy-MM-dd&quot;);    formarts.add(&quot;yyyy-MM-dd HH:mm&quot;);    formarts.add(&quot;yyyy-MM-dd HH:mm:ss&quot;);}@Overridepublic Date convert(String s) {    if(StringUtils.isEmpty(s)){        return null;    }    try {        String formatter = &quot;&quot;;        if (s.matches(&quot;^\\d{4}-\\d{1,2}$&quot;)) {            formatter = formarts.get(0);        } else if (s.matches(&quot;^\\d{4}-\\d{1,2}-\\d{1,2}$&quot;)) {            formatter = formarts.get(1);        } else if (s.matches(&quot;^\\d{4}-\\d{1,2}-\\d{1,2} {1}\\d{1,2}:\\d{1,2}$&quot;)) {            formatter = formarts.get(2);        } else if (s.matches(&quot;^\\d{4}-\\d{1,2}-\\d{1,2} {1}\\d{1,2}:\\d{1,2}:\\d{1,2}$&quot;)) {            formatter = formarts.get(3);        } else {            throw new IllegalArgumentException(&quot;Invalid boolean value &apos;&quot; + s + &quot;&apos;&quot;);        }        DateFormat dateFormat = new SimpleDateFormat(formatter);        Date date = dateFormat.parse(s);        return date;    } catch (Exception e){        return null;    }}}</code></pre><h3 id="在springmvc-xml里面配置"><a href="#在springmvc-xml里面配置" class="headerlink" title="在springmvc.xml里面配置"></a>在springmvc.xml里面配置</h3><pre><code>&lt;!-- 配置注解驱动，如果配置此标签可以不用配置处理器映射器和适配器  --&gt;&lt;!-- &lt;mvc:annotation-driven /&gt; --&gt;&lt;!-- 加载注解驱动 --&gt;&lt;mvc:annotation-driven conversion-service=&quot;conversionService&quot;/&gt;&lt;!-- 转换器配置 --&gt;&lt;bean id=&quot;conversionService&quot;    class=&quot;org.springframework.format.support.FormattingConversionServiceFactoryBean&quot;&gt;    &lt;property name=&quot;converters&quot;&gt;        &lt;set&gt;            &lt;bean class=&quot;cn.lxm.springmvc.convert.DateConverter&quot;/&gt;        &lt;/set&gt;    &lt;/property&gt;&lt;/bean&gt;</code></pre><h2 id="解决post乱码问题"><a href="#解决post乱码问题" class="headerlink" title="解决post乱码问题"></a>解决post乱码问题</h2><p>在web.xml中加入：</p><pre><code>&lt;filter&gt;    &lt;filter-name&gt;CharacterEncodingFilter&lt;/filter-name&gt;    &lt;filter-class&gt;org.springframework.web.filter.CharacterEncodingFilter&lt;/filter-class&gt;    &lt;init-param&gt;        &lt;param-name&gt;encoding&lt;/param-name&gt;        &lt;param-value&gt;utf-8&lt;/param-value&gt;    &lt;/init-param&gt;&lt;/filter&gt;&lt;filter-mapping&gt;    &lt;filter-name&gt;CharacterEncodingFilter&lt;/filter-name&gt;    &lt;url-pattern&gt;/*&lt;/url-pattern&gt;&lt;/filter-mapping&gt;</code></pre><p>以上可以解决post请求乱码问题。</p><p>对于get请求中文参数出现乱码解决方法有两个：</p><p>修改tomcat配置文件添加编码与工程编码一致，如下：</p><pre><code>&lt;Connector URIEncoding=&quot;utf-8&quot; connectionTimeout=&quot;20000&quot; port=&quot;8080&quot; protocol=&quot;HTTP/1.1&quot; redirectPort=&quot;8443&quot;/&gt;</code></pre><p>另外一种方法对参数进行重新编码：</p><pre><code>String userName new String(request.getParamter(&quot;userName&quot;).getBytes(&quot;ISO8859-1&quot;),&quot;utf-8&quot;)</code></pre><p>ISO8859-1是tomcat默认编码，需要将tomcat编码后的内容按utf-8编码</p>]]></content>
      
      <categories>
          
          <category> SSM </category>
          
      </categories>
      
      
        <tags>
            
            <tag> SpringMVC </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>mybatis五</title>
      <link href="/2018/02/26/mybatis%E4%BA%94/"/>
      <content type="html"><![CDATA[<script src="\assets\js\APlayer.min.js"> </script><h1 id="mybatis整合spring"><a href="#mybatis整合spring" class="headerlink" title="mybatis整合spring"></a>mybatis整合spring</h1><h2 id="整合思路"><a href="#整合思路" class="headerlink" title="整合思路"></a>整合思路</h2><p>1、SqlSessionFactory对象应该放到spring容器中作为单例存在。</p><p>2、传统dao的开发方式中，应该从spring容器中获得sqlsession对象。</p><p>3、Mapper代理形式中，应该从spring容器中直接获得mapper的代理对象。</p><p>4、数据库的连接以及数据库连接池事务管理都交给spring容器来完成。</p><a id="more"></a><h2 id="整合需要的jar包"><a href="#整合需要的jar包" class="headerlink" title="整合需要的jar包"></a>整合需要的jar包</h2><p>1、spring的jar包<br>2、Mybatis的jar包<br>3、Spring+mybatis的整合包。<br>4、Mysql的数据库驱动jar包。<br>5、数据库连接池的jar包。</p><h2 id="整合的步骤"><a href="#整合的步骤" class="headerlink" title="整合的步骤"></a>整合的步骤</h2><p>第一步：创建一个java工程。</p><p>第二步：导入jar包。（上面提到的jar包）</p><p>第三步：mybatis的配置文件SqlMapConfig.xml</p><p>第四步：编写Spring的配置文件</p><pre><code>1、数据库连接及连接池2、事务管理（暂时可以不配置）3、sqlsessionFactory对象，配置到spring容器中4、mapeer代理对象或者是dao实现类配置到spring容器中。</code></pre><p>第五步：编写dao或者mapper文件</p><p>第六步：测试。</p><h3 id="SqlMapConfig-xml"><a href="#SqlMapConfig-xml" class="headerlink" title="SqlMapConfig.xml"></a>SqlMapConfig.xml</h3><pre><code>&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; ?&gt;&lt;!DOCTYPE configurationPUBLIC &quot;-//mybatis.org//DTD Config 3.0//EN&quot;&quot;http://mybatis.org/dtd/mybatis-3-config.dtd&quot;&gt;&lt;configuration&gt;    &lt;typeAliases&gt;        &lt;package name=&quot;cn.lxm.mybatis.pojo&quot;/&gt;    &lt;/typeAliases&gt;    &lt;mappers&gt;        &lt;!-- 使用包扫描扫描mapper.xml            如果在ApplicationContext.xml中配置了扫描包之后,就 不需要此配置         --&gt;        &lt;package name=&quot;cn.lxm.mybatis.mapper&quot;/&gt;    &lt;/mappers&gt;&lt;/configuration&gt;</code></pre><h3 id="applicationContext-xml"><a href="#applicationContext-xml" class="headerlink" title="applicationContext.xml"></a>applicationContext.xml</h3><pre><code>&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot;    xmlns:context=&quot;http://www.springframework.org/schema/context&quot; xmlns:p=&quot;http://www.springframework.org/schema/p&quot;    xmlns:aop=&quot;http://www.springframework.org/schema/aop&quot; xmlns:tx=&quot;http://www.springframework.org/schema/tx&quot;    xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;    xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans-4.0.xsd    http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context-4.0.xsd    http://www.springframework.org/schema/aop http://www.springframework.org/schema/aop/spring-aop-4.0.xsd http://www.springframework.org/schema/tx http://www.springframework.org/schema/tx/spring-tx-4.0.xsd    http://www.springframework.org/schema/util http://www.springframework.org/schema/util/spring-util-4.0.xsd&quot;&gt;    &lt;!-- 加载配置文件 --&gt;    &lt;context:property-placeholder location=&quot;classpath:db.properties&quot; /&gt;    &lt;!-- 数据库连接池 --&gt;    &lt;bean id=&quot;dataSource&quot; class=&quot;org.apache.commons.dbcp.BasicDataSource&quot;        destroy-method=&quot;close&quot;&gt;        &lt;property name=&quot;driverClassName&quot; value=&quot;${jdbc.driver}&quot; /&gt;        &lt;property name=&quot;url&quot; value=&quot;${jdbc.url}&quot; /&gt;        &lt;property name=&quot;username&quot; value=&quot;${jdbc.username}&quot; /&gt;        &lt;property name=&quot;password&quot; value=&quot;${jdbc.password}&quot; /&gt;        &lt;property name=&quot;maxActive&quot; value=&quot;10&quot; /&gt;        &lt;property name=&quot;maxIdle&quot; value=&quot;5&quot; /&gt;    &lt;/bean&gt;    &lt;!-- mapper配置 --&gt;    &lt;!-- 让spring管理sqlsessionfactory 使用mybatis和spring整合包中的 --&gt;    &lt;bean id=&quot;sqlSessionFactory&quot; class=&quot;org.mybatis.spring.SqlSessionFactoryBean&quot;&gt;        &lt;!-- 数据库连接池 --&gt;        &lt;property name=&quot;dataSource&quot; ref=&quot;dataSource&quot; /&gt;        &lt;!-- 加载mybatis的全局配置文件 --&gt;        &lt;property name=&quot;configLocation&quot; value=&quot;classpath:mybatis/SqlMapConfig.xml&quot; /&gt;    &lt;/bean&gt;&lt;/beans&gt;</code></pre><h3 id="db-properties"><a href="#db-properties" class="headerlink" title="db.properties"></a>db.properties</h3><pre><code>jdbc.driver=com.mysql.jdbc.Driverjdbc.url=jdbc:mysql://localhost:3306/mybatis?characterEncoding=utf-8jdbc.username=rootjdbc.password=root</code></pre><h2 id="Dao的开发"><a href="#Dao的开发" class="headerlink" title="Dao的开发"></a>Dao的开发</h2><p>三种dao的实现方式：</p><pre><code>1、传统dao的开发方式2、使用mapper代理形式开发方式3、使用扫描包配置mapper代理。</code></pre><p>这里只介绍第二种和第三种</p><h3 id="Mapper代理形式开发dao"><a href="#Mapper代理形式开发dao" class="headerlink" title="Mapper代理形式开发dao"></a>Mapper代理形式开发dao</h3><h4 id="开发mapper接口"><a href="#开发mapper接口" class="headerlink" title="开发mapper接口"></a>开发mapper接口</h4><p>开发mapper文件</p><p>创建UserMapper.java</p><pre><code>public interface UserMapper {    User findUserById(Integer id) throws Exception;}</code></pre><p>并且在同一目录下创建UserMapper.xml</p><pre><code> &lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; ?&gt;&lt;!DOCTYPE mapperPUBLIC &quot;-//mybatis.org//DTD Mapper 3.0//EN&quot;&quot;http://mybatis.org/dtd/mybatis-3-mapper.dtd&quot;&gt;&lt;mapper namespace=&quot;cn.lxm.mybatis.mapper.UserMapper&quot;&gt;    &lt;!-- 根据id获取用户信息 --&gt;    &lt;select id=&quot;findUserById&quot; parameterType=&quot;int&quot; resultType=&quot;cn.lxm.mybatis.po.User&quot;&gt;        select * from user where id = #{id}    &lt;/select&gt;&lt;/mapper&gt;</code></pre><h4 id="配置mapper代理"><a href="#配置mapper代理" class="headerlink" title="配置mapper代理"></a>配置mapper代理</h4><pre><code>&lt;!-- 配置mapper代理对象 --&gt;&lt;bean class=&quot;org.mybatis.spring.mapper.MapperFactoryBean&quot;&gt;    &lt;property name=&quot;mapperInterface&quot; value=&quot;cn.lxm.mybatis.mapper.UserMapper&quot;/&gt;    &lt;property name=&quot;sqlSessionFactory&quot; ref=&quot;sqlSessionFactory&quot;&gt;&lt;/property&gt;&lt;/bean&gt;</code></pre><h4 id="测试方法"><a href="#测试方法" class="headerlink" title="测试方法"></a>测试方法</h4><pre><code>public class UserMapperTest {    private ApplicationContext applicationContext;    @Before    public void setUp() throws Exception {        applicationContext = new ClassPathXmlApplicationContext(&quot;classpath:spring/applicationContext.xml&quot;);    }    @Test    public void testGetUserById() {        UserMapper userMapper = applicationContext.getBean(UserMapper.class);        User user = userMapper.getUserById(1);        System.out.println(user);    }}</code></pre><h3 id="扫描包形式配置mapper"><a href="#扫描包形式配置mapper" class="headerlink" title="扫描包形式配置mapper"></a>扫描包形式配置mapper</h3><pre><code>&lt;!-- 使用扫描包的形式来创建mapper代理对象 --&gt;&lt;bean class=&quot;org.mybatis.spring.mapper.MapperScannerConfigurer&quot;&gt;    &lt;property name=&quot;basePackage&quot; value=&quot;cn.lxm.mybatis.mapper&quot;&gt;&lt;/property&gt;&lt;/bean&gt;</code></pre><p>如果配置了这个后 ,在SQLMapConfig.xml中的包扫描配置就不需要了</p><h2 id="逆向工程生成代码"><a href="#逆向工程生成代码" class="headerlink" title="逆向工程生成代码"></a>逆向工程生成代码</h2><p>步骤:</p><p>1.导入逆向工程代码,然后修改配置文件generatorConfig.xml</p><pre><code>&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;!DOCTYPE generatorConfiguration  PUBLIC &quot;-//mybatis.org//DTD MyBatis Generator Configuration 1.0//EN&quot;  &quot;http://mybatis.org/dtd/mybatis-generator-config_1_0.dtd&quot;&gt;&lt;generatorConfiguration&gt;    &lt;context id=&quot;testTables&quot; targetRuntime=&quot;MyBatis3&quot;&gt;        &lt;commentGenerator&gt;            &lt;!-- 是否去除自动生成的注释 true：是 ： false:否 --&gt;            &lt;property name=&quot;suppressAllComments&quot; value=&quot;true&quot; /&gt;        &lt;/commentGenerator&gt;        &lt;!--数据库连接的信息：驱动类、连接地址、用户名、密码 --&gt;        &lt;jdbcConnection driverClass=&quot;com.mysql.jdbc.Driver&quot;            connectionURL=&quot;jdbc:mysql://localhost:3306/mybatis&quot; userId=&quot;root&quot;            password=&quot;root&quot;&gt;        &lt;/jdbcConnection&gt;        &lt;!-- &lt;jdbcConnection driverClass=&quot;oracle.jdbc.OracleDriver&quot;            connectionURL=&quot;jdbc:oracle:thin:@127.0.0.1:1521:yycg&quot;             userId=&quot;yycg&quot;            password=&quot;yycg&quot;&gt;        &lt;/jdbcConnection&gt; --&gt;        &lt;!-- 默认false，把JDBC DECIMAL 和 NUMERIC 类型解析为 Integer，为 true时把JDBC DECIMAL 和             NUMERIC 类型解析为java.math.BigDecimal --&gt;        &lt;javaTypeResolver&gt;            &lt;property name=&quot;forceBigDecimals&quot; value=&quot;false&quot; /&gt;        &lt;/javaTypeResolver&gt;        &lt;!-- targetProject:生成PO类的位置 --&gt;        &lt;javaModelGenerator targetPackage=&quot;cn.lxm.mybatis.po&quot;            targetProject=&quot;.\src&quot;&gt;            &lt;!-- enableSubPackages:是否让schema作为包的后缀 --&gt;            &lt;property name=&quot;enableSubPackages&quot; value=&quot;false&quot; /&gt;            &lt;!-- 从数据库返回的值被清理前后的空格 --&gt;            &lt;property name=&quot;trimStrings&quot; value=&quot;true&quot; /&gt;        &lt;/javaModelGenerator&gt;        &lt;!-- targetProject:mapper映射文件生成的位置 --&gt;        &lt;sqlMapGenerator targetPackage=&quot;cn.lxm.mybatis.mapper&quot;             targetProject=&quot;.\src&quot;&gt;            &lt;!-- enableSubPackages:是否让schema作为包的后缀 --&gt;            &lt;property name=&quot;enableSubPackages&quot; value=&quot;false&quot; /&gt;        &lt;/sqlMapGenerator&gt;        &lt;!-- targetPackage：mapper接口生成的位置 --&gt;        &lt;javaClientGenerator type=&quot;XMLMAPPER&quot;            targetPackage=&quot;cn.lxm.mybatis.mapper&quot;             targetProject=&quot;.\src&quot;&gt;            &lt;!-- enableSubPackages:是否让schema作为包的后缀 --&gt;            &lt;property name=&quot;enableSubPackages&quot; value=&quot;false&quot; /&gt;        &lt;/javaClientGenerator&gt;        &lt;!-- 指定数据库表 --&gt;        &lt;table schema=&quot;&quot; tableName=&quot;user&quot;&gt;&lt;/table&gt;        &lt;table schema=&quot;&quot; tableName=&quot;orders&quot;&gt;&lt;/table&gt;        &lt;!-- 有些表的字段需要指定java类型         &lt;table schema=&quot;&quot; tableName=&quot;&quot;&gt;            &lt;columnOverride column=&quot;&quot; javaType=&quot;&quot; /&gt;        &lt;/table&gt; --&gt;    &lt;/context&gt;&lt;/generatorConfiguration&gt;</code></pre>]]></content>
      
      <categories>
          
          <category> SSM </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Mybatis </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>mybatis四</title>
      <link href="/2018/02/25/mybatis%E5%9B%9B/"/>
      <content type="html"><![CDATA[<script src="\assets\js\APlayer.min.js"> </script><h1 id="关联查询"><a href="#关联查询" class="headerlink" title="关联查询"></a>关联查询</h1><h2 id="一对一查询"><a href="#一对一查询" class="headerlink" title="一对一查询"></a>一对一查询</h2><p>这里举例是一个订单对应一个用户</p><h3 id="方法一："><a href="#方法一：" class="headerlink" title="方法一："></a>方法一：</h3><p>使用resultType，定义订单信息po类，此po类中包括了订单信息和用户信息：</p><a id="more"></a><h4 id="Sql语句："><a href="#Sql语句：" class="headerlink" title="Sql语句："></a>Sql语句：</h4><pre><code>SELECT   orders.*,  user.username,  user.addressFROM  orders,  user WHERE orders.user_id = user.id</code></pre><h4 id="定义po类"><a href="#定义po类" class="headerlink" title="定义po类"></a>定义po类</h4><p>Po类中应该包括上边sql查询出来的所有字段，如下：</p><pre><code>public class OrdersCustom extends Orders {private String username;// 用户名称private String address;// 用户地址get/set。。。。</code></pre><p>OrdersCustom类继承Orders类后OrdersCustom类包括了Orders类的所有字段，只需要定义用户的信息字段即可。</p><h4 id="Mapper-xml"><a href="#Mapper-xml" class="headerlink" title="Mapper.xml"></a>Mapper.xml</h4><pre><code>&lt;!-- 查询所有订单信息 --&gt;&lt;select id=&quot;findOrdersList&quot; resultType=&quot;cn.lxm.mybatis.po.OrdersCustom&quot;&gt;SELECTorders.*,user.username,user.addressFROMorders,    userWHERE orders.user_id = user.id &lt;/select&gt;</code></pre><h4 id="Mapper接口："><a href="#Mapper接口：" class="headerlink" title="Mapper接口："></a>Mapper接口：</h4><pre><code>public List&lt;OrdersCustom&gt; findOrdersList() throws Exception;</code></pre><h4 id="测试："><a href="#测试：" class="headerlink" title="测试："></a>测试：</h4><pre><code>Public void testfindOrdersList()throws Exception{    //获取session    SqlSession session = sqlSessionFactory.openSession();    //获限mapper接口实例    UserMapper userMapper = session.getMapper(UserMapper.class);    //查询订单信息    List&lt;OrdersCustom&gt; list = userMapper.findOrdersList();    System.out.println(list);    //关闭session    session.close();}</code></pre><h4 id="小结："><a href="#小结：" class="headerlink" title="小结："></a>小结：</h4><pre><code>定义专门的po类作为输出类型，其中定义了sql查询结果集所有的字段。此方法较为简单，企业中使用普遍。</code></pre><h3 id="方法二："><a href="#方法二：" class="headerlink" title="方法二："></a>方法二：</h3><p>使用resultMap，定义专门的resultMap用于映射一对一查询结果。</p><h4 id="Sql语句：-1"><a href="#Sql语句：-1" class="headerlink" title="Sql语句："></a>Sql语句：</h4><pre><code>SELECT   orders.*,  user.username,  user.addressFROM  orders,  user WHERE orders.user_id = user.id</code></pre><h4 id="定义po类-1"><a href="#定义po类-1" class="headerlink" title="定义po类"></a>定义po类</h4><p>在Orders类中加入User属性，user属性中用于存储关联查询的用户信息，因为订单关联查询用户是一对一关系，所以这里使用单个User对象存储关联查询的用户信息。<br>    public class Orders {<br>    private Integer id;</p><pre><code>private Integer userId;private String number;private Date createtime;private String note;private User user;get/set()...</code></pre><h4 id="Mapper-xml-1"><a href="#Mapper-xml-1" class="headerlink" title="Mapper.xml"></a>Mapper.xml</h4><pre><code>&lt;!-- 查询订单关联用户信息使用resultmap --&gt;&lt;resultMap type=&quot;Orders&quot; id=&quot;orderUserResultMap&quot;&gt;    &lt;id column=&quot;id&quot; property=&quot;id&quot;/&gt;    &lt;result column=&quot;user_id&quot; property=&quot;userId&quot;/&gt;    &lt;result column=&quot;number&quot; property=&quot;number&quot;/&gt;    &lt;result column=&quot;createtime&quot; property=&quot;createtime&quot;/&gt;    &lt;result column=&quot;note&quot; property=&quot;note&quot;/&gt;    &lt;!-- 一对一关联映射 --&gt;    &lt;!--     property:Orders对象的user属性    javaType：user属性对应 的类型     --&gt;    &lt;association property=&quot;user&quot; javaType=&quot;cn.lxm.po.User&quot;&gt;        &lt;!-- column:user表的主键对应的列  property：user对象中id属性--&gt;        &lt;id column=&quot;user_id&quot; property=&quot;id&quot;/&gt;        &lt;result column=&quot;username&quot; property=&quot;username&quot;/&gt;        &lt;result column=&quot;address&quot; property=&quot;address&quot;/&gt;    &lt;/association&gt;&lt;/resultMap&gt;&lt;select id=&quot;findOrdersWithUserResultMap&quot; resultMap=&quot;orderUserResultMap&quot;&gt;    SELECT        o.id,        o.user_id,        o.number,        o.createtime,        o.note,        u.username,        u.address    FROM        orders o    JOIN `user` u ON u.id = o.user_id&lt;/select&gt;</code></pre><p>这里resultMap指定orderUserResultMap。</p><p>association：表示进行关联查询单条记录</p><p>property：表示关联查询的结果存储在cn.lxm.mybatis.po.Orders的user属性中</p><p>javaType：表示关联查询的结果类型</p><p>&lt; id property=”id” column=”user_id”/&gt;：查询结果的user_id列对应关联对象的id属性，这里是&lt; id /&gt;表示user_id是关联查询对象的唯一标识。</p><p>&lt; result property=”username” column=”username”/&gt;：查询结果的username列对应关联对象的username属性。</p><h4 id="Mapper接口：-1"><a href="#Mapper接口：-1" class="headerlink" title="Mapper接口："></a>Mapper接口：</h4><pre><code>public List&lt;Orders&gt; findOrdersListResultMap() throws Exception;</code></pre><h4 id="测试：-1"><a href="#测试：-1" class="headerlink" title="测试："></a>测试：</h4><pre><code>Public void testfindOrdersListResultMap()throws Exception{    //获取session    SqlSession session = sqlSessionFactory.openSession();    //获限mapper接口实例    UserMapper userMapper = session.getMapper(UserMapper.class);    //查询订单信息    List&lt;Orders&gt; list = userMapper.findOrdersList2();    System.out.println(list);    //关闭session    session.close();}</code></pre><h4 id="小结：-1"><a href="#小结：-1" class="headerlink" title="小结："></a>小结：</h4><p>使用association完成关联查询，将关联查询信息映射到pojo对象中。</p><h2 id="一对多查询"><a href="#一对多查询" class="headerlink" title="一对多查询"></a>一对多查询</h2><p>案例：查询所有用户信息及用户关联的订单信息。</p><p>用户信息和订单信息为一对多关系。</p><p>使用resultMap实现如下：</p><h3 id="Sql语句：-2"><a href="#Sql语句：-2" class="headerlink" title="Sql语句："></a>Sql语句：</h3><pre><code>SELECTu.*, o.id oid,o.number,o.createtime,o.noteFROM`user` uLEFT JOIN orders o ON u.id = o.user_id</code></pre><h3 id="定义po类-2"><a href="#定义po类-2" class="headerlink" title="定义po类"></a>定义po类</h3><p>在User类中加入List&lt; Orders&gt; orders属性</p><pre><code>public class User {   private int id;   private String username;// 用户姓名   private String sex;// 性别   private Date birthday;// 生日   private String address;// 地址   private List&lt;Orders&gt; orders;   get/set()...</code></pre><h3 id="Mapper-xml-2"><a href="#Mapper-xml-2" class="headerlink" title="Mapper.xml"></a>Mapper.xml</h3><pre><code>&lt;resultMap type=&quot;user&quot; id=&quot;userOrderResultMap&quot;&gt;    &lt;!-- 用户信息映射 --&gt;    &lt;id property=&quot;id&quot; column=&quot;id&quot;/&gt;    &lt;result property=&quot;username&quot; column=&quot;username&quot;/&gt;    &lt;result property=&quot;birthday&quot; column=&quot;birthday&quot;/&gt;    &lt;result property=&quot;sex&quot; column=&quot;sex&quot;/&gt;    &lt;result property=&quot;address&quot; column=&quot;address&quot;/&gt;    &lt;!-- 一对多关联映射 --&gt;    &lt;collection property=&quot;orders&quot; ofType=&quot;orders&quot;&gt;        &lt;id property=&quot;id&quot; column=&quot;oid&quot;/&gt;              &lt;!--用户id已经在user对象中存在，此处可以不设置--&gt;        &lt;!-- &lt;result property=&quot;userId&quot; column=&quot;id&quot;/&gt; --&gt;        &lt;result property=&quot;number&quot; column=&quot;number&quot;/&gt;        &lt;result property=&quot;createtime&quot; column=&quot;createtime&quot;/&gt;        &lt;result property=&quot;note&quot; column=&quot;note&quot;/&gt;    &lt;/collection&gt;&lt;/resultMap&gt;&lt;select id=&quot;getUserOrderList&quot; resultMap=&quot;userOrderResultMap&quot;&gt;    SELECT    u.*, o.id oid,    o.number,    o.createtime,    o.note    FROM    `user` u    LEFT JOIN orders o ON u.id = o.user_id&lt;/select&gt;</code></pre><p>collection部分定义了用户关联的订单信息。表示关联查询结果集</p><p>property=”orders”：关联查询的结果集存储在User对象的上哪个属性。</p><p>ofType=”orders”：指定关联查询的结果集中的对象类型即List中的对象类型。此处可以使用别名，也可以使用全限定名。</p><p>&lt; id /&gt;及&lt; result/&gt;的意义同一对一查询。</p><h3 id="Mapper接口：-2"><a href="#Mapper接口：-2" class="headerlink" title="Mapper接口："></a>Mapper接口：</h3><pre><code>List&lt;User&gt; getUserOrderList();</code></pre><h3 id="测试"><a href="#测试" class="headerlink" title="测试"></a>测试</h3><pre><code>@Testpublic void getUserOrderList() {    SqlSession session = sqlSessionFactory.openSession();    UserMapper userMapper = session.getMapper(UserMapper.class);    List&lt;User&gt; result = userMapper.getUserOrderList();    for (User user : result) {        System.out.println(user);    }    session.close();}</code></pre>]]></content>
      
      <categories>
          
          <category> SSM </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Mybatis </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>mybatis三</title>
      <link href="/2018/02/25/mybatis%E4%B8%89/"/>
      <content type="html"><![CDATA[<script src="\assets\js\APlayer.min.js"> </script><h1 id="输入映射和输出映射"><a href="#输入映射和输出映射" class="headerlink" title="输入映射和输出映射"></a>输入映射和输出映射</h1><p>Mapper.xml映射文件中定义了操作数据库的sql，每个sql是一个statement，映射文件是mybatis的核心。<br><a id="more"></a></p><h2 id="parameterType-输入类型"><a href="#parameterType-输入类型" class="headerlink" title="parameterType(输入类型)"></a>parameterType(输入类型)</h2><h3 id="传递简单类型"><a href="#传递简单类型" class="headerlink" title="传递简单类型"></a>传递简单类型</h3><p>参考文章 <a href="http://fashionkillyou.xyz/2018/02/24/mybatis入门一/" title="mybatis入门一" target="_blank" rel="noopener">mybatis入门一</a></p><h3 id="传递pojo对象"><a href="#传递pojo对象" class="headerlink" title="传递pojo对象"></a>传递pojo对象</h3><p>Mybatis使用ognl表达式解析对象字段的值，#{}或者${}括号中的值为pojo属性名称。</p><h3 id="传递pojo包装对象"><a href="#传递pojo包装对象" class="headerlink" title="传递pojo包装对象"></a>传递pojo包装对象</h3><p>开发中通过pojo传递查询条件 ，查询条件是综合的查询条件，不仅包括用户查询条件还包括其它的查询条件（比如将用户购买商品信息也作为查询条件），这时可以使用包装对象传递输入参数。<br>Pojo类中包含pojo。</p><p>需求：根据用户名查询用户信息，查询条件放到QueryVo的user属性中。</p><h4 id="QueryVo"><a href="#QueryVo" class="headerlink" title="QueryVo"></a>QueryVo</h4><pre><code>public class QueryVo {    private User user;    public User getUser() {        return user;    }    public void setUser(User user) {        this.user = user;    }}</code></pre><h4 id="Sql语句"><a href="#Sql语句" class="headerlink" title="Sql语句"></a>Sql语句</h4><p>SELECT * FROM user where username like ‘%刘%’</p><h4 id="Mapper文件"><a href="#Mapper文件" class="headerlink" title="Mapper文件"></a>Mapper文件</h4><pre><code>&lt;!-- 使用包装类型查询用户使用ognl从对象中取属性值，如果是包装对象可以使用.操作符来取内容部的属性--&gt;&lt;select id=&quot;findUserByQueryVo&quot; parameterType=&quot;queryvo&quot; resultType=&quot;user&quot;&gt;    SELECT * FROM user where username like &apos;%${user.username}%&apos;&lt;/select&gt;</code></pre><h4 id="接口"><a href="#接口" class="headerlink" title="接口"></a>接口</h4><pre><code> public interface UserMapper{    User findUserById(int id) throws Exception;    void insertUser(User user) throws Exception;    List&lt;User&gt; findUserByQueryVo(QueryVo queryVo) throws Exception;}</code></pre><h4 id="测试方法"><a href="#测试方法" class="headerlink" title="测试方法"></a>测试方法</h4><pre><code>@Testpublic void testFindUserByQueryVo() throws Exception {    SqlSession sqlSession = sessionFactory.openSession();    //获得mapper的代理对象    UserMapper userMapper = sqlSession.getMapper(UserMapper.class);    //创建QueryVo对象    QueryVo queryVo = new QueryVo();    //创建user对象    User user = new User();    user.setUsername(&quot;刘&quot;);    queryVo.setUser(user);    //根据queryvo查询用户    List&lt;User&gt; list = userMapper.findUserByQueryVo(queryVo);    System.out.println(list);    sqlSession.close();}</code></pre><h2 id="resultType-输出类型"><a href="#resultType-输出类型" class="headerlink" title="resultType(输出类型)"></a>resultType(输出类型)</h2><h3 id="输出简单类型"><a href="#输出简单类型" class="headerlink" title="输出简单类型"></a>输出简单类型</h3><p>参考getnow输出日期类型，看下边的例子输出整型：</p><p>Mapper.xml文件</p><pre><code>&lt;!-- 获取用户列表总数 --&gt;&lt;select id=&quot;findUserCount&quot; parameterType=&quot;user&quot; resultType=&quot;int&quot;&gt;   select count(1) from user&lt;/select&gt;</code></pre><p>Mapper接口</p><pre><code>public int findUserCount(User user) throws Exception;</code></pre><p>调用：</p><pre><code>Public void testFindUserCount() throws Exception{    //获取session    SqlSession session = sqlSessionFactory.openSession();    //获取mapper接口实例    UserMapper userMapper = session.getMapper(UserMapper.class);    User user = new User();    user.setUsername(&quot;管理员&quot;);    //传递Hashmap对象查询用户列表    int count = userMapper.findUserCount(user);    //关闭session    session.close();}</code></pre><p>输出简单类型必须查询出来的结果集有一条记录，最终将第一个字段的值转换为输出类型。<br>使用session的selectOne可查询单条记录。</p><h3 id="输出pojo对象"><a href="#输出pojo对象" class="headerlink" title="输出pojo对象"></a>输出pojo对象</h3><p>参考文章 <a href="http://fashionkillyou.xyz/2018/02/24/mybatis入门一/" title="mybatis入门一" target="_blank" rel="noopener">mybatis入门一</a></p><h3 id="输出pojo列表"><a href="#输出pojo列表" class="headerlink" title="输出pojo列表"></a>输出pojo列表</h3><p>参考文章 <a href="http://fashionkillyou.xyz/2018/02/24/mybatis入门一/" title="mybatis入门一" target="_blank" rel="noopener">mybatis入门一</a></p><h2 id="resultMap"><a href="#resultMap" class="headerlink" title="resultMap"></a>resultMap</h2><p>resultType可以指定pojo将查询结果映射为pojo，但需要pojo的属性名和sql查询的列名一致方可映射成功。</p><p>如果sql查询字段名和pojo的属性名不一致，可以通过resultMap将字段名和属性名作一个对应关系 ，resultMap实质上还需要将查询结果映射到pojo对象中。</p><p>resultMap可以实现将查询结果映射为复杂类型的pojo，比如在查询结果映射对象中包括pojo和list实现一对一查询和一对多查询。</p><h3 id="Mapper-xml定义"><a href="#Mapper-xml定义" class="headerlink" title="Mapper.xml定义"></a>Mapper.xml定义</h3><pre><code> &lt;select id=&quot;findUserListResultMap&quot; parameterType=&quot;queryVo&quot; resultMap=&quot;userListResultMap&quot;&gt;    select id id_,username username_,birthday birthday_ from user&lt;/select&gt;</code></pre><p>使用resultMap指定上边定义的personmap。</p><h3 id="定义resultMap"><a href="#定义resultMap" class="headerlink" title="定义resultMap"></a>定义resultMap</h3><p>由于上边的mapper.xml中sql查询列和Users.java类属性不一致，需要定义resultMap：</p><p>userListResultMap将sql查询列和Users.java类属性对应起来</p><pre><code>&lt;!-- type:最终映射的java对象.id:resultMap的唯一标识 --&gt;&lt;resultMap type=&quot;user&quot; id=&quot;userListResultMap&quot;&gt;&lt;!-- id标签:查询结果集的唯一标识列(主键或唯一标识)    column:SQL查询字段名(列名)    property:pojo的属性名    result标签:普通列 --&gt;    &lt;id property=&quot;id&quot; column=&quot;id_&quot;/&gt;    &lt;result property=&quot;username&quot; column=&quot;username_&quot;/&gt;    &lt;result property=&quot;birthday&quot; column=&quot;birthday_&quot;/&gt;&lt;/resultMap&gt;</code></pre><p>&lt; id /&gt;：此属性表示查询结果集的唯一标识，非常重要。如果是多个字段为复合唯一约束则定义多个&lt; id /&gt;。</p><p>Property：表示User类的属性。</p><p>Column：表示sql查询出来的字段名。</p><p>Column和property放在一块儿表示将sql查询出来的字段映射到指定的pojo类属性上。</p><p>&lt; result /&gt;：普通结果，即pojo的属性。</p><h3 id="Mapper接口定义"><a href="#Mapper接口定义" class="headerlink" title="Mapper接口定义"></a>Mapper接口定义</h3><pre><code>public List&lt;User&gt; findUserListResultMap() throws Exception;</code></pre><h1 id="动态sql"><a href="#动态sql" class="headerlink" title="动态sql"></a>动态sql</h1><p>通过mybatis提供的各种标签方法实现动态拼接sql。</p><h2 id="If"><a href="#If" class="headerlink" title="If"></a>If</h2><pre><code>&lt;!-- 传递pojo综合查询用户信息 --&gt;&lt;select id=&quot;findUserList&quot; parameterType=&quot;user&quot; resultType=&quot;user&quot;&gt;    select * from user     where 1=1     &lt;if test=&quot;id!=null and id!=&apos;&apos;&quot;&gt;    and id=#{id}    &lt;/if&gt;    &lt;if test=&quot;username!=null and username!=&apos;&apos;&quot;&gt;    and username like &apos;%${username}%&apos;    &lt;/if&gt;&lt;/select&gt;</code></pre><p>注意要做不等于空字符串校验。</p><h2 id="Where"><a href="#Where" class="headerlink" title="Where"></a>Where</h2><p>上边的sql也可以改为：</p><pre><code>&lt;select id=&quot;findUserList&quot; parameterType=&quot;user&quot; resultType=&quot;user&quot;&gt;    select * from user     &lt;where&gt;    &lt;if test=&quot;id!=null and id!=&apos;&apos;&quot;&gt;    and id=#{id}    &lt;/if&gt;    &lt;if test=&quot;username!=null and username!=&apos;&apos;&quot;&gt;    and username like &apos;%${username}%&apos;    &lt;/if&gt;    &lt;/where&gt;&lt;/select&gt;</code></pre><p>&lt; where /&gt;可以自动处理第一个and。</p><h2 id="foreach"><a href="#foreach" class="headerlink" title="foreach"></a>foreach</h2><p>向sql传递数组或List，mybatis使用foreach解析，如下：</p><p>需求<br>传入多个id查询用户信息，用下边两个sql实现：</p><pre><code>SELECT * FROM USERS WHERE username LIKE &apos;%张%&apos; AND (id =10 OR id =89 OR id=16)SELECT * FROM USERS WHERE username LIKE &apos;%张%&apos;  id IN (10,89,16)</code></pre><p>在pojo中定义list属性ids存储多个用户id，并添加getter/setter方法</p><pre><code> public class QueryVo {    private User user;    private List&lt;Integer&gt; ids;    public List&lt;Integer&gt; getIds() {        return ids;    }    public void setIds(List&lt;Integer&gt; ids) {        this.ids = ids;    }...</code></pre><p>mapper.xml</p><pre><code>&lt;if test=&quot;ids!=null and ids.size&gt;0&quot;&gt;        &lt;foreach collection=&quot;ids&quot; open=&quot; and id in(&quot; close=&quot;)&quot; item=&quot;id&quot; separator=&quot;,&quot; &gt;            #{id}        &lt;/foreach&gt;&lt;/if&gt;</code></pre><p>测试代码：</p><pre><code>List&lt;Integer&gt; ids = new ArrayList&lt;Integer&gt;();    ids.add(1);//查询id为1的用户    ids.add(10); //查询id为10的用户    queryVo.setIds(ids);    List&lt;User&gt; list = userMapper.findUserList(queryVo);</code></pre><h2 id="Sql片段"><a href="#Sql片段" class="headerlink" title="Sql片段"></a>Sql片段</h2><p>Sql中可将重复的sql提取出来，使用时用include引用即可，最终达到sql重用的目的，如下：</p><pre><code>&lt;!-- 传递pojo综合查询用户信息 --&gt;&lt;select id=&quot;findUserList&quot; parameterType=&quot;user&quot; resultType=&quot;user&quot;&gt;    select * from user     &lt;where&gt;    &lt;if test=&quot;id!=null and id!=&apos;&apos;&quot;&gt;    and id=#{id}    &lt;/if&gt;    &lt;if test=&quot;username!=null and username!=&apos;&apos;&quot;&gt;    and username like &apos;%${username}%&apos;    &lt;/if&gt;    &lt;/where&gt;&lt;/select&gt;</code></pre><p>    将where条件抽取出来：</p><pre><code>&lt;sql id=&quot;query_user_where&quot;&gt;    &lt;if test=&quot;id!=null and id!=&apos;&apos;&quot;&gt;        and id=#{id}    &lt;/if&gt;    &lt;if test=&quot;username!=null and username!=&apos;&apos;&quot;&gt;        and username like &apos;%${username}%&apos;    &lt;/if&gt;&lt;/sql&gt;</code></pre><p>    使用include引用：</p><pre><code>&lt;select id=&quot;findUserList&quot; parameterType=&quot;user&quot; resultType=&quot;user&quot;&gt;    select * from user     &lt;where&gt;    &lt;include refid=&quot;query_user_where&quot;/&gt;    &lt;/where&gt;&lt;/select&gt;</code></pre><p>注意：如果引用其它mapper.xml的sql片段，则在引用时需要加上namespace，如下：</p><pre><code>&lt;include refid=&quot;namespace.sql片段”/&gt;</code></pre><p>如果使用 &gt;或者&lt;符号的时候,因为是在xml文件中这些符号都是有特殊含义的,可以使用CDATA区域 &lt;![CDATA[要写的内容]]&gt;       &lt;![CDATA[&gt;]]&gt;大于   &lt;![CDATA[&lt;]]&gt;</p>]]></content>
      
      <categories>
          
          <category> SSM </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Mybatis </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>mybatis二</title>
      <link href="/2018/02/24/mybatis%E4%BA%8C/"/>
      <content type="html"><![CDATA[<script src="\assets\js\APlayer.min.js"> </script><h1 id="Mapper动态代理方式"><a href="#Mapper动态代理方式" class="headerlink" title="Mapper动态代理方式"></a>Mapper动态代理方式</h1><h2 id="开发规范"><a href="#开发规范" class="headerlink" title="开发规范"></a>开发规范</h2><p>Mapper接口开发方法只需要程序员编写Mapper接口（相当于Dao接口），由Mybatis框架根据接口定义创建接口的动态代理对象，代理对象的方法体同上边Dao接口实现类方法。</p><p>Mapper接口开发需要遵循以下规范：<br><a id="more"></a><br>1、    Mapper.xml文件中的namespace与mapper接口的类路径相同。</p><p>2、    Mapper接口方法名和Mapper.xml中定义的每个statement的id相同</p><p>3、    Mapper接口方法的输入参数类型和mapper.xml中定义的每个sql 的parameterType的类型相同</p><p>4、    Mapper接口方法的输出参数类型和mapper.xml中定义的每个sql的resultType的类型相同</p><h2 id="Mapper-xml-映射文件"><a href="#Mapper-xml-映射文件" class="headerlink" title="Mapper.xml(映射文件)"></a>Mapper.xml(映射文件)</h2><p>定义mapper映射文件UserMapper.xml（内容同Users.xml），需要修改namespace的值为 UserMapper接口路径。将UserMapper.xml放在classpath 下mapper目录 下。</p><pre><code>&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; ?&gt;&lt;!DOCTYPE mapperPUBLIC &quot;-//mybatis.org//DTD Mapper 3.0//EN&quot;&quot;http://mybatis.org/dtd/mybatis-3-mapper.dtd&quot;&gt;&lt;mapper namespace=&quot;cn.lxm.mybatis.mapper.UserMapper&quot;&gt;&lt;!-- 根据id获取用户信息 --&gt;&lt;select id=&quot;findUserById&quot; parameterType=&quot;int&quot; resultType=&quot;cn.lxm.mybatis.po.User&quot;&gt;    select * from user where id = #{id}&lt;/select&gt;&lt;!-- 自定义条件查询用户列表 --&gt;&lt;select id=&quot;findUserByUsername&quot; parameterType=&quot;java.lang.String&quot;         resultType=&quot;cn.lxm.mybatis.po.User&quot;&gt;   select * from user where username like &apos;%${value}%&apos; &lt;/select&gt;&lt;!-- 添加用户 --&gt;&lt;insert id=&quot;insertUser&quot; parameterType=&quot;cn.lxm.mybatis.po.User&quot;&gt;&lt;selectKey keyProperty=&quot;id&quot; order=&quot;AFTER&quot; resultType=&quot;java.lang.Integer&quot;&gt;    select LAST_INSERT_ID() &lt;/selectKey&gt;  insert into user(username,birthday,sex,address)   values(#{username},#{birthday},#{sex},#{address})&lt;/insert&gt;&lt;/mapper&gt;</code></pre><h2 id="Mapper-java-接口文件"><a href="#Mapper-java-接口文件" class="headerlink" title="Mapper.java(接口文件)"></a>Mapper.java(接口文件)</h2><pre><code>/** * 用户管理mapper */Public interface UserMapper {//根据用户id查询用户信息public User findUserById(int id) throws Exception;//查询用户列表public List&lt;User&gt; findUserByUsername(String username) throws Exception;//添加用户信息public void insertUser(User user)throws Exception; }</code></pre><p>接口定义有如下特点：</p><p>1、    Mapper接口方法名和Mapper.xml中定义的statement的id相同</p><p>2、    Mapper接口方法的输入参数类型和mapper.xml中定义的statement的parameterType的类型相同</p><p>3、    Mapper接口方法的输出参数类型和mapper.xml中定义的statement的resultType的类型相同</p><h2 id="加载UserMapper-xml文件"><a href="#加载UserMapper-xml文件" class="headerlink" title="加载UserMapper.xml文件"></a>加载UserMapper.xml文件</h2><p>修改SqlMapConfig.xml文件：</p><pre><code>&lt;!-- 加载映射文件 --&gt;&lt;mappers&gt;    &lt;mapper resource=&quot;mapper/UserMapper.xml&quot;/&gt;&lt;/mappers&gt;</code></pre><h2 id="测试"><a href="#测试" class="headerlink" title="测试"></a>测试</h2><pre><code>Public class UserMapperTest extends TestCase {    private SqlSessionFactory sqlSessionFactory;    protected void setUp() throws Exception {        //mybatis配置文件        String resource = &quot;sqlMapConfig.xml&quot;;        InputStream inputStream = Resources.getResourceAsStream(resource);        //使用SqlSessionFactoryBuilder创建sessionFactory        sqlSessionFactory = new SqlSessionFactoryBuilder().build(inputStream);    }    Public void testFindUserById() throws Exception {        //获取session        SqlSession session = sqlSessionFactory.openSession();        //获取mapper接口的代理对象        UserMapper userMapper = session.getMapper(UserMapper.class);        //调用代理对象方法        User user = userMapper.findUserById(1);        System.out.println(user);        //关闭session        session.close();    }    @Test    public void testFindUserByUsername() throws Exception {        SqlSession sqlSession = sqlSessionFactory.openSession();        UserMapper userMapper = sqlSession.getMapper(UserMapper.class);        List&lt;User&gt; list = userMapper.findUserByUsername(&quot;张&quot;);        System.out.println(list.size());    }    Public void testInsertUser() throws Exception {        //获取session        SqlSession session = sqlSessionFactory.openSession();        //获取mapper接口的代理对象        UserMapper userMapper = session.getMapper(UserMapper.class);        //要添加的数据        User user = new User();        user.setUsername(&quot;张三&quot;);        user.setBirthday(new Date());        user.setSex(&quot;1&quot;);        user.setAddress(&quot;北京市&quot;);        //通过mapper接口添加用户        userMapper.insertUser(user);        //提交        session.commit();        //关闭session        session.close();    }}</code></pre><h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><ul><li><p>selectOne和selectList<br>动态代理对象调用sqlSession.selectOne()和sqlSession.selectList()是根据mapper接口方法的返回值决定，如果返回list则调用selectList方法，如果返回单个对象则调用selectOne方法。</p></li><li><p>namespace<br>mybatis官方推荐使用mapper代理方法开发mapper接口，程序员不用编写mapper接口实现类，使用mapper代理方法时，输入参数可以使用pojo包装对象或map对象，保证dao的通用性。</p></li></ul><h2 id="SqlMapConfig-xml配置文件"><a href="#SqlMapConfig-xml配置文件" class="headerlink" title="SqlMapConfig.xml配置文件"></a>SqlMapConfig.xml配置文件</h2><h3 id="配置内容"><a href="#配置内容" class="headerlink" title="配置内容"></a>配置内容</h3><p>SqlMapConfig.xml中配置的内容和顺序如下：</p><pre><code>properties（属性）settings（全局配置参数）typeAliases（类型别名）typeHandlers（类型处理器）objectFactory（对象工厂）plugins（插件）environments（环境集合属性对象）environment（环境子属性对象）transactionManager（事务管理）dataSource（数据源）mappers（映射器）</code></pre><h2 id="properties（属性）"><a href="#properties（属性）" class="headerlink" title="properties（属性）"></a>properties（属性）</h2><p>SqlMapConfig.xml可以引用java属性文件中的配置信息如下：</p><p>在classpath下定义db.properties文件</p><pre><code>jdbc.driver=com.mysql.jdbc.Driverjdbc.url=jdbc:mysql://localhost:3306/mybatis?characterEncoding=utf-8jdbc.username=rootjdbc.password=root</code></pre><p>SqlMapConfig.xml引用如下：</p><pre><code>&lt;properties resource=&quot;db.properties&quot;/&gt;    &lt;environments default=&quot;development&quot;&gt;        &lt;environment id=&quot;development&quot;&gt;            &lt;transactionManager type=&quot;JDBC&quot;/&gt;            &lt;dataSource type=&quot;POOLED&quot;&gt;                &lt;property name=&quot;driver&quot; value=&quot;${jdbc.driver}&quot;/&gt;                &lt;property name=&quot;url&quot; value=&quot;${jdbc.url}&quot;/&gt;                &lt;property name=&quot;username&quot; value=&quot;${jdbc.username}&quot;/&gt;                &lt;property name=&quot;password&quot; value=&quot;${jdbc.password}&quot;/&gt;            &lt;/dataSource&gt;        &lt;/environment&gt;    &lt;/environments&gt;</code></pre><p>注意： MyBatis 将按照下面的顺序来加载属性：</p><ul><li>在 properties 元素体内定义的属性首先被读取。 </li><li>然后会读取properties 元素中resource或 url 加载的属性，它会覆盖已读取的同名属性。 </li></ul><h2 id="typeAliases（类型别名）"><a href="#typeAliases（类型别名）" class="headerlink" title="typeAliases（类型别名）"></a>typeAliases（类型别名）</h2><h3 id="mybatis支持别名："><a href="#mybatis支持别名：" class="headerlink" title="mybatis支持别名："></a>mybatis支持别名：</h3><pre><code>别名    映射的类型_byte     byte _long     long _short     short _int     int _integer     int _double     double _float     float _boolean     boolean string     String byte     Byte long     Long short     Short int     Integer integer     Integer double     Double float     Float boolean     Boolean date     Date decimal     BigDecimal bigdecimal     BigDecimal map    Map</code></pre><h3 id="自定义别名："><a href="#自定义别名：" class="headerlink" title="自定义别名："></a>自定义别名：</h3><p>在SqlMapConfig.xml中配置：<br>    <typealiases><br>        <!-- 单个别名定义 --><br>        <typealias alias="user" type="cn.lxm.mybatis.po.User"><br>        <!-- 批量别名定义，扫描整个包下的类，别名为类名（首字母大写或小写都可以） --><br>        <package name="cn.lxm.mybatis.po"><br>        <package name="其它包"><br>    </package></package></typealias></typealiases><br>这个<typealiases>标签的位置必须放在<environments>标签前面,dtd的约束</environments></typealiases></p><h2 id="mappers（映射器）"><a href="#mappers（映射器）" class="headerlink" title="mappers（映射器）"></a>mappers（映射器）</h2><p>Mapper配置的几种方法：</p><ul><li>&lt; mapper resource=” “ /&gt;</li></ul><p>使用相对于类路径的资源如：</p><pre><code>&lt;mapper resource=&quot;sqlmap/User.xml&quot; /&gt;</code></pre><ul><li>&lt; mapper class=” “ /&gt;</li></ul><p>使用mapper接口类路径如：</p><pre><code>&lt;mapper class=&quot;cn.lxm.mybatis.mapper.UserMapper&quot;/&gt;</code></pre><p>注意：此种方法要求mapper接口名称和mapper映射文件名称相同，且放在同一个目录中。</p><ul><li>&lt; package name=””/&gt;</li></ul><p>注册指定包下的所有mapper接口如：</p><pre><code>&lt;package name=&quot;cn.lxm.mybatis.mapper&quot;/&gt;</code></pre><p>注意：此种方法要求mapper接口名称和mapper映射文件名称相同，且放在同一个目录中。</p>]]></content>
      
      <categories>
          
          <category> SSM </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Mybatis </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>mybatis一</title>
      <link href="/2018/02/24/mybatis%E4%B8%80/"/>
      <content type="html"><![CDATA[<script src="\assets\js\APlayer.min.js"> </script><h1 id="Mybatis入门程序"><a href="#Mybatis入门程序" class="headerlink" title="Mybatis入门程序"></a>Mybatis入门程序</h1><h2 id="1-mybatis下载"><a href="#1-mybatis下载" class="headerlink" title="1 mybatis下载"></a>1 mybatis下载</h2><p>mybaits的代码由github.com管理，地址：<a href="https://github.com/mybatis/mybatis-3/releases" target="_blank" rel="noopener">https://github.com/mybatis/mybatis-3/releases</a><br><a id="more"></a> </p><p>mybatis-3.2.7.jar—-mybatis的核心包<br>lib—-mybatis的依赖包<br>mybatis-3.2.7.pdf—-mybatis使用手册</p><h2 id="2-工程搭建"><a href="#2-工程搭建" class="headerlink" title="2 工程搭建"></a>2 工程搭建</h2><h3 id="第一步：创建java工程"><a href="#第一步：创建java工程" class="headerlink" title="第一步：创建java工程"></a>第一步：创建java工程</h3><p>使用eclipse创建java工程，jdk使用1.7.0_72。</p><h3 id="第二步：加入jar包"><a href="#第二步：加入jar包" class="headerlink" title="第二步：加入jar包"></a>第二步：加入jar包</h3><p>加入mybatis核心包、依赖包、数据驱动包。</p><h3 id="第三步：log4j-properties"><a href="#第三步：log4j-properties" class="headerlink" title="第三步：log4j.properties"></a>第三步：log4j.properties</h3><p>在classpath下创建log4j.properties如下：</p><pre><code># Global logging configurationlog4j.rootLogger=DEBUG, stdout# Console output...log4j.appender.stdout=org.apache.log4j.ConsoleAppenderlog4j.appender.stdout.layout=org.apache.log4j.PatternLayoutlog4j.appender.stdout.layout.ConversionPattern=%5p [%t] - %m%n</code></pre><p>mybatis默认使用log4j作为输出日志信息。</p><h3 id="第四步：SqlMapConfig-xml"><a href="#第四步：SqlMapConfig-xml" class="headerlink" title="第四步：SqlMapConfig.xml"></a>第四步：SqlMapConfig.xml</h3><p>在classpath下创建SqlMapConfig.xml，如下：</p><pre><code>&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; ?&gt;&lt;!DOCTYPE configurationPUBLIC &quot;-//mybatis.org//DTD Config 3.0//EN&quot;&quot;http://mybatis.org/dtd/mybatis-3-config.dtd&quot;&gt;&lt;configuration&gt;&lt;!-- 和spring整合后 environments配置将废除--&gt;&lt;environments default=&quot;development&quot;&gt;    &lt;environment id=&quot;development&quot;&gt;    &lt;!-- 使用jdbc事务管理--&gt;        &lt;transactionManager type=&quot;JDBC&quot; /&gt;    &lt;!-- 数据库连接池--&gt;        &lt;dataSource type=&quot;POOLED&quot;&gt;            &lt;property name=&quot;driver&quot; value=&quot;com.mysql.jdbc.Driver&quot; /&gt;            &lt;property name=&quot;url&quot; value=&quot;jdbc:mysql://localhost:3306/mybatis?characterEncoding=utf-8&quot; /&gt;            &lt;property name=&quot;username&quot; value=&quot;root&quot; /&gt;            &lt;property name=&quot;password&quot; value=&quot;root&quot; /&gt;        &lt;/dataSource&gt;    &lt;/environment&gt;&lt;/environments&gt;&lt;/configuration&gt;</code></pre><p>SqlMapConfig.xml是mybatis核心配置文件，上边文件的配置内容为数据源、事务管理。</p><h3 id="第五步：po类"><a href="#第五步：po类" class="headerlink" title="第五步：po类"></a>第五步：po类</h3><p>Po类作为mybatis进行sql映射使用，po类通常与数据库表对应，User.java如下：</p><pre><code>Public class User {    private int id;    private String username;// 用户姓名    private String sex;// 性别    private Date birthday;// 生日    private String address;// 地址get/set……</code></pre><h3 id="第六步：sql映射文件"><a href="#第六步：sql映射文件" class="headerlink" title="第六步：sql映射文件"></a>第六步：sql映射文件</h3><p>在classpath下的sqlmap目录下创建sql映射文件Users.xml：</p><pre><code>&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; ?&gt;&lt;!DOCTYPE mapperPUBLIC &quot;-//mybatis.org//DTD Mapper 3.0//EN&quot;&quot;http://mybatis.org/dtd/mybatis-3-mapper.dtd&quot;&gt;&lt;mapper namespace=&quot;test&quot;&gt;&lt;/mapper&gt;</code></pre><p>namespace ：命名空间，用于隔离sql语句，后面会讲另一层非常重要的作用。</p><h3 id="第七步：加载映射文件"><a href="#第七步：加载映射文件" class="headerlink" title="第七步：加载映射文件"></a>第七步：加载映射文件</h3><p>mybatis框架需要加载映射文件，将User.xml添加在SqlMapConfig.xml，如下：</p><pre><code>&lt;mappers&gt;    &lt;mapper resource=&quot;sqlmap/User.xml&quot;/&gt;&lt;/mappers&gt;</code></pre><h2 id="3-根据id查询用户信息"><a href="#3-根据id查询用户信息" class="headerlink" title="3 根据id查询用户信息"></a>3 根据id查询用户信息</h2><h3 id="映射文件："><a href="#映射文件：" class="headerlink" title="映射文件："></a>映射文件：</h3><p>在user.xml中添加：</p><pre><code>&lt;!-- 根据id获取用户信息 - -&gt;&lt;select id=&quot;findUserById&quot; parameterType=&quot;int&quot; resultType=&quot;cn.lxm.mybatis.po.User&quot;&gt;    select * from user where id = #{id}&lt;/select&gt;</code></pre><p>parameterType：定义输入到sql中的映射类型，#{id}表示使用preparedstatement设置占位符号并将输入变量id传到sql。<br>resultType：定义结果映射类型。</p><h3 id="测试程序："><a href="#测试程序：" class="headerlink" title="测试程序："></a>测试程序：</h3><pre><code>public class Mybatis_first {    //会话工厂    private SqlSessionFactory sqlSessionFactory;    @Before    public void createSqlSessionFactory() throws IOException {        // 配置文件        String resource = &quot;SqlMapConfig.xml&quot;;        InputStream inputStream = Resources.getResourceAsStream(resource);        // 使用SqlSessionFactoryBuilder从xml配置文件中创建SqlSessionFactory        sqlSessionFactory = new SqlSessionFactoryBuilder()                .build(inputStream);    }    // 根据 id查询用户信息    @Test    public void testFindUserById() {        // 数据库会话实例        SqlSession sqlSession = null;        try {            // 创建数据库会话实例sqlSession            sqlSession = sqlSessionFactory.openSession();            // 查询单个记录，根据用户id查询用户信息            User user = sqlSession.selectOne(&quot;test.findUserById&quot;, 10);            // 输出用户信息            System.out.println(user);        } catch (Exception e) {            e.printStackTrace();        } finally {            if (sqlSession != null) {                sqlSession.close();            }        }    }}</code></pre><h2 id="4-根据用户名查询用户信息"><a href="#4-根据用户名查询用户信息" class="headerlink" title="4 根据用户名查询用户信息"></a>4 根据用户名查询用户信息</h2><h3 id="映射文件：-1"><a href="#映射文件：-1" class="headerlink" title="映射文件："></a>映射文件：</h3><p>在user.xml中添加：</p><pre><code>&lt;!-- 自定义条件查询用户列表  - -&gt;&lt;select id=&quot;findUserByUsername&quot; parameterType=&quot;java.lang.String&quot;         resultType=&quot;cn.lxm.mybatis.po.User&quot;&gt;   select * from user where username like &apos;%${value}%&apos; &lt;/select&gt;</code></pre><p>parameterType：定义输入到sql中的映射类型，${value}表示使用参数将${value}替换，做字符串的拼接。<br>注意：如果是取简单数据类型的参数，括号中的值必须为value<br>resultType：定义结果映射类型。</p><h3 id="测试程序：-1"><a href="#测试程序：-1" class="headerlink" title="测试程序："></a>测试程序：</h3><pre><code>// 根据用户名称模糊查询用户信息@Testpublic void testFindUserByUsername() {    // 数据库会话实例    SqlSession sqlSession = null;    try {        // 创建数据库会话实例sqlSession        sqlSession = sqlSessionFactory.openSession();        // 查询单个记录，根据用户id查询用户信息        List&lt;User&gt; list = sqlSession.selectList(&quot;test.findUserByUsername&quot;, &quot;张&quot;);        System.out.println(list.size());    } catch (Exception e) {        e.printStackTrace();    } finally {        if (sqlSession != null) {            sqlSession.close();        }    }}</code></pre><h1 id="5小结"><a href="#5小结" class="headerlink" title="5小结"></a>5小结</h1><h2 id="和"><a href="#和" class="headerlink" title="#{}和${}"></a>#{}和${}</h2><p>-#{}表示一个占位符号，通过#{}可以实现preparedStatement向占位符中设置值，自动进行java类型和jdbc类型转换，#{}可以有效防止sql注入。 #{}可以接收简单类型值或pojo属性值。 如果parameterType传输单个简单类型值，#{}括号中可以是value或其它名称。</p><p>-${}表示拼接sql串，通过${}可以将parameterType 传入的内容拼接在sql中且不进行jdbc类型转换， ${}可以接收简单类型值或pojo属性值，如果parameterType传输单个简单类型值，${}括号中只能是value。</p><h2 id="parameterType和resultType"><a href="#parameterType和resultType" class="headerlink" title="parameterType和resultType"></a>parameterType和resultType</h2><p>parameterType：指定输入参数类型，mybatis通过ognl从输入对象中获取参数值拼接在sql中。<br>resultType：指定输出结果类型，mybatis将sql查询结果的一行记录数据映射为resultType指定类型的对象。</p><h2 id="selectOne和selectList"><a href="#selectOne和selectList" class="headerlink" title="selectOne和selectList"></a>selectOne和selectList</h2><p>selectOne查询一条记录，如果使用selectOne查询多条记录则抛出异常：<br>    org.apache.ibatis.exceptions.TooManyResultsException: Expected one result (or null) to be returned by selectOne(), but found: 3<br>    at org.apache.ibatis.session.defaults.DefaultSqlSession.selectOne(DefaultSqlSession.java:70)</p><p>selectList可以查询一条或多条记录。</p><h1 id="6添加用户"><a href="#6添加用户" class="headerlink" title="6添加用户"></a>6添加用户</h1><h2 id="映射文件：-2"><a href="#映射文件：-2" class="headerlink" title="映射文件："></a>映射文件：</h2><p>在SqlMapConfig.xml中添加：<br><!-- 添加用户 --><br>    <insert id="insertUser" parametertype="cn.lxm.mybatis.po.User"><br>      insert into user(username,birthday,sex,address)<br>      values(#{username},#{birthday},#{sex},#{address})<br>    </insert></p><h2 id="测试程序：-2"><a href="#测试程序：-2" class="headerlink" title="测试程序："></a>测试程序：</h2><pre><code>// 添加用户信息@Testpublic void testInsert() {    // 数据库会话实例    SqlSession sqlSession = null;    try {        // 创建数据库会话实例sqlSession        sqlSession = sqlSessionFactory.openSession();        // 添加用户信息        User user = new User();        user.setUsername(&quot;张小明&quot;);        user.setAddress(&quot;河南郑州&quot;);        user.setSex(&quot;1&quot;);        user.setPrice(1999.9f);        sqlSession.insert(&quot;test.insertUser&quot;, user);        //提交事务        sqlSession.commit();    } catch (Exception e) {        e.printStackTrace();    } finally {        if (sqlSession != null) {            sqlSession.close();        }    }}</code></pre><h2 id="mysql自增主键返回"><a href="#mysql自增主键返回" class="headerlink" title="mysql自增主键返回"></a>mysql自增主键返回</h2><p>通过修改sql映射文件，可以将mysql自增主键返回:</p><pre><code>&lt;insert id=&quot;insertUser&quot; parameterType=&quot;cn.lxm.mybatis.po.User&quot;&gt;    &lt;!-- selectKey将主键返回，需要再返回 使用user.getId()获取返回的id值 --&gt;    &lt;selectKey keyProperty=&quot;id&quot; order=&quot;AFTER&quot; resultType=&quot;java.lang.Integer&quot;&gt;        select LAST_INSERT_ID()    &lt;/selectKey&gt;   insert into user(username,birthday,sex,address)    values(#{username},#{birthday},#{sex},#{address});&lt;/insert&gt;</code></pre><p>添加selectKey实现将主键返回</p><p>keyProperty:返回的主键存储在pojo中的哪个属性</p><p>order：selectKey的执行顺序，是相对与insert语句来说，由于mysql的自增原理执行完insert语句之后才将主键生成，所以这里selectKey的执行顺序为after</p><p>resultType:返回的主键是什么类型</p><p>LAST_INSERT_ID():是mysql的函数，返回auto_increment自增列新记录id值。</p><h2 id="oracle自增主键返回"><a href="#oracle自增主键返回" class="headerlink" title="oracle自增主键返回"></a>oracle自增主键返回</h2><pre><code>&lt;insert id=&quot;insertUser&quot; parameterType=&quot;cn.lxm.mybatis.po.User&quot;&gt;    &lt;!-- selectKey将主键返回，需要再返回 --&gt;    &lt;selectKey keyProperty=&quot;id&quot; order=&quot;BEFORE&quot; resultType=&quot;java.lang.Integer&quot;&gt;        select 序列的.nextval()    &lt;/selectKey&gt;   insert into user(id,username,birthday,sex,address)    values(#{id},#{username},#{birthday},#{sex},#{address});&lt;/insert&gt;</code></pre><p>oracle的不是很常用,这里是需要先取出序列里面的主键,然后再插入数据,插入的时候讲取出来的主键放进去.所以这里的order是BEFORE</p><h2 id="Mysql使用-uuid实现主键"><a href="#Mysql使用-uuid实现主键" class="headerlink" title="Mysql使用 uuid实现主键"></a>Mysql使用 uuid实现主键</h2><p>需要增加通过select uuid()得到uuid值</p><pre><code>&lt;insert  id=&quot;insertUser&quot; parameterType=&quot;cn.lxm.mybatis.po.User&quot;&gt;&lt;selectKey resultType=&quot;java.lang.String&quot; order=&quot;BEFORE&quot; keyProperty=&quot;id&quot;&gt;select uuid()&lt;/selectKey&gt;insert into user(id,username,birthday,sex,address)          values(#{id},#{username},#{birthday},#{sex},#{address})&lt;/insert&gt;</code></pre><p>注意这里使用的order是“BEFORE”</p><h1 id="7删除用户"><a href="#7删除用户" class="headerlink" title="7删除用户"></a>7删除用户</h1><h2 id="映射文件：-3"><a href="#映射文件：-3" class="headerlink" title="映射文件："></a>映射文件：</h2><!-- 删除用户 --><pre><code>&lt;delete id=&quot;deleteUserById&quot; parameterType=&quot;int&quot;&gt;    delete from user where id=#{id}&lt;/delete&gt;</code></pre><h2 id="测试程序：-3"><a href="#测试程序：-3" class="headerlink" title="测试程序："></a>测试程序：</h2><pre><code>// 根据id删除用户@Testpublic void testDelete() {    // 数据库会话实例    SqlSession sqlSession = null;    try {        // 创建数据库会话实例sqlSession        sqlSession = sqlSessionFactory.openSession();        // 删除用户        sqlSession.delete(&quot;test.deleteUserById&quot;,18);        // 提交事务        sqlSession.commit();    } catch (Exception e) {        e.printStackTrace();    } finally {        if (sqlSession != null) {            sqlSession.close();        }    }}</code></pre><h1 id="8修改用户"><a href="#8修改用户" class="headerlink" title="8修改用户"></a>8修改用户</h1><h2 id="映射文件"><a href="#映射文件" class="headerlink" title="映射文件"></a>映射文件</h2><!-- 更新用户 --><pre><code>&lt;update id=&quot;updateUser&quot; parameterType=&quot;cn.lxm.mybatis.po.User&quot;&gt;    update user set username=#{username},birthday=#{birthday},sex=#{sex},address=#{address}    where id=#{id}&lt;/update&gt;</code></pre><h2 id="测试程序"><a href="#测试程序" class="headerlink" title="测试程序"></a>测试程序</h2><pre><code>// 更新用户信息@Testpublic void testUpdate() {    // 数据库会话实例    SqlSession sqlSession = null;    try {        // 创建数据库会话实例sqlSession        sqlSession = sqlSessionFactory.openSession();        // 添加用户信息        User user = new User();        user.setId(16);        user.setUsername(&quot;张小明&quot;);        user.setAddress(&quot;河南郑州&quot;);        user.setSex(&quot;1&quot;);        user.setPrice(1999.9f);        sqlSession.update(&quot;test.updateUser&quot;, user);        // 提交事务        sqlSession.commit();    } catch (Exception e) {        e.printStackTrace();    } finally {        if (sqlSession != null) {            sqlSession.close();        }    }}</code></pre><h1 id="9-Mybatis解决jdbc编程的问题"><a href="#9-Mybatis解决jdbc编程的问题" class="headerlink" title="9 Mybatis解决jdbc编程的问题"></a>9 Mybatis解决jdbc编程的问题</h1><ul><li>1、    数据库链接创建、释放频繁造成系统资源浪费从而影响系统性能，如果使用数据库链接池可解决此问题。<br>解决：在SqlMapConfig.xml中配置数据链接池，使用连接池管理数据库链接。</li><li>2、    Sql语句写在代码中造成代码不易维护，实际应用sql变化的可能较大，sql变动需要改变java代码。<br>解决：将Sql语句配置在XXXXmapper.xml文件中与java代码分离。</li><li>3、    向sql语句传参数麻烦，因为sql语句的where条件不一定，可能多也可能少，占位符需要和参数一一对应。<br>解决：Mybatis自动将java对象映射至sql语句，通过statement中的parameterType定义输入参数的类型。</li><li>4、    对结果集解析麻烦，sql变化导致解析代码变化，且解析前需要遍历，如果能将数据库记录封装成pojo对象解析比较方便。<br>解决：Mybatis自动将sql执行结果映射至java对象，通过statement中的resultType定义输出结果的类型。</li></ul><h1 id="10-mybatis与hibernate不同"><a href="#10-mybatis与hibernate不同" class="headerlink" title="10 mybatis与hibernate不同"></a>10 mybatis与hibernate不同</h1><ul><li><p>Mybatis和hibernate不同，它不完全是一个ORM框架，因为MyBatis需要程序员自己编写Sql语句，不过mybatis可以通过XML或注解方式灵活配置要运行的sql语句，并将java对象和sql语句映射生成最终执行的sql，最后将sql执行的结果再映射生成java对象。</p></li><li><p>Mybatis学习门槛低，简单易学，程序员直接编写原生态sql，可严格控制sql执行性能，灵活度高，非常适合对关系数据模型要求不高的软件开发，例如互联网软件、企业运营类软件等，因为这类软件需求变化频繁，一但需求变化要求成果输出迅速。但是灵活的前提是mybatis无法做到数据库无关性，如果需要实现支持多种数据库的软件则需要自定义多套sql映射文件，工作量大。</p></li><li><p>Hibernate对象/关系映射能力强，数据库无关性好，对于关系模型要求高的软件（例如需求固定的定制化软件）如果用hibernate开发可以节省很多代码，提高效率。但是Hibernate的学习门槛高，要精通门槛更高，而且怎么设计O/R映射，在性能和对象模型之间如何权衡，以及怎样用好Hibernate需要具有很强的经验和能力才行。</p></li><li><p>总之，按照用户的需求在有限的资源环境下只要能做出维护性、扩展性良好的软件架构都是好架构，所以框架只有适合才是最好。</p></li></ul>]]></content>
      
      <categories>
          
          <category> SSM </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Mybatis </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>webService天气预报接口</title>
      <link href="/2018/02/11/webService%E5%A4%A9%E6%B0%94%E9%A2%84%E6%8A%A5%E6%8E%A5%E5%8F%A3/"/>
      <content type="html"><![CDATA[<script src="\assets\js\APlayer.min.js"> </script><p>一：环境搭建<br>二：根据wsdl文件生成客户端代码<br>三：测试代码<br><a id="more"></a></p><h1 id="一：环境搭建"><a href="#一：环境搭建" class="headerlink" title="一：环境搭建"></a>一：环境搭建</h1><pre><code>1：新建一个java project工程weatherInf2：引入相应的jar包activation.jaraxis-ant.jaraxis.jarcommons-discovery-0.2.jarcommons-logging-1.0.4.jarjaxrpc.jarlog4j-1.2.8.jarmail.jarsaaj.jarwsdl4j-1.5.1.jar下载axis 1.4 src压缩包，解压后到webapp/web-info/lib下取包，具体路径如下：http://download.csdn.net/detail/yyg64/5351114其中mail.jar 以及 activation.jar 可到如下路径下载：http://download.csdn.net/detail/dbhunter/3982583：将天气预报接口wsdl文件拷贝到src目录下http://www.webxml.com.cn/WebServices/WeatherWebService.asmx?wsdl</code></pre><h1 id="二：根据wsdl文件生成客户端代码"><a href="#二：根据wsdl文件生成客户端代码" class="headerlink" title="二：根据wsdl文件生成客户端代码"></a>二：根据wsdl文件生成客户端代码</h1><p>wsdl文件——右键——web services——Generate Client，然后一路next到finish。</p><h1 id="三：测试代码"><a href="#三：测试代码" class="headerlink" title="三：测试代码"></a>三：测试代码</h1><pre><code> 1 /** 2  *  3  */ 4 package com.paic.services; 5  6 import java.rmi.RemoteException; 7  8 import javax.xml.rpc.ServiceException; 9 10 import cn.com.WebXml.WeatherWebServiceLocator;11 import cn.com.WebXml.WeatherWebServiceSoapStub;12 13 /**14  * @author Administrator15  * 16  */17 public class TestWeather {18     public static void main(String[] args) throws ServiceException,19             RemoteException {20         WeatherWebServiceLocator locator = new WeatherWebServiceLocator();21         WeatherWebServiceSoapStub service = (WeatherWebServiceSoapStub) locator22                 .getPort(WeatherWebServiceSoapStub.class);23         invokeGetSupportProvince(service);24         System.out.println(&quot;...................&quot;);25         invokeGetSupportCity(service);26         invokeGetWeatherByOneCity(service);27     }28 29     // 调用获取支持的省份、州接口30     public static void invokeGetSupportProvince(31             WeatherWebServiceSoapStub service) throws RemoteException {32         String[] provices = service.getSupportProvince();33         System.out.println(&quot;总共&quot; + provices.length + &quot;个&quot;);34         int count = 0;35         for (String str : provices) {36             if (0 != count &amp;&amp; count % 5 == 0) {37                 System.out.println();38             }39             System.out.print(str + &quot;\t&quot;);40             count++;41         }42     }43 44     // 调用获取支持查询某个省份内的城市接口45     public static void invokeGetSupportCity(WeatherWebServiceSoapStub service)46             throws RemoteException {47         String provinceName = &quot;江苏&quot;;48         String[] cities = service.getSupportCity(provinceName);49         System.out.println(&quot;总共&quot; + cities.length + &quot;个市&quot;);50         for (int i = 0; i &lt; cities.length; i++) {51             if (0 != i &amp;&amp; i % 5 == 0) {52                 System.out.println();53             }54             System.out.print(cities[i] + &quot;\t&quot;);55         }56     }57 58     // 调用查询某个城市天气的接口59     public static void invokeGetWeatherByOneCity(60             WeatherWebServiceSoapStub service) throws RemoteException {61         String cityName = &quot;南京&quot;;62         String[] weatherInfo = service.getWeatherbyCityName(cityName);63         for (String str : weatherInfo) {64             System.out.println(str);65         }66     }67 }</code></pre>]]></content>
      
      <categories>
          
          <category> 前端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> webservice </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Quarze入门知识</title>
      <link href="/2018/02/10/Quarze%E5%85%A5%E9%97%A8%E7%9F%A5%E8%AF%86/"/>
      <content type="html"><![CDATA[<script src="\assets\js\APlayer.min.js"> </script><h1 id="Quartz-入门详解"><a href="#Quartz-入门详解" class="headerlink" title="Quartz 入门详解"></a>Quartz 入门详解</h1><h2 id="入门简介："><a href="#入门简介：" class="headerlink" title="入门简介："></a>入门简介：</h2><p>基本上任何公司都会用到调度这个功能， 比如我们公司需要定期执行调度生成报表， 或者比如博客什么的定时更新之类的，都可以靠Quartz来完成。正如官网所说，小到独立应用大到大型电子商务网站， Quartz都能胜任。</p><a id="more"></a><h2 id="Quartz体系结构："><a href="#Quartz体系结构：" class="headerlink" title="Quartz体系结构："></a>Quartz体系结构：</h2><p>明白Quartz怎么用，首先要了解Scheduler(调度器)、Job(任务)和Trigger(触发器)这3个核心的概念。</p><h3 id="1-Job："><a href="#1-Job：" class="headerlink" title="1. Job："></a>1. Job：</h3><p>是一个接口，只定义一个方法execute(JobExecutionContext context)，在实现接口的execute方法中编写所需要定时执行的Job(任务)， JobExecutionContext类提供了调度应用的一些信息。Job运行时的信息保存在JobDataMap实例中；</p><h3 id="2-JobDetail："><a href="#2-JobDetail：" class="headerlink" title="2. JobDetail："></a>2. JobDetail：</h3><p>Quartz每次调度Job时， 都重新创建一个Job实例， 所以它不直接接受一个Job的实例，相反它接收一个Job实现类(JobDetail:描述Job的实现类及其它相关的静态信息，如Job名字、描述、关联监听器等信息)，以便运行时通过newInstance()的反射机制实例化Job。</p><h3 id="3-Trigger："><a href="#3-Trigger：" class="headerlink" title="3. Trigger："></a>3. Trigger：</h3><p>是一个类，描述触发Job执行的时间触发规则。主要有SimpleTrigger和CronTrigger这两个子类。当且仅当需调度一次或者以固定时间间隔周期执行调度，SimpleTrigger是最适合的选择；而CronTrigger则可以通过Cron表达式定义出各种复杂时间规则的调度方案：如工作日周一到周五的15：00~16：00执行调度等；</p><h4 id="Cron表达式的格式："><a href="#Cron表达式的格式：" class="headerlink" title="Cron表达式的格式："></a>Cron表达式的格式：</h4><pre><code>秒 分 时 日 月 周 年(可选)。字段名                 允许的值                        允许的特殊字符秒                         0-59                               , – * /分                         0-59                               , – * /小时                   0-23                                 , – * /日                         1-31                               , – * ? / L W C月                         1-12 or JAN-DEC           , – * /周几                     1-7 or SUN-SAT             , – * ? / L C #      MON  FRI年 (可选字段)     empty, 1970-2099            , – * /“?”字符：表示不确定的值“,”字符：指定数个值“-”字符：指定一个值的范围“/”字符：指定一个值的增加幅度。n/m表示从n开始，每次增加m“L”字符：用在日表示一个月中的最后一天，用在周表示该月最后一个星期X“W”字符：指定离给定日期最近的工作日(周一到周五)“#”字符：表示该月第几个周X。6#3表示该月第3个周五Cron表达式范例：每隔5秒执行一次：*/5 * * * * ?每隔1分钟执行一次：0 */1 * * * ?每天23点执行一次：0 0 23 * * ?每天凌晨1点执行一次：0 0 1 * * ?每月1号凌晨1点执行一次：0 0 1 1 * ?每月最后一天23点执行一次：0 0 23 L * ?每周星期天凌晨1点实行一次：0 0 1 ? * L在26分、29分、33分执行一次：0 26,29,33 * * * ?每天的0点、13点、18点、21点都执行一次：0 0 0,13,18,21 * * ?</code></pre><h3 id="4-Calendar："><a href="#4-Calendar：" class="headerlink" title="4. Calendar："></a>4. Calendar：</h3><p>org.quartz.Calendar和java.util.Calendar不同， 它是一些日历特定时间点的集合（可以简单地将org.quartz.Calendar看作java.util.Calendar的集合——java.util.Calendar代表一个日历时间点，无特殊说明后面的Calendar即指org.quartz.Calendar）。 一个Trigger可以和多个Calendar关联， 以便排除或包含某些时间点。<br>假设，我们安排每周星期一早上10:00执行任务，但是如果碰到法定的节日，任务则不执行，这时就需要在Trigger触发机制的基础上使用Calendar进行定点排除。针对不同时间段类型，Quartz在org.quartz.impl.calendar包下提供了若干个Calendar的实现类，如AnnualCalendar、MonthlyCalendar、WeeklyCalendar分别针对每年、每月和每周进行定义；</p><h3 id="5-Scheduler："><a href="#5-Scheduler：" class="headerlink" title="5. Scheduler："></a>5. Scheduler：</h3><p>代表一个Quartz的独立运行容器， Trigger和JobDetail可以注册到Scheduler中， 两者在Scheduler中拥有各自的组及名称， 组及名称是Scheduler查找定位容器中某一对象的依据， Trigger的组及名称必须唯一， JobDetail的组和名称也必须唯一（但可以和Trigger的组和名称相同，因为它们是不同类型的）。Scheduler定义了多个接口方法， 允许外部通过组及名称访问和控制容器中Trigger和JobDetail。<br>Scheduler可以将Trigger绑定到某一JobDetail中， 这样当Trigger触发时， 对应的Job就被执行。一个Job可以对应多个Trigger， 但一个Trigger只能对应一个Job。可以通过SchedulerFactory创建一个Scheduler实例。Scheduler拥有一个SchedulerContext，它类似于ServletContext，保存着Scheduler上下文信息，Job和Trigger都可以访问SchedulerContext内的信息。SchedulerContext内部通过一个Map，以键值对的方式维护这些上下文数据，SchedulerContext为保存和获取数据提供了多个put()和getXxx()的方法。可以通过Scheduler# getContext()获取对应的SchedulerContext实例；</p><h3 id="6-ThreadPool："><a href="#6-ThreadPool：" class="headerlink" title="6. ThreadPool："></a>6. ThreadPool：</h3><p>Scheduler使用一个线程池作为任务运行的基础设施，任务通过共享线程池中的线程提高运行效率。<br>Job有一个StatefulJob子接口，代表有状态的任务，该接口是一个没有方法的标签接口，其目的是让Quartz知道任务的类型，以便采用不同的执行方案。无状态任务在执行时拥有自己的JobDataMap拷贝，对JobDataMap的更改不会影响下次的执行。而有状态任务共享共享同一个JobDataMap实例，每次任务执行对JobDataMap所做的更改会保存下来，后面的执行可以看到这个更改，也即每次执行任务后都会对后面的执行发生影响。<br>正因为这个原因，无状态的Job可以并发执行，而有状态的StatefulJob不能并发执行，这意味着如果前次的StatefulJob还没有执行完毕，下一次的任务将阻塞等待，直到前次任务执行完毕。有状态任务比无状态任务需要考虑更多的因素，程序往往拥有更高的复杂度，因此除非必要，应该尽量使用无状态的Job。<br>如果Quartz使用了数据库持久化任务调度信息，无状态的JobDataMap仅会在Scheduler注册任务时保持一次，而有状态任务对应的JobDataMap在每次执行任务后都会进行保存。<br>Trigger自身也可以拥有一个JobDataMap，其关联的Job可以通过JobExecutionContext#getTrigger().getJobDataMap()获取Trigger中的JobDataMap。不管是有状态还是无状态的任务，在任务执行期间对Trigger的JobDataMap所做的更改都不会进行持久，也即不会对下次的执行产生影响。<br>Quartz拥有完善的事件和监听体系，大部分组件都拥有事件，如任务执行前事件、任务执行后事件、触发器触发前事件、触发后事件、调度器开始事件、关闭事件等等，可以注册相应的监听器处理感兴趣的事件。<br>下图描述了Scheduler的内部组件结构，SchedulerContext提供Scheduler全局可见的上下文信息，每一个任务都对应一个JobDataMap，虚线表达的JobDataMap表示对应有状态的任务：</p><p>废话不多说， 上代码：</p><ol><li><p>最简单的Job代码(就打印Hello Quartz ！)：<br> package com.wenniuwuren.quartz;  </p><p> import org.quartz.Job;<br> import org.quartz.JobExecutionContext;<br> import org.quartz.JobExecutionException;  </p><p> public class HelloQuartz  implements Job {  </p><p> public void execute(JobExecutionContext arg0) throws JobExecutionException {  </p><pre><code>System.out.println(&quot;Hello Quartz !&quot;);                 </code></pre><p> }<br> }</p></li><li><p>设置触发器<br> package com.wenniuwuren.quartz;  </p><p> import org.quartz.CronScheduleBuilder;<br> import org.quartz.JobBuilder;<br> import org.quartz.JobDetail;<br> import org.quartz.Scheduler;<br> import org.quartz.SchedulerException;<br> import org.quartz.SchedulerFactory;<br> import org.quartz.SimpleScheduleBuilder;<br> import org.quartz.Trigger;<br> import org.quartz.TriggerBuilder;<br> import org.quartz.impl.StdSchedulerFactory;    </p><p> public class SchedulerTest {    </p><pre><code>public static void main(String[] args) throws InterruptedException {    //通过schedulerFactory获取一个调度器    SchedulerFactory schedulerfactory = new StdSchedulerFactory();    Scheduler scheduler=null;    try{        // 通过schedulerFactory获取一个调度器        scheduler = schedulerfactory.getScheduler();         // 创建jobDetail实例，绑定Job实现类         // 指明job的名称，所在组的名称，以及绑定job类        JobDetail job = JobBuilder.newJob(HelloQuartz.class).withIdentity(&quot;JobName&quot;, &quot;JobGroupName&quot;).build();         // 定义调度触发规则         // SimpleTrigger    //      Trigger trigger=TriggerBuilder.newTrigger().withIdentity(&quot;SimpleTrigger&quot;, &quot;SimpleTriggerGroup&quot;)     //                    .withSchedule(SimpleScheduleBuilder.repeatSecondlyForever(3).withRepeatCount(6))     //                    .startNow().build();         //  corn表达式  每五秒执行一次         Trigger trigger=TriggerBuilder.newTrigger().withIdentity(&quot;CronTrigger1&quot;, &quot;CronTriggerGroup&quot;)           .withSchedule(CronScheduleBuilder.cronSchedule(&quot;*/5 * * * * ?&quot;))           .startNow().build();          // 把作业和触发器注册到任务调度中        scheduler.scheduleJob(job, trigger);        // 启动调度        scheduler.start();        Thread.sleep(10000);      // 停止调度      scheduler.shutdown();   }catch(SchedulerException e){            e.printStackTrace();        }        }     }</code></pre><p>输出(设置了sleep10秒， 故在0秒调度一次， 5秒一次， 10秒最后一次)：</p></li></ol>]]></content>
      
      <categories>
          
          <category> java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> quarze </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Oracle知识点总结</title>
      <link href="/2018/02/10/Oracle%E7%9F%A5%E8%AF%86%E7%82%B9%E6%80%BB%E7%BB%93/"/>
      <content type="html"><![CDATA[<script src="\assets\js\APlayer.min.js"> </script><h1 id="ORACLE"><a href="#ORACLE" class="headerlink" title="ORACLE"></a>ORACLE</h1><h2 id="01-单表查询-简单条件和去重"><a href="#01-单表查询-简单条件和去重" class="headerlink" title="01.单表查询-简单条件和去重"></a>01.单表查询-简单条件和去重</h2><h3 id="Oracle-的简单查询和去重"><a href="#Oracle-的简单查询和去重" class="headerlink" title="Oracle 的简单查询和去重"></a>Oracle 的简单查询和去重</h3><p>（1）–精确查询</p><p>–需求：查询水表编号为 30408 的业主记录<br>select * from T_OWNERS where watermeter = ‘30408’;</p><p>（2）–模糊查询</p><p>–需求：查询业主名称包含“刘”的业主记录<br>select * from T_OWNERS where name like ‘%刘%’;<br><a id="more"></a>  </p><p>（3）–and 运算符</p><p>–需求：查询业主名称包含“刘”的并且门牌号包含 5 的业主记录<br>select * from T_OWNERS where name like ‘%刘%’ and housenumber like ‘%5%’;</p><p>（4）–or 运算符</p><p>–需求：查询业主名称包含“刘”的或者门牌号包含 5 的业主记录<br>select * from T_OWNERS where name like ‘%刘%’ or housenumber like ‘%5%’;</p><p>（5）–and 与 or 运算符混合使用</p><p>–需求：查询业主名称包含“刘”的或者门牌号包含 5 的业主记录，并且地址编号为 3 的记录。<br>select * from T_OWNERS where (name like ‘%刘%’ or housenumber like ‘%5%’) and addressid = 3</p><p>（6）–范围查询</p><p>–需求：查询台账记录中用水字数大于等于 10000，并且小于等于 20000 的记录我们可以用&gt;= 和&lt;=来实现，语句<br>select <em> from T_ACCOUNT where usenum&gt;=10000 and usenum &lt;=20000<br>select </em> from T_ACCOUNT where usenum between 10000 and 20000</p><p>（7）–空值查询</p><p>–需求：查询 T_PRICETABLE 表中 MAXNUM 为空的记录<br>select <em> from T_PRICETABLE where maxnum is null<br>–不为空<br>select </em> from T_PRICETABLE where maxnum is not null</p><p>（8）–去掉重复记录</p><p>–需求：查询业主表中的地址 ID,不重复显示<br>select distinct addressid from T_OWNERS  </p><h2 id="02-单表查询-排序和基于伪列查询（开发中经常用到必须掌握）"><a href="#02-单表查询-排序和基于伪列查询（开发中经常用到必须掌握）" class="headerlink" title="02.单表查询-排序和基于伪列查询（开发中经常用到必须掌握）"></a>02.单表查询-排序和基于伪列查询（开发中经常用到必须掌握）</h2><p>   要点：排序和伪列</p><p>（1）–排序查询</p><p>–需求：对 T_ACCOUNT 表按使用量进行升序排序(由小到大)<br>select <em> from T_ACCOUNT order by usenum asc –asc可以省略<br>–降序排序<br>–需求：对 T_ACCOUNT 表按使用量进行降序排序（由大到小）<br>select </em> from T_ACCOUNT order by usenum desc</p><p>可以通过数据库表中的多个字段来排序，要求：根据排序的前面字段，有重复，按照书写的顺序来进行排序的。例如： 对业主表，按照地址ID降序排列，地址一样，按照ID升序排列：<br>select * from T_OWNERS t order by t.addressid desc, t.id asc</p><p>（2）伪列：Oracle对每张表自动加上两列rowid和rownum成为伪列</p><p>rowid：存储的是物理地址，值是不重复的查询速度比较快<br>–伪列 rowid<br>select rowid,t.<em> from T_OWNERS t –如果想跟其他字段一起显示<br>select rowid from T_OWNERS –可以单独查询rowid<br>select rowid,t.</em> from T_OWNERS t where t.rowid = ‘AAAM1VAAGAAAABNAAA’     –可以根据条件查询</p><p>rownum：每张表Oracle自动给加上的一个序号。<br>–伪列rownum<br>select rownum,t.* from T_OWNERS t –如果想跟其他字段一起显示<br>select rownum from T_OWNERS –可以单独查询rownum</p><h1 id="03-单表查询-聚合统计"><a href="#03-单表查询-聚合统计" class="headerlink" title="03.单表查询-聚合统计"></a>03.单表查询-聚合统计</h1><p>要点：聚合统计</p><p>–聚合统计</p><p>（1）–求和 sum</p><p>–需求：统计 2012 年所有用户的用水量总和<br>select sum(usenum) from T_ACCOUNT where year = ‘2012’</p><p>（2）–求平均 avg</p><p>–需求：统计 2012 年所有用水量（字数）的平均值<br>select avg(usenum) from T_ACCOUNT where year = ‘2012’</p><p>（3）–求最大值 max</p><p>–需求：统计 2012 年最高用水量（字数）<br>select max(usenum) from T_ACCOUNT where year = ‘2012’</p><p>（4）–求最小值 min</p><p>–需求：统计 2012 年最低用水量（字数）<br>select min(usenum) from T_ACCOUNT where year = ‘2012’</p><p>（5）–统计记录个数 count</p><p>–需求：统计业主类型 ID 为 1 的业主数量<br>select count(*) from T_OWNERS where ownertypeid = 1</p><p>（6）– 分组聚合 Group by (select 后面一定是分组聚合的条件或者是聚合函数)</p><p>–需求：按区域分组统计水费合计数<br>select areaid,sum(money) from T_ACCOUNT group by areaid；</p><p>（7）– 分组后条件查询 having</p><p>–需求：查询水费合计大于 16900 的区域及水费合计<br>select areaid,sum(money) from T_ACCOUNT group by areaid having sum(money)&gt;169000<br>where和having区别？<br>    1.where 不能放在GROUP BY 后面<br>2.HAVING 是跟GROUP BY 连在一起用的，放在GROUP BY 后面，此时的作用相当于WHERE<br>3.WHERE 后面的条件中不能有聚集函数，比如SUM(),AVG()等，而HAVING 可以</p><h1 id="04-内连接"><a href="#04-内连接" class="headerlink" title="04.内连接"></a>04.内连接</h1><p>要点：内连接查询如果接到一个很复杂的查询需求，这里介绍的是如果分析一个复杂的查询需求。（重点要学习思路）<br>第一步: 找到所需信息所在的所有表<br>第二步: 描述各个表之间的关系(外键 = 主键)</p><p>（1）–多表内连接查询</p><p>–（1）需求：查询显示业主编号，业主名称，业主类型名称<br>select os.id 业主编号,os.name 业主名称,ot.name 业主类型<br>from T_OWNERS os,T_OWNERTYPE ot<br>where os.ownertypeid = ot.id</p><p>（2）–（2）需求：查询显示业主编号，业主名称、地址和业主类型<br>select ow.id 业主编号,ow.name 业主名称,ad.name 地址,ot.name 业主类型<br>from t_owners ow, t_ownertype ot,t_address ad<br>where ow.addressid = ad.id and ow.ownertypeid = ot.id</p><p>（3）–（3）需求：查询显示业主编号、业主名称、地址、所属区域、业主分类<br>select ow.id 业主编号,ow.name 业主名称,ad.name 地址,ar.name 所属区域,ot.name 业主类型<br>from t_owners ow, t_ownertype ot,t_address ad,t_area ar<br>where ow.addressid = ad.id and ow.ownertypeid = ot.id and ad.areaid = ar.id</p><p>（4）–（4）需求：查询显示业主编号、业主名称、地址、所属区域、收费员、业主分类<br>select ow.id 业主编号,ow.name 业主名称,ad.name 地址,ar.name 所属区域,op.name 收费员,ot.name 业主类型<br>from t_owners ow, t_ownertype ot,t_address ad,t_area ar,t_operator op<br>where ow.addressid = ad.id and ow.ownertypeid = ot.id and ad.areaid = ar.id and ad.operatorid = op.id</p><h1 id="05-外连接"><a href="#05-外连接" class="headerlink" title="05.外连接"></a>05.外连接</h1><p>要点：使用sql1999用法  xxx join  … on… 。<br>使用（+）这种写法，oracle数据库专用,移植到其他数据库中会报错。</p><p>（1）–左外连接查询：左边表所有数据全部查出来，右边的表没有匹配的数据显示空。<br>–需求：查询业主的账务记录，显示业主编号、名称、年、月、金额。如果此业主没有账务记录也要列出姓名。<br>–sql1999<br>select ow.id 业主编号,ow.name 业主名称,ac.year 年,ac.month 月,ac.money 金额<br>from t_owners ow left join  t_account ac<br>on ac.owneruuid= ow.id</p><p>–oracle的语法<br>select ow.id 业主编号,ow.name 业主名称,ac.year 年,ac.month 月,ac.money 金额<br>from t_owners ow , t_account ac<br>where ow.id=ac.owneruuid(+);<br>（2）–右外连接查询：右边表所有数据全部查出来，左边的表没有匹配的数据显示空。<br>–需求：查询业主的账务记录，显示业主编号、名称、年、月、金额。如果账务记录没有对应的业主信息，也要列出记录。<br>–sql1999<br>select ow.id 业主编号,ow.name 业主名称,ac.year 年,ac.month 月,ac.money 金额<br>from t_owners ow right join  t_account ac<br>on ac.ownerid = ow.id<br>–oracle的语法<br>select ow.id 业主编号,ow.name 业主名称,ac.year 年,ac.month 月,ac.money 金额<br>from t_owners ow , t_account ac<br>where ow.id(+) = ac.owneruuid;</p><h1 id="06-where子句中的子查询"><a href="#06-where子句中的子查询" class="headerlink" title="06.where子句中的子查询"></a>06.where子句中的子查询</h1><p>要点：单行子查询where条件后查询的结果只有一行适用于大于，小于，等于等等<br>多行子查询 where条件后查询的结果为多条或者一条，最常用的是in包含的意思。（现实开发经常遇到）</p><p>1、单行子查询<br>（1）–where 子句中的子查询<br>–需求：查询 2012 年 1 月用水量大于平均值的台账记录<br>–查询2012年1月平均用水量<br>select avg(usenum) from t_account  where year=’2012’ and month=’01’;</p><p>（2）–查询2012年1月用水量大于20009.5<br>select * from t_account  where year=’2012’ and month=’01’ and usenum&gt;20009.5;</p><p>（3）–需求：查询 2012 年 1 月用水量大于平均值的台账记录<br>select * from t_account  where year=’2012’ and month=’01’<br>and usenum&gt;(select avg(usenum) from t_account  where year=’2012’ and month=’01’)</p><p>2、多行子查询 in 运算符</p><p>–（1）需求：查询地址编号为 1 、3、4 的业主记录<br>select * from t_owners where addressid in(1,3,4);</p><p>–（2）需求：查询地址含有“花园”的业主的信息<br>–查询地址含有“花园”的地址编号<br>select id from t_address where name like ‘%花园%’</p><p>–最终结果<br>select * from t_owners where addressid in(select id from t_address where name like ‘%花园%’)</p><p>–（3）需求：查询地址不含有“花园”的业主的信息<br>select * from t_owners where addressid not in(select id from t_address where name like ‘%花园%’)</p><h1 id="07-from子句的子查询"><a href="#07-from子句的子查询" class="headerlink" title="07.from子句的子查询"></a>07.from子句的子查询</h1><p>要点：from后边的子查询当成一个表使用即可。</p><p>（1）–from 子句的子查询为多行子查询<br>–需求：查询显示业主编号，业主名称，业主类型名称，条件为业主类型为”居民”，使用子查询实现。<br>–内连接写法<br>select ow.id 业主编号,ow.name 业主名称,ot.name 业主类型<br>from t_owners ow,t_ownertype ot<br>where ow.ownertypeid = ot.id and ot.name = ‘居民’<br>（2）–子查询写法<br>select * from (<br>select ow.id 业主编号,ow.name 业主名称,ot.name 业主类型<br>from t_owners ow,t_ownertype ot<br>where ow.ownertypeid = ot.id<br>) where 业主类型 = ‘居民’</p><h1 id="08-select子句子查询（实际开发中经常遇到）"><a href="#08-select子句子查询（实际开发中经常遇到）" class="headerlink" title="08.select子句子查询（实际开发中经常遇到）"></a>08.select子句子查询（实际开发中经常遇到）</h1><p>要点：select子查询后边必须是查询单一字段。因为select后边都是单一的字段<br>（1）–select 子句中的子查询<br>–（1）需求：列出业主信息，包括 ID，名称，所属地址。<br>–内关联写法<br>1、如果只查询id、业主名称那只需要从业主表中进行查询。<br>2、现在我们想得到地址表的名称，那么我们就要到地址表中把名称查询出来。<br>画个表<br>select o.id,o.name,ad.name<br>from t_owners o,t_address ad<br>where o.addressid= ad.id</p><p>（2）–select子查询写法<br>select id,name,(select name from t_address where id=addressid) addressname<br>from t_owners</p><p>–（2）需求：列出业主信息，包括 ID，名称，所属地址，所属区域。<br>–内连接写法<br>select ow.id,ow.name 名称,ad.name 所属地址,ar.name 所属区域<br>from t_owners ow,t_address ad,t_area ar<br>where ow.addressid = ad.id and ad.areaid = ar.id<br>–select子查询写法<br>select id,name,<br>(select name from t_address where id=addressid) addressname,<br>(select (select name from t_area where id=areaid) from t_address where id=addressid) areaname<br>from t_owners;</p><h1 id="09-分页查询"><a href="#09-分页查询" class="headerlink" title="09.分页查询"></a>09.分页查询</h1><p>要点：</p><p>面试要点：oracle 和mysql分页<br>回答：oracle 用ruwnum三层嵌套，mysql 用limit进行分页。</p><p>（1）–需求：分页查询台账表 T_ACCOUNT，每页 10 条记录<br>–分析：我们在 ORACLE 进行分页查询，需要用到伪列 ROWNUM 和嵌套查询<br>–我们首先显示前 10 条记录<br>select rownum,t.* from t_account t where rownum&lt;=10</p><p>（2）–显示第二页10条内容<br>select <em> from (select rownum r,t.</em> from t_account t)<br>where r&gt;10 and r &lt;=20</p><p>（3）–需求：分页查询台账表 T_ACCOUNT，每页 10 条记录，按使用字数降序排序。<br>–我们查询第 2 页数据，如果基于上边的语句添加排序<br>select <em> from ( select rownum r,t.</em> from (select * from t_account  order by usenum desc) t )<br>where r&gt;10 and r &lt;=20</p><h1 id="10-字符函数"><a href="#10-字符函数" class="headerlink" title="10.字符函数"></a>10.字符函数</h1><pre><code>要点：伪表dual：Oracle提供用来测试函数的表</code></pre><p>（1）–（1）求字符串长度 LENGTH<br>select length(‘ABCD’) from dual;<br>（2）–求字符串子串(原字符串，从第几位截取，截取字符数)<br>select substr(‘ABCDEF’,2,2) from dual;</p><p>（3）–字符串拼接<br>select concat(‘ABC’,’D’) from dual;<br>–如果想继续拼接（不推荐使用）<br>select concat(concat(‘ABC’,’D’),’EF’) from dual;<br>–如果想继续拼接（推荐使用）<br>select ‘ABC’||’D’||’EF’ from dual;</p><p>–拼接查询的内容<br>select ow.name||’住在’||ad.name 信息 from t_owners ow,t_address ad where ow.addressid = ad.id;</p><h1 id="11-数值函数"><a href="#11-数值函数" class="headerlink" title="11.数值函数"></a>11.数值函数</h1><p>要点：数值函数常用的四舍五入（round），数字截取（trunc），求模（mod）<br>根据个人编程习惯采用数值函数。<br>（1）–四舍五入<br>select round(100.567,2) from dual;</p><p>（2）–数字截取<br>select trunc(100.567,2) from dual;<br>（3）–取模<br>select mod(10,3) from dual;</p><h1 id="12-日期函数"><a href="#12-日期函数" class="headerlink" title="12.日期函数"></a>12.日期函数</h1><pre><code>要点：日期函数实际开发中只有在特定的需求里会遇到。</code></pre><p>（1）–取系统当前日期<br>select sysdate from dual;<br>（2）–加月<br>select add_months(sysdate,2) from dual;<br>–减月<br>select add_months(sysdate,-2) from dual;<br>（3）–求当月最后一天<br>select last_day(sysdate) from dual;<br>select last_day(sysdate-4) from dual;<br>（4）–日期截取<br>select trunc(sysdate) from dual;–按日截取（把时间截掉）</p><p>select trunc(sysdate,’mm’) from dual;–按月截取（把日截掉）</p><p>select trunc(sysdate,’yyyy’) from dual;–按年截取</p><p>select trunc(sysdate,’hh’) from dual;–按小时截取</p><p>select trunc(sysdate,’mi’) from dual;–按分钟截取</p><p>–没有按秒截取</p><h1 id="13-转换函数"><a href="#13-转换函数" class="headerlink" title="13.转换函数"></a>13.转换函数</h1><p>要点：类似于Java语言的类型转换，特定需求下会使用数据库转换函数。<br>（1）–转换函数<br>–数字转换字符串<br>select to_char(100)||’分’ from dual;<br>select 100||’’ from dual;<br>（2）–日期转字符串<br>select to_char(sysdate,’yyyy-mm-dd’) from dual;<br>select to_char(sysdate,’yyyy’)||’年’||to_char(sysdate,’mm’)||’月’||to_char(sysdate,’dd’)||’日’ from dual;<br>select to_char(sysdate,’yyyy-mm-dd hh:mi:ss’) from dual;<br>（3）–字符串转日期<br>select to_date(‘2017-03-10’,’yyyy-mm-dd’) from dual;<br>（4）–字符串转数字<br>select to_number(‘100’)+10 from dual;<br>select ‘100’+0 from dual;<br>select ‘100’||0 from dual;–拼接后就变成字符串了</p><h1 id="14-其它函数"><a href="#14-其它函数" class="headerlink" title="14.其它函数"></a>14.其它函数</h1><p>要点：空值处理nvl对空值进行处理，nvl2可以转换类型。<br>条件判断decode可以根据检测的值不同，取得不同的结果。<br>case when then sql1999标准必须掌握实际开发会经常遇到。</p><p>–其他函数<br>（1）–空值处理<br>select nvl(null,0) from dual;<br>–显示价格表中业主类型ID为1的价格记录，如果上限值为NULL,则显示9999999<br>select nvl(maxnum,9999999) from t_pricetable where ownertypeid=1;<br>（2）–NVL2（检测的值，如果不为 null 的值，如果为 null 的值）；<br>select nvl2(null,0,100) from dual;–结果为100<br>select nvl2(20,0,100) from dual;–结果为0<br>–需求：显示价格表中业主类型 ID 为 1 的价格记录，如果上限值为 NULL,显示“不限”.<br>select nvl2(maxnum,to_char(maxnum),’不限’) from t_pricetable where ownertypeid=1;</p><p>（3）–（3）条件判断 decode<br>select decode(100,1,2,3,4,100,200,300,400) from dual;<br>–需求：显示下列信息（不要关联查询业主类型表，直接判断 1 2 3 的值）<br>select name,decode(ownertypeid,1,’居民’,2,’行政事业单位’,3,’商业’,’其他’) from t_owners;<br>（4）–case when then第一种写法 sql1999<br>select name,(case ownertypeid<br>                  when 1 then ‘居民’<br>                  when 2 then ‘行政事业’<br>                  when 3 then ‘商业’<br>                  else ‘其他’<br>             end )from t_owners;<br>–case when then第二种写法 sql1999（灵活）<br>select name,(case<br>                  when ownertypeid=1 then ‘居民’<br>                  when ownertypeid=2 then ‘行政事业’<br>                  when ownertypeid=3 then ‘商业’<br>                  else ‘其他’<br>             end )from t_owners;</p><h1 id="15-行列转换"><a href="#15-行列转换" class="headerlink" title="15.行列转换"></a>15.行列转换</h1><p>（1）–行列转换<br>–需求：按月份统计 2012 年各个地区的水费<br>select (select name from t_area where id=areaid) 区域,<br>     sum(case when month = ‘01’ then money else 0 end) 一月,<br>     sum(case when month = ‘02’ then money else 0 end) 二月,<br>     sum(case when month = ‘03’ then money else 0 end) 三月,<br>     sum(case when month = ‘04’ then money else 0 end) 四月,<br>     sum(case when month = ‘05’ then money else 0 end) 五月,<br>     sum(case when month = ‘06’ then money else 0 end) 六月,<br>     sum(case when month = ‘07’ then money else 0 end) 七月,<br>     sum(case when month = ‘08’ then money else 0 end) 八月,<br>     sum(case when month = ‘09’ then money else 0 end) 九月,<br>     sum(case when month = ‘10’ then money else 0 end) 十月,<br>     sum(case when month = ‘11’ then money else 0 end) 十一月,<br>     sum(case when month = ‘12’ then money else 0 end) 十二月<br>from t_account where year=’2012’ group by areaid;</p><p>（2）–需求：按季度统计 2012 年各个地区的水费<br>select (select name from t_area where id=areaid) 区域,<br>     sum(case when month &gt;= ‘01’ and month&lt;=’03’ then money else 0 end) 第一季度,<br>     sum(case when month &gt;= ‘04’ and month&lt;=’06’ then money else 0 end) 第二季度,<br>     sum(case when month &gt;= ‘07’ and month&lt;=’09’ then money else 0 end) 第三季度,<br>     sum(case when month &gt;= ‘10’ and month&lt;=’12’ then money else 0 end) 第四季度<br>from t_account where year=’2012’ group by areaid;</p><h1 id="16-分析函数"><a href="#16-分析函数" class="headerlink" title="16.分析函数"></a>16.分析函数</h1><p>（1）–分析函数<br>–值相同，排名相同，序号跳跃<br>select rank() over(order by usenum desc) 排名,t.<em> from t_account t<br>（2）–值相同，排名相同，序号连续<br>select dense_rank() over(order by usenum desc) 排名,t.</em> from t_account t<br>（3）–序号连续，不管值是否相同<br>select row_number() over(order by usenum desc) 排名,t.<em> from t_account t<br>（4）–用分析函数来实现分页<br>select </em> from<br>   (select row_number() over(order by usenum desc) rownumber,t.* from t_account t)<br>where rownumber&gt;10 and rownumber&lt;=20;</p><h1 id="17-集合运算"><a href="#17-集合运算" class="headerlink" title="17.集合运算"></a>17.集合运算</h1><p>（1）–集合运算<br>–并集（包括重复记录）</p><p>select <em> from t_owners where id&gt;5<br>union all<br>select </em> from t_owners where id&lt;8</p><p>（2）–并集（去掉重复记录）<br>select <em> from t_owners where id&gt;5<br>union<br>select </em> from t_owners where id&lt;8<br>（3）–交集（两个结果集的重复部分）</p><p>select <em> from t_owners where id&gt;5<br>intersect<br>select </em> from t_owners where id&lt;8</p><p>（4）–差集  返回的属于第一个集合但是不属于第二个集合的记录</p><p>select <em> from t_owners where id&gt;5<br>minus<br>select </em> from t_owners where id&lt;8</p><p>select <em> from t_owners where id&lt;8<br>minus<br>select </em> from t_owners where id&gt;5</p><p>（5）–差集分页<br>select rownum,t.<em> from t_account t where rownum&lt;=20<br>minus<br>select rownum,t.</em> from t_account t where rownum&lt;=10<br>总结<br>1、    oracle单表查询。<br>2、    oracle的多表连接查询。<br>3、    oracle的嵌套查询。<br>4、    oracle的基本函数。</p><h1 id="01-什么是视图"><a href="#01-什么是视图" class="headerlink" title="01.什么是视图"></a>01.什么是视图</h1><p>1、    要点：对sql语句的一种封装，它是一个虚拟的表。<br>2、    使用场景：对经常需要查询的数据，进行封装。<br>3、    优点：提高工作效率。     </p><h1 id="02-创建修改删除视图语法"><a href="#02-创建修改删除视图语法" class="headerlink" title="02.创建修改删除视图语法"></a>02.创建修改删除视图语法</h1><p>要点：创建视图的基本语法和删除视图。<br>1、CREATE [OR REPLACE] [FORCE] VIEW view_name<br>AS subquery<br>[WITH CHECK OPTION ]<br>[WITH READ ONLY]<br>REPLACE：删除已有视图，重新创建视图。<br>FORCE：不管基表是否存在，都会创建视图。<br>WITH CHECK OPTION：插入或修改的数据行必须满足视图定义的约束。<br>WITH READ ONLY：只读。</p><p>2、删除视图：DROP VIEW view_name</p><h1 id="03-视图案例-简单视图"><a href="#03-视图案例-简单视图" class="headerlink" title="03.视图案例-简单视图"></a>03.视图案例-简单视图</h1><p>要点：视图中查询的表称之为基表，修改视图实际就是在修改基表中的数据。视图在数据库中实际上就是一条sql语句，查询视图的数据实际就是在查询基表的数据。<br>1、–需求：创建视图 ：业主类型为 1 的业主信息<br>create view view_owners1 as<br>select <em> from t_owners where ownertypeid = 1;<br>2、–查询简单视图<br>select </em> from view_owners1 where addressid = 1;<br>3、–修改视图数据<br>update view_owners1 set name=’范小冰’ where id=1;<br>commit;<br>4、–查询表<br>select * from t_owners where ownertypeid = 1;</p><h1 id="04-视图案例-检查约束的视图"><a href="#04-视图案例-检查约束的视图" class="headerlink" title="04.视图案例-检查约束的视图"></a>04.视图案例-检查约束的视图</h1><p>要点：视图中添加with check option选项，无法修改视图中基表的条件字段。<br>1、–带检查约束的视图<br>–需求：根据地址表（T_ADDRESS）创建视图 VIEW_ADDRESS2 ,内容为区域 ID为 2 的记录。<br>create view view_address2 as<br>select * from t_address where areaid=2<br>with check option<br>2、–无法修改成功的语句，因为该视图的条件是areaid=2<br>update view_address2 set areaid=3 where id=4;<br>3、–可以修改成功的语句，因为条件不是areaid<br>update view_address2 set name=’河畔花园1’ where id=4;<br>commit;</p><h1 id="05-视图案例-只读视图"><a href="#05-视图案例-只读视图" class="headerlink" title="05.视图案例-只读视图"></a>05.视图案例-只读视图</h1><p>要点： 视图中添加or replace删除原有视图，重新创建视图，添加with read only视图只能查看不能修改。<br>1、–需求：将上边的视图修改为只读视图<br>create or replace view view_owners1 as<br>select * from t_owners where ownertypeid=1<br>with read only<br>2、–修改只读视图数据<br>update view_owners1 set name=’aaa’ where id=1;</p><h1 id="06-视图案例-带错误的视图"><a href="#06-视图案例-带错误的视图" class="headerlink" title="06.视图案例-带错误的视图"></a>06.视图案例-带错误的视图</h1><p>要点：视图中添加 force选项可以创建数据库中没有的表。<br>–创建带错误的视图<br>create force view view_test as<br>select * from t_test</p><h1 id="07-视图案例-多表关联的视图"><a href="#07-视图案例-多表关联的视图" class="headerlink" title="07.视图案例-多表关联的视图"></a>07.视图案例-多表关联的视图</h1><p>要点：复杂视图：视图的 SQL 语句中，有聚合函数或多表关联查询。<br>键保留表：把主键保留下来的那个表。<br>1、–创建视图，查询显示业主编号，业主名称，业主类型名称<br>create or replace view view_owners as<br>select ow.id 业主编号,ow.name 业主名称,ot.name 业主类型 from t_owners ow,t_ownertype ot<br>where ow.ownertypeid=ot.id<br>2、–查询复杂视图（多表关联）<br>select * from view_owners where 业主类型=’居民’;<br>3、–修改键保留表复杂视图（多表关联）的数据<br>update view_owners set 业主名称=’林玲玲’ where 业主编号=4;<br>commit;<br>4、–修改非键保留表复杂视图（多表关联）的数据<br>update view_owners set 业主类型=’商业’ where 业主编号=4;<br>–键保留表：把主键保留下来的那个表，并且能作为视图的主键</p><p>复杂视图(多表关联) 修改语句只能修改包含外键的表(t_owners-外键:t_ownertypeid)不管视图中是否包含T_owners的主键,都可以修改.提供外键的表t_ownertype不能修改.</p><h1 id="08-视图案例-聚合统计的视图"><a href="#08-视图案例-聚合统计的视图" class="headerlink" title="08.视图案例-聚合统计的视图"></a>08.视图案例-聚合统计的视图</h1><p>要点：聚合统计视图默认是只读，无法修改数据。<br>1、–需求：创建视图，按年月统计水费金额<br>create view view_accountsum as<br>select year,month,sum(money) money<br>from t_account<br>group by year,month<br>order by year,month<br>2、–查询视图<br>select * from view_accountsum where year=’2012’ and month=’03’<br>3、–不能修改<br>update view_accountsum set money=10000 where year=’2012’ and month=’03’</p><h1 id="09-物化视图-概念及语法"><a href="#09-物化视图-概念及语法" class="headerlink" title="09.物化视图-概念及语法"></a>09.物化视图-概念及语法</h1><p>要点：1、物化视图概念：将视图中查询出来的数据存储到一张表中。<br>2、优点：查询速度比视图要快。<br>3、缺点：占用资源，并且要时时更新数据。<br>4、创建物化视图<br>CREATE METERIALIZED VIEW view_name<br>[BUILD IMMEDIATE | BUILD DEFERRED ]<br>REFRESH [FAST|COMPLETE|FORCE]<br>[<br>ON [COMMIT |DEMAND ] | START WITH (start_time) NEXT<br>(next_time)<br>]<br>AS<br>Subquery<br>METERIALIZED:实体化。<br>BUILD IMMEDIATE: 创建物化视图的时候就生成数据。<br>BUILD DEFERRED: 创建物化视图的时候不生成数据。<br>默认为 BUILD IMMEDIATE<br>FAST：快速刷新，增量刷新。<br>COMPLETE：基表更新，删除物化视图数据，重新生成数据。<br>FORCE：自动选择，能增量刷新就增量，不能增量就完全刷新。<br>默认为FORCE<br>ON COMMIT：基表变化，物化视图就刷新。<br>ON DEMAND：手动刷新<br>默认：ON DEMAND</p><h1 id="10-物化视图案例-手动刷新的物化视图"><a href="#10-物化视图案例-手动刷新的物化视图" class="headerlink" title="10.物化视图案例-手动刷新的物化视图"></a>10.物化视图案例-手动刷新的物化视图</h1><p>要点：创建物化视图默认为手动刷新ON DEMAND，基表如果数据发生变化，物化视图中的表不会发生变化，需要手动进行刷新。<br>1、–需求：查询地址 ID,地址名称和所属区域名称<br>create materialized view view_address1 as<br>select ad.id,ad.name,ar.name arname<br>from t_address ad,t_area ar<br>where ad.areaid=ar.id<br>–删除物化视图<br>drop materialized view view_address1;<br>2、–物化视图一般以mv开头<br>create materialized view mv_address1 as<br>select ad.id,ad.name,ar.name arname<br>from t_address ad,t_area ar<br>where ad.areaid=ar.id<br>–查询物化视图<br>select <em> from mv_address1;<br>3、–向基表插入数据<br>insert into t_address values(8,’西三旗’,2,2);<br>commit;<br>–查询t_address<br>select </em> from t_address;<br>4、–执行刷新语句<br>begin<br>  DBMS_MVIEW.refresh(‘MV_ADDRESS1’,’C’);<br>end;<br>5、–向基表插入数据<br>insert into t_address values(9,’西四旗’,2,2);<br>commit;<br>6、命令窗口更新刷新数据<br>EXEC DBMS_MVIEW.refresh(‘MV_ADDRESS1’,’C’);</p><h1 id="11-物化视图案例-自动刷新的物化视图"><a href="#11-物化视图案例-自动刷新的物化视图" class="headerlink" title="11.物化视图案例-自动刷新的物化视图"></a>11.物化视图案例-自动刷新的物化视图</h1><p>1、–创建自动刷新的物化视图 -基表发生commit操作，自动刷新物化视图<br>create materialized view mv_address2<br>refresh<br>on commit<br>as<br>select ad.id,ad.name,ar.name arname<br>from t_address ad,t_area ar<br>where ad.areaid=ar.id<br>2、–向基表插入数据<br>insert into t_address values(10,’西5旗’,2,2);<br>commit;<br>3、–查询物化视图<br>select * from mv_address2;</p><h1 id="12-物化视图案例-创建时不生成数据的物化视图"><a href="#12-物化视图案例-创建时不生成数据的物化视图" class="headerlink" title="12.物化视图案例-创建时不生成数据的物化视图"></a>12.物化视图案例-创建时不生成数据的物化视图</h1><p>要点：增加build deferred创建物化视图时，视图表中不产生数据，需要手动刷新，如果增加on commit那么以后基表进行commit操作，物化视图为自动刷新。<br>1、–创建时不生成数据的物化视图<br>create materialized view mv_address3<br>build deferred<br>refresh<br>on commit<br>as<br>select ad.id,ad.name,ar.name arname<br>from t_address ad,t_area ar<br>where ad.areaid=ar.id<br>2、–查询物化视图<br>select * from mv_address3;<br>3、–向基表插入数据<br>insert into t_address values(11,’西6旗’,2,2);<br>commit;<br>4、–执行刷新语句(第一次必须手动执行刷新)<br>begin<br>  DBMS_MVIEW.refresh(‘MV_ADDRESS3’,’C’);<br>end;<br>5、–向基表插入数据<br>insert into t_address values(12,’西7旗’,2,2);<br>commit;</p><h1 id="13-物化视图案例-增量刷新的物化视图（了解）"><a href="#13-物化视图案例-增量刷新的物化视图（了解）" class="headerlink" title="13.物化视图案例-增量刷新的物化视图（了解）"></a>13.物化视图案例-增量刷新的物化视图（了解）</h1><p>1、–创建增量刷新的物化视图<br>–前提是必须创建物化视图日志：记录基表发生了哪些变化，用这些记录去更新物化视图<br>create materialized view log on t_address with rowid<br>create materialized view log on t_area with rowid<br>–创建物化视图中的语句，必须有基表的rowid<br>create materialized view mv_address4<br>refresh fast<br>as<br>select ad.rowid adrowid,ar.rowid arrowid,ad.id,ad.name,ar.name arname<br>from t_address ad,t_area ar<br>where ad.areaid=ar.id<br>2、–查询物化视图<br>select * from mv_address4;<br>–向基表插入数据<br>insert into t_address values(13,’西8旗’,2,2);<br>commit;<br>–向基表插入数据<br>insert into t_address values(14,’西9旗’,2,2);<br>commit;<br>–删除数据<br>delete from t_address where id=14;<br>commit;<br>3、–执行刷新语句<br>begin<br>  DBMS_MVIEW.refresh(‘MV_ADDRESS4’,’C’);<br>end;</p><h1 id="14-序列-什么是序列"><a href="#14-序列-什么是序列" class="headerlink" title="14.序列-什么是序列"></a>14.序列-什么是序列</h1><p>–创建简单序列<br>create sequence seq_test;<br>–查询序列的下一个值<br>select seq_test.nextval from dual;<br>–查询序列的当前值<br>select seq_test.currval from dual;</p><h1 id="15-序列-语法"><a href="#15-序列-语法" class="headerlink" title="15.序列-语法"></a>15.序列-语法</h1><h1 id="16-序列-案例"><a href="#16-序列-案例" class="headerlink" title="16.序列-案例"></a>16.序列-案例</h1><p>–有最大值的非循环序列<br>create sequence seq_test1<br>maxvalue 20;<br>–查询序列<br>select seq_test1.nextval from dual;<br>–自定义增长值<br>create sequence seq_test2<br>increment by 10<br>start with 10<br>maxvalue 100<br>–查询序列<br>select seq_test2.nextval from dual;</p><p>create sequence seq_test3<br>increment by 10<br>start with 10<br>minvalue 5<br>maxvalue 100<br>–查询序列<br>select seq_test3.nextval from dual;<br>–循环的序列<br>create sequence seq_test4<br>increment by 10<br>start with 10<br>minvalue 10<br>maxvalue 210<br>cycle</p><p>create sequence seq_test5<br>increment by 10<br>start with 10<br>minvalue 10<br>maxvalue 201<br>cycle<br>–查询序列<br>select seq_test4.nextval from dual;<br>select seq_test5.nextval from dual;</p><p>create sequence seq_test5<br>increment by 10<br>start with 10<br>minvalue 10<br>maxvalue 201<br>cycle<br>cache 5<br>–一次缓存数有多少 cache值*增长值   缓存的默认值是20,不设置的话cache为20<br>–一次循环的值不能小于 一次缓存的数<br>–开始值不能小于最小值</p><h1 id="17-同义词-概念"><a href="#17-同义词-概念" class="headerlink" title="17.同义词-概念"></a>17.同义词-概念</h1><p>2、语法：create [public] SYNONYM synooym for object;<br>加上public，数据库所有用户都可以访问别名。<br>不加public，只针对当前用户可以访问。</p><h1 id="18-同义词-案例"><a href="#18-同义词-案例" class="headerlink" title="18.同义词-案例"></a>18.同义词-案例</h1><p>–创建私有同义词<br>create synonym owner for t_owners;<br>select <em> from owner;<br>–dba超级管理员身份可以用system用户直接访问<br>select </em> from wateruser.t_owners;<br>–创建共有同义词<br>create public synonym owner2 for t_owners;<br>select * from owner2;</p><h1 id="19-索引-什么是索引"><a href="#19-索引-什么是索引" class="headerlink" title="19.索引-什么是索引"></a>19.索引-什么是索引</h1><p>要点：1、索引是用于加速数据存取的数据对象。<br>2、适用于百万以上数据。<br>3、优点：查询速度比较快。<br>4、缺点：占用资源比较大。</p><h1 id="20-索引-普通索引"><a href="#20-索引-普通索引" class="headerlink" title="20.索引-普通索引"></a>20.索引-普通索引</h1><p>要点：创建一个普通索引。<br>1、–创建普通索引<br>create index index_owners_name on t_owners(name);<br>select * from t_owners where name=’张哲’;<br>2、–性能测试 创建一个表，向表中插入100万条记录<br>create table t_indextest(id number,name varchar2(30));<br>begin<br>  for x in 1..1000000<br>    loop<br>      insert into t_indextest values(x,’aa’||x);<br>      end loop;<br>      commit;<br>end;<br>3、–创建索引<br>create index index_test on t_indextest(name);</p><p>select * from t_indextest where id=777777;</p><p>select t.rowid,t.* from t_indextest t where name=’aa777777’;</p><p>select * from t_indextest where rowid=’AAAM3NAAGAAAAkNACz’;</p><h1 id="21-索引-唯一索引和复合索引"><a href="#21-索引-唯一索引和复合索引" class="headerlink" title="21.索引-唯一索引和复合索引"></a>21.索引-唯一索引和复合索引</h1><p>要点：1、创建唯一索引：此列不能有重复字段。<br>2、复合索引要注意where条件的顺序是什么，创建复合索引的顺序就是什么。<br>–创建唯一索引<br>create unique index index_owners_meter on t_owners(watermeter);</p><p>select * from t_owners where addressid=1 and housenumber=’1-3’;<br>–创建复合索引<br>create index index_owners_ah on t_owners(addressid,housenumber);</p><h1 id="22-索引-反向键索引"><a href="#22-索引-反向键索引" class="headerlink" title="22.索引-反向键索引"></a>22.索引-反向键索引</h1><p>要点：当某个字段为连续增长的值，适合用反向键索引。<br>create index 索引名称 on 表名(列名) reverse;</p><p>普通索引和反向建索引统称b-tree-*索引</p><h1 id="23-索引-位图索引"><a href="#23-索引-位图索引" class="headerlink" title="23.索引-位图索引"></a>23.索引-位图索引</h1><p>要点：1、位图索引适合创建在低基数列上，比方说男、女或者颜色、56个民族等等。</p><p>2、语法：create bitmap index 索引名称 on 表名(列名);<br>3、需求：我们在T_owners表的ownertypeid列上建立位图索引。</p><p>   create bitmap index index_owners_typeid on t_owners(ownertypeid)<br>总结<br>（1）    Oracle的视图和物化视图。<br>（2）    Oracle的序列。<br>（3）    Oracle的同义词。<br>（4）    Oracle的索引。</p><h1 id="01-什么是PLSQL"><a href="#01-什么是PLSQL" class="headerlink" title="01.什么是PLSQL"></a>01.什么是PLSQL</h1><p>要点：1、plsql就是Oracle的一种编程语言。<br>2、语法：[declare<br>– 声明变量<br>]<br>begin<br>– 代码逻辑<br>[exception<br>– 异常处理<br>]<br>end;          </p><h1 id="02-变量声明与赋值"><a href="#02-变量声明与赋值" class="headerlink" title="02.变量声明与赋值"></a>02.变量声明与赋值</h1><p>  要点：1、如何声明变量。<br>2、如何赋值变量。<br>–声明变量水费单价、水费字数、吨数、金额。<br>–对水费单价、字数、进行赋值 。吨数根据水费字数换算，规则为水费字数除以<br>–1000，并且四舍五入，保留两位小数。计算金额，金额=单价<em>吨数。<br>–输出单价 、数量和金额。<br>declare<br> v_price number(10,2);–单价<br> v_usenum number;–水费字数<br> v_usenum2 number(10,2);–吨数<br> v_money number(10,2);–金额<br>begin<br>  v_price:=2.45;–单价赋值<br>  v_usenum:=9999;–水费字数<br>  v_usenum:=round(v_usenum/1000,2);–吨数<br>  v_money:=v_usenum</em>v_price;–金额<br>  dbms_output.put_line(‘金额：’||v_money);<br>  –DBMS.OUTPUT.put_line(‘金额：’||v_money);<br>end;</p><h1 id="03-变量select-into赋值"><a href="#03-变量select-into赋值" class="headerlink" title="03.变量select into赋值"></a>03.变量select into赋值</h1><p>要点：通过select into 将表中的数据赋值给变量，注意查询结果只能是一条记录。<br>declare<br> v_price number(10,2);–单价<br> v_usenum number;–水费字数<br> v_usenum2 number(10,2);–吨数<br> v_money number(10,2);–金额<br> v_num0 number;–上月水表数<br> v_num1 number;–本月水表数<br>begin<br>  v_price:=2.45;–单价赋值<br> – v_usenum:=9999;–水费字数<br> select usenum,num0,num1 into v_usenum,v_num0,v_num1 from t_account<br> where year=’2012’ and month=’01’ and owneruuid=1;<br>  v_usenum2:=round(v_usenum/1000,2);–吨数<br>  v_money:=v_usenum2*v_price;–金额<br>  dbms_output.put_line(‘水费字数：’||v_usenum||’金额：’||v_money);<br>  –DBMS.OUTPUT.put_line(‘金额：’||v_money);<br>end;</p><h1 id="04-属性类型"><a href="#04-属性类型" class="headerlink" title="04.属性类型"></a>04.属性类型</h1><p>要点：1、在变量较少的情况下，定义的变量是某个表的某列字段，可以采用 表名.字段名%type。<br>2、在变量较多的情况下，可以采用纪录型，把表名定义成变量 表名%rowtype。<br>–引用某表某列的字段类型<br>declare<br> v_price number(10,2);–单价<br> v_usenum t_account.usenum%type;–水费字数<br> v_usenum2 number(10,2);–吨数<br> v_money number(10,2);–金额<br> v_num0 t_account.num0%type;–上月水表数<br> v_num1 t_account.num1%type;–本月水表数<br>begin<br>  v_price:=2.45;–单价赋值<br> – v_usenum:=9999;–水费字数<br> select usenum,num0,num1 into v_usenum,v_num0,v_num1 from t_account<br> where year=’2012’ and month=’01’ and ownerid=1;<br>  v_usenum2:=round(v_usenum/1000,2);–吨数<br>  v_money:=v_usenum2*v_price;–金额<br>  dbms_output.put_line(‘水费字数：’||v_usenum||’金额：’||v_money);<br>  –DBMS.OUTPUT.put_line(‘金额：’||v_money);<br>end;<br>–属性类型（记录型 表名%rowtype）</p><p>declare<br> v_price number(10,2);–单价</p><p> v_usenum2 number(10,2);–吨数<br> v_money number(10,2);–金额<br> v_account t_account%rowtype;–台帐行记录类型<br>begin<br>  v_price:=2.45;–单价赋值<br> – v_usenum:=9999;–水费字数<br> select <em> into v_account from t_account<br> where year=’2012’ and month=’01’ and ownerid=1;<br>  v_usenum2:=round(v_account.usenum/1000,2);–吨数<br>  v_money:=v_usenum2</em>v_price;–金额<br>  dbms_output.put_line(‘水费字数：’||v_account.usenum||’金额：’||v_money);<br>  –DBMS.OUTPUT.put_line(‘金额：’||v_money);<br>end;</p><h1 id="05-异常"><a href="#05-异常" class="headerlink" title="05.异常"></a>05.异常</h1><p>要点：了解预定义异常用法即可。<br>–异常处理1<br>declare<br> v_price number(10,2);–单价<br> v_usenum2 number(10,2);–吨数<br> v_money number(10,2);–金额<br> v_account t_account%rowtype;–台帐行记录类型<br>begin<br>  v_price:=2.45;–单价赋值<br> – v_usenum:=9999;–水费字数<br> select <em> into v_account from t_account<br> where year=’2012’ and month=’01’ and ownerid=200;<br>  v_usenum2:=round(v_account.usenum/1000,2);–吨数<br>  v_money:=v_usenum2</em>v_price;–金额<br>  dbms_output.put_line(‘水费字数：’||v_account.usenum||’金额：’||v_money);<br>  exception<br>    when no_data_found then<br>      DBMS_OUTPUT.put_line(‘没有数据’);<br>end;<br>–异常处理2<br>declare<br> v_price number(10,2);–单价<br> v_usenum2 number(10,2);–吨数<br> v_money number(10,2);–金额<br> v_account t_account%rowtype;–台帐行记录类型<br>begin<br>  v_price:=2.45;–单价赋值<br> select <em> into v_account from t_account<br> where year=’2012’ ;<br>  v_usenum2:=round(v_account.usenum/1000,2);–吨数<br>  v_money:=v_usenum2</em>v_price;–金额<br>  dbms_output.put_line(‘水费字数：’||v_account.usenum||’金额：’||v_money);<br>  exception<br>    when no_data_found then<br>      DBMS_OUTPUT.put_line(‘没有数据’);<br>    when too_many_rows then<br>      DBMS_OUTPUT.put_line(‘返回多行’);<br>end;</p><h1 id="06-条件判断"><a href="#06-条件判断" class="headerlink" title="06.条件判断"></a>06.条件判断</h1><p>要点：了解plsql中的if、else判断语法。</p><p>declare<br> v_price1 number(10,2);–单价<br> v_price2 number(10,2);–单价<br> v_price3 number(10,2);–单价<br> v_usenum2 number(10,2);–吨数<br> v_money number(10,2);–金额<br> v_account t_account%rowtype;–台帐行记录类型<br>begin<br>  v_price1:=2.45;–单价赋值（5吨以下）<br>  v_price2:=3.45;–单价赋值（5-10吨）<br>  v_price3:=4.45;–单价赋值（超过10吨）<br> select <em> into v_account from t_account<br> where year=’2012’ and month=’01’ and ownerid=1;<br>  v_usenum2:=round(v_account.usenum/1000,2);–吨数<br>  –v_money:=v_usenum2</em>v_price;–金额<br>  –阶梯水费计算<br>  if v_usenum2&lt;=5 then<br>    v_money:=v_price1<em>v_usenum2;<br>  elsif v_usenum2&gt;5 and v_usenum2&lt;=10 then<br>    v_money:=v_price1</em>5+v_price2<em>(v_usenum2-5);<br>  else<br>    v_money:=v_price1</em>5+v_price2<em>5 + v_price3</em>(v_usenum2-10);<br>  end if;</p><p>  dbms_output.put_line(‘水费字数：’||v_account.usenum||’金额：’||v_money);<br>  exception<br>    when no_data_found then<br>      DBMS_OUTPUT.put_line(‘没有数据’);<br>    when too_many_rows then<br>      DBMS_OUTPUT.put_line(‘返回多行’);<br>end;</p><h1 id="07-循环"><a href="#07-循环" class="headerlink" title="07.循环"></a>07.循环</h1><p>要点：循环有三种无条件循环、有条件循环、和for循环。<br>–无条件循环：1到100<br>declare<br>   v_num number;<br>begin<br>  v_num:=1;<br>  loop<br>    dbms_output.put_line(v_num);<br>    v_num:=v_num+1;<br>    if v_num&gt;100 then<br>      exit;<br>      end if;<br>  end loop;<br>end;<br>–有条件循环1到100<br>declare<br>   v_num number;<br>begin<br>   v_num:=1;<br>   while v_num &lt;= 100<br>   loop<br>    dbms_output.put_line(v_num);<br>    v_num:=v_num+1;<br>   end loop;<br>end;<br>–for循环1到100<br>begin<br>  for v_num in 1 .. 100<br>  loop<br>    dbms_output.put_line(v_num);<br>  end loop;<br>end;</p><h1 id="08-游标语法"><a href="#08-游标语法" class="headerlink" title="08.游标语法"></a>08.游标语法</h1><p>要点：游标是系统为用户开设的一个数据缓冲区,存放 SQL 语句的执行结果。我们可以把游标理解为 PL/SQL 中的结果集。</p><h1 id="09-游标案例"><a href="#09-游标案例" class="headerlink" title="09.游标案例"></a>09.游标案例</h1><p>要点：创建游标后面跟着sql语句，然后打开游标循环游标的内容直到游标内容循环结束。关闭游标。<br>–需求：打印业主类型为 1 的价格表<br>declare<br>  cursor cur_pricetable is select * from t_pricetable where ownertypeid=1;–声明游标<br>  v_pricetable t_pricetable%rowtype;<br>begin<br>  open cur_pricetable;–打开游标<br>  loop<br>    fetch cur_pricetable into v_pricetable;–提取游标<br>    exit when cur_pricetable%notfound;–退出循环游标<br>    dbms_output.put_line(‘价格：’||v_pricetable.price||<br>    ‘ 吨位：’||v_pricetable.minnum||’-‘||v_pricetable.maxnum);<br>  end loop;<br>  close cur_pricetable;–关闭游标<br>end;</p><h1 id="10-带参数的游标"><a href="#10-带参数的游标" class="headerlink" title="10.带参数的游标"></a>10.带参数的游标</h1><pre><code>要点：与Java方法相似可以传递参数，声明游标在游标名称后面定义参数，sql语句中使用参数，打开游标时传递参数。</code></pre><p>–带参数的游标<br>declare<br>  cursor cur_pricetable(v_ownertype number) is select * from t_pricetable where ownertypeid=v_ownertype;–声明游标<br>  v_pricetable t_pricetable%rowtype;<br>begin<br>  open cur_pricetable(1);–打开游标<br>  loop<br>    fetch cur_pricetable into v_pricetable;–提取游标<br>    exit when cur_pricetable%notfound;–退出循环游标<br>    dbms_output.put_line(‘价格：’||v_pricetable.price||<br>    ‘ 吨位：’||v_pricetable.minnum||’-‘||v_pricetable.maxnum);<br>  end loop;<br>  close cur_pricetable;–关闭游标<br>end;         </p><h1 id="11-for循环游标"><a href="#11-for循环游标" class="headerlink" title="11.for循环游标"></a>11.for循环游标</h1><p>要点：for循环可以自动打开关闭游标，自动提取游标，而且还可以自动声明变量。<br>–for循环 带参数的游标<br>declare<br>  cursor cur_pricetable(v_ownertype number) is select * from t_pricetable where ownertypeid=v_ownertype;–声明游标<br>begin<br>  for v_pricetable in cur_pricetable(1)<br>  loop<br>    dbms_output.put_line(‘价格：’||v_pricetable.price||<br>    ‘ 吨位：’||v_pricetable.minnum||’-‘||v_pricetable.maxnum);<br>  end loop;<br>end;</p><h1 id="12-存储函数"><a href="#12-存储函数" class="headerlink" title="12.存储函数"></a>12.存储函数</h1><pre><code>要点：存储函数也叫自定义函数，可以接收一个或者多个参数，返回一个结果。类似于Java中的方法。</code></pre><p>1、语法<br>函数名称后面的参数类型不需要写长度大小<br>return 后面的参数也不需要写长度</p><p>2、案例<br>–需求： 创建存储函数，根据地址 ID 查询地址名称。<br>create or replace function fn_getaddress<br>(v_id number)<br>return varchar2<br>is<br>  v_name varchar2(30);<br>begin<br>  –查询地址表<br>  select name into v_name from t_address where id=v_id;<br>  return v_name;<br>end;<br>–存储函数测试<br>select fn_getaddress(3) from dual;<br>–存储函数的应用<br>–需求：查询业主 ID，业主名称，业主地址，业主地址使用刚才我们创建的函数来实现。<br>select id,name,fn_getaddress(addressid) from t_owners;</p><h1 id="13-存储过程-什么是存储过程"><a href="#13-存储过程-什么是存储过程" class="headerlink" title="13.存储过程-什么是存储过程"></a>13.存储过程-什么是存储过程</h1><p>要点：1、存储过程实际上就是供应用程序调用的一种数据函数对象。<br>2、存储函数与存储过程的区别：存储函数一般用来select查询，且返回的只有一个值，存储过程只能供应用程序调用可以返回多个值。且存储过程没有return返回值，可以通过参数设置一个或者多个返回值。<br>3、语法：<br>CREATE [ OR REPLACE ] PROCEDURE 存储过程名称<br>（参数名 类型, 参数名 类型, 参数名 类型）<br>IS|AS<br>变量声明部分;<br>BEGIN<br>逻辑部分<br>[EXCEPTION<br>异常处理部分]<br>END;<br>参数只指定类型，不指定长度<br>过程参数的三种模式：<br>IN 传入参数（默认）<br>OUT 传出参数 ，主要用于返回程序运行结果<br>IN OUT 传入传出参数</p><h1 id="14-不带传出参数的存储过程创建及调用"><a href="#14-不带传出参数的存储过程创建及调用" class="headerlink" title="14.不带传出参数的存储过程创建及调用"></a>14.不带传出参数的存储过程创建及调用</h1><p>要点：1、根据例子理解如何创建一个不带传出参数的存储过程。<br>2、根据例子理解如果用Oracle调用存储过程。</p><p>–创建业主序列起始值为11<br>create sequence seq_owners start with 11;<br>–不带传出参数的存储过程<br>create or replace procedure pro_owners_add<br>(<br>v_name varchar2,–名称<br>v_addressid number,–地址编号<br>v_housenumber varchar2,–门牌号<br>v_watermeter varchar2,–水表号<br>v_ownertype number–业主类型<br>)<br>is</p><p>begin<br>  insert into t_owners values(seq_owners.nextval,v_name,v_addressid,v_housenumber,v_watermeter,sysdate,v_ownertype);<br>  commit;<br>end;<br>–调用不带传出参数的存储过程<br>call pro_owners_add(‘马大哈’,2,’3232’,’22333’,1);</p><p>begin<br>  pro_owners_add(‘马2哈’,2,’32312’,’223331’,1);<br>end;</p><h1 id="15-JDBC调用不带传出参数的存储过程"><a href="#15-JDBC调用不带传出参数的存储过程" class="headerlink" title="15.JDBC调用不带传出参数的存储过程"></a>15.JDBC调用不带传出参数的存储过程</h1><p>要点：通过jdbc代码调用存储过程注意调用存储过程使用CallableStatement，sql语句中要用“{call 存储过程名称（？，？,…）}”。</p><h1 id="16-带传出参数的存储过程创建与调用"><a href="#16-带传出参数的存储过程创建与调用" class="headerlink" title="16.带传出参数的存储过程创建与调用"></a>16.带传出参数的存储过程创建与调用</h1><p>要点：1、根据例子理解如何创建一个带传出参数的存储过程。<br>2、根据例子理解如果用Oracle调用存储过程。</p><p>–创建带传出参数的存储过程<br>create or replace procedure pro_owners_add1<br>(<br>v_name varchar2,–名称<br>v_addressid number,–地址编号<br>v_housenumber varchar2,–门牌号<br>v_watermeter varchar2,–水表号<br>v_ownertypeid number,–业主类型<br>v_id out number<br>)<br>is</p><p>begin<br>  select seq_owners.nextval into v_id from dual;<br>  insert into t_owners values(v_id,v_name,v_addressid,v_housenumber,v_watermeter,sysdate,v_ownertypeid);<br>  commit;<br>end;<br>–调用传出参数的存储过程<br>declare<br>   v_id number;<br>begin<br>   pro_owners_add1(‘马3哈’,2,’32-32’,’2233312’,1,v_id);<br>   dbms_output.put_line(v_id);<br>end;</p><h1 id="17-JDBC调用带传出参数的存储过程"><a href="#17-JDBC调用带传出参数的存储过程" class="headerlink" title="17.JDBC调用带传出参数的存储过程"></a>17.JDBC调用带传出参数的存储过程</h1><p>要点：1、通过代码例子了解如何调用带传出参数的存储过程。<br>2、注意需要传出的参数要再执行sql语句之前注册类型，并且获得传出参数时要再执行完sql语句之后。</p><h1 id="18-什么是触发器"><a href="#18-什么是触发器" class="headerlink" title="18.什么是触发器"></a>18.什么是触发器</h1><p>要点：1、触发器：当一个指定的语句执行增删改的操作时。Oracle自动执行了触发器中自定义的数据库函数。<br>2、前置触发器：在增删改操作没有commit之前执行的触发器叫前置触发器。<br>3、后置触发器：在增删改操作commit之后执行的触发器叫后置触发器。</p><h1 id="19-触发器语法"><a href="#19-触发器语法" class="headerlink" title="19.触发器语法"></a>19.触发器语法</h1><p>要点：1、行级触发器：针对表中每行数据变化进行操作。<br>2、语句级触发器：针对每张表进行操作的触发器。<br>3、：old 修改前的数据。Update 和 delete。<br>4、：new 修改后的数据。Insert 和 update。</p><p>5、语法：<br>CREATE [or REPLACE] TRIGGER 触发器名<br>BEFORE | AFTER<br>[DELETE ][[or] INSERT] [[or]UPDATE [OF 列名]]<br>ON 表名<br>[FOR EACH ROW ][WHEN(条件) ]<br>declare<br>……<br>begin<br>PLSQL 块<br>End ；</p><h1 id="20-前置触发器"><a href="#20-前置触发器" class="headerlink" title="20.前置触发器"></a>20.前置触发器</h1><p>要点：根据例子理解如何创建前置触发器。<br>–需求：当用户输入本月累计表数后，自动计算出本月使用数 。<br>create or replace trigger tri_account_num1<br>before<br>update of num1<br>on t_account<br>for each row<br>declare</p><p>begin<br>  –通过伪记录变量修改usenum字段的值num1（水表现在的数值），num0（上个月使用的水表数）<br>  :new.usenum := :new.num1-:new.num0;<br>end;</p><h1 id="21-后置触发器"><a href="#21-后置触发器" class="headerlink" title="21.后置触发器"></a>21.后置触发器</h1><p>要点：根据例子理解如何创建后置触发器。<br>–需求：当用户修改了业主信息表的数据时记录修改前与修改后的值<br>–创建后置触发器日志表<br>create table t_owners_log(<br>updatetime date,<br>ownerid number,<br>oldname varchar2(30),<br>newname varchar2(30)<br>);<br>–根据需求创建后置触发器<br>create or replace trigger tri_owners_log<br>after<br>update of name<br>on t_owners<br>for each row<br>declare<br>begin<br>  –向日志表插入记录<br>  insert into t_owners_log values(sysdate,:new.id,:old.name,:new.name);<br>end;<br>–修改t_owners表中的name<br>update t_owners set name=’林玲玲1’ where id=4;</p>]]></content>
      
      <categories>
          
          <category> 数据库 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> oracle </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>写文章的步骤</title>
      <link href="/2018/02/10/hello-world/"/>
      <content type="html"><![CDATA[<script src="\assets\js\APlayer.min.js"> </script><h1 id="创建步骤"><a href="#创建步骤" class="headerlink" title="创建步骤:"></a>创建步骤:</h1><p>1、写一篇文章:<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo new <span class="string">"My New Post"</span></span><br></pre></td></tr></table></figure></p><a id="more"></a><p>2、运行服务:<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure></p><p>3、生成静态页面:<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure></p><p>4、发布到服务器:<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure></p><p>5、开启播客旅程</p><h1 id="next主题优化设置"><a href="#next主题优化设置" class="headerlink" title="next主题优化设置:"></a>next主题优化设置:</h1><h2 id="1、显示网易云的音乐"><a href="#1、显示网易云的音乐" class="headerlink" title="1、显示网易云的音乐:"></a>1、显示网易云的音乐:</h2><p>在C:\lxm\MyBlog\themes\next\layout_macro\sidebar.swig里面137行加上网易云的外链<iframe></iframe></p>]]></content>
      
      <categories>
          
          <category> 杂七杂八 </category>
          
      </categories>
      
      
    </entry>
    
    <entry>
      <title>追梦赤子心</title>
      <link href="/2017/11/11/%E6%8A%80%E6%9C%AF%E4%BA%A4%E6%B5%81%E6%96%87%E7%AB%A0/"/>
      <content type="html"><![CDATA[<script src="\assets\js\APlayer.min.js"> </script><video src="http://p5o3l7yyo.bkt.clouddn.com/hc%20-%20%E8%BF%BD%E6%A2%A6%E8%B5%A4%E5%AD%90%E5%BF%83%20%E5%AE%98%E6%96%B9%E7%89%88.mp4" type="video/mp4" controls="controls" width="100%" height="100%"><br></video><p><img src="http://p57l8frp4.bkt.clouddn.com/indexImg.jpg" alt=""><br><a id="more"></a></p><h3 id="你好-如果你有神马想和我说的请留言-发送邮件至我的邮箱"><a href="#你好-如果你有神马想和我说的请留言-发送邮件至我的邮箱" class="headerlink" title="你好,如果你有神马想和我说的请留言,发送邮件至我的邮箱:"></a>你好,如果你有神马想和我说的请留言,发送邮件至我的邮箱:</h3><h2 id="fashionkillyou-foxmail-com"><a href="#fashionkillyou-foxmail-com" class="headerlink" title="fashionkillyou@foxmail.com"></a>fashionkillyou@foxmail.com</h2><h3 id="请大家多多支持-多多指教-持续更新中…"><a href="#请大家多多支持-多多指教-持续更新中…" class="headerlink" title="请大家多多支持,多多指教!持续更新中…"></a>请大家多多支持,多多指教!持续更新中…</h3>]]></content>
      
      <categories>
          
          <category> 站长留言 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 站长留言 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>第一篇播客</title>
      <link href="/2017/11/10/%E7%AC%AC%E4%B8%80%E7%AF%87%E6%92%AD%E5%AE%A2/"/>
      <content type="html"><![CDATA[<script src="\assets\js\APlayer.min.js"> </script><h3 id="我的第一篇博客"><a href="#我的第一篇博客" class="headerlink" title="我的第一篇博客,"></a>我的第一篇博客,</h3><p> 这是我的第一篇博客,哈哈,今后开启我的博客生涯,写了很多的东西笔记什么的终于可以发到网上了,我很激动很开心,yes!</p><iframe frameborder="no" border="0" marginwidth="0" marginheight="0" width="330" height="86" src="//music.163.com/outchain/player?type=2&id=544274399&auto=1&height=66"></iframe>]]></content>
      
      <categories>
          
          <category> 杂七杂八 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> test </tag>
            
        </tags>
      
    </entry>
    
  
  
</search>
