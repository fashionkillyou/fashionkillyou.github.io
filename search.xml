<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[Solr搜索平台]]></title>
    <url>%2F2018%2F03%2F18%2FSolr%E6%90%9C%E7%B4%A2%E5%B9%B3%E5%8F%B0%2F</url>
    <content type="text"><![CDATA[Solr安装与配置什么是Solr大多数搜索引擎应用都必须具有某种搜索功能，问题是搜索功能往往是巨大的资源消耗并且它们由于沉重的数据库加载而拖垮你的应用的性能。这就是为什么转移负载到一个外部的搜索服务器是一个不错的主意，Apache Solr是一个流行的开源搜索服务器，它通过使用类似REST的HTTP API，这就确保你能从几乎任何编程语言来使用solr。Solr是一个开源搜索平台，用于构建搜索应用程序。 它建立在Lucene(全文搜索引擎)之上。 Solr是企业级的，快速的和高度可扩展的。 使用Solr构建的应用程序非常复杂，可提供高性能。 为了在CNET网络的公司网站上添加搜索功能，Yonik Seely于2004年创建了Solr。并在2006年1月，它成为Apache软件基金会下的一个开源项目。并于2016年发布最新版本Solr 6.0，支持并行SQL查询的执行。 Solr可以和Hadoop一起使用。由于Hadoop处理大量数据，Solr帮助我们从这么大的源中找到所需的信息。不仅限于搜索，Solr也可以用于存储目的。像其他NoSQL数据库一样，它是一种非关系数据存储和处理技术。 总之，Solr是一个可扩展的，可部署，搜索/存储引擎，优化搜索大量以文本为中心的数据。 solr和Lucene的区别 solr是基于Lucene的 Lucene是一个全文检索工具包都是一些类库,只能java调用 solr是个Apache开源顶级项目,一个服务平台,供不同的语言调用 Lucene不支持数值范围的查询语法price:[100 To 200] solr支持数值范围的查询语法price:[100 To 200] Solr安装准备资料: 链接：https://pan.baidu.com/s/14nZ-Uq07QwPrLDeyNWGpMQ 密码：5n10 1：安装 Tomcat，解压缩即可。 2：解压 solr。 3：把 solr 下的dist目录solr-4.10.3.war部署到 Tomcat\webapps下(为了访问方便,去掉版本号)。 4：启动 Tomcat解压缩 war 包 5：把solr下example/lib/ext 目录下的所有的 jar 包，添加到 solr 的工程中(\WEB-INF\lib目录下)。 6：创建一个 solrhome 。solr 下的/example/solr 目录就是一个 solrhome。复制此目录到D盘改名为solrhome 7：关联 solr 及 solrhome。需要修改 solr 工程的 web.xml 文件。(配置文件里面有只需解开注释然后修改成以下内容即可,如果只有war的话启动一下生成即可) &lt;env-entry&gt; &lt;env-entry-name&gt;solr/home&lt;/env-entry-name&gt; &lt;env-entry-value&gt;d:\solrhome&lt;/env-entry-value&gt; &lt;env-entry-type&gt;java.lang.String&lt;/env-entry-type&gt; &lt;/env-entry&gt; 8：启动 Tomcat(如果之前有了tomcat的话,这里必须要将端口号修改.然后访问自己配置的端口号即可)http://IP:8080/solr/ 中文分析器IK AnalyzerIK Analyzer简介IK Analyzer 是一个开源的，基亍 java 语言开发的轻量级的中文分词工具包。从 2006年 12 月推出 1.0 版开始， IKAnalyzer 已经推出了 4 个大版本。最初，它是以开源项目Luence 为应用主体的，结合词典分词和文法分析算法的中文分词组件。从 3.0 版本开始，IK 发展为面向 Java 的公用分词组件，独立亍 Lucene 项目，同时提供了对 Lucene 的默认优化实现。在 2012 版本中，IK 实现了简单的分词歧义排除算法，标志着 IK 分词器从单纯的词典分词向模拟语义分词衍化。 IK Analyzer配置步骤：1、把IKAnalyzer2012FF_u1.jar 添加到 solr 工程的 lib 目录下 2、创建WEB-INF/classes文件夹 把扩展词典、停用词词典、配置文件放到 solr 工程的 WEB-INF/classes 目录下。 (扩展词典、停用词词典、配置文件 ext_stopword.dic IKAnalyzer.cfg.xml mydict.dic) 3、修改 Solrhome 的collection1\conf\schema.xml 文件，配置一个 FieldType，使用 IKAnalyzer &lt;fieldType name=&quot;text_ik&quot; class=&quot;solr.TextField&quot;&gt; &lt;analyzer class=&quot;org.wltea.analyzer.lucene.IKAnalyzer&quot;/&gt; &lt;/fieldType&gt; 配置域域相当于数据库的表字段，用户存放数据，因此用户根据业务需要去定义相关的Field（域），一般来说，每一种对应着一种数据，用户对同一种数据进行相同的操作。 域的常用属性： • name：指定域的名称 • type：指定域的类型 • indexed：是否索引 • stored：是否存储 • required：是否必须 • multiValued：是否多值 域修改solrhome的schema.xml 文件 设置业务系统 Field &lt;field name=&quot;item_goodsid&quot; type=&quot;long&quot; indexed=&quot;true&quot; stored=&quot;true&quot;/&gt; &lt;field name=&quot;item_title&quot; type=&quot;text_ik&quot; indexed=&quot;true&quot; stored=&quot;true&quot;/&gt; &lt;field name=&quot;item_price&quot; type=&quot;double&quot; indexed=&quot;true&quot; stored=&quot;true&quot;/&gt; &lt;field name=&quot;item_image&quot; type=&quot;string&quot; indexed=&quot;false&quot; stored=&quot;true&quot; /&gt; &lt;field name=&quot;item_category&quot; type=&quot;string&quot; indexed=&quot;true&quot; stored=&quot;true&quot; /&gt; &lt;field name=&quot;item_seller&quot; type=&quot;text_ik&quot; indexed=&quot;true&quot; stored=&quot;true&quot; /&gt; &lt;field name=&quot;item_brand&quot; type=&quot;string&quot; indexed=&quot;true&quot; stored=&quot;true&quot; /&gt; 复制域复制域的作用在于将某一个Field中的数据复制到另一个域中(在电商项目的商品搜索中,设置这个复制域可以集成多个条件的查询,将其他域的数据集中到这一个item_keywords域中,方便查询) &lt;field name=&quot;item_keywords&quot; type=&quot;text_ik&quot; indexed=&quot;true&quot; stored=&quot;false&quot; multiValued=&quot;true&quot;/&gt; &lt;copyField source=&quot;item_title&quot; dest=&quot;item_keywords&quot;/&gt; &lt;copyField source=&quot;item_category&quot; dest=&quot;item_keywords&quot;/&gt; &lt;copyField source=&quot;item_seller&quot; dest=&quot;item_keywords&quot;/&gt; &lt;copyField source=&quot;item_brand&quot; dest=&quot;item_keywords&quot;/&gt; 动态域当我们需要动态扩充字段时，我们需要使用动态域。对于电商项目，规格的值是不确定的，所以我们需要使用动态域来实现。 配置： &lt;dynamicField name=&quot;item_spec_*&quot; type=&quot;string&quot; indexed=&quot;true&quot; stored=&quot;true&quot; /&gt; Spring Data Solr入门Spring Data Solr简介虽然支持任何编程语言的能力具有很大的市场价值，你可能感兴趣的问题是：我如何将Solr的应用集成到Spring中？可以，Spring Data Solr就是为了方便Solr的开发所研制的一个框架，其底层是对SolrJ（官方API）的封装。 Spring Data Solr入门小Demo搭建工程（1）创建maven工程，pom.xml中引入依赖 &lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.data&lt;/groupId&gt; &lt;artifactId&gt;spring-data-solr&lt;/artifactId&gt; &lt;version&gt;1.5.5.RELEASE&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-test&lt;/artifactId&gt; &lt;version&gt;4.2.4.RELEASE&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;junit&lt;/groupId&gt; &lt;artifactId&gt;junit&lt;/artifactId&gt; &lt;version&gt;4.9&lt;/version&gt; &lt;/dependency&gt; &lt;/dependencies&gt; （2）在src/main/resources下创建 applicationContext-solr.xml &lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt; &lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xmlns:p=&quot;http://www.springframework.org/schema/p&quot; xmlns:context=&quot;http://www.springframework.org/schema/context&quot; xmlns:solr=&quot;http://www.springframework.org/schema/data/solr&quot; xsi:schemaLocation=&quot;http://www.springframework.org/schema/data/solr http://www.springframework.org/schema/data/solr/spring-solr-1.0.xsd http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context.xsd&quot;&gt; &lt;!-- solr服务器地址 --&gt; &lt;solr:solr-server id=&quot;solrServer&quot; url=&quot;http://127.0.0.1:8080/solr&quot; /&gt; &lt;!-- solr模板，使用solr模板可对索引库进行CRUD的操作 --&gt; &lt;bean id=&quot;solrTemplate&quot; class=&quot;org.springframework.data.solr.core.SolrTemplate&quot;&gt; &lt;constructor-arg ref=&quot;solrServer&quot; /&gt; &lt;/bean&gt; &lt;/beans&gt; @Field 注解创建 cn.lxm.pojo 包，创建TbItem实体类,属性使用@Field注解标识 。如果属性与配置文件定义的域名称不一致，需要在注解中指定域名称。 public class TbItem implements Serializable{ @Field private Long id; @Field(&quot;item_title&quot;) private String title; @Field(&quot;item_price&quot;) private BigDecimal price; @Field(&quot;item_image&quot;) private String image; @Field(&quot;item_goodsid&quot;) private Long goodsId; @Field(&quot;item_category&quot;) private String category; @Field(&quot;item_brand&quot;) private String brand; @Field(&quot;item_seller&quot;) private String seller; ....... } 增加（修改）创建测试类TestTemplate.java @RunWith(SpringJUnit4ClassRunner.class) @ContextConfiguration(locations=&quot;classpath:applicationContext-solr.xml&quot;) public class TestTemplate { @Autowired private SolrTemplate solrTemplate; @Test public void testAdd(){ TbItem item=new TbItem(); item.setId(1L); item.setBrand(&quot;华为&quot;); item.setCategory(&quot;手机&quot;); item.setGoodsId(1L); item.setSeller(&quot;华为2号专卖店&quot;); item.setTitle(&quot;华为Mate9&quot;); item.setPrice(new BigDecimal(2000)); solrTemplate.saveBean(item); solrTemplate.commit(); } } 按主键查询@Test public void testFindOne(){ TbItem item = solrTemplate.getById(1, TbItem.class); System.out.println(item.getTitle()); } 按主键删除@Test public void testDelete(){ solrTemplate.deleteById(&quot;1&quot;); solrTemplate.commit(); } 分页查询首先循环插入100条测试数据 @Test public void testAddList(){ List&lt;TbItem&gt; list=new ArrayList(); for(int i=0;i&lt;100;i++){ TbItem item=new TbItem(); item.setId(i+1L); item.setBrand(&quot;华为&quot;); item.setCategory(&quot;手机&quot;); item.setGoodsId(1L); item.setSeller(&quot;华为2号专卖店&quot;); item.setTitle(&quot;华为Mate&quot;+i); item.setPrice(new BigDecimal(2000+i)); list.add(item); } solrTemplate.saveBeans(list); solrTemplate.commit(); } 编写分页查询测试代码： @Test public void testPageQuery(){ Query query=new SimpleQuery(&quot;*:*&quot;); query.setOffset(20);//开始索引（默认0） query.setRows(20);//每页记录数(默认10) ScoredPage&lt;TbItem&gt; page = solrTemplate.queryForPage(query, TbItem.class); System.out.println(&quot;总记录数：&quot;+page.getTotalElements()); List&lt;TbItem&gt; list = page.getContent(); showList(list); } 公共代码遍历循环显示查询结果: //显示记录数据 private void showList(List&lt;TbItem&gt; list){ for(TbItem item:list){ System.out.println(item.getTitle() +item.getPrice()); } } 条件查询 Criteria 用于对条件的封装： @Test public void testPageQueryMutil(){ Query query=new SimpleQuery(&quot;*:*&quot;); Criteria criteria=new Criteria(&quot;item_title&quot;).contains(&quot;2&quot;); criteria=criteria.and(&quot;item_title&quot;).contains(&quot;5&quot;); query.addCriteria(criteria); //query.setOffset(20);//开始索引（默认0） //query.setRows(20);//每页记录数(默认10) ScoredPage&lt;TbItem&gt; page = solrTemplate.queryForPage(query, TbItem.class); System.out.println(&quot;总记录数：&quot;+page.getTotalElements()); List&lt;TbItem&gt; list = page.getContent(); showList(list); } 删除全部数据@Test public void testDeleteAll(){ Query query=new SimpleQuery(&quot;*:*&quot;); solrTemplate.delete(query); solrTemplate.commit(); } 描述 设置高亮显示@Test public void testHighLight(){ HighlightQuery query = new SimpleHighlightQuery(); //设置高亮的域 HighlightOptions highlightOptions = new HighlightOptions().addField(&quot;item_title&quot;); //设置高亮显示的前缀 highlightOptions.setSimplePrefix(&quot;&lt;em style=&apos;color:red&apos;&quot;); //设置高亮显示的后缀 highlightOptions.setSimplePostfix(&quot;&lt;/em&gt;&quot;); //设置高亮选项 query.setHighlightOptions(highlightOptions); //设置查询条件 Criteria criteria = new Criteria(&quot;item_title&quot;).contains(&quot;手机&quot;); query.addCriteria(criteria); HighlightPage&lt;TbItem&gt; page = solrTemplate.queryForHighlightPage(query, TbItem.class); //循环高亮入口集合 for (HighlightEntry&lt;TbItem&gt; h : page.getHighlighted()) { //获取原实体类 TbItem item = h.getEntity(); if(h.getHighlights().size()&gt;0 &amp;&amp; h.getHighlights().get(0).getSnipplets().size()&gt;0){ //设置高亮的结果 item.setTitle(h.getHighlights().get(0).getSnipplets().get(0)); } } System.out.println(&quot;总记录数：&quot;+page.getTotalElements()); List&lt;TbItem&gt; list = page.getContent(); showList(list); }]]></content>
      <categories>
        <category>搜索解决方案</category>
      </categories>
      <tags>
        <tag>Solr</tag>
        <tag>Spring Data Solr</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Spring-Data-Redis总结]]></title>
    <url>%2F2018%2F03%2F15%2FSpring-Data-Redis%E6%80%BB%E7%BB%93%2F</url>
    <content type="text"><![CDATA[什么是Redisredis是一个非关系型Key-Value数据库,运行在内存中,由ANSI C编写。企业开发通常采用Redis来实现缓存。同类的产品还有memcache 、memcached 、MongoDB等。 什么是JedisJedis是Redis官方推出的一款面向Java的客户端，提供了很多接口供Java语言调用。可以在Redis官网下载，当然还有一些开源爱好者提供的客户端，如Jredis、SRP等等，推荐使用Jedis。 Spring Data RedisSpring-data-redis是spring大家族的一部分，提供了在srping应用中通过简单的配置访问redis服务，对reids底层开发包(Jedis, JRedis, and RJC)进行了高度封装，RedisTemplate提供了redis各种操作、异常处理及序列化，支持发布订阅，并对spring 3.1 cache进行了实现。spring-data-redis针对jedis提供了如下功能： 1.连接池自动管理，提供了一个高度封装的“RedisTemplate”类 2.针对jedis客户端中大量api进行了归类封装,将同一类型操作封装为operation接口 ValueOperations：简单K-V操作 SetOperations：set类型数据操作 ZSetOperations：zset类型数据操作 HashOperations：针对map类型的数据操作 ListOperations：针对list类型的数据操作 使用spring-data-redis准备工作:1.构建maven工程(步骤略,如果已有请忽略)2.引入spring相关依赖,引入junit依赖(步骤略,如果已有请忽略)3.引入jedis和SpringDataRedis依赖&lt;!-- 缓存 --&gt; &lt;dependency&gt; &lt;groupId&gt;redis.clients&lt;/groupId&gt; &lt;artifactId&gt;jedis&lt;/artifactId&gt; &lt;version&gt;2.8.1&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.data&lt;/groupId&gt; &lt;artifactId&gt;spring-data-redis&lt;/artifactId&gt; &lt;version&gt;1.7.2.RELEASE&lt;/version&gt; &lt;/dependency&gt; 4.在src/main/resource下创建properties文件夹,建立redis-config.propertiesredis.host用来设置服务器地址 redis.port用来设置端口号 redis.host=127.0.0.1 redis.port=6379 redis.pass= redis.database=0 redis.maxIdle=300 redis.maxWait=3000 redis.testOnBorrow=true 5.在src/main/resources下创建spring文件夹 ，创建applicationContext-redis.xml&lt;context:property-placeholder location=&quot;classpath*:properties/*.properties&quot; /&gt; &lt;!-- redis 相关配置 --&gt; &lt;bean id=&quot;poolConfig&quot; class=&quot;redis.clients.jedis.JedisPoolConfig&quot;&gt; &lt;property name=&quot;maxIdle&quot; value=&quot;${redis.maxIdle}&quot; /&gt; &lt;property name=&quot;maxWaitMillis&quot; value=&quot;${redis.maxWait}&quot; /&gt; &lt;property name=&quot;testOnBorrow&quot; value=&quot;${redis.testOnBorrow}&quot; /&gt; &lt;/bean&gt; &lt;bean id=&quot;JedisConnectionFactory&quot; class=&quot;org.springframework.data.redis.connection.jedis.JedisConnectionFactory&quot; p:host-name=&quot;${redis.host}&quot; p:port=&quot;${redis.port}&quot; p:password=&quot;${redis.pass}&quot; p:pool-config-ref=&quot;poolConfig&quot;/&gt; &lt;bean id=&quot;redisTemplate&quot; class=&quot;org.springframework.data.redis.core.RedisTemplate&quot;&gt; &lt;property name=&quot;connectionFactory&quot; ref=&quot;JedisConnectionFactory&quot; /&gt; &lt;/bean&gt; maxIdle ：最大空闲数 maxWaitMillis:连接时的最大等待毫秒数 testOnBorrow：在提取一个jedis实例时，是否提前进行验证操作；如果为true，则得到的jedis实例均是可用的 测试这里只写常用的hash和String两种类型的数据CRUD String:@RunWith(SpringJUnit4ClassRunner.class) @ContextConfiguration(locations=&quot;classpath:spring/applicationContext-redis.xml&quot;) public class TestValue { @Autowired private RedisTemplate redisTemplate; @Test public void setValue(){ redisTemplate.boundValueOps(&quot;name&quot;).set(&quot;itcast&quot;); } @Test public void getValue(){ String str = (String) redisTemplate.boundValueOps(&quot;name&quot;).get(); System.out.println(str); } @Test public void deleteValue(){ redisTemplate.delete(&quot;name&quot;);; } } Hash类型操作创建测试类TestHash （1）存入值 @Test public void testSetValue(){ redisTemplate.boundHashOps(&quot;namehash&quot;).put(&quot;a&quot;, &quot;唐僧&quot;); redisTemplate.boundHashOps(&quot;namehash&quot;).put(&quot;b&quot;, &quot;悟空&quot;); redisTemplate.boundHashOps(&quot;namehash&quot;).put(&quot;c&quot;, &quot;八戒&quot;); redisTemplate.boundHashOps(&quot;namehash&quot;).put(&quot;d&quot;, &quot;沙僧&quot;); } （2）提取所有的KEY @Test public void testGetKeys(){ Set s = redisTemplate.boundHashOps(&quot;namehash&quot;).keys(); System.out.println(s); } 运行结果：[a, b, c, d] （3）提取所有的值 @Test public void testGetValues(){ List values = redisTemplate.boundHashOps(&quot;namehash&quot;).values(); System.out.println(values); } 运行结果：[唐僧, 悟空, 八戒, 沙僧] （4）根据KEY提取值 @Test public void testGetValueByKey(){ Object object = redisTemplate.boundHashOps(&quot;namehash&quot;).get(&quot;b&quot;); System.out.println(object); } 运行结果：悟空 （5）根据KEY移除值 @Test public void testRemoveValueByKey(){ redisTemplate.boundHashOps(&quot;namehash&quot;).delete(&quot;c&quot;); } 运行后再次查看集合内容：[唐僧, 悟空, 沙僧] 小节(缓存同步问题) 在项目中使用redis会涉及到缓存同步的问题,解决这个问题是在进行缓存内容增删改之前要先删除缓存,然后再进行查询数据,这样在更改后的下次查询,在缓存中查不到数据就会去数据库中查询,然后再保存进缓存,这样就实现了缓存的同步. 在使用时是先要查询缓存,然后判断缓存是否存在所要查询的数据,如果存在的话就直接返回结果,如果没有查询到的话,就去数据库里面查询,然后将查询结果保存进缓存中.]]></content>
      <categories>
        <category>java</category>
      </categories>
      <tags>
        <tag>redis</tag>
        <tag>spring-data-redis</tag>
        <tag>jedis</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[数据库的事务]]></title>
    <url>%2F2018%2F03%2F14%2F%E6%95%B0%E6%8D%AE%E5%BA%93%E7%9A%84%E4%BA%8B%E5%8A%A1%2F</url>
    <content type="text"><![CDATA[【事务的概述】什么是事务:事务指的是逻辑上的一组操作,组成这组操作的各个逻辑单元要么一起成功,要么一起失败.MYSQL的事务管理有两种方式:(MYSQL数据库事务默认是自动提交的.Oracle数据库事务默认是不自动提交.) 1.手动开启事务 start transaction; – 开启事务 多条sql; commit/rollback; 2.设置一个自动提交参数 show variables like ‘%commit%’; – 查看与commit相关参数. set autocommit = 0; – 将autocommit参数设置为OFF. 【JDBC中的事务管理】JDBC的事务的管理的API:同一个事务 连接必须得是同一个对象(就是提交和设置的connection必须得是同一个),要加在业务层 总结:事务特性: 原子性：强调事务的不可分割.(要么一起成功,要么一起失败) 一致性：强调的是事务的执行的前后，数据的完整性要保持一致.(转账前总和2000,转完后总和也得是2000) 隔离性：一个事务的执行不应该受到其他事务的干扰. 持久性：事务一旦结束(提交/回滚)数据就持久保持到了数据库. 如果不考虑事务的隔离性,引发一些安全性问题: 一类是 读问题: 不可重复读 :一个事务读到了另一个事务已经提交的update的数据,导致在当前的事务中多次查询结果不一致. 虚读/幻读 :一个事务读到另一个事务已经提交的insert的数据,导致在 当前的事务中多次的查询结果不一致. 一类是 写问题: 引发两类丢失更新: 解决引发的读问题:设置事务的隔离级别: read uncommitted :未提交读.脏读，不可重复读，虚读都可能发生.(安全性低,但是效率高) read committed :已提交读.避免脏读.但是不可重复读和虚读有可能发生. repeatable read :可重复读.避免脏读,不可重复读.但是虚读有可能发生. serializable :串行化的.避免脏读，不可重复读，虚读的发生.(安全性高,但是效率低) * MYSQL隔离级别：repeatable read Oracle隔离级别:read committed]]></content>
      <categories>
        <category>数据库</category>
      </categories>
      <tags>
        <tag>事务管理</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[使用FastDFS+angularJS+HTML5+springMVC进行文件上传]]></title>
    <url>%2F2018%2F03%2F12%2F%E4%BD%BF%E7%94%A8FastDFS-angularJS-HTML5-springMVC%E8%BF%9B%E8%A1%8C%E6%96%87%E4%BB%B6%E4%B8%8A%E4%BC%A0%2F</url>
    <content type="text"><![CDATA[分布式文件服务器FastDFS什么是FastDFSFastDFS 是用 c 语言编写的一款开源的分布式文件系统。FastDFS 为互联网量身定制，充分考虑了冗余备份、负载均衡、线性扩容等机制，并注重高可用、高性能等指标，使用 FastDFS很容易搭建一套高性能的文件服务器集群提供文件上传、下载等服务。 FastDFS 架构包括 Tracker server 和 Storage server。客户端请求 Tracker server 进行文件上传、下载，通过 Tracker server 调度最终由 Storage server 完成文件上传和下载。 Tracker server 作用是负载均衡和调度，通过 Tracker server 在文件上传时可以根据一些策略找到 Storage server 提供文件上传服务。可以将 tracker 称为追踪服务器或调度服务器。 Storage server 作用是文件存储，客户端上传的文件最终存储在 Storage 服务器上，Storageserver 没有实现自己的文件系统而是利用操作系统 的文件系统来管理文件。可以将storage称为存储服务器。 服务端两个角色： Tracker：管理集群，tracker 也可以实现集群。每个 tracker 节点地位平等。收集 Storage 集群的状态。 Storage：实际保存文件 Storage 分为多个组，每个组之间保存的文件是不同的。每个组内部可以有多个成员，组成员内部保存的内容是一样的，组成员的地位是一致的，没有主从的概念。 文件上传及下载的流程文件上传流程 客户端上传文件后存储服务器将文件 ID 返回给客户端，此文件 ID 用于以后访问该文件的索引信息。文件索引信息包括：组名，虚拟磁盘路径，数据两级目录，文件名。 组名：文件上传后所在的 storage 组名称，在文件上传成功后有 storage 服务器返回，需要客户端自行保存。 虚拟磁盘路径：storage 配置的虚拟路径，与磁盘选项 store_path*对应。如果配置了store_path0 则是 M00，如果配置了 store_path1 则是 M01，以此类推。 数据两级目录：storage 服务器在每个虚拟磁盘路径下创建的两级目录，用于存储数据文件。 文件名：与文件上传时不同。是由存储服务器根据特定信息生成，文件名包含：源存储服务器 IP 地址、文件创建时间戳、文件大小、随机数和文件拓展名等信息。 文件下载流程 最简单的 FastDFS 架构 FastDFS安装请参考一下博客: https://www.cnblogs.com/fishbay/archive/2017/09/24/7586772.html http://blog.csdn.net/XingJames/article/details/52759876 FastDFS安装全过程记录 代码案例依赖的jar包:&lt;!-- 文件上传组件 --&gt; &lt;dependency&gt; &lt;groupId&gt;org.csource.fastdfs&lt;/groupId&gt; &lt;artifactId&gt;fastdfs&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;commons-fileupload&lt;/groupId&gt; &lt;artifactId&gt;commons-fileupload&lt;/artifactId&gt; &lt;/dependency&gt; 使用的工具类:package util; import org.csource.common.NameValuePair; import org.csource.fastdfs.ClientGlobal; import org.csource.fastdfs.StorageClient1; import org.csource.fastdfs.StorageServer; import org.csource.fastdfs.TrackerClient; import org.csource.fastdfs.TrackerServer; public class FastDFSClient { private TrackerClient trackerClient = null; private TrackerServer trackerServer = null; private StorageServer storageServer = null; private StorageClient1 storageClient = null; public FastDFSClient(String conf) throws Exception { if (conf.contains(&quot;classpath:&quot;)) { conf = conf.replace(&quot;classpath:&quot;, this.getClass().getResource(&quot;/&quot;).getPath()); } ClientGlobal.init(conf); trackerClient = new TrackerClient(); trackerServer = trackerClient.getConnection(); storageServer = null; storageClient = new StorageClient1(trackerServer, storageServer); } /** * 上传文件方法 * &lt;p&gt;Title: uploadFile&lt;/p&gt; * &lt;p&gt;Description: &lt;/p&gt; * @param fileName 文件全路径 * @param extName 文件扩展名，不包含（.） * @param metas 文件扩展信息 * @return * @throws Exception */ public String uploadFile(String fileName, String extName, NameValuePair[] metas) throws Exception { String result = storageClient.upload_file1(fileName, extName, metas); return result; } public String uploadFile(String fileName) throws Exception { return uploadFile(fileName, null, null); } public String uploadFile(String fileName, String extName) throws Exception { return uploadFile(fileName, extName, null); } /** * 上传文件方法 * &lt;p&gt;Title: uploadFile&lt;/p&gt; * &lt;p&gt;Description: &lt;/p&gt; * @param fileContent 文件的内容，字节数组 * @param extName 文件扩展名 * @param metas 文件扩展信息 * @return * @throws Exception */ public String uploadFile(byte[] fileContent, String extName, NameValuePair[] metas) throws Exception { String result = storageClient.upload_file1(fileContent, extName, metas); return result; } public String uploadFile(byte[] fileContent) throws Exception { return uploadFile(fileContent, null, null); } public String uploadFile(byte[] fileContent, String extName) throws Exception { return uploadFile(fileContent, extName, null); } } config下的配置文件(fdfs_client.conf):注意修改 tracker_server=192.168.25.133:22122为tracker服务器地址 # connect timeout in seconds # default value is 30s connect_timeout=30 # network timeout in seconds # default value is 30s network_timeout=60 # the base path to store log files base_path=/home/fastdfs # tracker_server can ocur more than once, and tracker_server format is # &quot;host:port&quot;, host can be hostname or ip address tracker_server=192.168.25.133:22122 #standard log level as syslog, case insensitive, value list: ### emerg for emergency ### alert ### crit for critical ### error ### warn for warning ### notice ### info ### debug log_level=info # if use connection pool # default value is false # since V4.05 use_connection_pool = false # connections whose the idle time exceeds this time will be closed # unit: second # default value is 3600 # since V4.05 connection_pool_max_idle_time = 3600 # if load FastDFS parameters from tracker server # since V4.05 # default value is false load_fdfs_parameters_from_tracker=false # if use storage ID instead of IP address # same as tracker.conf # valid only when load_fdfs_parameters_from_tracker is false # default value is false # since V4.05 use_storage_id = false # specify storage ids filename, can use relative or absolute path # same as tracker.conf # valid only when load_fdfs_parameters_from_tracker is false # since V4.05 storage_ids_filename = storage_ids.conf #HTTP settings http.tracker_server_port=80 #use &quot;#include&quot; directive to include HTTP other settiongs ##include http.conf springmvc.xml中添加配置&lt;!-- 配置多媒体解析器 --&gt; &lt;bean id=&quot;multipartResolver&quot; class=&quot;org.springframework.web.multipart.commons.CommonsMultipartResolver&quot;&gt; &lt;property name=&quot;defaultEncoding&quot; value=&quot;UTF-8&quot;&gt;&lt;/property&gt; &lt;!-- 设定文件上传的最大值5MB，5*1024*1024 --&gt; &lt;property name=&quot;maxUploadSize&quot; value=&quot;5242880&quot;&gt;&lt;/property&gt; &lt;/bean&gt; controller控制层代码:/** * 文件上传Controller * @author Administrator * */ @RestController public class UploadController { @RequestMapping(&quot;/upload&quot;) public Result upload( MultipartFile file){ //1、取文件的扩展名 String originalFilename = file.getOriginalFilename(); String extName = originalFilename.substring(originalFilename.lastIndexOf(&quot;.&quot;) + 1); try { //2、创建一个 FastDFS 的客户端 FastDFSClient fastDFSClient = new FastDFSClient(&quot;classpath:config/fdfs_client.conf&quot;); //3、执行上传处理 String path = fastDFSClient.uploadFile(file.getBytes(), extName); //4、拼接返回的 url 和 ip 地址，拼装成完整的 url String url = &quot;文件服务器地址&quot; + path; return new Result(true,url); } catch (Exception e) { e.printStackTrace(); return new Result(false, &quot;上传失败&quot;); } } } 前端Service.js代码//文件上传服务层 app.service(&quot;uploadService&quot;,function($http){ this.uploadFile=function(){ var formData=new FormData(); formData.append(&quot;file&quot;,file.files[0]); return $http({ method:&apos;POST&apos;, url:&quot;../upload.do&quot;, data: formData, headers: {&apos;Content-Type&apos;:undefined}, transformRequest: angular.identity }); } }); anjularjs对于post和get请求默认的Content-Type header 是application/json。通过设置‘Content-Type’: undefined，这样浏览器会帮我们把Content-Type 设置为 multipart/form-data. 通过设置 transformRequest: angular.identity ，anjularjs transformRequest function 将序列化我们的formdata object. 前端controller.js代码app.controller(&apos;myController&apos; ,function($scope,$controller,goodsService,itemCatService,uploadService){ /** * 上传图片 */ $scope.uploadFile=function(){ uploadService.uploadFile().success(function(response) { if(response.success){//如果上传成功，取出url $scope.image_entity.url=response.message;//设置文件地址 }else{ alert(response.message); } }).error(function() { alert(&quot;上传发生错误&quot;); }); }; } 页面显示&lt;div class=&quot;modal-body&quot;&gt; &lt;table class=&quot;table table-bordered table-striped&quot;&gt; &lt;tr&gt; &lt;td&gt;图片&lt;/td&gt; &lt;td&gt; &lt;table&gt; &lt;tr&gt; &lt;td&gt; &lt;input type=&quot;file&quot; id=&quot;file&quot; /&gt; &lt;button class=&quot;btn btn-primary&quot; type=&quot;button&quot; ng-click=&quot;uploadFile()&quot;&gt; 上传 &lt;/button&gt; &lt;/td&gt; &lt;td&gt; &lt;img src=&quot;{{image_entity.url}}&quot; width=&quot;200px&quot; height=&quot;200px&quot;&gt; &lt;/td&gt; &lt;/tr&gt; &lt;/table&gt; &lt;/td&gt; &lt;/tr&gt; &lt;/table&gt; &lt;/div&gt;]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>FastDFS</tag>
        <tag>angularJS</tag>
        <tag>HTML5</tag>
        <tag>springMVC</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[基于angularJS的多选框select2]]></title>
    <url>%2F2018%2F03%2F09%2F%E5%9F%BA%E4%BA%8EangularJS%E7%9A%84%E5%A4%9A%E9%80%89%E6%A1%86select2%2F</url>
    <content type="text"><![CDATA[基于angularJS框架下的select2插件的使用 使用步骤:引入JS文件&lt;link rel=&quot;stylesheet&quot; href=&quot;bootstrap/css/bootstrap.min.css&quot;&gt; &lt;script src=&quot;jQuery/jquery-2.2.3.min.js&quot;&gt;&lt;/script&gt; &lt;script src=&quot;bootstrap/js/bootstrap.min.js&quot;&gt;&lt;/script&gt; &lt;!-- 引入angularJS,分页,controller,service --&gt; &lt;script type=&quot;text/javascript&quot; src=&quot;angularjs/angular.min.js&quot;&gt; &lt;/script&gt; &lt;!-- 引入select2的插件 --&gt; &lt;!-- 这个要在base_pagination.js之后,因为用到了app --&gt; &lt;link rel=&quot;stylesheet&quot; href=&quot;select2/select2.css&quot; /&gt; &lt;link rel=&quot;stylesheet&quot; href=&quot;select2/select2-bootstrap.css&quot; /&gt; &lt;script src=&quot;select2/select2.min.js&quot; type=&quot;text/javascript&quot;&gt;&lt;/script&gt; &lt;script type=&quot;text/javascript&quot; src=&quot;select2/angular-select2.js&quot;&gt;&lt;/script&gt; 写input的属性&lt;input select2 select2-model=&quot;entity.brandIds&quot; config=&quot;brandList&quot; multiple placeholder=&quot; 选择品牌（可多选） &quot; class=&quot;form-control&quot;&gt; multiple 表示可多选 Config用于配置数据来源 select2-model用于指定用户选择后提交的变量 select2 必须加上否则失效 给定数据源注意这个要放置在select插件的前面,因为select2使用到了app 这里的数据格式默认是{{id:2,text:'华为'}} &lt;script type=&quot;text/javascript&quot;&gt; var app = angular.module(&apos;app&apos;,[]); app.controller(&apos;myController&apos;,function($scope){ //列表数据 $scope.brandList={data:[{id:1,text:&apos;联想&apos;},{id:2,text:&apos;华为&apos;},{id:3,text:&apos;小米&apos;}]}; }); &lt;/script&gt; 资源文件: 简单多选demo链接：https://pan.baidu.com/s/12xz7kcmZGwcTjMH7MJhmDg 密码：0aq2 完整说明文档链接：https://pan.baidu.com/s/1XSHqbbx3ikZRlkIFgXgMGQ 密码：66gc 官网https://select2.org/]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>angularJS</tag>
        <tag>select2</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[使用Mybatis的PageHelper插件进行分页]]></title>
    <url>%2F2018%2F03%2F07%2F%E4%BD%BF%E7%94%A8Mybatis%E7%9A%84PageHelper%E6%8F%92%E4%BB%B6%E8%BF%9B%E8%A1%8C%E5%88%86%E9%A1%B5%2F</url>
    <content type="text"><![CDATA[PageHelper插件进行分页实现效果 ##准备内容本文是建立在以下框架之上: 前端使用的是angularJS框架+BootStrap 后台是SpringMVC+Spring+Mybatis 前期的搭建请看(官方文档) 推荐博客: http://blog.csdn.net/maoyuanming0806/article/details/77720754 http://blog.csdn.net/FansUnion/article/details/40304187 后端代码分页结果封装实体创建类PageResult用于在controller中返回分页数据 package entity; import java.util.List; /** * 分页结果封装对象 * @author Administrator * */ public class PageResult implements Serializable{ private long total;//总记录数 private List rows;//当前页结果 public PageResult(long total, List rows) { super(); this.total = total; this.rows = rows; } //getter and setter ..... } 服务接口层在service的接口BrandService.java 增加方法定义 /** * 返回分页列表 * @return */ public PageResult findPage(int pageNum,int pageSize); 服务实现层service的实现类BrandServiceImpl.java中实现该方法 @Override public PageResult findPage(int pageNum, int pageSize) { PageHelper.startPage(pageNum, pageSize); Page&lt;TbBrand&gt; page= (Page&lt;TbBrand&gt;) brandMapper.selectByExample(null); return new PageResult(page.getTotal(), page.getResult()); } PageHelper为MyBatis分页插件 控制层在控制层BrandController.java新增方法 /** * 返回全部列表 * @return */ @RequestMapping(&quot;/findPage&quot;) public PageResult findPage(int page,int rows){ return brandService.findPage(page, rows); } 前端代码HTML在brand.html引入分页组件 &lt;!-- 分页组件开始 --&gt; &lt;script src=&quot;../plugins/angularjs/pagination.js&quot;&gt;&lt;/script&gt; &lt;link rel=&quot;stylesheet&quot; href=&quot;../plugins/angularjs/pagination.css&quot;&gt; &lt;!-- 分页组件结束 --&gt; 构建app模块时引入pagination模块 var app=angular.module(&apos;pinyougou&apos;,[&apos;pagination&apos;]); 页面的表格下放置分页组件 &lt;!-- 分页 --&gt; &lt;tm-pagination conf=&quot;paginationConf&quot;&gt;&lt;/tm-pagination&gt; JS代码//重新加载列表 数据 $scope.reloadList=function(){ //切换页码 $scope.findPage( $scope.paginationConf.currentPage, $scope.paginationConf.itemsPerPage); } //分页控件配置 $scope.paginationConf = { currentPage: 1, totalItems: 10, itemsPerPage: 10, perPageOptions: [10, 20, 30, 40, 50], onChange: function(){ $scope.reloadList();//重新加载 } }; //分页 $scope.findPage=function(page,rows){ $http.get(&apos;../brand/findPage.do?page=&apos;+page+&apos;&amp;rows=&apos;+rows).success( function(response){ $scope.list=response.rows; $scope.paginationConf.totalItems=response.total;//更新总记录数 } ); } paginationConf 变量各属性的意义： currentPage：当前页码 totalItems:总条数 itemsPerPage: perPageOptions：页码选项 onChange：更改页面时触发事件]]></content>
      <tags>
        <tag>Mybatis</tag>
        <tag>PageHelper</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[AngularJS框架]]></title>
    <url>%2F2018%2F03%2F07%2FAngularJS%E6%A1%86%E6%9E%B6%2F</url>
    <content type="text"><![CDATA[AngularJS简介 AngularJS 诞生于2009年，由Misko Hevery 等人创建，后为Google所收购。是一款优秀的前端JS框架，已经被用于Google的多款产品当中。AngularJS有着诸多特性，最为核心的是：MVC、模块化、自动化双向数据绑定、依赖注入等等。 AngularJS四大特征MVC 模式Angular遵循软件工程的MVC模式,并鼓励展现，数据，和逻辑组件之间的松耦合.通过依赖注入（dependency injection），Angular为客户端的Web应用带来了传统服务端的服务，例如独立于视图的控制。 因此，后端减少了许多负担，产生了更轻的Web应用。 Model:数据,其实就是angular变量($scope.XX); View: 数据的呈现,Html+Directive(指令); Controller:操作数据,就是function,数据的增删改查; 双向绑定AngularJS是建立在这样的信念上的：即声明式编程应该用于构建用户界面以及编写软件构建，而指令式编程非常适合来表示业务逻辑。框架采用并扩展了传统HTML，通过双向的数据绑定来适应动态内容，双向的数据绑定允许模型和视图之间的自动同步。因此，AngularJS使得对DOM的操作不再重要并提升了可测试性。 依赖注入依赖注入(Dependency Injection,简称DI)是一种设计模式, 指某个对象依赖的其他对象无需手工创建，只需要“吼一嗓子”，则此对象在创建时，其依赖的对象由框架来自动创建并注入进来,其实就是最少知识法则;模块中所有的service和provider两类对象，都可以根据形参名称实现DI. 模块化设计高内聚低耦合法则 官方提供的模块 ng、ngRoute、ngAnimate 用户自定义的模块 angular.module(‘模块名’,[ ]) 入门小Demo表达式&lt;html&gt; &lt;head&gt; &lt;title&gt;入门小Demo-1&lt;/title&gt; &lt;script src=&quot;angular.min.js&quot;&gt;&lt;/script&gt; &lt;/head&gt; &lt;body ng-app&gt; {{100+100}} &lt;/body&gt; &lt;/html&gt; 执行结果如下： 表达式的写法是 表达式可以是变量或是运算式 ng-app 指令 作用是告诉子元素一下的指令是归angularJs的,angularJs会识别的 ng-app 指令定义了 AngularJS 应用程序的 根元素。 ng-app 指令在网页加载完毕时会自动引导（自动初始化）应用程序。 双向绑定&lt;html&gt; &lt;head&gt; &lt;title&gt;入门小Demo-1 双向绑定&lt;/title&gt; &lt;script src=&quot;angular.min.js&quot;&gt;&lt;/script&gt; &lt;/head&gt; &lt;body ng-app&gt; 请输入你的姓名：&lt;input ng-model=&quot;myname&quot;&gt; &lt;br&gt; {{myname}},你好 &lt;/body&gt; &lt;/html&gt; 运行效果如下： ng-model 指令用于绑定变量,这样用户在文本框输入的内容会绑定到变量上，而表达式可以实时地输出变量。 初始化指令我们如果希望有些变量具有初始值，可以使用ng-init指令来对变量初始化 &lt;html&gt; &lt;head&gt; &lt;title&gt;入门小Demo-3 初始化&lt;/title&gt; &lt;script src=&quot;angular.min.js&quot;&gt;&lt;/script&gt; &lt;/head&gt; &lt;body ng-app ng-init=&quot;myname=&apos;陈大海&apos;&quot;&gt; 请输入你的姓名：&lt;input ng-model=&quot;myname&quot;&gt; &lt;br&gt; {{myname}},你好 &lt;/body&gt; &lt;/html&gt; 控制器&lt;html&gt; &lt;head&gt; &lt;title&gt;入门小Demo-3 初始化&lt;/title&gt; &lt;script src=&quot;angular.min.js&quot;&gt;&lt;/script&gt; &lt;script&gt; var app=angular.module(&apos;myApp&apos;,[]); //定义了一个叫myApp的模块 //定义控制器 app.controller(&apos;myController&apos;,function($scope){ $scope.add=function(){ return parseInt($scope.x)+parseInt($scope.y); } }); &lt;/script&gt; &lt;/head&gt; &lt;body ng-app=&quot;myApp&quot; ng-controller=&quot;myController&quot;&gt; x:&lt;input ng-model=&quot;x&quot; &gt; y:&lt;input ng-model=&quot;y&quot; &gt; 运算结果：{{add()}} &lt;/body&gt; &lt;/html&gt; 运行结果如下： ng-controller用于指定所使用的控制器。 理解 $scope： $scope 的使用贯穿整个 AngularJS App 应用,它与数据模型相关联,同时也是表达式执行的上下文.有了$scope 就在视图和控制器之间建立了一个通道,基于作用域视图在修改数据时会立刻更新 $scope,同样的$scope 发生改变时也会立刻重新渲染视图. 事件指令&lt;html&gt; &lt;head&gt; &lt;title&gt;入门小Demo-5 事件指令&lt;/title&gt; &lt;script src=&quot;angular.min.js&quot;&gt;&lt;/script&gt; &lt;script&gt; var app=angular.module(&apos;myApp&apos;,[]); //定义了一个叫myApp的模块 //定义控制器 app.controller(&apos;myController&apos;,function($scope){ $scope.add=function(){ $scope.z= parseInt($scope.x)+parseInt($scope.y); } }); &lt;/script&gt; &lt;/head&gt; &lt;body ng-app=&quot;myApp&quot; ng-controller=&quot;myController&quot;&gt; x:&lt;input ng-model=&quot;x&quot; &gt; y:&lt;input ng-model=&quot;y&quot; &gt; &lt;button ng-click=&quot;add()&quot;&gt;运算&lt;/button&gt; 结果：{{z}} &lt;/body&gt; &lt;/html&gt; 运行结果： ng-click 是最常用的单击事件指令，再点击时触发控制器的某个方法 循环数组&lt;html&gt; &lt;head&gt; &lt;title&gt;入门小Demo-6 循环数据&lt;/title&gt; &lt;script src=&quot;angular.min.js&quot;&gt;&lt;/script&gt; &lt;script&gt; var app=angular.module(&apos;myApp&apos;,[]); //定义了一个叫myApp的模块 //定义控制器 app.controller(&apos;myController&apos;,function($scope){ $scope.list= [100,192,203,434 ];//定义数组 }); &lt;/script&gt; &lt;/head&gt; &lt;body ng-app=&quot;myApp&quot; ng-controller=&quot;myController&quot;&gt; &lt;table&gt; &lt;tr ng-repeat=&quot;x in list&quot;&gt; &lt;td&gt;{{x}}&lt;/td&gt; &lt;/tr&gt; &lt;/table&gt; &lt;/body&gt; &lt;/html&gt; 这里的ng-repeat指令用于循环数组变量。运行结果如下： 循环对象数组&lt;html&gt; &lt;head&gt; &lt;title&gt;入门小Demo-7 循环对象数组&lt;/title&gt; &lt;script src=&quot;angular.min.js&quot;&gt;&lt;/script&gt; &lt;script&gt; var app=angular.module(&apos;myApp&apos;,[]); //定义了一个叫myApp的模块 //定义控制器 app.controller(&apos;myController&apos;,function($scope){ $scope.list= [ {name:&apos;张三&apos;,shuxue:100,yuwen:93}, {name:&apos;李四&apos;,shuxue:88,yuwen:87}, {name:&apos;王五&apos;,shuxue:77,yuwen:56} ];//定义数组 }); &lt;/script&gt; &lt;/head&gt; &lt;body ng-app=&quot;myApp&quot; ng-controller=&quot;myController&quot;&gt; &lt;table&gt; &lt;tr&gt; &lt;td&gt;姓名&lt;/td&gt; &lt;td&gt;数学&lt;/td&gt; &lt;td&gt;语文&lt;/td&gt; &lt;/tr&gt; &lt;tr ng-repeat=&quot;entity in list&quot;&gt; &lt;td&gt;{{entity.name}}&lt;/td&gt; &lt;td&gt;{{entity.shuxue}}&lt;/td&gt; &lt;td&gt;{{entity.yuwen}}&lt;/td&gt; &lt;/tr&gt; &lt;/table&gt; &lt;/body&gt; &lt;/html&gt; 运行结果如下： 内置服务我们的数据一般都是从后端获取的，那么如何获取数据呢？我们一般使用内置服务$http来实现。注意：以下代码需要在tomcat中运行。 &lt;html&gt; &lt;head&gt; &lt;title&gt;入门小Demo-8 内置服务&lt;/title&gt; &lt;meta charset=&quot;utf-8&quot; /&gt; &lt;script src=&quot;angular.min.js&quot;&gt;&lt;/script&gt; &lt;script&gt; var app=angular.module(&apos;myApp&apos;,[]); //定义了一个叫myApp的模块 //定义控制器 app.controller(&apos;myController&apos;,function($scope,$http){ $scope.findAll=function(){ $http.get(&apos;data.json&apos;).success( function(response){ $scope.list=response; } ); } }); &lt;/script&gt; &lt;/head&gt; &lt;body ng-app=&quot;myApp&quot; ng-controller=&quot;myController&quot; ng-init=&quot;findAll()&quot;&gt; &lt;table&gt; &lt;tr&gt; &lt;td&gt;姓名&lt;/td&gt; &lt;td&gt;数学&lt;/td&gt; &lt;td&gt;语文&lt;/td&gt; &lt;/tr&gt; &lt;tr ng-repeat=&quot;entity in list&quot;&gt; &lt;td&gt;{{entity.name}}&lt;/td&gt; &lt;td&gt;{{entity.shuxue}}&lt;/td&gt; &lt;td&gt;{{entity.yuwen}}&lt;/td&gt; &lt;/tr&gt; &lt;/table&gt; &lt;/body&gt; &lt;/html&gt; 建立文件 data.json [ {&quot;name&quot;:&quot;张三&quot;,&quot;shuxue&quot;:100,&quot;yuwen&quot;:93}, {&quot;name&quot;:&quot;李四&quot;,&quot;shuxue&quot;:88,&quot;yuwen&quot;:87}, {&quot;name&quot;:&quot;王五&quot;,&quot;shuxue&quot;:77,&quot;yuwen&quot;:56}, {&quot;name&quot;:&quot;赵六&quot;,&quot;shuxue&quot;:67,&quot;yuwen&quot;:86} ] 常用的指令名称 描述 ngApp 定义应用程序的根元素。 ngBind 绑定 HTML 元素到应用程序数据 ngBindhtml 绑定 HTML 元素的 innerHTML 到应用程序数据，并移除 HTML 字符串中危险字符 ngBindtemplate 规定要使用模板替换的文本内容 ngBlur 规定 blur 事件的行为 ngChange 规定在内容改变时要执行的表达式 ngChecked 规定元素是否被选中 ngClass 指定 HTML 元素使用的 CSS 类 ngClasseven 类似 ng-class，但只在偶数行起作用 ngClassodd 类似 ng-class，但只在奇数行起作用 ngClick 定义元素被点击时的行为 ngCloak 在应用正要加载时防止其闪烁 ngController 定义应用的控制器对象 ngCopy 规定拷贝事件的行为 ngCsp 修改内容的安全策略 ngCut 规定剪切事件的行为 ngDblclick 规定双击事件的行为 ngDisabled 规定一个元素是否被禁用 ngFocus 规定聚焦事件的行为 ngHide 隐藏或显示 HTML 元素 ngHref 为 元素指定链接 ngIf 判断语句，如果值为falsh，所在的div层不显示 ngInclude 在应用中包含 HTML 文件 ngInit 定义应用的初始化值 ngKeydown 规定按下按键事件的行为 ngKeypress 规定按下按键事件的行为 ngKeyup 规定松开按键事件的行为 ngList 将文本转换为列表 (数组) ngModel 绑定 HTML 控制器的值到应用数据 ngModeloptions 规定如何更新模型 ngMousedown 规定按下鼠标按键时的行为 ngMouseenter 规定鼠标指针穿过元素时的行为 ngMouseleave 规定鼠标指针离开元素时的行为 ngMousemove 规定鼠标指针在指定的元素中移动时的行为 ngMouseover 规定鼠标指针位于元素上方时的行为 ngMouseup 规定当在元素上松开鼠标按钮时的行为 ngNonbindable 规定元素或子元素不能绑定数据 ngOpen 指定元素的 open 属性 ngOptions 在 &lt; select&gt; 列表中指定 &lt; options&gt; ngPaste 规定粘贴事件的行为 ngReadonly 指定元素的 readonly 属性 ngRepeat 定义集合中每项数据的模板 ngSelected 指定元素的 selected 属性 ngShow 显示或隐藏 HTML 元素 ngSrc 指定 元素的 src 属性 ngSrcset 指定 元素的 srcset 属性 ngStyle 指定元素的 style 属性 ngSubmit 规定 onsubmit 事件发生时执行的表达式 ngSwitch 规定显示或隐藏子元素的条件 ngValue 规定input元素的值 服务名称 描述 $http $http是Angular的一个核心服务，它有利于浏览器通过XMLHttpRequest 对象或者 JSONP和远程HTTP服务器交互。 $controller $filter () // 定义过滤器 app.filter(&apos;trustHtml&apos;,[&apos;$sce&apos;,function($sce){ return function(data){//传入参数时被过滤的内容 return $sce.trustAsHtml(data);//返回的是过滤后的内容（信任html的转换） } } ]); 页面: $location $location服务解析浏览器地址中的url（基于window.location）并且使url在应用程序中可用。将地址栏中的网址的变化反映到$location服务和$location的变化反映到浏览器地址栏。 $sce $sce 服务是AngularJs提供的一种严格上下文转义服务。]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>AngularJS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Dubbox框架入门小demo]]></title>
    <url>%2F2018%2F03%2F05%2FDubbox%E6%A1%86%E6%9E%B6%E5%85%A5%E9%97%A8%E5%B0%8Fdemo%2F</url>
    <content type="text"><![CDATA[Dubbox框架Dubbox简介Dubbox 是一个分布式服务框架，其前身是阿里巴巴开源项目Dubbo ，被国内电商及互联网项目中使用，后期阿里巴巴停止了该项目的维护，当当网便在Dubbo基础上进行优化，并继续维护，为了与原有的Dubbo区分，故将其命名为Dubbox。Dubbox 致力于提供高性能和透明化的RPC远程服务调用方案，以及SOA服务治理方案。简单的说，dubbox就是个服务框架，如果没有分布式的需求，其实是不需要用的，只有在分布式的时候，才有dubbox这样的分布式服务框架的需求，并且本质上是个服务调用的东东，说白了就是个远程服务调用的分布式框架。 ###节点角色说明：• Provider: 暴露服务的服务提供方。 • Consumer: 调用远程服务的服务消费方。 • Registry: 服务注册与发现的注册中心。 • Monitor: 统计服务的调用次调和调用时间的监控中心。 • Container: 服务运行容器。 调用关系说明：• 0. 服务容器负责启动，加载，运行服务提供者。 • 1. 服务提供者在启动时，向注册中心注册自己提供的服务。 • 2. 服务消费者在启动时，向注册中心订阅自己所需的服务。 • 3. 注册中心返回服务提供者地址列表给消费者，如果有变更，注册中心将基于长连接推送变更数据给消费者。 • 4. 服务消费者，从提供者地址列表中，基于软负载均衡算法，选一台提供者进行调用，如果调用失败，再选另一台调用。 • 5. 服务消费者和提供者，在内存中累计调用次数和调用时间，定时每分钟发送一次统计数据到监控中心。 注册中心ZookeeperZookeeper 介绍官方推荐使用 zookeeper 注册中心。注册中心负责服务地址的注册与查找，相当于目录服务，服务提供者和消费者只在启动时与注册中心交互，注册中心不转发请求，压力较小。 Zookeeper 是 Apacahe Hadoop 的子项目，是一个树型的目录服务，支持变更推送，适合作为Dubbox 服务的注册中心，工业强度较高，可用于生产环境。 Zookeeper 在Linux系统的安装安装步骤： 第一步：安装 jdk(这里请自行百度,如何在Linux中安装jdk) 第二步：把 zookeeper 的压缩包（…\dubbox\zookeeper-3.4.6.tar.gz）上传到 linux 系统。 Alt+P 进入SFTP ，输入put d:\zookeeper-3.4.6.tar.gz 上传(这里d:是你放置压缩包的位置) 第三步：解压缩压缩包 tar -zxvf zookeeper-3.4.6.tar.gz 第四步：进入 zookeeper-3.4.6 目录，创建 data 文件夹。 mkdir data 第五步：进入conf目录 ，把 zoo_sample.cfg 改名为 zoo.cfg cd conf mv zoo_sample.cfg zoo.cfg 第六步：打开zoo.cfg , 修改 data 属性： dataDir=/root/zookeeper-3.4.6/data Zookeeper 服务启动进入bin目录，启动服务输入命令 ./zkServer.sh start 关闭服务输入命令 ./zkServer.sh stop 查看状态： ./zkServer.sh status Dubbox本地 JAR包部署与安装Dubbox的jar包并没有部署到Maven的中央仓库中，大家在Maven的中央仓库中可以查找到Dubbo的最终版本是2.5.3 , 阿里巴巴解散了Dubbo团队后由当当网继续维护此项目，并改名为 Dubbox ,坐标不变，版本变更了，但是并没有提交到中央仓库。 我们现在需要手动将Dubbox的jar包安装到我的本地仓库中。 先将dubbo-2.8.4.jar包放到d:\setup, 然后输入命令 mvn install:install-file -Dfile=d:\setup\dubbo-2.8.4.jar -DgroupId=com.alibaba -DartifactId=dubbo -Dversion=2.8.4 -Dpackaging=jar 配置离线约束地址： http://code.alibabatech.com/schema/dubbo/dubbo.xsd 入门小Demo服务提供者开发开发步骤： （1）创建Maven工程（WAR）dubboxdemo-service ，在pom.xml中引入依赖 &lt;project xmlns=&quot;http://maven.apache.org/POM/4.0.0&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xsi:schemaLocation=&quot;http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd&quot;&gt; &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt; &lt;groupId&gt;cn.lxm.dubboxdemo&lt;/groupId&gt; &lt;artifactId&gt;dubboxdemo-service&lt;/artifactId&gt; &lt;version&gt;0.0.1-SNAPSHOT&lt;/version&gt; &lt;packaging&gt;war&lt;/packaging&gt; &lt;properties&gt; &lt;spring.version&gt;4.2.4.RELEASE&lt;/spring.version&gt; &lt;/properties&gt; &lt;dependencies&gt; &lt;!-- Spring --&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-context&lt;/artifactId&gt; &lt;version&gt;${spring.version}&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-beans&lt;/artifactId&gt; &lt;version&gt;${spring.version}&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-webmvc&lt;/artifactId&gt; &lt;version&gt;${spring.version}&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-jdbc&lt;/artifactId&gt; &lt;version&gt;${spring.version}&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-aspects&lt;/artifactId&gt; &lt;version&gt;${spring.version}&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-jms&lt;/artifactId&gt; &lt;version&gt;${spring.version}&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-context-support&lt;/artifactId&gt; &lt;version&gt;${spring.version}&lt;/version&gt; &lt;/dependency&gt; &lt;!-- dubbo相关 --&gt; &lt;dependency&gt; &lt;groupId&gt;com.alibaba&lt;/groupId&gt; &lt;artifactId&gt;dubbo&lt;/artifactId&gt; &lt;version&gt;2.8.4&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.apache.zookeeper&lt;/groupId&gt; &lt;artifactId&gt;zookeeper&lt;/artifactId&gt; &lt;version&gt;3.4.6&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;com.github.sgroschupf&lt;/groupId&gt; &lt;artifactId&gt;zkclient&lt;/artifactId&gt; &lt;version&gt;0.1&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;javassist&lt;/groupId&gt; &lt;artifactId&gt;javassist&lt;/artifactId&gt; &lt;version&gt;3.11.0.GA&lt;/version&gt; &lt;/dependency&gt; &lt;/dependencies&gt; &lt;build&gt; &lt;plugins&gt; &lt;plugin&gt; &lt;groupId&gt;org.apache.maven.plugins&lt;/groupId&gt; &lt;artifactId&gt;maven-compiler-plugin&lt;/artifactId&gt; &lt;version&gt;2.3.2&lt;/version&gt; &lt;configuration&gt; &lt;source&gt;1.7&lt;/source&gt; &lt;target&gt;1.7&lt;/target&gt; &lt;/configuration&gt; &lt;/plugin&gt; &lt;plugin&gt; &lt;groupId&gt;org.apache.tomcat.maven&lt;/groupId&gt; &lt;artifactId&gt;tomcat7-maven-plugin&lt;/artifactId&gt; &lt;configuration&gt; &lt;!-- 指定端口 --&gt; &lt;port&gt;8081&lt;/port&gt; &lt;!-- 请求路径 --&gt; &lt;path&gt;/&lt;/path&gt; &lt;/configuration&gt; &lt;/plugin&gt; &lt;/plugins&gt; &lt;/build&gt; &lt;/project&gt; （2）在工程的webapps下创建WEB-INF文件夹，创建web.xml &lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt; &lt;web-app xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xmlns=&quot;http://java.sun.com/xml/ns/javaee&quot; xsi:schemaLocation=&quot;http://java.sun.com/xml/ns/javaee http://java.sun.com/xml/ns/javaee/web-app_2_5.xsd&quot; version=&quot;2.5&quot;&gt; &lt;!-- 加载spring容器 --&gt; &lt;context-param&gt; &lt;param-name&gt;contextConfigLocation&lt;/param-name&gt; &lt;param-value&gt;classpath:applicationContext*.xml&lt;/param-value&gt; &lt;/context-param&gt; &lt;listener&gt; &lt;listener-class&gt;org.springframework.web.context.ContextLoaderListener&lt;/listener-class&gt; &lt;/listener&gt; &lt;/web-app&gt; （3）创建业务接口创建包cn.lxm.dubbodemo.service，用于存放业务接口，创建接口 package cn.lxm.dubbodemo.service; /** * 业务接口 * @author Administrator * */ public interface UserService { public String getName(); } （4）创建业务实现类创建包cn.lxm.dubbodemo.service.impl ，用于存放业务实现类。创建业务实现类： package cn.lxm.dubbodemo.service.impl; import com.alibaba.dubbo.config.annotation.Service; import cn.lxm.dubbodemo.service.UserService; @Service public class UserServiceImpl implements UserService { public String getName() { return &quot;lxm&quot;; } } 注意：Service注解与原来不同，需要引入com.alibaba包下的 （5）编写配置文件在src/main/resources下创建applicationContext-service.xml ,内容如下： &lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt; &lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xmlns:p=&quot;http://www.springframework.org/schema/p&quot; xmlns:context=&quot;http://www.springframework.org/schema/context&quot; xmlns:dubbo=&quot;http://code.alibabatech.com/schema/dubbo&quot; xmlns:mvc=&quot;http://www.springframework.org/schema/mvc&quot; xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd http://www.springframework.org/schema/mvc http://www.springframework.org/schema/mvc/spring-mvc.xsd http://code.alibabatech.com/schema/dubbo http://code.alibabatech.com/schema/dubbo/dubbo.xsd http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context.xsd&quot;&gt; &lt;dubbo:application name=&quot;dubboxdemo-service&quot;/&gt; &lt;dubbo:registry address=&quot;zookeeper://192.168.25.132:2181&quot;/&gt; &lt;dubbo:annotation package=&quot;cn.lxm.dubboxdemo.service&quot; /&gt; &lt;/beans&gt; 注意：dubbo:annotation用于扫描@Service注解。 服务消费者开发开发步骤： （1）创建Maven工程（WAR）dubboxdemo-web ，在pom.xml引入依赖 ，同“dubboxdemo-service”工程。区别就是把tomcat插件的运行端口改为8082 。 （2）在webapps目录下创建WEB-INF 目录，并创建web.xml &lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt; &lt;web-app xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xmlns=&quot;http://java.sun.com/xml/ns/javaee&quot; xsi:schemaLocation=&quot;http://java.sun.com/xml/ns/javaee http://java.sun.com/xml/ns/javaee/web-app_2_5.xsd&quot; version=&quot;2.5&quot;&gt; &lt;!-- 解决post乱码 --&gt; &lt;filter&gt; &lt;filter-name&gt;CharacterEncodingFilter&lt;/filter-name&gt; &lt;filter-class&gt;org.springframework.web.filter.CharacterEncodingFilter&lt;/filter-class&gt; &lt;init-param&gt; &lt;param-name&gt;encoding&lt;/param-name&gt; &lt;param-value&gt;utf-8&lt;/param-value&gt; &lt;/init-param&gt; &lt;init-param&gt; &lt;param-name&gt;forceEncoding&lt;/param-name&gt; &lt;param-value&gt;true&lt;/param-value&gt; &lt;/init-param&gt; &lt;/filter&gt; &lt;filter-mapping&gt; &lt;filter-name&gt;CharacterEncodingFilter&lt;/filter-name&gt; &lt;url-pattern&gt;/*&lt;/url-pattern&gt; &lt;/filter-mapping&gt; &lt;servlet&gt; &lt;servlet-name&gt;springmvc&lt;/servlet-name&gt; &lt;servlet-class&gt;org.springframework.web.servlet.DispatcherServlet&lt;/servlet-class&gt; &lt;!-- 指定加载的配置文件 ，通过参数contextConfigLocation加载--&gt; &lt;init-param&gt; &lt;param-name&gt;contextConfigLocation&lt;/param-name&gt; &lt;param-value&gt;classpath:applicationContext-web.xml&lt;/param-value&gt; &lt;/init-param&gt; &lt;/servlet&gt; &lt;servlet-mapping&gt; &lt;servlet-name&gt;springmvc&lt;/servlet-name&gt; &lt;url-pattern&gt;*.do&lt;/url-pattern&gt; &lt;/servlet-mapping&gt; &lt;/web-app&gt; （3）拷贝业务接口将“dubboxdemo-service”工程的cn.lxm.dubboxdemo.service 包以及下面的接口拷贝至此工程。 （4）编写Controller package cn.lxm.dubboxdemo.controller; import org.springframework.beans.factory.annotation.Autowired; import org.springframework.stereotype.Controller; import org.springframework.web.bind.annotation.RequestMapping; import org.springframework.web.bind.annotation.ResponseBody; import cn.lxm.dubbodemo.service.UserService; @Controller @RequestMapping(&quot;/user&quot;) public class UserController { @Reference private UserService userService; @RequestMapping(&quot;/showName&quot;) @ResponseBody public String showName(){ return userService.getName(); } } （5）编写spring配置文件在src/main/resources下创建applicationContext-web.xml &lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt; &lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xmlns:p=&quot;http://www.springframework.org/schema/p&quot; xmlns:context=&quot;http://www.springframework.org/schema/context&quot; xmlns:dubbo=&quot;http://code.alibabatech.com/schema/dubbo&quot; xmlns:mvc=&quot;http://www.springframework.org/schema/mvc&quot; xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd http://www.springframework.org/schema/mvc http://www.springframework.org/schema/mvc/spring-mvc.xsd http://code.alibabatech.com/schema/dubbo http://code.alibabatech.com/schema/dubbo/dubbo.xsd http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context.xsd&quot;&gt; &lt;mvc:annotation-driven &gt; &lt;mvc:message-converters register-defaults=&quot;false&quot;&gt; &lt;bean class=&quot;org.springframework.http.converter.StringHttpMessageConverter&quot;&gt; &lt;constructor-arg value=&quot;UTF-8&quot; /&gt; &lt;/bean&gt; &lt;/mvc:message-converters&gt; &lt;/mvc:annotation-driven&gt; &lt;!-- 引用dubbo 服务 --&gt; &lt;dubbo:application name=&quot;dubboxdemo-web&quot; /&gt; &lt;dubbo:registry address=&quot;zookeeper://192.168.25.132:2181&quot;/&gt; &lt;dubbo:annotation package=&quot;cn.lxm.dubboxdemo.controller&quot; /&gt; &lt;/beans&gt; （6）测试运行 tomcat7:run在浏览器输入http://localhost:8082/user/showName.do，查看浏览器输出结果]]></content>
      <categories>
        <category>java</category>
      </categories>
      <tags>
        <tag>Dubbox</tag>
        <tag>分布式服务框架</tag>
        <tag>Dubbo</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Lucene全文检索入门]]></title>
    <url>%2F2018%2F03%2F03%2FLucene%E5%85%A8%E6%96%87%E6%A3%80%E7%B4%A2%E5%85%A5%E9%97%A8%2F</url>
    <content type="text"><![CDATA[#Lucene概述 什么是Lucene Lucene是一套用于全文检索和搜寻的开源程序库，由Apache软件基金会支持和提供 Lucene提供了一个简单却强大的应用程序接口（API），能够做全文索引和搜寻，在Java开发环境里Lucene是一个成熟的免费开放源代码工具 Lucene并不是现成的搜索引擎产品，但可以用来制作搜索引擎产品 官网：http://lucene.apache.org/ # 待更新…]]></content>
      <categories>
        <category>搜索解决方案</category>
      </categories>
      <tags>
        <tag>Lucene</tag>
        <tag>全文检索</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[使用formfill.js快速填充表单]]></title>
    <url>%2F2018%2F03%2F02%2F%E4%BD%BF%E7%94%A8formfill-js%E5%BF%AB%E9%80%9F%E5%A1%AB%E5%85%85%E8%A1%A8%E5%8D%95%2F</url>
    <content type="text"><![CDATA[form表单的快速回显做项目开发的时候在写修改的页面时,如果字段很多的话,数据回显塞值挺麻烦的,所以最近找了一个formfill.js快速填充表单的js 使用起来很简单,首先引用js文件百度云盘下载: 链接：https://pan.baidu.com/s/1mjSDRtA 密码：5ljt &lt;script src=&quot;../js/jquery.formautofill.js&quot;&gt;&lt;/script&gt; 使用: var data = {&quot;name&quot;:&quot;haha&quot;,&quot;password&quot;:&quot;123&quot;} $(&quot;#formId&quot;).autofill(data); 英文解释:jQuery form autofilljQuery plugin to simply autofill an empty form with data. DocumentationSee complete documentation and demo UsageYou have a form 1234567&lt;form id="f"&gt; name &lt;input type="text" name="name"&gt; email &lt;input type="text" name="email"&gt; love jQuery &lt;input type="radio" name="lovejquery" value="yes"&gt; yes &lt;input type="radio" name="lovejquery" value="no"&gt; no&lt;/form&gt; And data 12345var data = &#123; "name": "John Doe", "email": "johndoe@mail.com", "lovejquery": "yes"&#125; Autofill the form with data ? just do 1$("#f").autofill( data );]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>jquery</tag>
        <tag>formautofill</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[SpringMVC架构入门二]]></title>
    <url>%2F2018%2F03%2F01%2FSpringMVC%E6%9E%B6%E6%9E%84%E5%85%A5%E9%97%A8%E4%BA%8C%2F</url>
    <content type="text"><![CDATA[高级参数绑定绑定数组Controller方法中可以用String[]接收，或者pojo的String[]属性接收。两种方式任选其一即可。使用String[]: @RequestMapping(&quot;/queryitem&quot;) public String queryItem(Query queryVo, String[] ids) { System.out.println(queryVo.getItems().getName()); System.out.println(queryVo.getItems().getPrice()); System.out.println(ids.toString()); return null; } pojo的String[]: public class Query{ private Items items; private String[] ids; get/set... } 将表单的数据绑定到ListList中存放对象，并将定义的List放在包装类中，使用包装pojo对象接收。 public class Query{ private Items items; private String[] ids; private List&lt;Items&gt; itemList; get/set... } jsp页面: &lt;tr&gt; &lt;td&gt; &lt;input type=&quot;text&quot; name=&quot; itemsList[0].id&quot; value=&quot;${item.id}&quot;/&gt; &lt;/td&gt; &lt;td&gt; &lt;input type=&quot;text&quot; name=&quot; itemsList[0].name&quot; value=&quot;${item.name }&quot;/&gt; &lt;/td&gt; &lt;td&gt; &lt;input type=&quot;text&quot; name=&quot; itemsList[0].price&quot; value=&quot;${item.price}&quot;/&gt; &lt;/td&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td&gt; &lt;input type=&quot;text&quot; name=&quot; itemsList[1].id&quot; value=&quot;${item.id}&quot;/&gt; &lt;/td&gt; &lt;td&gt; &lt;input type=&quot;text&quot; name=&quot; itemsList[1].name&quot; value=&quot;${item.name }&quot;/&gt; &lt;/td&gt; &lt;td&gt; &lt;input type=&quot;text&quot; name=&quot; itemsList[1].price&quot; value=&quot;${item.price}&quot;/&gt; &lt;/td&gt; &lt;/tr&gt; Name属性必须是包装pojo的list属性+下标+元素属性。 Jsp做如下改造： &lt;c:forEach items=&quot;${itemList }&quot; var=&quot;item&quot;&gt; &lt;tr&gt; &lt;td&gt; &lt;input name=&quot;ids&quot; value=&quot;${item.id}&quot; type=&quot;checkbox&quot;&gt;&lt;/td&gt; &lt;td&gt; &lt;input name=&quot;id&quot; value=&quot;${item.id}&quot; type=&quot;hidden&quot;&gt; &lt;input name=&quot;name&quot; value=&quot;${item.name }&quot; type=&quot;text&quot;&gt; &lt;/td&gt; &lt;td&gt; &lt;input name=&quot;name&quot; value=&quot;${item.price }&quot; type=&quot;text&quot;&gt;&lt;/td&gt; &lt;td&gt; &lt;input name=&quot;name&quot; value=&quot;&lt;fmt:formatDate value=&quot;${item.createtime}&quot; pattern=&quot;yyyy-MM-dd HH:mm:ss&quot;/&gt;&quot; type=&quot;text&quot;&gt;&lt;/td&gt; &lt;td&gt; &lt;input name=&quot;name&quot; value=&quot;${item.detail }&quot; type=&quot;text&quot;&gt;&lt;/td&gt; &lt;td&gt; &lt;a href=&quot;${pageContext.request.contextPath }/itemEdit.action?id=${item.id}&quot;&gt;修改&lt;/a&gt; &lt;/td&gt; &lt;/tr&gt; &lt;/c:forEach&gt; varStatus属性常用参数总结下： ${status.index} 输出行号，从0开始。 ${status.count} 输出行号，从1开始。 ${status.current} 当前这次迭代的（集合中的）项 ${status.first} 判断当前项是否为集合中的第一项，返回值为true或false ${status.last} 判断当前项是否为集合中的最后一项，返回值为true或false begin、end、step分别表示：起始序号，结束序号，跳跃步伐。 Contrller @RequestMapping(&quot;/queryitem&quot;) public String queryItem(QueryVo queryVo, String[] ids) { System.out.println(queryVo.getItems().getName()); System.out.println(queryVo.getItems().getPrice()); System.out.println(ids.toString()); return null; } 注意：接收List类型的数据必须是pojo的属性，方法的形参为List类型无法正确接收到数据。 @RequestMapping通过RequestMapping注解可以定义不同的处理器映射规则。 URL路径映射@RequestMapping(value=”/item”)或@RequestMapping(“/item）value的值是数组，可以将多个url映射到同一个方法 窄化请求映射在class上添加@RequestMapping(url)指定通用请求前缀， 限制此类下的所有方法请求url必须以请求前缀开头，通过此方法对url进行分类管理。 如下： @RequestMapping放在类名上边，设置请求前缀 @Controller @RequestMapping(&quot;/item&quot;) 方法名上边设置请求映射url： @RequestMapping放在方法名上边，如下： @RequestMapping(&quot;/queryItem &quot;) 访问地址为：/item/queryItem 请求方法限定限定GET方法@RequestMapping(method = RequestMethod.GET) 如果通过Post访问则报错：HTTP Status 405 - Request method ‘POST’ not supported 例如： @RequestMapping(value=&quot;/editItem&quot;,method=RequestMethod.GET) 限定POST方法@RequestMapping(method = RequestMethod.POST) 如果通过Post访问则报错：HTTP Status 405 - Request method ‘GET’ not supported GET和POST都可以@RequestMapping(method={RequestMethod.GET,RequestMethod.POST}) controller方法返回值返回ModelAndViewcontroller方法中定义ModelAndView对象并返回，对象中可添加model数据、指定view。 返回void在controller方法形参上可以定义request和response，使用request或response指定响应结果： 1、使用request转向页面，如下： request.getRequestDispatcher(&quot;页面路径&quot;).forward(request, response); 2、也可以通过response页面重定向： response.sendRedirect(&quot;url&quot;) 3、也可以通过response指定响应结果，例如响应json数据如下： response.setCharacterEncoding(&quot;utf-8&quot;); response.setContentType(&quot;application/json;charset=utf-8&quot;); response.getWriter().write(&quot;json串&quot;); 返回字符串逻辑视图名controller方法返回字符串可以指定逻辑视图名，通过视图解析器解析为物理视图地址。 //指定逻辑视图名，经过视图解析器解析为jsp物理路径：/WEB-INF/jsp/item/editItem.jsp return &quot;item/editItem&quot;; Redirect重定向Contrller方法返回结果重定向到一个url地址，如下商品修改提交后重定向到商品查询方法，参数无法带到商品查询方法中。 //重定向到queryItem.action地址,request无法带过去 return &quot;redirect:queryItem.action&quot;; redirect方式相当于“response.sendRedirect()”，转发后浏览器的地址栏变为转发后的地址，因为转发即执行了一个新的request和response。由于新发起一个request原来的参数在转发时就不能传递到下一个url，如果要传参数可以/item/queryItem.action后边加参数，如下： /item/queryItem?...&amp;….. 如果使用了model的话,他会自动给你拼接数据,就是自动在后面拼接? forward转发controller方法执行后继续执行另一个controller方法，如下商品修改提交后转向到商品修改页面，修改商品的id参数可以带到商品修改方法中。 //结果转发到editItem.action，request可以带过去 return &quot;forward:editItem.action&quot;; forward方式相当于“request.getRequestDispatcher().forward(request,response)”，转发后浏览器地址栏还是原来的地址。转发并没有执行新的request和response，而是和转发前的请求共用一个request和response。所以转发前请求的参数在转发后仍然可以读取到。 异常处理器springmvc在处理请求过程中出现异常信息交由异常处理器进行处理，自定义异常处理器可以实现一个系统的异常处理逻辑。 异常处理思路系统中异常包括两类：预期异常和运行时异常RuntimeException，前者通过捕获异常从而获取异常信息，后者主要通过规范代码开发、测试通过手段减少运行时异常的发生。 系统的dao、service、controller出现都通过throws Exception向上抛出，最后由springmvc前端控制器交由异常处理器进行异常处理 步骤:写异常处理器类,然后在springmvc.xml中配置,然后写异常错误页面 自定义异常处理器public class CustomExceptionResolver implements HandlerExceptionResolver { @Override public ModelAndView resolveException(HttpServletRequest request, HttpServletResponse response, Object handler, Exception ex) { ex.printStackTrace(); CustomException customException = null; //如果抛出的是系统自定义异常则直接转换 if(ex instanceof CustomException){ customException = (CustomException)ex; }else{ //如果抛出的不是系统自定义异常则重新构造一个系统错误异常。 customException = new CustomException(&quot;系统错误，请与系统管理 员联系！&quot;); } ModelAndView modelAndView = new ModelAndView(); modelAndView.addObject(&quot;message&quot;, customException.getMessage()); modelAndView.setViewName(&quot;error&quot;); return modelAndView; } } ###取异常堆栈： //错误信息存储在堆栈中,取异常堆栈将其显示在控制台上,或输出到日志文件中 try { } catch (Exception e) { StringWriter s = new StringWriter(); PrintWriter printWriter = new PrintWriter(s); e.printStackTrace(printWriter); s.toString(); } 错误页面&lt;%@ page language=&quot;java&quot; contentType=&quot;text/html; charset=UTF-8&quot; pageEncoding=&quot;UTF-8&quot;%&gt; &lt;%@ taglib uri=&quot;http://java.sun.com/jsp/jstl/core&quot; prefix=&quot;c&quot; %&gt; &lt;%@ taglib uri=&quot;http://java.sun.com/jsp/jstl/fmt&quot; prefix=&quot;fmt&quot;%&gt; &lt;!DOCTYPE html PUBLIC &quot;-//W3C//DTD HTML 4.01 Transitional//EN&quot; &quot;http://www.w3.org/TR/html4/loose.dtd&quot;&gt; &lt;html&gt; &lt;head&gt; &lt;meta http-equiv=&quot;Content-Type&quot; content=&quot;text/html; charset=UTF-8&quot;&gt; &lt;title&gt;错误页面&lt;/title&gt; &lt;/head&gt; &lt;body&gt; 您的操作出现错误如下：&lt;br/&gt; ${message } &lt;/body&gt; &lt;/html&gt; 异常处理器配置在springmvc.xml中添加： &lt;!-- 全局异常处理器 --&gt; &lt;bean class=&quot;com.lxm.springmvc.exception.GlobalExceptionResolver&quot;/&gt; 测试异常在需要抛出异常的地方加上throw new CustomerException(“出错信息”);然后方法上向上抛出就可以了 @RequestMapping(&quot;/itemEdit&quot;) public String getEditItem(@RequestParam(value=&quot;id&quot;,required=true)Integer id,Model model) throws CustomerException{ Items items = itemService.getItemById(id); if(items == null){ throw new CustomerException(&quot;商品信息不存在!&quot;); } model.addAttribute(&quot;item&quot;,items); return &quot;editItem&quot;; } 上传图片配置虚拟目录在tomcat上配置图片虚拟目录，在tomcat下conf/server.xml中添加： &lt;Context docBase=&quot;F:\develop\upload\temp&quot; path=&quot;/pic&quot; reloadable=&quot;false&quot;/&gt; 访问http://localhost:8080/pic即可访问F:\develop\upload\temp下的图片。 也可以通过eclipse配置： 1:在tomcat服务配置里面有个modules,点击AddExternalWebModule 2:然后在Documentbase里面填写虚拟路径的绝对路径(例如:F:\develop\upload\temp), 3:在Path里面填写虚拟路径(例如:/pic) 4:AutoReload(这个根据需要自行设定,以下是作用,一般设置为disabled就可以) 在eclipse中集成tomca来开发时,如果使用run as模式启动项目的话,tomcat配置Auto reloading enabled,我们修改java文件,项目会重新加载,修改的内容会生效.如果使用debug as 模式启动项目的话,tomcat不要配置Auto reloading enabled,我们修改的java文件,也会生效. 注意:在debug模式下,tomcat配置了Auto reloading enabled,当修改了java文件,项目会报错. jar包CommonsMultipartResolver解析器依赖: commons-fileupload commons-io 配置解析器springmvc.xml &lt;!-- 文件上传 --&gt; &lt;bean id=&quot;multipartResolver&quot; class=&quot;org.springframework.web.multipart.commons.CommonsMultipartResolver&quot;&gt; &lt;!-- 设置上传文件的最大尺寸为5MB --&gt; &lt;property name=&quot;maxUploadSize&quot;&gt; &lt;value&gt;5242880&lt;/value&gt; &lt;/property&gt; &lt;/bean&gt; 图片上传controller： @RequestMapping(&quot;/updateitem&quot;) public String updateItem(Items items,MultipartFile pictureFile) throws Exception, IOException{ //把图片保存到图片目录下 //为每个文件生成一个新的文件名 String picName = UUID.randomUUID().toString(); //去文件的扩展名 String oriName = pictureFile.getOriginalFilename(); System.out.println(&quot;oriName&quot;+oriName); if(oriName!=null &amp;&amp; oriName!=&quot;&quot;){ String extName = oriName.substring(oriName.lastIndexOf(&quot;.&quot;)); System.out.println(&quot;extName&quot;+extName); //保存文件 d:\picture\temp pictureFile.transferTo(new File(&quot;d:\\picture\\temp\\&quot;+picName+extName)); //把文件名保存到数据库 items.setPic(picName+extName); } itemService.updateItem(items); // return &quot;forward:/itemList.action?items=&quot;+items;//转发是可以传递对象的 return &quot;forward:/itemList.action&quot;; } 页面：form添加enctype=&quot;multipart/form-data&quot;： &lt;form id=&quot;itemForm&quot; action=&quot;${pageContext.request.contextPath }/item/editItemSubmit.action&quot; method=&quot;post&quot; enctype=&quot;multipart/form-data&quot;&gt; &lt;input type=&quot;hidden&quot; name=&quot;pic&quot; value=&quot;${item.pic }&quot; /&gt; file的name与controller形参一致： &lt;tr&gt; &lt;td&gt;商品图片&lt;/td&gt; &lt;td&gt;&lt;c:if test=&quot;${item.pic !=null}&quot;&gt; &lt;img src=&quot;/pic/${item.pic}&quot; width=100 height=100 /&gt; &lt;br /&gt; &lt;/c:if&gt; &lt;input type=&quot;file&quot; name=&quot;pictureFile&quot; /&gt;&lt;/td&gt; &lt;/tr&gt; json数据交互@RequestBody作用： @RequestBody注解用于读取http请求的内容(字符串)，通过springmvc提供的HttpMessageConverter接口将读到的内容转换为json、xml等格式的数据并绑定到controller方法的参数上。 List.action?id=1&amp;name=zhangsan&amp;age=12 本例子应用： @RequestBody注解实现接收http请求的json数据，将json数据转换为java对象 @ResponseBody作用： 该注解用于将Controller的方法返回的对象，通过HttpMessageConverter接口转换为指定格式的数据如：json,xml等，通过Response响应给客户端 本例子应用： @ResponseBody注解实现将controller方法返回对象转换为json响应给客户端 请求json，响应json实现：环境准备Springmvc默认用MappingJacksonHttpMessageConverter对json数据进行转换，需要加入jackson的包， jackson-annotations-2.4.0.jar jackson-core-2.4.2.jar jackson-databind-2.4.2.jar 配置json转换器在注解适配器中加入messageConverters &lt;!--注解适配器 --&gt; &lt;bean class=&quot;org.springframework.web.servlet.mvc.method.annotation.RequestMappingHandlerAdapter&quot;&gt; &lt;property name=&quot;messageConverters&quot;&gt; &lt;list&gt; &lt;bean class=&quot;org.springframework.http.converter.json.MappingJacksonHttpMessageConverter&quot;&gt;&lt;/bean&gt; &lt;/list&gt; &lt;/property&gt; &lt;/bean&gt; 注意：如果使用 则不用定义上边的内容。 controller编写// 商品修改提交json信息，响应json信息 @RequestMapping(&quot;/editItemSubmit_RequestJson&quot;) public @ResponseBody Items editItemSubmit_RequestJson(@RequestBody Items items) throws Exception { System.out.println(items); //itemService.saveItem(items); return items; } 页面js方法编写：引入 js： //请求json响应json function request_json(){ $.ajax({ type:&quot;post&quot;, url:&quot;${pageContext.request.contextPath }/item/editItemSubmit_RequestJson.action&quot;, contentType:&quot;application/json;charset=utf-8&quot;, data:&apos;{&quot;name&quot;:&quot;测试商品&quot;,&quot;price&quot;:99.9}&apos;, success:function(data){ alert(data); } }); }]]></content>
      <categories>
        <category>SSM</category>
      </categories>
      <tags>
        <tag>SpringMVC</tag>
        <tag>SpringWebMVC</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[SpringMVC架构入门一]]></title>
    <url>%2F2018%2F02%2F27%2FSpringMVC%E6%9E%B6%E6%9E%84%E5%85%A5%E9%97%A8%E4%B8%80%2F</url>
    <content type="text"><![CDATA[SpringMVC架构Spring web mvc和Struts2都属于表现层的框架,它是Spring框架的一部分. 架构流程1、 用户发送请求至前端控制器DispatcherServlet 2、 DispatcherServlet收到请求调用HandlerMapping处理器映射器。 3、 处理器映射器根据请求url找到具体的处理器，生成处理器对象及处理器拦截器(如果有则生成)一并返回给DispatcherServlet。 4、 DispatcherServlet通过HandlerAdapter处理器适配器调用处理器 5、 执行处理器(Controller，也叫后端控制器)。 6、 Controller执行完成返回ModelAndView 7、 HandlerAdapter将controller执行结果ModelAndView返回给DispatcherServlet 8、 DispatcherServlet将ModelAndView传给ViewReslover视图解析器 9、 ViewReslover解析后返回具体View 10、 DispatcherServlet对View进行渲染视图（即将模型数据填充至视图中）。 11、 DispatcherServlet响应用户 组件说明以下组件通常使用框架提供实现： DispatcherServlet：前端控制器 用户请求到达前端控制器，它就相当于mvc模式中的c，dispatcherServlet是整个流程控制的中心，由它调用其它组件处理用户的请求，dispatcherServlet的存在降低了组件之间的耦合性。 HandlerMapping：处理器映射器 HandlerMapping负责根据用户请求找到Handler即处理器，springmvc提供了不同的映射器实现不同的映射方式，例如：配置文件方式，实现接口方式，注解方式等。 Handler：处理器 Handler 是继DispatcherServlet前端控制器的后端控制器，在DispatcherServlet的控制下Handler对具体的用户请求进行处理。 由于Handler涉及到具体的用户业务请求，所以一般情况需要程序员根据业务需求开发Handler。 HandlAdapter：处理器适配器 通过HandlerAdapter对处理器进行执行，这是适配器模式的应用，通过扩展适配器可以对更多类型的处理器进行执行。 View Resolver：视图解析器 View Resolver负责将处理结果生成View视图，View Resolver首先根据逻辑视图名解析成物理视图名即具体的页面地址，再生成View视图对象，最后对View进行渲染将处理结果通过页面展示给用户。 View：视图 springmvc框架提供了很多的View视图类型的支持，包括：jstlView、freemarkerView、pdfView等。我们最常用的视图就是jsp。 一般情况下需要通过页面标签或页面模版技术将模型数据通过页面展示给用户，需要由程序员根据业务需求开发具体的页面。 说明：在springmvc的各个组件中，处理器映射器、处理器适配器、视图解析器称为springmvc的三大组件。 需要用户开放的组件有handler、view 注解映射器和适配器组件扫描器使用组件扫描器省去在spring容器配置每个controller类的繁琐。使用自动扫描标记@controller的控制器类，配置如下： &lt;!-- 扫描controller注解,多个包中间使用半角逗号分隔 --&gt; &lt;context:component-scan base-package=&quot;cn.lxm.springmvc.controller.first&quot;/&gt; RequestMappingHandlerMapping注解式处理器映射器，对类中标记@ResquestMapping的方法进行映射，根据ResquestMapping定义的url匹配ResquestMapping标记的方法，匹配成功返回HandlerMethod对象给前端控制器，HandlerMethod对象中封装url对应的方法Method。 从spring3.1版本开始，废除了DefaultAnnotationHandlerMapping的使用，推荐使用RequestMappingHandlerMapping完成注解式处理器映射。 配置如下： &lt;!--注解映射器 --&gt; &lt;bean class=&quot;org.springframework.web.servlet.mvc.method.annotation.RequestMappingHandlerMapping&quot;/&gt; 注解描述：@RequestMapping：定义请求url到处理器功能方法的映射 RequestMappingHandlerAdapter注解式处理器适配器，对标记@ResquestMapping的方法进行适配。 从spring3.1版本开始，废除了AnnotationMethodHandlerAdapter的使用，推荐使用RequestMappingHandlerAdapter完成注解式处理器适配。 配置如下： &lt;!--注解适配器 --&gt; &lt;bean class=&quot;org.springframework.web.servlet.mvc.method.annotation.RequestMappingHandlerAdapter&quot;/&gt; springmvc使用自动加载RequestMappingHandlerMapping和RequestMappingHandlerAdapter，可用在springmvc.xml配置文件中使用替代注解处理器和适配器的配置。 视图解析器在springmvc.xml文件配置如下： &lt;bean class=&quot;org.springframework.web.servlet.view.InternalResourceViewResolver&quot;&gt; &lt;property name=&quot;viewClass&quot; value=&quot;org.springframework.web.servlet.view.JstlView&quot; /&gt; &lt;property name=&quot;prefix&quot; value=&quot;/WEB-INF/jsp/&quot; /&gt; &lt;property name=&quot;suffix&quot; value=&quot;.jsp&quot; /&gt; &lt;/bean&gt; InternalResourceViewResolver：支持JSP视图解析 viewClass：JstlView表示JSP模板页面需要使用JSTL标签库，所以classpath中必须包含jstl的相关jar 包。此属性可以不设置，默认为JstlView。 prefix 和suffix：查找视图页面的前缀和后缀，最终视图的地址为：前缀+逻辑视图名+后缀，逻辑视图名需要在controller中返回ModelAndView指定，比如逻辑视图名为hello，则最终返回的jsp视图地址 “WEB-INF/jsp/hello.jsp” 整合mybatisssm框架:springmvc + spring + mybatis 控制层采用springmvc、持久层使用mybatis实现。 准备jar包spring（包括springmvc）、mybatis、mybatis-spring整合包、数据库驱动、第三方连接池。 整合思路Dao层：1、SqlMapConfig.xml 空文件即可。需要文件头。 2、applicationContext-dao.xml。 a) 数据库连接池 b) SqlSessionFactory对象，需要spring和mybatis整合包下的。 c) 配置mapper文件扫描器。 Service层：1、applicationContext-service.xml 包扫描器，扫描@service注解的类。 2、applicationContext-trans.xml 配置事务。 表现层：Springmvc.xml 1、包扫描器，扫描@Controller注解的类。 2、配置注解驱动。 3、视图解析器 Web.xml 配置前端控制器。 参数绑定Controller参数绑定要根据id查询商品数据，需要从请求的参数中把请求的id取出来。Id应该包含在Request对象中。可以从Request对象中取id。 @RequestMapping(&quot;/itemEdit&quot;) public ModelAndView itemEdit(HttpServletRequest request) { //从Request中取id String strId = request.getParameter(&quot;id&quot;); Integer id = null; //如果id有值则转换成int类型 if (strId != null &amp;&amp; !&quot;&quot;.equals(strId)) { id = new Integer(strId); } else { //出错 return null; } Items items = itemService.getItemById(id); //创建ModelAndView ModelAndView modelAndView = new ModelAndView(); //向jsp传递数据 modelAndView.addObject(&quot;item&quot;, items); //设置跳转的jsp页面 modelAndView.setViewName(&quot;editItem&quot;); return modelAndView; } 如果想获得Request对象只需要在Controller方法的形参中添加一个参数即可。Springmvc框架会自动把Request对象传递给方法。 Service@Override public Items getItemById(int id) { Items items = itemsMapper.selectByPrimaryKey(id); return items; } 默认支持的参数类型处理器形参中添加如下类型的参数处理适配器会默认识别并进行赋值。 HttpServletRequest通过request对象获取请求信息 HttpServletResponse通过response处理响应信息 HttpSession通过session对象得到session中存放的对象 Model/ModelMapModelMap是Model接口的实现类，通过Model或ModelMap向页面传递数据，如下： //调用service查询商品信息 Items item = itemService.findItemById(id); model.addAttribute(&quot;item&quot;, item); 页面通过${item.XXXX}获取item对象的属性值。 使用Model和ModelMap的效果一样，如果直接使用Model，springmvc会实例化ModelMap。 如果使用Model则可以不使用ModelAndView对象，Model对象可以向页面传递数据，View对象则可以使用String返回值替代。不管是Model还是ModelAndView，其本质都是使用Request对象向jsp传递数据。如果使用Model则方法可以改造成： @RequestMapping(&quot;/itemEdit&quot;) public String itemEdit(HttpServletRequest request, Model model) { //从Request中取id String strId = request.getParameter(&quot;id&quot;); Integer id = null; //如果id有值则转换成int类型 if (strId != null &amp;&amp; !&quot;&quot;.equals(strId)) { id = new Integer(strId); } else { //出错 return null; } Items items = itemService.getItemById(id); //创建ModelAndView //ModelAndView modelAndView = new ModelAndView(); //向jsp传递数据 //modelAndView.addObject(&quot;item&quot;, items); model.addAttribute(&quot;item&quot;, items); //设置跳转的jsp页面 //modelAndView.setViewName(&quot;editItem&quot;); //return modelAndView; return &quot;editItem&quot;; } 绑定简单类型当请求的参数名称和处理器形参名称一致时会将请求参数与形参进行绑定。从Request取参数的方法可以进一步简化。 @RequestMapping(&quot;/itemEdit&quot;) public String itemEdit(Integer id, Model model) { Items items = itemService.getItemById(id); //向jsp传递数据 model.addAttribute(&quot;item&quot;, items); //设置跳转的jsp页面 return &quot;editItem&quot;; } 支持的数据类型参数类型推荐使用包装数据类型，因为基础数据类型不可以为null 整形：Integer、int 字符串：String 单精度：Float、float 双精度：Double、double 布尔型：Boolean、boolean 说明：对于布尔类型的参数，请求的参数值为true或false。 处理器方法： public String editItem(Model model,Integer id,Boolean status) throws Exception 请求url： http://localhost:8080/xxx.action?id=2&amp;status=false @RequestParam使用@RequestParam常用于处理简单类型的绑定。 value：参数名字，即入参的请求参数名字，如value=“item_id”表示请求的参数区中的名字为item_id的参数的值将传入； required：是否必须，默认是true，表示请求中一定要有相应的参数，否则将报； TTP Status 400 - Required Integer parameter ‘XXXX’ is not present defaultValue：默认值，表示如果请求中没有同名参数时的默认值 定义如下： public String editItem(@RequestParam(value=&quot;item_id&quot;,required=true) String id) { } 形参名称为id，但是这里使用value=” item_id”限定请求的参数名为item_id，所以页面传递参数的名必须为item_id。 注意：如果请求参数中没有item_id将跑出异常： HTTP Status 500 - Required Integer parameter &apos;item_id&apos; is not present 这里通过required=true限定item_id参数为必需传递，如果不传递则报400错误，可以使用defaultvalue设置默认值，即使required=true也可以不传item_id参数值 绑定pojo类型Controller:@RequestMapping(&quot;/updateitem&quot;) public String updateItem(Items items){ itemService.updateItem(items); return &quot;success&quot;; } service@Override public void updateItem(Items items) { //ItemsExample example = new ItemsExample(); //如果example定义了两个字段，数据库共4个字段，则修改数据库的两个字段，其余两个字段改为null //itemsMapper.updateByExample(items, example); //成功,但是没有的值置为了null //itemsMapper.updateByPrimaryKey(items); //成功,但是没有的值置为了null //itemsMapper.updateByPrimaryKeyWithBLOBs(items); //和updateByExample相比此方法可以修改大字段类型，其余性质和updateByExample相同 //itemsMapper.updateByExampleWithBLOBs(items, example); //如果example定义了两个字段，数据库共4个字段，则修改数据库的两个字段，其余两个字段不动 itemsMapper.updateByPrimaryKeySelective(items); } 注意：提交的表单中不要有日期类型的数据，否则会报400错误。如果想提交日期类型的数据需要用到后面的自定义参数绑定的内容。 解决日期参数问题:自定义Converterimport org.joda.time.DateTime; import org.joda.time.format.DateTimeFormat; import org.joda.time.format.DateTimeFormatter; import org.springframework.core.convert.converter.Converter; import org.springframework.util.StringUtils; import java.util.ArrayList; import java.util.Date; import java.util.List; /** * Created by Rock 2016/12/6. */ public class DateConverter implements Converter&lt;String,Date&gt; { private static final List&lt;String&gt; formarts = new ArrayList&lt;&gt;(4); static { formarts.add(&quot;yyyy-MM&quot;); formarts.add(&quot;yyyy-MM-dd&quot;); formarts.add(&quot;yyyy-MM-dd HH:mm&quot;); formarts.add(&quot;yyyy-MM-dd HH:mm:ss&quot;); } @Override public Date convert(String s) { if(StringUtils.isEmpty(s)){ return null; } try { String formatter = &quot;&quot;; if (s.matches(&quot;^\\d{4}-\\d{1,2}$&quot;)) { formatter = formarts.get(0); } else if (s.matches(&quot;^\\d{4}-\\d{1,2}-\\d{1,2}$&quot;)) { formatter = formarts.get(1); } else if (s.matches(&quot;^\\d{4}-\\d{1,2}-\\d{1,2} {1}\\d{1,2}:\\d{1,2}$&quot;)) { formatter = formarts.get(2); } else if (s.matches(&quot;^\\d{4}-\\d{1,2}-\\d{1,2} {1}\\d{1,2}:\\d{1,2}:\\d{1,2}$&quot;)) { formatter = formarts.get(3); } else { throw new IllegalArgumentException(&quot;Invalid boolean value &apos;&quot; + s + &quot;&apos;&quot;); } DateFormat dateFormat = new SimpleDateFormat(formatter); Date date = dateFormat.parse(s); return date; } catch (Exception e){ return null; } } } 在springmvc.xml里面配置&lt;!-- 配置注解驱动，如果配置此标签可以不用配置处理器映射器和适配器 --&gt; &lt;!-- &lt;mvc:annotation-driven /&gt; --&gt; &lt;!-- 加载注解驱动 --&gt; &lt;mvc:annotation-driven conversion-service=&quot;conversionService&quot;/&gt; &lt;!-- 转换器配置 --&gt; &lt;bean id=&quot;conversionService&quot; class=&quot;org.springframework.format.support.FormattingConversionServiceFactoryBean&quot;&gt; &lt;property name=&quot;converters&quot;&gt; &lt;set&gt; &lt;bean class=&quot;cn.lxm.springmvc.convert.DateConverter&quot;/&gt; &lt;/set&gt; &lt;/property&gt; &lt;/bean&gt; 解决post乱码问题在web.xml中加入： &lt;filter&gt; &lt;filter-name&gt;CharacterEncodingFilter&lt;/filter-name&gt; &lt;filter-class&gt;org.springframework.web.filter.CharacterEncodingFilter&lt;/filter-class&gt; &lt;init-param&gt; &lt;param-name&gt;encoding&lt;/param-name&gt; &lt;param-value&gt;utf-8&lt;/param-value&gt; &lt;/init-param&gt; &lt;/filter&gt; &lt;filter-mapping&gt; &lt;filter-name&gt;CharacterEncodingFilter&lt;/filter-name&gt; &lt;url-pattern&gt;/*&lt;/url-pattern&gt; &lt;/filter-mapping&gt; 以上可以解决post请求乱码问题。 对于get请求中文参数出现乱码解决方法有两个： 修改tomcat配置文件添加编码与工程编码一致，如下： &lt;Connector URIEncoding=&quot;utf-8&quot; connectionTimeout=&quot;20000&quot; port=&quot;8080&quot; protocol=&quot;HTTP/1.1&quot; redirectPort=&quot;8443&quot;/&gt; 另外一种方法对参数进行重新编码： String userName new String(request.getParamter(&quot;userName&quot;).getBytes(&quot;ISO8859-1&quot;),&quot;utf-8&quot;) ISO8859-1是tomcat默认编码，需要将tomcat编码后的内容按utf-8编码]]></content>
      <categories>
        <category>SSM</category>
      </categories>
      <tags>
        <tag>SpringMVC</tag>
        <tag>SpringWebMVC</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[mybatis五]]></title>
    <url>%2F2018%2F02%2F26%2Fmybatis%E4%BA%94%2F</url>
    <content type="text"><![CDATA[mybatis整合spring整合思路1、SqlSessionFactory对象应该放到spring容器中作为单例存在。 2、传统dao的开发方式中，应该从spring容器中获得sqlsession对象。 3、Mapper代理形式中，应该从spring容器中直接获得mapper的代理对象。 4、数据库的连接以及数据库连接池事务管理都交给spring容器来完成。 整合需要的jar包1、spring的jar包2、Mybatis的jar包3、Spring+mybatis的整合包。4、Mysql的数据库驱动jar包。5、数据库连接池的jar包。 整合的步骤第一步：创建一个java工程。 第二步：导入jar包。（上面提到的jar包） 第三步：mybatis的配置文件SqlMapConfig.xml 第四步：编写Spring的配置文件 1、数据库连接及连接池 2、事务管理（暂时可以不配置） 3、sqlsessionFactory对象，配置到spring容器中 4、mapeer代理对象或者是dao实现类配置到spring容器中。 第五步：编写dao或者mapper文件 第六步：测试。 SqlMapConfig.xml&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; ?&gt; &lt;!DOCTYPE configuration PUBLIC &quot;-//mybatis.org//DTD Config 3.0//EN&quot; &quot;http://mybatis.org/dtd/mybatis-3-config.dtd&quot;&gt; &lt;configuration&gt; &lt;typeAliases&gt; &lt;package name=&quot;cn.lxm.mybatis.pojo&quot;/&gt; &lt;/typeAliases&gt; &lt;mappers&gt; &lt;!-- 使用包扫描扫描mapper.xml 如果在ApplicationContext.xml中配置了扫描包之后,就 不需要此配置 --&gt; &lt;package name=&quot;cn.lxm.mybatis.mapper&quot;/&gt; &lt;/mappers&gt; &lt;/configuration&gt; applicationContext.xml&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt; &lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot; xmlns:context=&quot;http://www.springframework.org/schema/context&quot; xmlns:p=&quot;http://www.springframework.org/schema/p&quot; xmlns:aop=&quot;http://www.springframework.org/schema/aop&quot; xmlns:tx=&quot;http://www.springframework.org/schema/tx&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans-4.0.xsd http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context-4.0.xsd http://www.springframework.org/schema/aop http://www.springframework.org/schema/aop/spring-aop-4.0.xsd http://www.springframework.org/schema/tx http://www.springframework.org/schema/tx/spring-tx-4.0.xsd http://www.springframework.org/schema/util http://www.springframework.org/schema/util/spring-util-4.0.xsd&quot;&gt; &lt;!-- 加载配置文件 --&gt; &lt;context:property-placeholder location=&quot;classpath:db.properties&quot; /&gt; &lt;!-- 数据库连接池 --&gt; &lt;bean id=&quot;dataSource&quot; class=&quot;org.apache.commons.dbcp.BasicDataSource&quot; destroy-method=&quot;close&quot;&gt; &lt;property name=&quot;driverClassName&quot; value=&quot;${jdbc.driver}&quot; /&gt; &lt;property name=&quot;url&quot; value=&quot;${jdbc.url}&quot; /&gt; &lt;property name=&quot;username&quot; value=&quot;${jdbc.username}&quot; /&gt; &lt;property name=&quot;password&quot; value=&quot;${jdbc.password}&quot; /&gt; &lt;property name=&quot;maxActive&quot; value=&quot;10&quot; /&gt; &lt;property name=&quot;maxIdle&quot; value=&quot;5&quot; /&gt; &lt;/bean&gt; &lt;!-- mapper配置 --&gt; &lt;!-- 让spring管理sqlsessionfactory 使用mybatis和spring整合包中的 --&gt; &lt;bean id=&quot;sqlSessionFactory&quot; class=&quot;org.mybatis.spring.SqlSessionFactoryBean&quot;&gt; &lt;!-- 数据库连接池 --&gt; &lt;property name=&quot;dataSource&quot; ref=&quot;dataSource&quot; /&gt; &lt;!-- 加载mybatis的全局配置文件 --&gt; &lt;property name=&quot;configLocation&quot; value=&quot;classpath:mybatis/SqlMapConfig.xml&quot; /&gt; &lt;/bean&gt; &lt;/beans&gt; db.propertiesjdbc.driver=com.mysql.jdbc.Driver jdbc.url=jdbc:mysql://localhost:3306/mybatis?characterEncoding=utf-8 jdbc.username=root jdbc.password=root Dao的开发三种dao的实现方式： 1、传统dao的开发方式 2、使用mapper代理形式开发方式 3、使用扫描包配置mapper代理。 这里只介绍第二种和第三种 Mapper代理形式开发dao开发mapper接口开发mapper文件 创建UserMapper.java public interface UserMapper { User findUserById(Integer id) throws Exception; } 并且在同一目录下创建UserMapper.xml &lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; ?&gt; &lt;!DOCTYPE mapper PUBLIC &quot;-//mybatis.org//DTD Mapper 3.0//EN&quot; &quot;http://mybatis.org/dtd/mybatis-3-mapper.dtd&quot;&gt; &lt;mapper namespace=&quot;cn.lxm.mybatis.mapper.UserMapper&quot;&gt; &lt;!-- 根据id获取用户信息 --&gt; &lt;select id=&quot;findUserById&quot; parameterType=&quot;int&quot; resultType=&quot;cn.lxm.mybatis.po.User&quot;&gt; select * from user where id = #{id} &lt;/select&gt; &lt;/mapper&gt; 配置mapper代理&lt;!-- 配置mapper代理对象 --&gt; &lt;bean class=&quot;org.mybatis.spring.mapper.MapperFactoryBean&quot;&gt; &lt;property name=&quot;mapperInterface&quot; value=&quot;cn.lxm.mybatis.mapper.UserMapper&quot;/&gt; &lt;property name=&quot;sqlSessionFactory&quot; ref=&quot;sqlSessionFactory&quot;&gt;&lt;/property&gt; &lt;/bean&gt; 测试方法public class UserMapperTest { private ApplicationContext applicationContext; @Before public void setUp() throws Exception { applicationContext = new ClassPathXmlApplicationContext(&quot;classpath:spring/applicationContext.xml&quot;); } @Test public void testGetUserById() { UserMapper userMapper = applicationContext.getBean(UserMapper.class); User user = userMapper.getUserById(1); System.out.println(user); } } 扫描包形式配置mapper&lt;!-- 使用扫描包的形式来创建mapper代理对象 --&gt; &lt;bean class=&quot;org.mybatis.spring.mapper.MapperScannerConfigurer&quot;&gt; &lt;property name=&quot;basePackage&quot; value=&quot;cn.lxm.mybatis.mapper&quot;&gt;&lt;/property&gt; &lt;/bean&gt; 如果配置了这个后 ,在SQLMapConfig.xml中的包扫描配置就不需要了 逆向工程生成代码步骤: 1.导入逆向工程代码,然后修改配置文件generatorConfig.xml &lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt; &lt;!DOCTYPE generatorConfiguration PUBLIC &quot;-//mybatis.org//DTD MyBatis Generator Configuration 1.0//EN&quot; &quot;http://mybatis.org/dtd/mybatis-generator-config_1_0.dtd&quot;&gt; &lt;generatorConfiguration&gt; &lt;context id=&quot;testTables&quot; targetRuntime=&quot;MyBatis3&quot;&gt; &lt;commentGenerator&gt; &lt;!-- 是否去除自动生成的注释 true：是 ： false:否 --&gt; &lt;property name=&quot;suppressAllComments&quot; value=&quot;true&quot; /&gt; &lt;/commentGenerator&gt; &lt;!--数据库连接的信息：驱动类、连接地址、用户名、密码 --&gt; &lt;jdbcConnection driverClass=&quot;com.mysql.jdbc.Driver&quot; connectionURL=&quot;jdbc:mysql://localhost:3306/mybatis&quot; userId=&quot;root&quot; password=&quot;root&quot;&gt; &lt;/jdbcConnection&gt; &lt;!-- &lt;jdbcConnection driverClass=&quot;oracle.jdbc.OracleDriver&quot; connectionURL=&quot;jdbc:oracle:thin:@127.0.0.1:1521:yycg&quot; userId=&quot;yycg&quot; password=&quot;yycg&quot;&gt; &lt;/jdbcConnection&gt; --&gt; &lt;!-- 默认false，把JDBC DECIMAL 和 NUMERIC 类型解析为 Integer，为 true时把JDBC DECIMAL 和 NUMERIC 类型解析为java.math.BigDecimal --&gt; &lt;javaTypeResolver&gt; &lt;property name=&quot;forceBigDecimals&quot; value=&quot;false&quot; /&gt; &lt;/javaTypeResolver&gt; &lt;!-- targetProject:生成PO类的位置 --&gt; &lt;javaModelGenerator targetPackage=&quot;cn.lxm.mybatis.po&quot; targetProject=&quot;.\src&quot;&gt; &lt;!-- enableSubPackages:是否让schema作为包的后缀 --&gt; &lt;property name=&quot;enableSubPackages&quot; value=&quot;false&quot; /&gt; &lt;!-- 从数据库返回的值被清理前后的空格 --&gt; &lt;property name=&quot;trimStrings&quot; value=&quot;true&quot; /&gt; &lt;/javaModelGenerator&gt; &lt;!-- targetProject:mapper映射文件生成的位置 --&gt; &lt;sqlMapGenerator targetPackage=&quot;cn.lxm.mybatis.mapper&quot; targetProject=&quot;.\src&quot;&gt; &lt;!-- enableSubPackages:是否让schema作为包的后缀 --&gt; &lt;property name=&quot;enableSubPackages&quot; value=&quot;false&quot; /&gt; &lt;/sqlMapGenerator&gt; &lt;!-- targetPackage：mapper接口生成的位置 --&gt; &lt;javaClientGenerator type=&quot;XMLMAPPER&quot; targetPackage=&quot;cn.lxm.mybatis.mapper&quot; targetProject=&quot;.\src&quot;&gt; &lt;!-- enableSubPackages:是否让schema作为包的后缀 --&gt; &lt;property name=&quot;enableSubPackages&quot; value=&quot;false&quot; /&gt; &lt;/javaClientGenerator&gt; &lt;!-- 指定数据库表 --&gt; &lt;table schema=&quot;&quot; tableName=&quot;user&quot;&gt;&lt;/table&gt; &lt;table schema=&quot;&quot; tableName=&quot;orders&quot;&gt;&lt;/table&gt; &lt;!-- 有些表的字段需要指定java类型 &lt;table schema=&quot;&quot; tableName=&quot;&quot;&gt; &lt;columnOverride column=&quot;&quot; javaType=&quot;&quot; /&gt; &lt;/table&gt; --&gt; &lt;/context&gt; &lt;/generatorConfiguration&gt;]]></content>
      <categories>
        <category>SSM</category>
      </categories>
      <tags>
        <tag>mybatis</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[mybatis四]]></title>
    <url>%2F2018%2F02%2F25%2Fmybatis%E5%9B%9B%2F</url>
    <content type="text"><![CDATA[关联查询一对一查询这里举例是一个订单对应一个用户 方法一：使用resultType，定义订单信息po类，此po类中包括了订单信息和用户信息： Sql语句：SELECT orders.*, user.username, user.address FROM orders, user WHERE orders.user_id = user.id 定义po类Po类中应该包括上边sql查询出来的所有字段，如下： public class OrdersCustom extends Orders { private String username;// 用户名称 private String address;// 用户地址 get/set。。。。 OrdersCustom类继承Orders类后OrdersCustom类包括了Orders类的所有字段，只需要定义用户的信息字段即可。 Mapper.xml&lt;!-- 查询所有订单信息 --&gt; &lt;select id=&quot;findOrdersList&quot; resultType=&quot;cn.lxm.mybatis.po.OrdersCustom&quot;&gt; SELECT orders.*, user.username, user.address FROM orders, user WHERE orders.user_id = user.id &lt;/select&gt; Mapper接口：public List&lt;OrdersCustom&gt; findOrdersList() throws Exception; 测试：Public void testfindOrdersList()throws Exception{ //获取session SqlSession session = sqlSessionFactory.openSession(); //获限mapper接口实例 UserMapper userMapper = session.getMapper(UserMapper.class); //查询订单信息 List&lt;OrdersCustom&gt; list = userMapper.findOrdersList(); System.out.println(list); //关闭session session.close(); } 小结：定义专门的po类作为输出类型，其中定义了sql查询结果集所有的字段。此方法较为简单，企业中使用普遍。 方法二：使用resultMap，定义专门的resultMap用于映射一对一查询结果。 Sql语句：SELECT orders.*, user.username, user.address FROM orders, user WHERE orders.user_id = user.id 定义po类在Orders类中加入User属性，user属性中用于存储关联查询的用户信息，因为订单关联查询用户是一对一关系，所以这里使用单个User对象存储关联查询的用户信息。 public class Orders { private Integer id; private Integer userId; private String number; private Date createtime; private String note; private User user; get/set()... Mapper.xml&lt;!-- 查询订单关联用户信息使用resultmap --&gt; &lt;resultMap type=&quot;Orders&quot; id=&quot;orderUserResultMap&quot;&gt; &lt;id column=&quot;id&quot; property=&quot;id&quot;/&gt; &lt;result column=&quot;user_id&quot; property=&quot;userId&quot;/&gt; &lt;result column=&quot;number&quot; property=&quot;number&quot;/&gt; &lt;result column=&quot;createtime&quot; property=&quot;createtime&quot;/&gt; &lt;result column=&quot;note&quot; property=&quot;note&quot;/&gt; &lt;!-- 一对一关联映射 --&gt; &lt;!-- property:Orders对象的user属性 javaType：user属性对应 的类型 --&gt; &lt;association property=&quot;user&quot; javaType=&quot;cn.lxm.po.User&quot;&gt; &lt;!-- column:user表的主键对应的列 property：user对象中id属性--&gt; &lt;id column=&quot;user_id&quot; property=&quot;id&quot;/&gt; &lt;result column=&quot;username&quot; property=&quot;username&quot;/&gt; &lt;result column=&quot;address&quot; property=&quot;address&quot;/&gt; &lt;/association&gt; &lt;/resultMap&gt; &lt;select id=&quot;findOrdersWithUserResultMap&quot; resultMap=&quot;orderUserResultMap&quot;&gt; SELECT o.id, o.user_id, o.number, o.createtime, o.note, u.username, u.address FROM orders o JOIN `user` u ON u.id = o.user_id &lt;/select&gt; 这里resultMap指定orderUserResultMap。 association：表示进行关联查询单条记录 property：表示关联查询的结果存储在cn.lxm.mybatis.po.Orders的user属性中 javaType：表示关联查询的结果类型 &lt; id property=”id” column=”user_id”/&gt;：查询结果的user_id列对应关联对象的id属性，这里是&lt; id /&gt;表示user_id是关联查询对象的唯一标识。 &lt; result property=”username” column=”username”/&gt;：查询结果的username列对应关联对象的username属性。 Mapper接口：public List&lt;Orders&gt; findOrdersListResultMap() throws Exception; 测试：Public void testfindOrdersListResultMap()throws Exception{ //获取session SqlSession session = sqlSessionFactory.openSession(); //获限mapper接口实例 UserMapper userMapper = session.getMapper(UserMapper.class); //查询订单信息 List&lt;Orders&gt; list = userMapper.findOrdersList2(); System.out.println(list); //关闭session session.close(); } 小结：使用association完成关联查询，将关联查询信息映射到pojo对象中。 一对多查询案例：查询所有用户信息及用户关联的订单信息。 用户信息和订单信息为一对多关系。 使用resultMap实现如下： Sql语句：SELECT u.*, o.id oid, o.number, o.createtime, o.note FROM `user` u LEFT JOIN orders o ON u.id = o.user_id 定义po类在User类中加入List&lt; Orders&gt; orders属性 public class User { private int id; private String username;// 用户姓名 private String sex;// 性别 private Date birthday;// 生日 private String address;// 地址 private List&lt;Orders&gt; orders; get/set()... Mapper.xml&lt;resultMap type=&quot;user&quot; id=&quot;userOrderResultMap&quot;&gt; &lt;!-- 用户信息映射 --&gt; &lt;id property=&quot;id&quot; column=&quot;id&quot;/&gt; &lt;result property=&quot;username&quot; column=&quot;username&quot;/&gt; &lt;result property=&quot;birthday&quot; column=&quot;birthday&quot;/&gt; &lt;result property=&quot;sex&quot; column=&quot;sex&quot;/&gt; &lt;result property=&quot;address&quot; column=&quot;address&quot;/&gt; &lt;!-- 一对多关联映射 --&gt; &lt;collection property=&quot;orders&quot; ofType=&quot;orders&quot;&gt; &lt;id property=&quot;id&quot; column=&quot;oid&quot;/&gt; &lt;!--用户id已经在user对象中存在，此处可以不设置--&gt; &lt;!-- &lt;result property=&quot;userId&quot; column=&quot;id&quot;/&gt; --&gt; &lt;result property=&quot;number&quot; column=&quot;number&quot;/&gt; &lt;result property=&quot;createtime&quot; column=&quot;createtime&quot;/&gt; &lt;result property=&quot;note&quot; column=&quot;note&quot;/&gt; &lt;/collection&gt; &lt;/resultMap&gt; &lt;select id=&quot;getUserOrderList&quot; resultMap=&quot;userOrderResultMap&quot;&gt; SELECT u.*, o.id oid, o.number, o.createtime, o.note FROM `user` u LEFT JOIN orders o ON u.id = o.user_id &lt;/select&gt; collection部分定义了用户关联的订单信息。表示关联查询结果集 property=”orders”：关联查询的结果集存储在User对象的上哪个属性。 ofType=”orders”：指定关联查询的结果集中的对象类型即List中的对象类型。此处可以使用别名，也可以使用全限定名。 &lt; id /&gt;及&lt; result/&gt;的意义同一对一查询。 Mapper接口：List&lt;User&gt; getUserOrderList(); 测试@Test public void getUserOrderList() { SqlSession session = sqlSessionFactory.openSession(); UserMapper userMapper = session.getMapper(UserMapper.class); List&lt;User&gt; result = userMapper.getUserOrderList(); for (User user : result) { System.out.println(user); } session.close(); }]]></content>
      <categories>
        <category>SSM</category>
      </categories>
      <tags>
        <tag>mybatis</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[mybatis三]]></title>
    <url>%2F2018%2F02%2F25%2Fmybatis%E4%B8%89%2F</url>
    <content type="text"><![CDATA[输入映射和输出映射Mapper.xml映射文件中定义了操作数据库的sql，每个sql是一个statement，映射文件是mybatis的核心。 parameterType(输入类型)传递简单类型参考文章 mybatis入门一 传递pojo对象Mybatis使用ognl表达式解析对象字段的值，#{}或者${}括号中的值为pojo属性名称。 传递pojo包装对象开发中通过pojo传递查询条件 ，查询条件是综合的查询条件，不仅包括用户查询条件还包括其它的查询条件（比如将用户购买商品信息也作为查询条件），这时可以使用包装对象传递输入参数。Pojo类中包含pojo。 需求：根据用户名查询用户信息，查询条件放到QueryVo的user属性中。 QueryVopublic class QueryVo { private User user; public User getUser() { return user; } public void setUser(User user) { this.user = user; } } Sql语句SELECT * FROM user where username like ‘%刘%’ Mapper文件&lt;!-- 使用包装类型查询用户使用ognl从对象中取属性值，如果是包装对象可以使用.操作符来取内容部的属性--&gt; &lt;select id=&quot;findUserByQueryVo&quot; parameterType=&quot;queryvo&quot; resultType=&quot;user&quot;&gt; SELECT * FROM user where username like &apos;%${user.username}%&apos; &lt;/select&gt; 接口 public interface UserMapper{ User findUserById(int id) throws Exception; void insertUser(User user) throws Exception; List&lt;User&gt; findUserByQueryVo(QueryVo queryVo) throws Exception; } 测试方法@Test public void testFindUserByQueryVo() throws Exception { SqlSession sqlSession = sessionFactory.openSession(); //获得mapper的代理对象 UserMapper userMapper = sqlSession.getMapper(UserMapper.class); //创建QueryVo对象 QueryVo queryVo = new QueryVo(); //创建user对象 User user = new User(); user.setUsername(&quot;刘&quot;); queryVo.setUser(user); //根据queryvo查询用户 List&lt;User&gt; list = userMapper.findUserByQueryVo(queryVo); System.out.println(list); sqlSession.close(); } resultType(输出类型)输出简单类型参考getnow输出日期类型，看下边的例子输出整型： Mapper.xml文件 &lt;!-- 获取用户列表总数 --&gt; &lt;select id=&quot;findUserCount&quot; parameterType=&quot;user&quot; resultType=&quot;int&quot;&gt; select count(1) from user &lt;/select&gt; Mapper接口 public int findUserCount(User user) throws Exception; 调用： Public void testFindUserCount() throws Exception{ //获取session SqlSession session = sqlSessionFactory.openSession(); //获取mapper接口实例 UserMapper userMapper = session.getMapper(UserMapper.class); User user = new User(); user.setUsername(&quot;管理员&quot;); //传递Hashmap对象查询用户列表 int count = userMapper.findUserCount(user); //关闭session session.close(); } 输出简单类型必须查询出来的结果集有一条记录，最终将第一个字段的值转换为输出类型。使用session的selectOne可查询单条记录。 输出pojo对象参考文章 mybatis入门一 输出pojo列表参考文章 mybatis入门一 resultMapresultType可以指定pojo将查询结果映射为pojo，但需要pojo的属性名和sql查询的列名一致方可映射成功。 如果sql查询字段名和pojo的属性名不一致，可以通过resultMap将字段名和属性名作一个对应关系 ，resultMap实质上还需要将查询结果映射到pojo对象中。 resultMap可以实现将查询结果映射为复杂类型的pojo，比如在查询结果映射对象中包括pojo和list实现一对一查询和一对多查询。 Mapper.xml定义 &lt;select id=&quot;findUserListResultMap&quot; parameterType=&quot;queryVo&quot; resultMap=&quot;userListResultMap&quot;&gt; select id id_,username username_,birthday birthday_ from user &lt;/select&gt; 使用resultMap指定上边定义的personmap。 定义resultMap由于上边的mapper.xml中sql查询列和Users.java类属性不一致，需要定义resultMap： userListResultMap将sql查询列和Users.java类属性对应起来 &lt;!-- type:最终映射的java对象.id:resultMap的唯一标识 --&gt; &lt;resultMap type=&quot;user&quot; id=&quot;userListResultMap&quot;&gt; &lt;!-- id标签:查询结果集的唯一标识列(主键或唯一标识) column:SQL查询字段名(列名) property:pojo的属性名 result标签:普通列 --&gt; &lt;id property=&quot;id&quot; column=&quot;id_&quot;/&gt; &lt;result property=&quot;username&quot; column=&quot;username_&quot;/&gt; &lt;result property=&quot;birthday&quot; column=&quot;birthday_&quot;/&gt; &lt;/resultMap&gt; &lt; id /&gt;：此属性表示查询结果集的唯一标识，非常重要。如果是多个字段为复合唯一约束则定义多个&lt; id /&gt;。 Property：表示User类的属性。 Column：表示sql查询出来的字段名。 Column和property放在一块儿表示将sql查询出来的字段映射到指定的pojo类属性上。 &lt; result /&gt;：普通结果，即pojo的属性。 Mapper接口定义public List&lt;User&gt; findUserListResultMap() throws Exception; 动态sql通过mybatis提供的各种标签方法实现动态拼接sql。 If&lt;!-- 传递pojo综合查询用户信息 --&gt; &lt;select id=&quot;findUserList&quot; parameterType=&quot;user&quot; resultType=&quot;user&quot;&gt; select * from user where 1=1 &lt;if test=&quot;id!=null and id!=&apos;&apos;&quot;&gt; and id=#{id} &lt;/if&gt; &lt;if test=&quot;username!=null and username!=&apos;&apos;&quot;&gt; and username like &apos;%${username}%&apos; &lt;/if&gt; &lt;/select&gt; 注意要做不等于空字符串校验。 Where上边的sql也可以改为： &lt;select id=&quot;findUserList&quot; parameterType=&quot;user&quot; resultType=&quot;user&quot;&gt; select * from user &lt;where&gt; &lt;if test=&quot;id!=null and id!=&apos;&apos;&quot;&gt; and id=#{id} &lt;/if&gt; &lt;if test=&quot;username!=null and username!=&apos;&apos;&quot;&gt; and username like &apos;%${username}%&apos; &lt;/if&gt; &lt;/where&gt; &lt;/select&gt; &lt; where /&gt;可以自动处理第一个and。 foreach向sql传递数组或List，mybatis使用foreach解析，如下： 需求传入多个id查询用户信息，用下边两个sql实现： SELECT * FROM USERS WHERE username LIKE &apos;%张%&apos; AND (id =10 OR id =89 OR id=16) SELECT * FROM USERS WHERE username LIKE &apos;%张%&apos; id IN (10,89,16) 在pojo中定义list属性ids存储多个用户id，并添加getter/setter方法 public class QueryVo { private User user; private List&lt;Integer&gt; ids; public List&lt;Integer&gt; getIds() { return ids; } public void setIds(List&lt;Integer&gt; ids) { this.ids = ids; } ... mapper.xml &lt;if test=&quot;ids!=null and ids.size&gt;0&quot;&gt; &lt;foreach collection=&quot;ids&quot; open=&quot; and id in(&quot; close=&quot;)&quot; item=&quot;id&quot; separator=&quot;,&quot; &gt; #{id} &lt;/foreach&gt; &lt;/if&gt; 测试代码： List&lt;Integer&gt; ids = new ArrayList&lt;Integer&gt;(); ids.add(1);//查询id为1的用户 ids.add(10); //查询id为10的用户 queryVo.setIds(ids); List&lt;User&gt; list = userMapper.findUserList(queryVo); Sql片段Sql中可将重复的sql提取出来，使用时用include引用即可，最终达到sql重用的目的，如下： &lt;!-- 传递pojo综合查询用户信息 --&gt; &lt;select id=&quot;findUserList&quot; parameterType=&quot;user&quot; resultType=&quot;user&quot;&gt; select * from user &lt;where&gt; &lt;if test=&quot;id!=null and id!=&apos;&apos;&quot;&gt; and id=#{id} &lt;/if&gt; &lt;if test=&quot;username!=null and username!=&apos;&apos;&quot;&gt; and username like &apos;%${username}%&apos; &lt;/if&gt; &lt;/where&gt; &lt;/select&gt;  将where条件抽取出来： &lt;sql id=&quot;query_user_where&quot;&gt; &lt;if test=&quot;id!=null and id!=&apos;&apos;&quot;&gt; and id=#{id} &lt;/if&gt; &lt;if test=&quot;username!=null and username!=&apos;&apos;&quot;&gt; and username like &apos;%${username}%&apos; &lt;/if&gt; &lt;/sql&gt;  使用include引用： &lt;select id=&quot;findUserList&quot; parameterType=&quot;user&quot; resultType=&quot;user&quot;&gt; select * from user &lt;where&gt; &lt;include refid=&quot;query_user_where&quot;/&gt; &lt;/where&gt; &lt;/select&gt; 注意：如果引用其它mapper.xml的sql片段，则在引用时需要加上namespace，如下： &lt;include refid=&quot;namespace.sql片段”/&gt; 如果使用 &gt;或者&lt;符号的时候,因为是在xml文件中这些符号都是有特殊含义的,可以使用CDATA区域 &lt;![CDATA[要写的内容]]&gt; &lt;![CDATA[&gt;]]&gt;大于 &lt;![CDATA[&lt;]]&gt;]]></content>
      <categories>
        <category>SSM</category>
      </categories>
      <tags>
        <tag>mybatis</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[mybatis二]]></title>
    <url>%2F2018%2F02%2F24%2Fmybatis%E4%BA%8C%2F</url>
    <content type="text"><![CDATA[Mapper动态代理方式开发规范Mapper接口开发方法只需要程序员编写Mapper接口（相当于Dao接口），由Mybatis框架根据接口定义创建接口的动态代理对象，代理对象的方法体同上边Dao接口实现类方法。 Mapper接口开发需要遵循以下规范：1、 Mapper.xml文件中的namespace与mapper接口的类路径相同。 2、 Mapper接口方法名和Mapper.xml中定义的每个statement的id相同 3、 Mapper接口方法的输入参数类型和mapper.xml中定义的每个sql 的parameterType的类型相同 4、 Mapper接口方法的输出参数类型和mapper.xml中定义的每个sql的resultType的类型相同 Mapper.xml(映射文件)定义mapper映射文件UserMapper.xml（内容同Users.xml），需要修改namespace的值为 UserMapper接口路径。将UserMapper.xml放在classpath 下mapper目录 下。 &lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; ?&gt; &lt;!DOCTYPE mapper PUBLIC &quot;-//mybatis.org//DTD Mapper 3.0//EN&quot; &quot;http://mybatis.org/dtd/mybatis-3-mapper.dtd&quot;&gt; &lt;mapper namespace=&quot;cn.lxm.mybatis.mapper.UserMapper&quot;&gt; &lt;!-- 根据id获取用户信息 --&gt; &lt;select id=&quot;findUserById&quot; parameterType=&quot;int&quot; resultType=&quot;cn.lxm.mybatis.po.User&quot;&gt; select * from user where id = #{id} &lt;/select&gt; &lt;!-- 自定义条件查询用户列表 --&gt; &lt;select id=&quot;findUserByUsername&quot; parameterType=&quot;java.lang.String&quot; resultType=&quot;cn.lxm.mybatis.po.User&quot;&gt; select * from user where username like &apos;%${value}%&apos; &lt;/select&gt; &lt;!-- 添加用户 --&gt; &lt;insert id=&quot;insertUser&quot; parameterType=&quot;cn.lxm.mybatis.po.User&quot;&gt; &lt;selectKey keyProperty=&quot;id&quot; order=&quot;AFTER&quot; resultType=&quot;java.lang.Integer&quot;&gt; select LAST_INSERT_ID() &lt;/selectKey&gt; insert into user(username,birthday,sex,address) values(#{username},#{birthday},#{sex},#{address}) &lt;/insert&gt; &lt;/mapper&gt; Mapper.java(接口文件)/** * 用户管理mapper */ Public interface UserMapper { //根据用户id查询用户信息 public User findUserById(int id) throws Exception; //查询用户列表 public List&lt;User&gt; findUserByUsername(String username) throws Exception; //添加用户信息 public void insertUser(User user)throws Exception; } 接口定义有如下特点： 1、 Mapper接口方法名和Mapper.xml中定义的statement的id相同 2、 Mapper接口方法的输入参数类型和mapper.xml中定义的statement的parameterType的类型相同 3、 Mapper接口方法的输出参数类型和mapper.xml中定义的statement的resultType的类型相同 加载UserMapper.xml文件修改SqlMapConfig.xml文件： &lt;!-- 加载映射文件 --&gt; &lt;mappers&gt; &lt;mapper resource=&quot;mapper/UserMapper.xml&quot;/&gt; &lt;/mappers&gt; 测试Public class UserMapperTest extends TestCase { private SqlSessionFactory sqlSessionFactory; protected void setUp() throws Exception { //mybatis配置文件 String resource = &quot;sqlMapConfig.xml&quot;; InputStream inputStream = Resources.getResourceAsStream(resource); //使用SqlSessionFactoryBuilder创建sessionFactory sqlSessionFactory = new SqlSessionFactoryBuilder().build(inputStream); } Public void testFindUserById() throws Exception { //获取session SqlSession session = sqlSessionFactory.openSession(); //获取mapper接口的代理对象 UserMapper userMapper = session.getMapper(UserMapper.class); //调用代理对象方法 User user = userMapper.findUserById(1); System.out.println(user); //关闭session session.close(); } @Test public void testFindUserByUsername() throws Exception { SqlSession sqlSession = sqlSessionFactory.openSession(); UserMapper userMapper = sqlSession.getMapper(UserMapper.class); List&lt;User&gt; list = userMapper.findUserByUsername(&quot;张&quot;); System.out.println(list.size()); } Public void testInsertUser() throws Exception { //获取session SqlSession session = sqlSessionFactory.openSession(); //获取mapper接口的代理对象 UserMapper userMapper = session.getMapper(UserMapper.class); //要添加的数据 User user = new User(); user.setUsername(&quot;张三&quot;); user.setBirthday(new Date()); user.setSex(&quot;1&quot;); user.setAddress(&quot;北京市&quot;); //通过mapper接口添加用户 userMapper.insertUser(user); //提交 session.commit(); //关闭session session.close(); } } 小结 selectOne和selectList动态代理对象调用sqlSession.selectOne()和sqlSession.selectList()是根据mapper接口方法的返回值决定，如果返回list则调用selectList方法，如果返回单个对象则调用selectOne方法。 namespacemybatis官方推荐使用mapper代理方法开发mapper接口，程序员不用编写mapper接口实现类，使用mapper代理方法时，输入参数可以使用pojo包装对象或map对象，保证dao的通用性。 SqlMapConfig.xml配置文件配置内容SqlMapConfig.xml中配置的内容和顺序如下： properties（属性） settings（全局配置参数） typeAliases（类型别名） typeHandlers（类型处理器） objectFactory（对象工厂） plugins（插件） environments（环境集合属性对象） environment（环境子属性对象） transactionManager（事务管理） dataSource（数据源） mappers（映射器） properties（属性）SqlMapConfig.xml可以引用java属性文件中的配置信息如下： 在classpath下定义db.properties文件 jdbc.driver=com.mysql.jdbc.Driver jdbc.url=jdbc:mysql://localhost:3306/mybatis?characterEncoding=utf-8 jdbc.username=root jdbc.password=root SqlMapConfig.xml引用如下： &lt;properties resource=&quot;db.properties&quot;/&gt; &lt;environments default=&quot;development&quot;&gt; &lt;environment id=&quot;development&quot;&gt; &lt;transactionManager type=&quot;JDBC&quot;/&gt; &lt;dataSource type=&quot;POOLED&quot;&gt; &lt;property name=&quot;driver&quot; value=&quot;${jdbc.driver}&quot;/&gt; &lt;property name=&quot;url&quot; value=&quot;${jdbc.url}&quot;/&gt; &lt;property name=&quot;username&quot; value=&quot;${jdbc.username}&quot;/&gt; &lt;property name=&quot;password&quot; value=&quot;${jdbc.password}&quot;/&gt; &lt;/dataSource&gt; &lt;/environment&gt; &lt;/environments&gt; 注意： MyBatis 将按照下面的顺序来加载属性： 在 properties 元素体内定义的属性首先被读取。 然后会读取properties 元素中resource或 url 加载的属性，它会覆盖已读取的同名属性。 typeAliases（类型别名）mybatis支持别名：别名 映射的类型 _byte byte _long long _short short _int int _integer int _double double _float float _boolean boolean string String byte Byte long Long short Short int Integer integer Integer double Double float Float boolean Boolean date Date decimal BigDecimal bigdecimal BigDecimal map Map 自定义别名：在SqlMapConfig.xml中配置： 这个标签的位置必须放在标签前面,dtd的约束 mappers（映射器）Mapper配置的几种方法： &lt; mapper resource=” “ /&gt; 使用相对于类路径的资源如： &lt;mapper resource=&quot;sqlmap/User.xml&quot; /&gt; &lt; mapper class=” “ /&gt; 使用mapper接口类路径如： &lt;mapper class=&quot;cn.lxm.mybatis.mapper.UserMapper&quot;/&gt; 注意：此种方法要求mapper接口名称和mapper映射文件名称相同，且放在同一个目录中。 &lt; package name=””/&gt; 注册指定包下的所有mapper接口如： &lt;package name=&quot;cn.lxm.mybatis.mapper&quot;/&gt; 注意：此种方法要求mapper接口名称和mapper映射文件名称相同，且放在同一个目录中。]]></content>
      <categories>
        <category>SSM</category>
      </categories>
      <tags>
        <tag>mybatis</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[mybatis一]]></title>
    <url>%2F2018%2F02%2F24%2Fmybatis%E4%B8%80%2F</url>
    <content type="text"><![CDATA[Mybatis入门程序1 mybatis下载mybaits的代码由github.com管理，地址：https://github.com/mybatis/mybatis-3/releases mybatis-3.2.7.jar—-mybatis的核心包lib—-mybatis的依赖包mybatis-3.2.7.pdf—-mybatis使用手册 2 工程搭建第一步：创建java工程使用eclipse创建java工程，jdk使用1.7.0_72。 第二步：加入jar包加入mybatis核心包、依赖包、数据驱动包。 第三步：log4j.properties在classpath下创建log4j.properties如下： # Global logging configuration log4j.rootLogger=DEBUG, stdout # Console output... log4j.appender.stdout=org.apache.log4j.ConsoleAppender log4j.appender.stdout.layout=org.apache.log4j.PatternLayout log4j.appender.stdout.layout.ConversionPattern=%5p [%t] - %m%n mybatis默认使用log4j作为输出日志信息。 第四步：SqlMapConfig.xml在classpath下创建SqlMapConfig.xml，如下： &lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; ?&gt; &lt;!DOCTYPE configuration PUBLIC &quot;-//mybatis.org//DTD Config 3.0//EN&quot; &quot;http://mybatis.org/dtd/mybatis-3-config.dtd&quot;&gt; &lt;configuration&gt; &lt;!-- 和spring整合后 environments配置将废除--&gt; &lt;environments default=&quot;development&quot;&gt; &lt;environment id=&quot;development&quot;&gt; &lt;!-- 使用jdbc事务管理--&gt; &lt;transactionManager type=&quot;JDBC&quot; /&gt; &lt;!-- 数据库连接池--&gt; &lt;dataSource type=&quot;POOLED&quot;&gt; &lt;property name=&quot;driver&quot; value=&quot;com.mysql.jdbc.Driver&quot; /&gt; &lt;property name=&quot;url&quot; value=&quot;jdbc:mysql://localhost:3306/mybatis?characterEncoding=utf-8&quot; /&gt; &lt;property name=&quot;username&quot; value=&quot;root&quot; /&gt; &lt;property name=&quot;password&quot; value=&quot;root&quot; /&gt; &lt;/dataSource&gt; &lt;/environment&gt; &lt;/environments&gt; &lt;/configuration&gt; SqlMapConfig.xml是mybatis核心配置文件，上边文件的配置内容为数据源、事务管理。 第五步：po类Po类作为mybatis进行sql映射使用，po类通常与数据库表对应，User.java如下： Public class User { private int id; private String username;// 用户姓名 private String sex;// 性别 private Date birthday;// 生日 private String address;// 地址 get/set…… 第六步：sql映射文件在classpath下的sqlmap目录下创建sql映射文件Users.xml： &lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; ?&gt; &lt;!DOCTYPE mapper PUBLIC &quot;-//mybatis.org//DTD Mapper 3.0//EN&quot; &quot;http://mybatis.org/dtd/mybatis-3-mapper.dtd&quot;&gt; &lt;mapper namespace=&quot;test&quot;&gt; &lt;/mapper&gt; namespace ：命名空间，用于隔离sql语句，后面会讲另一层非常重要的作用。 第七步：加载映射文件mybatis框架需要加载映射文件，将User.xml添加在SqlMapConfig.xml，如下： &lt;mappers&gt; &lt;mapper resource=&quot;sqlmap/User.xml&quot;/&gt; &lt;/mappers&gt; 3 根据id查询用户信息映射文件：在user.xml中添加： &lt;!-- 根据id获取用户信息 - -&gt; &lt;select id=&quot;findUserById&quot; parameterType=&quot;int&quot; resultType=&quot;cn.lxm.mybatis.po.User&quot;&gt; select * from user where id = #{id} &lt;/select&gt; parameterType：定义输入到sql中的映射类型，#{id}表示使用preparedstatement设置占位符号并将输入变量id传到sql。resultType：定义结果映射类型。 测试程序：public class Mybatis_first { //会话工厂 private SqlSessionFactory sqlSessionFactory; @Before public void createSqlSessionFactory() throws IOException { // 配置文件 String resource = &quot;SqlMapConfig.xml&quot;; InputStream inputStream = Resources.getResourceAsStream(resource); // 使用SqlSessionFactoryBuilder从xml配置文件中创建SqlSessionFactory sqlSessionFactory = new SqlSessionFactoryBuilder() .build(inputStream); } // 根据 id查询用户信息 @Test public void testFindUserById() { // 数据库会话实例 SqlSession sqlSession = null; try { // 创建数据库会话实例sqlSession sqlSession = sqlSessionFactory.openSession(); // 查询单个记录，根据用户id查询用户信息 User user = sqlSession.selectOne(&quot;test.findUserById&quot;, 10); // 输出用户信息 System.out.println(user); } catch (Exception e) { e.printStackTrace(); } finally { if (sqlSession != null) { sqlSession.close(); } } } } 4 根据用户名查询用户信息映射文件：在user.xml中添加： &lt;!-- 自定义条件查询用户列表 - -&gt; &lt;select id=&quot;findUserByUsername&quot; parameterType=&quot;java.lang.String&quot; resultType=&quot;cn.lxm.mybatis.po.User&quot;&gt; select * from user where username like &apos;%${value}%&apos; &lt;/select&gt; parameterType：定义输入到sql中的映射类型，${value}表示使用参数将${value}替换，做字符串的拼接。注意：如果是取简单数据类型的参数，括号中的值必须为valueresultType：定义结果映射类型。 测试程序：// 根据用户名称模糊查询用户信息 @Test public void testFindUserByUsername() { // 数据库会话实例 SqlSession sqlSession = null; try { // 创建数据库会话实例sqlSession sqlSession = sqlSessionFactory.openSession(); // 查询单个记录，根据用户id查询用户信息 List&lt;User&gt; list = sqlSession.selectList(&quot;test.findUserByUsername&quot;, &quot;张&quot;); System.out.println(list.size()); } catch (Exception e) { e.printStackTrace(); } finally { if (sqlSession != null) { sqlSession.close(); } } } 5小结#{}和${}-#{}表示一个占位符号，通过#{}可以实现preparedStatement向占位符中设置值，自动进行java类型和jdbc类型转换，#{}可以有效防止sql注入。 #{}可以接收简单类型值或pojo属性值。 如果parameterType传输单个简单类型值，#{}括号中可以是value或其它名称。 -${}表示拼接sql串，通过${}可以将parameterType 传入的内容拼接在sql中且不进行jdbc类型转换， ${}可以接收简单类型值或pojo属性值，如果parameterType传输单个简单类型值，${}括号中只能是value。 parameterType和resultTypeparameterType：指定输入参数类型，mybatis通过ognl从输入对象中获取参数值拼接在sql中。resultType：指定输出结果类型，mybatis将sql查询结果的一行记录数据映射为resultType指定类型的对象。 selectOne和selectListselectOne查询一条记录，如果使用selectOne查询多条记录则抛出异常： org.apache.ibatis.exceptions.TooManyResultsException: Expected one result (or null) to be returned by selectOne(), but found: 3 at org.apache.ibatis.session.defaults.DefaultSqlSession.selectOne(DefaultSqlSession.java:70) selectList可以查询一条或多条记录。 6添加用户映射文件：在SqlMapConfig.xml中添加： insert into user(username,birthday,sex,address) values(#{username},#{birthday},#{sex},#{address}) 测试程序：// 添加用户信息 @Test public void testInsert() { // 数据库会话实例 SqlSession sqlSession = null; try { // 创建数据库会话实例sqlSession sqlSession = sqlSessionFactory.openSession(); // 添加用户信息 User user = new User(); user.setUsername(&quot;张小明&quot;); user.setAddress(&quot;河南郑州&quot;); user.setSex(&quot;1&quot;); user.setPrice(1999.9f); sqlSession.insert(&quot;test.insertUser&quot;, user); //提交事务 sqlSession.commit(); } catch (Exception e) { e.printStackTrace(); } finally { if (sqlSession != null) { sqlSession.close(); } } } mysql自增主键返回通过修改sql映射文件，可以将mysql自增主键返回: &lt;insert id=&quot;insertUser&quot; parameterType=&quot;cn.lxm.mybatis.po.User&quot;&gt; &lt;!-- selectKey将主键返回，需要再返回 使用user.getId()获取返回的id值 --&gt; &lt;selectKey keyProperty=&quot;id&quot; order=&quot;AFTER&quot; resultType=&quot;java.lang.Integer&quot;&gt; select LAST_INSERT_ID() &lt;/selectKey&gt; insert into user(username,birthday,sex,address) values(#{username},#{birthday},#{sex},#{address}); &lt;/insert&gt; 添加selectKey实现将主键返回 keyProperty:返回的主键存储在pojo中的哪个属性 order：selectKey的执行顺序，是相对与insert语句来说，由于mysql的自增原理执行完insert语句之后才将主键生成，所以这里selectKey的执行顺序为after resultType:返回的主键是什么类型 LAST_INSERT_ID():是mysql的函数，返回auto_increment自增列新记录id值。 oracle自增主键返回&lt;insert id=&quot;insertUser&quot; parameterType=&quot;cn.lxm.mybatis.po.User&quot;&gt; &lt;!-- selectKey将主键返回，需要再返回 --&gt; &lt;selectKey keyProperty=&quot;id&quot; order=&quot;BEFORE&quot; resultType=&quot;java.lang.Integer&quot;&gt; select 序列的.nextval() &lt;/selectKey&gt; insert into user(id,username,birthday,sex,address) values(#{id},#{username},#{birthday},#{sex},#{address}); &lt;/insert&gt; oracle的不是很常用,这里是需要先取出序列里面的主键,然后再插入数据,插入的时候讲取出来的主键放进去.所以这里的order是BEFORE Mysql使用 uuid实现主键需要增加通过select uuid()得到uuid值 &lt;insert id=&quot;insertUser&quot; parameterType=&quot;cn.lxm.mybatis.po.User&quot;&gt; &lt;selectKey resultType=&quot;java.lang.String&quot; order=&quot;BEFORE&quot; keyProperty=&quot;id&quot;&gt; select uuid() &lt;/selectKey&gt; insert into user(id,username,birthday,sex,address) values(#{id},#{username},#{birthday},#{sex},#{address}) &lt;/insert&gt; 注意这里使用的order是“BEFORE” 7删除用户映射文件： &lt;delete id=&quot;deleteUserById&quot; parameterType=&quot;int&quot;&gt; delete from user where id=#{id} &lt;/delete&gt; 测试程序：// 根据id删除用户 @Test public void testDelete() { // 数据库会话实例 SqlSession sqlSession = null; try { // 创建数据库会话实例sqlSession sqlSession = sqlSessionFactory.openSession(); // 删除用户 sqlSession.delete(&quot;test.deleteUserById&quot;,18); // 提交事务 sqlSession.commit(); } catch (Exception e) { e.printStackTrace(); } finally { if (sqlSession != null) { sqlSession.close(); } } } 8修改用户映射文件 &lt;update id=&quot;updateUser&quot; parameterType=&quot;cn.lxm.mybatis.po.User&quot;&gt; update user set username=#{username},birthday=#{birthday},sex=#{sex},address=#{address} where id=#{id} &lt;/update&gt; 测试程序// 更新用户信息 @Test public void testUpdate() { // 数据库会话实例 SqlSession sqlSession = null; try { // 创建数据库会话实例sqlSession sqlSession = sqlSessionFactory.openSession(); // 添加用户信息 User user = new User(); user.setId(16); user.setUsername(&quot;张小明&quot;); user.setAddress(&quot;河南郑州&quot;); user.setSex(&quot;1&quot;); user.setPrice(1999.9f); sqlSession.update(&quot;test.updateUser&quot;, user); // 提交事务 sqlSession.commit(); } catch (Exception e) { e.printStackTrace(); } finally { if (sqlSession != null) { sqlSession.close(); } } } 9 Mybatis解决jdbc编程的问题 1、 数据库链接创建、释放频繁造成系统资源浪费从而影响系统性能，如果使用数据库链接池可解决此问题。解决：在SqlMapConfig.xml中配置数据链接池，使用连接池管理数据库链接。 2、 Sql语句写在代码中造成代码不易维护，实际应用sql变化的可能较大，sql变动需要改变java代码。解决：将Sql语句配置在XXXXmapper.xml文件中与java代码分离。 3、 向sql语句传参数麻烦，因为sql语句的where条件不一定，可能多也可能少，占位符需要和参数一一对应。解决：Mybatis自动将java对象映射至sql语句，通过statement中的parameterType定义输入参数的类型。 4、 对结果集解析麻烦，sql变化导致解析代码变化，且解析前需要遍历，如果能将数据库记录封装成pojo对象解析比较方便。解决：Mybatis自动将sql执行结果映射至java对象，通过statement中的resultType定义输出结果的类型。 10 mybatis与hibernate不同 Mybatis和hibernate不同，它不完全是一个ORM框架，因为MyBatis需要程序员自己编写Sql语句，不过mybatis可以通过XML或注解方式灵活配置要运行的sql语句，并将java对象和sql语句映射生成最终执行的sql，最后将sql执行的结果再映射生成java对象。 Mybatis学习门槛低，简单易学，程序员直接编写原生态sql，可严格控制sql执行性能，灵活度高，非常适合对关系数据模型要求不高的软件开发，例如互联网软件、企业运营类软件等，因为这类软件需求变化频繁，一但需求变化要求成果输出迅速。但是灵活的前提是mybatis无法做到数据库无关性，如果需要实现支持多种数据库的软件则需要自定义多套sql映射文件，工作量大。 Hibernate对象/关系映射能力强，数据库无关性好，对于关系模型要求高的软件（例如需求固定的定制化软件）如果用hibernate开发可以节省很多代码，提高效率。但是Hibernate的学习门槛高，要精通门槛更高，而且怎么设计O/R映射，在性能和对象模型之间如何权衡，以及怎样用好Hibernate需要具有很强的经验和能力才行。 总之，按照用户的需求在有限的资源环境下只要能做出维护性、扩展性良好的软件架构都是好架构，所以框架只有适合才是最好。]]></content>
      <categories>
        <category>SSM</category>
      </categories>
      <tags>
        <tag>mybatis</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[webService天气预报接口]]></title>
    <url>%2F2018%2F02%2F11%2FwebService%E5%A4%A9%E6%B0%94%E9%A2%84%E6%8A%A5%E6%8E%A5%E5%8F%A3%2F</url>
    <content type="text"><![CDATA[一：环境搭建二：根据wsdl文件生成客户端代码三：测试代码 一：环境搭建1：新建一个java project工程weatherInf 2：引入相应的jar包 activation.jar axis-ant.jar axis.jar commons-discovery-0.2.jar commons-logging-1.0.4.jar jaxrpc.jar log4j-1.2.8.jar mail.jar saaj.jar wsdl4j-1.5.1.jar 下载axis 1.4 src压缩包，解压后到webapp/web-info/lib下取包，具体路径如下： http://download.csdn.net/detail/yyg64/5351114 其中mail.jar 以及 activation.jar 可到如下路径下载： http://download.csdn.net/detail/dbhunter/398258 3：将天气预报接口wsdl文件拷贝到src目录下 http://www.webxml.com.cn/WebServices/WeatherWebService.asmx?wsdl 二：根据wsdl文件生成客户端代码wsdl文件——右键——web services——Generate Client，然后一路next到finish。 三：测试代码 1 /** 2 * 3 */ 4 package com.paic.services; 5 6 import java.rmi.RemoteException; 7 8 import javax.xml.rpc.ServiceException; 9 10 import cn.com.WebXml.WeatherWebServiceLocator; 11 import cn.com.WebXml.WeatherWebServiceSoapStub; 12 13 /** 14 * @author Administrator 15 * 16 */ 17 public class TestWeather { 18 public static void main(String[] args) throws ServiceException, 19 RemoteException { 20 WeatherWebServiceLocator locator = new WeatherWebServiceLocator(); 21 WeatherWebServiceSoapStub service = (WeatherWebServiceSoapStub) locator 22 .getPort(WeatherWebServiceSoapStub.class); 23 invokeGetSupportProvince(service); 24 System.out.println(&quot;...................&quot;); 25 invokeGetSupportCity(service); 26 invokeGetWeatherByOneCity(service); 27 } 28 29 // 调用获取支持的省份、州接口 30 public static void invokeGetSupportProvince( 31 WeatherWebServiceSoapStub service) throws RemoteException { 32 String[] provices = service.getSupportProvince(); 33 System.out.println(&quot;总共&quot; + provices.length + &quot;个&quot;); 34 int count = 0; 35 for (String str : provices) { 36 if (0 != count &amp;&amp; count % 5 == 0) { 37 System.out.println(); 38 } 39 System.out.print(str + &quot;\t&quot;); 40 count++; 41 } 42 } 43 44 // 调用获取支持查询某个省份内的城市接口 45 public static void invokeGetSupportCity(WeatherWebServiceSoapStub service) 46 throws RemoteException { 47 String provinceName = &quot;江苏&quot;; 48 String[] cities = service.getSupportCity(provinceName); 49 System.out.println(&quot;总共&quot; + cities.length + &quot;个市&quot;); 50 for (int i = 0; i &lt; cities.length; i++) { 51 if (0 != i &amp;&amp; i % 5 == 0) { 52 System.out.println(); 53 } 54 System.out.print(cities[i] + &quot;\t&quot;); 55 } 56 } 57 58 // 调用查询某个城市天气的接口 59 public static void invokeGetWeatherByOneCity( 60 WeatherWebServiceSoapStub service) throws RemoteException { 61 String cityName = &quot;南京&quot;; 62 String[] weatherInfo = service.getWeatherbyCityName(cityName); 63 for (String str : weatherInfo) { 64 System.out.println(str); 65 } 66 } 67 }]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>webservice</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Quarze入门知识]]></title>
    <url>%2F2018%2F02%2F10%2FQuarze%E5%85%A5%E9%97%A8%E7%9F%A5%E8%AF%86%2F</url>
    <content type="text"><![CDATA[Quartz 入门详解入门简介：基本上任何公司都会用到调度这个功能， 比如我们公司需要定期执行调度生成报表， 或者比如博客什么的定时更新之类的，都可以靠Quartz来完成。正如官网所说，小到独立应用大到大型电子商务网站， Quartz都能胜任。 Quartz体系结构：明白Quartz怎么用，首先要了解Scheduler(调度器)、Job(任务)和Trigger(触发器)这3个核心的概念。 1. Job：是一个接口，只定义一个方法execute(JobExecutionContext context)，在实现接口的execute方法中编写所需要定时执行的Job(任务)， JobExecutionContext类提供了调度应用的一些信息。Job运行时的信息保存在JobDataMap实例中； 2. JobDetail：Quartz每次调度Job时， 都重新创建一个Job实例， 所以它不直接接受一个Job的实例，相反它接收一个Job实现类(JobDetail:描述Job的实现类及其它相关的静态信息，如Job名字、描述、关联监听器等信息)，以便运行时通过newInstance()的反射机制实例化Job。 3. Trigger：是一个类，描述触发Job执行的时间触发规则。主要有SimpleTrigger和CronTrigger这两个子类。当且仅当需调度一次或者以固定时间间隔周期执行调度，SimpleTrigger是最适合的选择；而CronTrigger则可以通过Cron表达式定义出各种复杂时间规则的调度方案：如工作日周一到周五的15：00~16：00执行调度等； Cron表达式的格式：秒 分 时 日 月 周 年(可选)。 字段名 允许的值 允许的特殊字符 秒 0-59 , – * / 分 0-59 , – * / 小时 0-23 , – * / 日 1-31 , – * ? / L W C 月 1-12 or JAN-DEC , – * / 周几 1-7 or SUN-SAT , – * ? / L C # MON FRI 年 (可选字段) empty, 1970-2099 , – * / “?”字符：表示不确定的值 “,”字符：指定数个值 “-”字符：指定一个值的范围 “/”字符：指定一个值的增加幅度。n/m表示从n开始，每次增加m “L”字符：用在日表示一个月中的最后一天，用在周表示该月最后一个星期X “W”字符：指定离给定日期最近的工作日(周一到周五) “#”字符：表示该月第几个周X。6#3表示该月第3个周五 Cron表达式范例： 每隔5秒执行一次：*/5 * * * * ? 每隔1分钟执行一次：0 */1 * * * ? 每天23点执行一次：0 0 23 * * ? 每天凌晨1点执行一次：0 0 1 * * ? 每月1号凌晨1点执行一次：0 0 1 1 * ? 每月最后一天23点执行一次：0 0 23 L * ? 每周星期天凌晨1点实行一次：0 0 1 ? * L 在26分、29分、33分执行一次：0 26,29,33 * * * ? 每天的0点、13点、18点、21点都执行一次：0 0 0,13,18,21 * * ? 4. Calendar：org.quartz.Calendar和java.util.Calendar不同， 它是一些日历特定时间点的集合（可以简单地将org.quartz.Calendar看作java.util.Calendar的集合——java.util.Calendar代表一个日历时间点，无特殊说明后面的Calendar即指org.quartz.Calendar）。 一个Trigger可以和多个Calendar关联， 以便排除或包含某些时间点。假设，我们安排每周星期一早上10:00执行任务，但是如果碰到法定的节日，任务则不执行，这时就需要在Trigger触发机制的基础上使用Calendar进行定点排除。针对不同时间段类型，Quartz在org.quartz.impl.calendar包下提供了若干个Calendar的实现类，如AnnualCalendar、MonthlyCalendar、WeeklyCalendar分别针对每年、每月和每周进行定义； 5. Scheduler：代表一个Quartz的独立运行容器， Trigger和JobDetail可以注册到Scheduler中， 两者在Scheduler中拥有各自的组及名称， 组及名称是Scheduler查找定位容器中某一对象的依据， Trigger的组及名称必须唯一， JobDetail的组和名称也必须唯一（但可以和Trigger的组和名称相同，因为它们是不同类型的）。Scheduler定义了多个接口方法， 允许外部通过组及名称访问和控制容器中Trigger和JobDetail。Scheduler可以将Trigger绑定到某一JobDetail中， 这样当Trigger触发时， 对应的Job就被执行。一个Job可以对应多个Trigger， 但一个Trigger只能对应一个Job。可以通过SchedulerFactory创建一个Scheduler实例。Scheduler拥有一个SchedulerContext，它类似于ServletContext，保存着Scheduler上下文信息，Job和Trigger都可以访问SchedulerContext内的信息。SchedulerContext内部通过一个Map，以键值对的方式维护这些上下文数据，SchedulerContext为保存和获取数据提供了多个put()和getXxx()的方法。可以通过Scheduler# getContext()获取对应的SchedulerContext实例； 6. ThreadPool：Scheduler使用一个线程池作为任务运行的基础设施，任务通过共享线程池中的线程提高运行效率。Job有一个StatefulJob子接口，代表有状态的任务，该接口是一个没有方法的标签接口，其目的是让Quartz知道任务的类型，以便采用不同的执行方案。无状态任务在执行时拥有自己的JobDataMap拷贝，对JobDataMap的更改不会影响下次的执行。而有状态任务共享共享同一个JobDataMap实例，每次任务执行对JobDataMap所做的更改会保存下来，后面的执行可以看到这个更改，也即每次执行任务后都会对后面的执行发生影响。正因为这个原因，无状态的Job可以并发执行，而有状态的StatefulJob不能并发执行，这意味着如果前次的StatefulJob还没有执行完毕，下一次的任务将阻塞等待，直到前次任务执行完毕。有状态任务比无状态任务需要考虑更多的因素，程序往往拥有更高的复杂度，因此除非必要，应该尽量使用无状态的Job。如果Quartz使用了数据库持久化任务调度信息，无状态的JobDataMap仅会在Scheduler注册任务时保持一次，而有状态任务对应的JobDataMap在每次执行任务后都会进行保存。Trigger自身也可以拥有一个JobDataMap，其关联的Job可以通过JobExecutionContext#getTrigger().getJobDataMap()获取Trigger中的JobDataMap。不管是有状态还是无状态的任务，在任务执行期间对Trigger的JobDataMap所做的更改都不会进行持久，也即不会对下次的执行产生影响。Quartz拥有完善的事件和监听体系，大部分组件都拥有事件，如任务执行前事件、任务执行后事件、触发器触发前事件、触发后事件、调度器开始事件、关闭事件等等，可以注册相应的监听器处理感兴趣的事件。下图描述了Scheduler的内部组件结构，SchedulerContext提供Scheduler全局可见的上下文信息，每一个任务都对应一个JobDataMap，虚线表达的JobDataMap表示对应有状态的任务： 废话不多说， 上代码： 最简单的Job代码(就打印Hello Quartz ！)： package com.wenniuwuren.quartz; import org.quartz.Job; import org.quartz.JobExecutionContext; import org.quartz.JobExecutionException; public class HelloQuartz implements Job { public void execute(JobExecutionContext arg0) throws JobExecutionException { System.out.println(&quot;Hello Quartz !&quot;); } } 设置触发器 package com.wenniuwuren.quartz; import org.quartz.CronScheduleBuilder; import org.quartz.JobBuilder; import org.quartz.JobDetail; import org.quartz.Scheduler; import org.quartz.SchedulerException; import org.quartz.SchedulerFactory; import org.quartz.SimpleScheduleBuilder; import org.quartz.Trigger; import org.quartz.TriggerBuilder; import org.quartz.impl.StdSchedulerFactory; public class SchedulerTest { public static void main(String[] args) throws InterruptedException { //通过schedulerFactory获取一个调度器 SchedulerFactory schedulerfactory = new StdSchedulerFactory(); Scheduler scheduler=null; try{ // 通过schedulerFactory获取一个调度器 scheduler = schedulerfactory.getScheduler(); // 创建jobDetail实例，绑定Job实现类 // 指明job的名称，所在组的名称，以及绑定job类 JobDetail job = JobBuilder.newJob(HelloQuartz.class).withIdentity(&quot;JobName&quot;, &quot;JobGroupName&quot;).build(); // 定义调度触发规则 // SimpleTrigger // Trigger trigger=TriggerBuilder.newTrigger().withIdentity(&quot;SimpleTrigger&quot;, &quot;SimpleTriggerGroup&quot;) // .withSchedule(SimpleScheduleBuilder.repeatSecondlyForever(3).withRepeatCount(6)) // .startNow().build(); // corn表达式 每五秒执行一次 Trigger trigger=TriggerBuilder.newTrigger().withIdentity(&quot;CronTrigger1&quot;, &quot;CronTriggerGroup&quot;) .withSchedule(CronScheduleBuilder.cronSchedule(&quot;*/5 * * * * ?&quot;)) .startNow().build(); // 把作业和触发器注册到任务调度中 scheduler.scheduleJob(job, trigger); // 启动调度 scheduler.start(); Thread.sleep(10000); // 停止调度 scheduler.shutdown(); }catch(SchedulerException e){ e.printStackTrace(); } } } 输出(设置了sleep10秒， 故在0秒调度一次， 5秒一次， 10秒最后一次)：]]></content>
      <categories>
        <category>java</category>
      </categories>
      <tags>
        <tag>quarze</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Oracle知识点总结]]></title>
    <url>%2F2018%2F02%2F10%2FOracle%E7%9F%A5%E8%AF%86%E7%82%B9%E6%80%BB%E7%BB%93%2F</url>
    <content type="text"><![CDATA[ORACLE01.单表查询-简单条件和去重Oracle 的简单查询和去重（1）–精确查询 –需求：查询水表编号为 30408 的业主记录select * from T_OWNERS where watermeter = ‘30408’; （2）–模糊查询 –需求：查询业主名称包含“刘”的业主记录select * from T_OWNERS where name like ‘%刘%’; （3）–and 运算符 –需求：查询业主名称包含“刘”的并且门牌号包含 5 的业主记录select * from T_OWNERS where name like ‘%刘%’ and housenumber like ‘%5%’; （4）–or 运算符 –需求：查询业主名称包含“刘”的或者门牌号包含 5 的业主记录select * from T_OWNERS where name like ‘%刘%’ or housenumber like ‘%5%’; （5）–and 与 or 运算符混合使用 –需求：查询业主名称包含“刘”的或者门牌号包含 5 的业主记录，并且地址编号为 3 的记录。select * from T_OWNERS where (name like ‘%刘%’ or housenumber like ‘%5%’) and addressid = 3 （6）–范围查询 –需求：查询台账记录中用水字数大于等于 10000，并且小于等于 20000 的记录我们可以用&gt;= 和&lt;=来实现，语句select from T_ACCOUNT where usenum&gt;=10000 and usenum &lt;=20000select from T_ACCOUNT where usenum between 10000 and 20000 （7）–空值查询 –需求：查询 T_PRICETABLE 表中 MAXNUM 为空的记录select from T_PRICETABLE where maxnum is null–不为空select from T_PRICETABLE where maxnum is not null （8）–去掉重复记录 –需求：查询业主表中的地址 ID,不重复显示select distinct addressid from T_OWNERS 02.单表查询-排序和基于伪列查询（开发中经常用到必须掌握） 要点：排序和伪列 （1）–排序查询 –需求：对 T_ACCOUNT 表按使用量进行升序排序(由小到大)select from T_ACCOUNT order by usenum asc –asc可以省略–降序排序–需求：对 T_ACCOUNT 表按使用量进行降序排序（由大到小）select from T_ACCOUNT order by usenum desc 可以通过数据库表中的多个字段来排序，要求：根据排序的前面字段，有重复，按照书写的顺序来进行排序的。例如： 对业主表，按照地址ID降序排列，地址一样，按照ID升序排列：select * from T_OWNERS t order by t.addressid desc, t.id asc （2）伪列：Oracle对每张表自动加上两列rowid和rownum成为伪列 rowid：存储的是物理地址，值是不重复的查询速度比较快–伪列 rowidselect rowid,t. from T_OWNERS t –如果想跟其他字段一起显示select rowid from T_OWNERS –可以单独查询rowidselect rowid,t. from T_OWNERS t where t.rowid = ‘AAAM1VAAGAAAABNAAA’ –可以根据条件查询 rownum：每张表Oracle自动给加上的一个序号。–伪列rownumselect rownum,t.* from T_OWNERS t –如果想跟其他字段一起显示select rownum from T_OWNERS –可以单独查询rownum 03.单表查询-聚合统计要点：聚合统计 –聚合统计 （1）–求和 sum –需求：统计 2012 年所有用户的用水量总和select sum(usenum) from T_ACCOUNT where year = ‘2012’ （2）–求平均 avg –需求：统计 2012 年所有用水量（字数）的平均值select avg(usenum) from T_ACCOUNT where year = ‘2012’ （3）–求最大值 max –需求：统计 2012 年最高用水量（字数）select max(usenum) from T_ACCOUNT where year = ‘2012’ （4）–求最小值 min –需求：统计 2012 年最低用水量（字数）select min(usenum) from T_ACCOUNT where year = ‘2012’ （5）–统计记录个数 count –需求：统计业主类型 ID 为 1 的业主数量select count(*) from T_OWNERS where ownertypeid = 1 （6）– 分组聚合 Group by (select 后面一定是分组聚合的条件或者是聚合函数) –需求：按区域分组统计水费合计数select areaid,sum(money) from T_ACCOUNT group by areaid； （7）– 分组后条件查询 having –需求：查询水费合计大于 16900 的区域及水费合计select areaid,sum(money) from T_ACCOUNT group by areaid having sum(money)&gt;169000where和having区别？ 1.where 不能放在GROUP BY 后面2.HAVING 是跟GROUP BY 连在一起用的，放在GROUP BY 后面，此时的作用相当于WHERE3.WHERE 后面的条件中不能有聚集函数，比如SUM(),AVG()等，而HAVING 可以 04.内连接要点：内连接查询如果接到一个很复杂的查询需求，这里介绍的是如果分析一个复杂的查询需求。（重点要学习思路）第一步: 找到所需信息所在的所有表第二步: 描述各个表之间的关系(外键 = 主键) （1）–多表内连接查询 –（1）需求：查询显示业主编号，业主名称，业主类型名称select os.id 业主编号,os.name 业主名称,ot.name 业主类型from T_OWNERS os,T_OWNERTYPE otwhere os.ownertypeid = ot.id （2）–（2）需求：查询显示业主编号，业主名称、地址和业主类型select ow.id 业主编号,ow.name 业主名称,ad.name 地址,ot.name 业主类型from t_owners ow, t_ownertype ot,t_address adwhere ow.addressid = ad.id and ow.ownertypeid = ot.id （3）–（3）需求：查询显示业主编号、业主名称、地址、所属区域、业主分类select ow.id 业主编号,ow.name 业主名称,ad.name 地址,ar.name 所属区域,ot.name 业主类型from t_owners ow, t_ownertype ot,t_address ad,t_area arwhere ow.addressid = ad.id and ow.ownertypeid = ot.id and ad.areaid = ar.id （4）–（4）需求：查询显示业主编号、业主名称、地址、所属区域、收费员、业主分类select ow.id 业主编号,ow.name 业主名称,ad.name 地址,ar.name 所属区域,op.name 收费员,ot.name 业主类型from t_owners ow, t_ownertype ot,t_address ad,t_area ar,t_operator opwhere ow.addressid = ad.id and ow.ownertypeid = ot.id and ad.areaid = ar.id and ad.operatorid = op.id 05.外连接要点：使用sql1999用法 xxx join … on… 。使用（+）这种写法，oracle数据库专用,移植到其他数据库中会报错。 （1）–左外连接查询：左边表所有数据全部查出来，右边的表没有匹配的数据显示空。–需求：查询业主的账务记录，显示业主编号、名称、年、月、金额。如果此业主没有账务记录也要列出姓名。–sql1999select ow.id 业主编号,ow.name 业主名称,ac.year 年,ac.month 月,ac.money 金额from t_owners ow left join t_account acon ac.owneruuid= ow.id –oracle的语法select ow.id 业主编号,ow.name 业主名称,ac.year 年,ac.month 月,ac.money 金额from t_owners ow , t_account acwhere ow.id=ac.owneruuid(+);（2）–右外连接查询：右边表所有数据全部查出来，左边的表没有匹配的数据显示空。–需求：查询业主的账务记录，显示业主编号、名称、年、月、金额。如果账务记录没有对应的业主信息，也要列出记录。–sql1999select ow.id 业主编号,ow.name 业主名称,ac.year 年,ac.month 月,ac.money 金额from t_owners ow right join t_account acon ac.ownerid = ow.id–oracle的语法select ow.id 业主编号,ow.name 业主名称,ac.year 年,ac.month 月,ac.money 金额from t_owners ow , t_account acwhere ow.id(+) = ac.owneruuid; 06.where子句中的子查询要点：单行子查询where条件后查询的结果只有一行适用于大于，小于，等于等等多行子查询 where条件后查询的结果为多条或者一条，最常用的是in包含的意思。（现实开发经常遇到） 1、单行子查询（1）–where 子句中的子查询–需求：查询 2012 年 1 月用水量大于平均值的台账记录–查询2012年1月平均用水量select avg(usenum) from t_account where year=’2012’ and month=’01’; （2）–查询2012年1月用水量大于20009.5select * from t_account where year=’2012’ and month=’01’ and usenum&gt;20009.5; （3）–需求：查询 2012 年 1 月用水量大于平均值的台账记录select * from t_account where year=’2012’ and month=’01’and usenum&gt;(select avg(usenum) from t_account where year=’2012’ and month=’01’) 2、多行子查询 in 运算符 –（1）需求：查询地址编号为 1 、3、4 的业主记录select * from t_owners where addressid in(1,3,4); –（2）需求：查询地址含有“花园”的业主的信息–查询地址含有“花园”的地址编号select id from t_address where name like ‘%花园%’ –最终结果select * from t_owners where addressid in(select id from t_address where name like ‘%花园%’) –（3）需求：查询地址不含有“花园”的业主的信息select * from t_owners where addressid not in(select id from t_address where name like ‘%花园%’) 07.from子句的子查询要点：from后边的子查询当成一个表使用即可。 （1）–from 子句的子查询为多行子查询–需求：查询显示业主编号，业主名称，业主类型名称，条件为业主类型为”居民”，使用子查询实现。–内连接写法select ow.id 业主编号,ow.name 业主名称,ot.name 业主类型from t_owners ow,t_ownertype otwhere ow.ownertypeid = ot.id and ot.name = ‘居民’（2）–子查询写法select * from (select ow.id 业主编号,ow.name 业主名称,ot.name 业主类型from t_owners ow,t_ownertype otwhere ow.ownertypeid = ot.id) where 业主类型 = ‘居民’ 08.select子句子查询（实际开发中经常遇到）要点：select子查询后边必须是查询单一字段。因为select后边都是单一的字段（1）–select 子句中的子查询–（1）需求：列出业主信息，包括 ID，名称，所属地址。–内关联写法1、如果只查询id、业主名称那只需要从业主表中进行查询。2、现在我们想得到地址表的名称，那么我们就要到地址表中把名称查询出来。画个表select o.id,o.name,ad.namefrom t_owners o,t_address adwhere o.addressid= ad.id （2）–select子查询写法select id,name,(select name from t_address where id=addressid) addressnamefrom t_owners –（2）需求：列出业主信息，包括 ID，名称，所属地址，所属区域。–内连接写法select ow.id,ow.name 名称,ad.name 所属地址,ar.name 所属区域from t_owners ow,t_address ad,t_area arwhere ow.addressid = ad.id and ad.areaid = ar.id–select子查询写法select id,name,(select name from t_address where id=addressid) addressname,(select (select name from t_area where id=areaid) from t_address where id=addressid) areanamefrom t_owners; 09.分页查询要点： 面试要点：oracle 和mysql分页回答：oracle 用ruwnum三层嵌套，mysql 用limit进行分页。 （1）–需求：分页查询台账表 T_ACCOUNT，每页 10 条记录–分析：我们在 ORACLE 进行分页查询，需要用到伪列 ROWNUM 和嵌套查询–我们首先显示前 10 条记录select rownum,t.* from t_account t where rownum&lt;=10 （2）–显示第二页10条内容select from (select rownum r,t. from t_account t)where r&gt;10 and r &lt;=20 （3）–需求：分页查询台账表 T_ACCOUNT，每页 10 条记录，按使用字数降序排序。–我们查询第 2 页数据，如果基于上边的语句添加排序select from ( select rownum r,t. from (select * from t_account order by usenum desc) t )where r&gt;10 and r &lt;=20 10.字符函数要点：伪表dual：Oracle提供用来测试函数的表 （1）–（1）求字符串长度 LENGTHselect length(‘ABCD’) from dual;（2）–求字符串子串(原字符串，从第几位截取，截取字符数)select substr(‘ABCDEF’,2,2) from dual; （3）–字符串拼接select concat(‘ABC’,’D’) from dual;–如果想继续拼接（不推荐使用）select concat(concat(‘ABC’,’D’),’EF’) from dual;–如果想继续拼接（推荐使用）select ‘ABC’||’D’||’EF’ from dual; –拼接查询的内容select ow.name||’住在’||ad.name 信息 from t_owners ow,t_address ad where ow.addressid = ad.id; 11.数值函数要点：数值函数常用的四舍五入（round），数字截取（trunc），求模（mod）根据个人编程习惯采用数值函数。（1）–四舍五入select round(100.567,2) from dual; （2）–数字截取select trunc(100.567,2) from dual;（3）–取模select mod(10,3) from dual; 12.日期函数要点：日期函数实际开发中只有在特定的需求里会遇到。 （1）–取系统当前日期select sysdate from dual;（2）–加月select add_months(sysdate,2) from dual;–减月select add_months(sysdate,-2) from dual;（3）–求当月最后一天select last_day(sysdate) from dual;select last_day(sysdate-4) from dual;（4）–日期截取select trunc(sysdate) from dual;–按日截取（把时间截掉） select trunc(sysdate,’mm’) from dual;–按月截取（把日截掉） select trunc(sysdate,’yyyy’) from dual;–按年截取 select trunc(sysdate,’hh’) from dual;–按小时截取 select trunc(sysdate,’mi’) from dual;–按分钟截取 –没有按秒截取 13.转换函数要点：类似于Java语言的类型转换，特定需求下会使用数据库转换函数。（1）–转换函数–数字转换字符串select to_char(100)||’分’ from dual;select 100||’’ from dual;（2）–日期转字符串select to_char(sysdate,’yyyy-mm-dd’) from dual;select to_char(sysdate,’yyyy’)||’年’||to_char(sysdate,’mm’)||’月’||to_char(sysdate,’dd’)||’日’ from dual;select to_char(sysdate,’yyyy-mm-dd hh:mi:ss’) from dual;（3）–字符串转日期select to_date(‘2017-03-10’,’yyyy-mm-dd’) from dual;（4）–字符串转数字select to_number(‘100’)+10 from dual;select ‘100’+0 from dual;select ‘100’||0 from dual;–拼接后就变成字符串了 14.其它函数要点：空值处理nvl对空值进行处理，nvl2可以转换类型。条件判断decode可以根据检测的值不同，取得不同的结果。case when then sql1999标准必须掌握实际开发会经常遇到。 –其他函数（1）–空值处理select nvl(null,0) from dual;–显示价格表中业主类型ID为1的价格记录，如果上限值为NULL,则显示9999999select nvl(maxnum,9999999) from t_pricetable where ownertypeid=1;（2）–NVL2（检测的值，如果不为 null 的值，如果为 null 的值）；select nvl2(null,0,100) from dual;–结果为100select nvl2(20,0,100) from dual;–结果为0–需求：显示价格表中业主类型 ID 为 1 的价格记录，如果上限值为 NULL,显示“不限”.select nvl2(maxnum,to_char(maxnum),’不限’) from t_pricetable where ownertypeid=1; （3）–（3）条件判断 decodeselect decode(100,1,2,3,4,100,200,300,400) from dual;–需求：显示下列信息（不要关联查询业主类型表，直接判断 1 2 3 的值）select name,decode(ownertypeid,1,’居民’,2,’行政事业单位’,3,’商业’,’其他’) from t_owners;（4）–case when then第一种写法 sql1999select name,(case ownertypeid when 1 then ‘居民’ when 2 then ‘行政事业’ when 3 then ‘商业’ else ‘其他’ end )from t_owners;–case when then第二种写法 sql1999（灵活）select name,(case when ownertypeid=1 then ‘居民’ when ownertypeid=2 then ‘行政事业’ when ownertypeid=3 then ‘商业’ else ‘其他’ end )from t_owners; 15.行列转换（1）–行列转换–需求：按月份统计 2012 年各个地区的水费select (select name from t_area where id=areaid) 区域, sum(case when month = ‘01’ then money else 0 end) 一月, sum(case when month = ‘02’ then money else 0 end) 二月, sum(case when month = ‘03’ then money else 0 end) 三月, sum(case when month = ‘04’ then money else 0 end) 四月, sum(case when month = ‘05’ then money else 0 end) 五月, sum(case when month = ‘06’ then money else 0 end) 六月, sum(case when month = ‘07’ then money else 0 end) 七月, sum(case when month = ‘08’ then money else 0 end) 八月, sum(case when month = ‘09’ then money else 0 end) 九月, sum(case when month = ‘10’ then money else 0 end) 十月, sum(case when month = ‘11’ then money else 0 end) 十一月, sum(case when month = ‘12’ then money else 0 end) 十二月from t_account where year=’2012’ group by areaid; （2）–需求：按季度统计 2012 年各个地区的水费select (select name from t_area where id=areaid) 区域, sum(case when month &gt;= ‘01’ and month&lt;=’03’ then money else 0 end) 第一季度, sum(case when month &gt;= ‘04’ and month&lt;=’06’ then money else 0 end) 第二季度, sum(case when month &gt;= ‘07’ and month&lt;=’09’ then money else 0 end) 第三季度, sum(case when month &gt;= ‘10’ and month&lt;=’12’ then money else 0 end) 第四季度from t_account where year=’2012’ group by areaid; 16.分析函数（1）–分析函数–值相同，排名相同，序号跳跃select rank() over(order by usenum desc) 排名,t. from t_account t（2）–值相同，排名相同，序号连续select dense_rank() over(order by usenum desc) 排名,t. from t_account t（3）–序号连续，不管值是否相同select row_number() over(order by usenum desc) 排名,t. from t_account t（4）–用分析函数来实现分页select from (select row_number() over(order by usenum desc) rownumber,t.* from t_account t)where rownumber&gt;10 and rownumber&lt;=20; 17.集合运算（1）–集合运算–并集（包括重复记录） select from t_owners where id&gt;5union allselect from t_owners where id&lt;8 （2）–并集（去掉重复记录）select from t_owners where id&gt;5unionselect from t_owners where id&lt;8（3）–交集（两个结果集的重复部分） select from t_owners where id&gt;5intersectselect from t_owners where id&lt;8 （4）–差集 返回的属于第一个集合但是不属于第二个集合的记录 select from t_owners where id&gt;5minusselect from t_owners where id&lt;8 select from t_owners where id&lt;8minusselect from t_owners where id&gt;5 （5）–差集分页select rownum,t. from t_account t where rownum&lt;=20minusselect rownum,t. from t_account t where rownum&lt;=10总结1、 oracle单表查询。2、 oracle的多表连接查询。3、 oracle的嵌套查询。4、 oracle的基本函数。 01.什么是视图1、 要点：对sql语句的一种封装，它是一个虚拟的表。2、 使用场景：对经常需要查询的数据，进行封装。3、 优点：提高工作效率。 02.创建修改删除视图语法要点：创建视图的基本语法和删除视图。1、CREATE [OR REPLACE] [FORCE] VIEW view_nameAS subquery[WITH CHECK OPTION ][WITH READ ONLY]REPLACE：删除已有视图，重新创建视图。FORCE：不管基表是否存在，都会创建视图。WITH CHECK OPTION：插入或修改的数据行必须满足视图定义的约束。WITH READ ONLY：只读。 2、删除视图：DROP VIEW view_name 03.视图案例-简单视图要点：视图中查询的表称之为基表，修改视图实际就是在修改基表中的数据。视图在数据库中实际上就是一条sql语句，查询视图的数据实际就是在查询基表的数据。1、–需求：创建视图 ：业主类型为 1 的业主信息create view view_owners1 asselect from t_owners where ownertypeid = 1;2、–查询简单视图select from view_owners1 where addressid = 1;3、–修改视图数据update view_owners1 set name=’范小冰’ where id=1;commit;4、–查询表select * from t_owners where ownertypeid = 1; 04.视图案例-检查约束的视图要点：视图中添加with check option选项，无法修改视图中基表的条件字段。1、–带检查约束的视图–需求：根据地址表（T_ADDRESS）创建视图 VIEW_ADDRESS2 ,内容为区域 ID为 2 的记录。create view view_address2 asselect * from t_address where areaid=2with check option2、–无法修改成功的语句，因为该视图的条件是areaid=2update view_address2 set areaid=3 where id=4;3、–可以修改成功的语句，因为条件不是areaidupdate view_address2 set name=’河畔花园1’ where id=4;commit; 05.视图案例-只读视图要点： 视图中添加or replace删除原有视图，重新创建视图，添加with read only视图只能查看不能修改。1、–需求：将上边的视图修改为只读视图create or replace view view_owners1 asselect * from t_owners where ownertypeid=1with read only2、–修改只读视图数据update view_owners1 set name=’aaa’ where id=1; 06.视图案例-带错误的视图要点：视图中添加 force选项可以创建数据库中没有的表。–创建带错误的视图create force view view_test asselect * from t_test 07.视图案例-多表关联的视图要点：复杂视图：视图的 SQL 语句中，有聚合函数或多表关联查询。键保留表：把主键保留下来的那个表。1、–创建视图，查询显示业主编号，业主名称，业主类型名称create or replace view view_owners asselect ow.id 业主编号,ow.name 业主名称,ot.name 业主类型 from t_owners ow,t_ownertype otwhere ow.ownertypeid=ot.id2、–查询复杂视图（多表关联）select * from view_owners where 业主类型=’居民’;3、–修改键保留表复杂视图（多表关联）的数据update view_owners set 业主名称=’林玲玲’ where 业主编号=4;commit;4、–修改非键保留表复杂视图（多表关联）的数据update view_owners set 业主类型=’商业’ where 业主编号=4;–键保留表：把主键保留下来的那个表，并且能作为视图的主键 复杂视图(多表关联) 修改语句只能修改包含外键的表(t_owners-外键:t_ownertypeid)不管视图中是否包含T_owners的主键,都可以修改.提供外键的表t_ownertype不能修改. 08.视图案例-聚合统计的视图要点：聚合统计视图默认是只读，无法修改数据。1、–需求：创建视图，按年月统计水费金额create view view_accountsum asselect year,month,sum(money) moneyfrom t_accountgroup by year,monthorder by year,month2、–查询视图select * from view_accountsum where year=’2012’ and month=’03’3、–不能修改update view_accountsum set money=10000 where year=’2012’ and month=’03’ 09.物化视图-概念及语法要点：1、物化视图概念：将视图中查询出来的数据存储到一张表中。2、优点：查询速度比视图要快。3、缺点：占用资源，并且要时时更新数据。4、创建物化视图CREATE METERIALIZED VIEW view_name[BUILD IMMEDIATE | BUILD DEFERRED ]REFRESH [FAST|COMPLETE|FORCE][ON [COMMIT |DEMAND ] | START WITH (start_time) NEXT(next_time)]ASSubqueryMETERIALIZED:实体化。BUILD IMMEDIATE: 创建物化视图的时候就生成数据。BUILD DEFERRED: 创建物化视图的时候不生成数据。默认为 BUILD IMMEDIATEFAST：快速刷新，增量刷新。COMPLETE：基表更新，删除物化视图数据，重新生成数据。FORCE：自动选择，能增量刷新就增量，不能增量就完全刷新。默认为FORCEON COMMIT：基表变化，物化视图就刷新。ON DEMAND：手动刷新默认：ON DEMAND 10.物化视图案例-手动刷新的物化视图要点：创建物化视图默认为手动刷新ON DEMAND，基表如果数据发生变化，物化视图中的表不会发生变化，需要手动进行刷新。1、–需求：查询地址 ID,地址名称和所属区域名称create materialized view view_address1 asselect ad.id,ad.name,ar.name arnamefrom t_address ad,t_area arwhere ad.areaid=ar.id–删除物化视图drop materialized view view_address1;2、–物化视图一般以mv开头create materialized view mv_address1 asselect ad.id,ad.name,ar.name arnamefrom t_address ad,t_area arwhere ad.areaid=ar.id–查询物化视图select from mv_address1;3、–向基表插入数据insert into t_address values(8,’西三旗’,2,2);commit;–查询t_addressselect from t_address;4、–执行刷新语句begin DBMS_MVIEW.refresh(‘MV_ADDRESS1’,’C’);end;5、–向基表插入数据insert into t_address values(9,’西四旗’,2,2);commit;6、命令窗口更新刷新数据EXEC DBMS_MVIEW.refresh(‘MV_ADDRESS1’,’C’); 11.物化视图案例-自动刷新的物化视图1、–创建自动刷新的物化视图 -基表发生commit操作，自动刷新物化视图create materialized view mv_address2refreshon commitasselect ad.id,ad.name,ar.name arnamefrom t_address ad,t_area arwhere ad.areaid=ar.id2、–向基表插入数据insert into t_address values(10,’西5旗’,2,2);commit;3、–查询物化视图select * from mv_address2; 12.物化视图案例-创建时不生成数据的物化视图要点：增加build deferred创建物化视图时，视图表中不产生数据，需要手动刷新，如果增加on commit那么以后基表进行commit操作，物化视图为自动刷新。1、–创建时不生成数据的物化视图create materialized view mv_address3build deferredrefreshon commitasselect ad.id,ad.name,ar.name arnamefrom t_address ad,t_area arwhere ad.areaid=ar.id2、–查询物化视图select * from mv_address3;3、–向基表插入数据insert into t_address values(11,’西6旗’,2,2);commit;4、–执行刷新语句(第一次必须手动执行刷新)begin DBMS_MVIEW.refresh(‘MV_ADDRESS3’,’C’);end;5、–向基表插入数据insert into t_address values(12,’西7旗’,2,2);commit; 13.物化视图案例-增量刷新的物化视图（了解）1、–创建增量刷新的物化视图–前提是必须创建物化视图日志：记录基表发生了哪些变化，用这些记录去更新物化视图create materialized view log on t_address with rowidcreate materialized view log on t_area with rowid–创建物化视图中的语句，必须有基表的rowidcreate materialized view mv_address4refresh fastasselect ad.rowid adrowid,ar.rowid arrowid,ad.id,ad.name,ar.name arnamefrom t_address ad,t_area arwhere ad.areaid=ar.id2、–查询物化视图select * from mv_address4;–向基表插入数据insert into t_address values(13,’西8旗’,2,2);commit;–向基表插入数据insert into t_address values(14,’西9旗’,2,2);commit;–删除数据delete from t_address where id=14;commit;3、–执行刷新语句begin DBMS_MVIEW.refresh(‘MV_ADDRESS4’,’C’);end; 14.序列-什么是序列–创建简单序列create sequence seq_test;–查询序列的下一个值select seq_test.nextval from dual;–查询序列的当前值select seq_test.currval from dual; 15.序列-语法16.序列-案例–有最大值的非循环序列create sequence seq_test1maxvalue 20;–查询序列select seq_test1.nextval from dual;–自定义增长值create sequence seq_test2increment by 10start with 10maxvalue 100–查询序列select seq_test2.nextval from dual; create sequence seq_test3increment by 10start with 10minvalue 5maxvalue 100–查询序列select seq_test3.nextval from dual;–循环的序列create sequence seq_test4increment by 10start with 10minvalue 10maxvalue 210cycle create sequence seq_test5increment by 10start with 10minvalue 10maxvalue 201cycle–查询序列select seq_test4.nextval from dual;select seq_test5.nextval from dual; create sequence seq_test5increment by 10start with 10minvalue 10maxvalue 201cyclecache 5–一次缓存数有多少 cache值*增长值 缓存的默认值是20,不设置的话cache为20–一次循环的值不能小于 一次缓存的数–开始值不能小于最小值 17.同义词-概念2、语法：create [public] SYNONYM synooym for object;加上public，数据库所有用户都可以访问别名。不加public，只针对当前用户可以访问。 18.同义词-案例–创建私有同义词create synonym owner for t_owners;select from owner;–dba超级管理员身份可以用system用户直接访问select from wateruser.t_owners;–创建共有同义词create public synonym owner2 for t_owners;select * from owner2; 19.索引-什么是索引要点：1、索引是用于加速数据存取的数据对象。2、适用于百万以上数据。3、优点：查询速度比较快。4、缺点：占用资源比较大。 20.索引-普通索引要点：创建一个普通索引。1、–创建普通索引create index index_owners_name on t_owners(name);select * from t_owners where name=’张哲’;2、–性能测试 创建一个表，向表中插入100万条记录create table t_indextest(id number,name varchar2(30));begin for x in 1..1000000 loop insert into t_indextest values(x,’aa’||x); end loop; commit;end;3、–创建索引create index index_test on t_indextest(name); select * from t_indextest where id=777777; select t.rowid,t.* from t_indextest t where name=’aa777777’; select * from t_indextest where rowid=’AAAM3NAAGAAAAkNACz’; 21.索引-唯一索引和复合索引要点：1、创建唯一索引：此列不能有重复字段。2、复合索引要注意where条件的顺序是什么，创建复合索引的顺序就是什么。–创建唯一索引create unique index index_owners_meter on t_owners(watermeter); select * from t_owners where addressid=1 and housenumber=’1-3’;–创建复合索引create index index_owners_ah on t_owners(addressid,housenumber); 22.索引-反向键索引要点：当某个字段为连续增长的值，适合用反向键索引。create index 索引名称 on 表名(列名) reverse; 普通索引和反向建索引统称b-tree-*索引 23.索引-位图索引要点：1、位图索引适合创建在低基数列上，比方说男、女或者颜色、56个民族等等。 2、语法：create bitmap index 索引名称 on 表名(列名);3、需求：我们在T_owners表的ownertypeid列上建立位图索引。 create bitmap index index_owners_typeid on t_owners(ownertypeid)总结（1） Oracle的视图和物化视图。（2） Oracle的序列。（3） Oracle的同义词。（4） Oracle的索引。 01.什么是PLSQL要点：1、plsql就是Oracle的一种编程语言。2、语法：[declare– 声明变量]begin– 代码逻辑[exception– 异常处理]end; 02.变量声明与赋值 要点：1、如何声明变量。2、如何赋值变量。–声明变量水费单价、水费字数、吨数、金额。–对水费单价、字数、进行赋值 。吨数根据水费字数换算，规则为水费字数除以–1000，并且四舍五入，保留两位小数。计算金额，金额=单价吨数。–输出单价 、数量和金额。declare v_price number(10,2);–单价 v_usenum number;–水费字数 v_usenum2 number(10,2);–吨数 v_money number(10,2);–金额begin v_price:=2.45;–单价赋值 v_usenum:=9999;–水费字数 v_usenum:=round(v_usenum/1000,2);–吨数 v_money:=v_usenumv_price;–金额 dbms_output.put_line(‘金额：’||v_money); –DBMS.OUTPUT.put_line(‘金额：’||v_money);end; 03.变量select into赋值要点：通过select into 将表中的数据赋值给变量，注意查询结果只能是一条记录。declare v_price number(10,2);–单价 v_usenum number;–水费字数 v_usenum2 number(10,2);–吨数 v_money number(10,2);–金额 v_num0 number;–上月水表数 v_num1 number;–本月水表数begin v_price:=2.45;–单价赋值 – v_usenum:=9999;–水费字数 select usenum,num0,num1 into v_usenum,v_num0,v_num1 from t_account where year=’2012’ and month=’01’ and owneruuid=1; v_usenum2:=round(v_usenum/1000,2);–吨数 v_money:=v_usenum2*v_price;–金额 dbms_output.put_line(‘水费字数：’||v_usenum||’金额：’||v_money); –DBMS.OUTPUT.put_line(‘金额：’||v_money);end; 04.属性类型要点：1、在变量较少的情况下，定义的变量是某个表的某列字段，可以采用 表名.字段名%type。2、在变量较多的情况下，可以采用纪录型，把表名定义成变量 表名%rowtype。–引用某表某列的字段类型declare v_price number(10,2);–单价 v_usenum t_account.usenum%type;–水费字数 v_usenum2 number(10,2);–吨数 v_money number(10,2);–金额 v_num0 t_account.num0%type;–上月水表数 v_num1 t_account.num1%type;–本月水表数begin v_price:=2.45;–单价赋值 – v_usenum:=9999;–水费字数 select usenum,num0,num1 into v_usenum,v_num0,v_num1 from t_account where year=’2012’ and month=’01’ and ownerid=1; v_usenum2:=round(v_usenum/1000,2);–吨数 v_money:=v_usenum2*v_price;–金额 dbms_output.put_line(‘水费字数：’||v_usenum||’金额：’||v_money); –DBMS.OUTPUT.put_line(‘金额：’||v_money);end;–属性类型（记录型 表名%rowtype） declare v_price number(10,2);–单价 v_usenum2 number(10,2);–吨数 v_money number(10,2);–金额 v_account t_account%rowtype;–台帐行记录类型begin v_price:=2.45;–单价赋值 – v_usenum:=9999;–水费字数 select into v_account from t_account where year=’2012’ and month=’01’ and ownerid=1; v_usenum2:=round(v_account.usenum/1000,2);–吨数 v_money:=v_usenum2v_price;–金额 dbms_output.put_line(‘水费字数：’||v_account.usenum||’金额：’||v_money); –DBMS.OUTPUT.put_line(‘金额：’||v_money);end; 05.异常要点：了解预定义异常用法即可。–异常处理1declare v_price number(10,2);–单价 v_usenum2 number(10,2);–吨数 v_money number(10,2);–金额 v_account t_account%rowtype;–台帐行记录类型begin v_price:=2.45;–单价赋值 – v_usenum:=9999;–水费字数 select into v_account from t_account where year=’2012’ and month=’01’ and ownerid=200; v_usenum2:=round(v_account.usenum/1000,2);–吨数 v_money:=v_usenum2v_price;–金额 dbms_output.put_line(‘水费字数：’||v_account.usenum||’金额：’||v_money); exception when no_data_found then DBMS_OUTPUT.put_line(‘没有数据’);end;–异常处理2declare v_price number(10,2);–单价 v_usenum2 number(10,2);–吨数 v_money number(10,2);–金额 v_account t_account%rowtype;–台帐行记录类型begin v_price:=2.45;–单价赋值 select into v_account from t_account where year=’2012’ ; v_usenum2:=round(v_account.usenum/1000,2);–吨数 v_money:=v_usenum2v_price;–金额 dbms_output.put_line(‘水费字数：’||v_account.usenum||’金额：’||v_money); exception when no_data_found then DBMS_OUTPUT.put_line(‘没有数据’); when too_many_rows then DBMS_OUTPUT.put_line(‘返回多行’);end; 06.条件判断要点：了解plsql中的if、else判断语法。 declare v_price1 number(10,2);–单价 v_price2 number(10,2);–单价 v_price3 number(10,2);–单价 v_usenum2 number(10,2);–吨数 v_money number(10,2);–金额 v_account t_account%rowtype;–台帐行记录类型begin v_price1:=2.45;–单价赋值（5吨以下） v_price2:=3.45;–单价赋值（5-10吨） v_price3:=4.45;–单价赋值（超过10吨） select into v_account from t_account where year=’2012’ and month=’01’ and ownerid=1; v_usenum2:=round(v_account.usenum/1000,2);–吨数 –v_money:=v_usenum2v_price;–金额 –阶梯水费计算 if v_usenum2&lt;=5 then v_money:=v_price1v_usenum2; elsif v_usenum2&gt;5 and v_usenum2&lt;=10 then v_money:=v_price15+v_price2(v_usenum2-5); else v_money:=v_price15+v_price25 + v_price3(v_usenum2-10); end if; dbms_output.put_line(‘水费字数：’||v_account.usenum||’金额：’||v_money); exception when no_data_found then DBMS_OUTPUT.put_line(‘没有数据’); when too_many_rows then DBMS_OUTPUT.put_line(‘返回多行’);end; 07.循环要点：循环有三种无条件循环、有条件循环、和for循环。–无条件循环：1到100declare v_num number;begin v_num:=1; loop dbms_output.put_line(v_num); v_num:=v_num+1; if v_num&gt;100 then exit; end if; end loop;end;–有条件循环1到100declare v_num number;begin v_num:=1; while v_num &lt;= 100 loop dbms_output.put_line(v_num); v_num:=v_num+1; end loop;end;–for循环1到100begin for v_num in 1 .. 100 loop dbms_output.put_line(v_num); end loop;end; 08.游标语法要点：游标是系统为用户开设的一个数据缓冲区,存放 SQL 语句的执行结果。我们可以把游标理解为 PL/SQL 中的结果集。 09.游标案例要点：创建游标后面跟着sql语句，然后打开游标循环游标的内容直到游标内容循环结束。关闭游标。–需求：打印业主类型为 1 的价格表declare cursor cur_pricetable is select * from t_pricetable where ownertypeid=1;–声明游标 v_pricetable t_pricetable%rowtype;begin open cur_pricetable;–打开游标 loop fetch cur_pricetable into v_pricetable;–提取游标 exit when cur_pricetable%notfound;–退出循环游标 dbms_output.put_line(‘价格：’||v_pricetable.price|| ‘ 吨位：’||v_pricetable.minnum||’-‘||v_pricetable.maxnum); end loop; close cur_pricetable;–关闭游标end; 10.带参数的游标要点：与Java方法相似可以传递参数，声明游标在游标名称后面定义参数，sql语句中使用参数，打开游标时传递参数。 –带参数的游标declare cursor cur_pricetable(v_ownertype number) is select * from t_pricetable where ownertypeid=v_ownertype;–声明游标 v_pricetable t_pricetable%rowtype;begin open cur_pricetable(1);–打开游标 loop fetch cur_pricetable into v_pricetable;–提取游标 exit when cur_pricetable%notfound;–退出循环游标 dbms_output.put_line(‘价格：’||v_pricetable.price|| ‘ 吨位：’||v_pricetable.minnum||’-‘||v_pricetable.maxnum); end loop; close cur_pricetable;–关闭游标end; 11.for循环游标要点：for循环可以自动打开关闭游标，自动提取游标，而且还可以自动声明变量。–for循环 带参数的游标declare cursor cur_pricetable(v_ownertype number) is select * from t_pricetable where ownertypeid=v_ownertype;–声明游标begin for v_pricetable in cur_pricetable(1) loop dbms_output.put_line(‘价格：’||v_pricetable.price|| ‘ 吨位：’||v_pricetable.minnum||’-‘||v_pricetable.maxnum); end loop;end; 12.存储函数要点：存储函数也叫自定义函数，可以接收一个或者多个参数，返回一个结果。类似于Java中的方法。 1、语法函数名称后面的参数类型不需要写长度大小return 后面的参数也不需要写长度 2、案例–需求： 创建存储函数，根据地址 ID 查询地址名称。create or replace function fn_getaddress(v_id number)return varchar2is v_name varchar2(30);begin –查询地址表 select name into v_name from t_address where id=v_id; return v_name;end;–存储函数测试select fn_getaddress(3) from dual;–存储函数的应用–需求：查询业主 ID，业主名称，业主地址，业主地址使用刚才我们创建的函数来实现。select id,name,fn_getaddress(addressid) from t_owners; 13.存储过程-什么是存储过程要点：1、存储过程实际上就是供应用程序调用的一种数据函数对象。2、存储函数与存储过程的区别：存储函数一般用来select查询，且返回的只有一个值，存储过程只能供应用程序调用可以返回多个值。且存储过程没有return返回值，可以通过参数设置一个或者多个返回值。3、语法：CREATE [ OR REPLACE ] PROCEDURE 存储过程名称（参数名 类型, 参数名 类型, 参数名 类型）IS|AS变量声明部分;BEGIN逻辑部分[EXCEPTION异常处理部分]END;参数只指定类型，不指定长度过程参数的三种模式：IN 传入参数（默认）OUT 传出参数 ，主要用于返回程序运行结果IN OUT 传入传出参数 14.不带传出参数的存储过程创建及调用要点：1、根据例子理解如何创建一个不带传出参数的存储过程。2、根据例子理解如果用Oracle调用存储过程。 –创建业主序列起始值为11create sequence seq_owners start with 11;–不带传出参数的存储过程create or replace procedure pro_owners_add(v_name varchar2,–名称v_addressid number,–地址编号v_housenumber varchar2,–门牌号v_watermeter varchar2,–水表号v_ownertype number–业主类型)is begin insert into t_owners values(seq_owners.nextval,v_name,v_addressid,v_housenumber,v_watermeter,sysdate,v_ownertype); commit;end;–调用不带传出参数的存储过程call pro_owners_add(‘马大哈’,2,’3232’,’22333’,1); begin pro_owners_add(‘马2哈’,2,’32312’,’223331’,1);end; 15.JDBC调用不带传出参数的存储过程要点：通过jdbc代码调用存储过程注意调用存储过程使用CallableStatement，sql语句中要用“{call 存储过程名称（？，？,…）}”。 16.带传出参数的存储过程创建与调用要点：1、根据例子理解如何创建一个带传出参数的存储过程。2、根据例子理解如果用Oracle调用存储过程。 –创建带传出参数的存储过程create or replace procedure pro_owners_add1(v_name varchar2,–名称v_addressid number,–地址编号v_housenumber varchar2,–门牌号v_watermeter varchar2,–水表号v_ownertypeid number,–业主类型v_id out number)is begin select seq_owners.nextval into v_id from dual; insert into t_owners values(v_id,v_name,v_addressid,v_housenumber,v_watermeter,sysdate,v_ownertypeid); commit;end;–调用传出参数的存储过程declare v_id number;begin pro_owners_add1(‘马3哈’,2,’32-32’,’2233312’,1,v_id); dbms_output.put_line(v_id);end; 17.JDBC调用带传出参数的存储过程要点：1、通过代码例子了解如何调用带传出参数的存储过程。2、注意需要传出的参数要再执行sql语句之前注册类型，并且获得传出参数时要再执行完sql语句之后。 18.什么是触发器要点：1、触发器：当一个指定的语句执行增删改的操作时。Oracle自动执行了触发器中自定义的数据库函数。2、前置触发器：在增删改操作没有commit之前执行的触发器叫前置触发器。3、后置触发器：在增删改操作commit之后执行的触发器叫后置触发器。 19.触发器语法要点：1、行级触发器：针对表中每行数据变化进行操作。2、语句级触发器：针对每张表进行操作的触发器。3、：old 修改前的数据。Update 和 delete。4、：new 修改后的数据。Insert 和 update。 5、语法：CREATE [or REPLACE] TRIGGER 触发器名BEFORE | AFTER[DELETE ][[or] INSERT] [[or]UPDATE [OF 列名]]ON 表名[FOR EACH ROW ][WHEN(条件) ]declare……beginPLSQL 块End ； 20.前置触发器要点：根据例子理解如何创建前置触发器。–需求：当用户输入本月累计表数后，自动计算出本月使用数 。create or replace trigger tri_account_num1beforeupdate of num1on t_accountfor each rowdeclare begin –通过伪记录变量修改usenum字段的值num1（水表现在的数值），num0（上个月使用的水表数） :new.usenum := :new.num1-:new.num0;end; 21.后置触发器要点：根据例子理解如何创建后置触发器。–需求：当用户修改了业主信息表的数据时记录修改前与修改后的值–创建后置触发器日志表create table t_owners_log(updatetime date,ownerid number,oldname varchar2(30),newname varchar2(30));–根据需求创建后置触发器create or replace trigger tri_owners_logafterupdate of nameon t_ownersfor each rowdeclarebegin –向日志表插入记录 insert into t_owners_log values(sysdate,:new.id,:old.name,:new.name);end;–修改t_owners表中的nameupdate t_owners set name=’林玲玲1’ where id=4;]]></content>
      <categories>
        <category>数据库</category>
      </categories>
      <tags>
        <tag>oracle</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[写文章的步骤]]></title>
    <url>%2F2018%2F02%2F10%2Fhello-world%2F</url>
    <content type="text"><![CDATA[创建步骤:1、写一篇文章:1$ hexo new "My New Post" 2、运行服务:1$ hexo server 3、生成静态页面:1$ hexo generate 4、发布到服务器:1$ hexo deploy 5、开启播客旅程 next主题优化设置:1、显示网易云的音乐:在C:\lxm\MyBlog\themes\next\layout_macro\sidebar.swig里面137行加上网易云的外链]]></content>
      <categories>
        <category>杂七杂八</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[追梦赤子心]]></title>
    <url>%2F2017%2F11%2F11%2F%E6%8A%80%E6%9C%AF%E4%BA%A4%E6%B5%81%E6%96%87%E7%AB%A0%2F</url>
    <content type="text"><![CDATA[你好,如果你有神马想和我说的请留言,发送邮件至我的邮箱:fashionkillyou@foxmail.com请大家多多支持,多多指教!持续更新中…]]></content>
      <categories>
        <category>站长留言</category>
      </categories>
      <tags>
        <tag>站长留言</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[第一篇播客]]></title>
    <url>%2F2017%2F11%2F10%2F%E7%AC%AC%E4%B8%80%E7%AF%87%E6%92%AD%E5%AE%A2%2F</url>
    <content type="text"><![CDATA[我的第一篇博客, 这是我的第一篇博客,哈哈,今后开启我的博客生涯,写了很多的东西笔记什么的终于可以发到网上了,我很激动很开心,yes!]]></content>
      <categories>
        <category>杂七杂八</category>
      </categories>
      <tags>
        <tag>test</tag>
      </tags>
  </entry>
</search>
